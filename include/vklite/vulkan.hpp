#ifndef VKLITE_VULKAN_HPP
#define VKLITE_VULKAN_HPP

#include "core.hpp"

namespace vklite {
#if VK_VERSION_1_0
using SampleMask = VkSampleMask;
using Bool32 = VkBool32;
using Flags = VkFlags;
#endif // VK_VERSION_1_0
#if VK_VERSION_1_3
using Flags64 = VkFlags64;
#endif // VK_VERSION_1_3
#if VK_VERSION_1_0
using DeviceSize = VkDeviceSize;
using DeviceAddress = VkDeviceAddress;

using PipelineDynamicStateCreateFlags = Flags;
using PipelineMultisampleStateCreateFlags = Flags;
using PipelineRasterizationStateCreateFlags = Flags;
using PipelineViewportStateCreateFlags = Flags;
using PipelineTessellationStateCreateFlags = Flags;
using PipelineInputAssemblyStateCreateFlags = Flags;
using PipelineVertexInputStateCreateFlags = Flags;
using BufferViewCreateFlags = Flags;
using DeviceCreateFlags = Flags;
using SemaphoreCreateFlags = Flags;
using ShaderModuleCreateFlags = Flags;
using DescriptorPoolResetFlags = Flags;
#endif // VK_VERSION_1_0
#if VK_VERSION_1_3
using PrivateDataSlotCreateFlags = Flags;
#endif // VK_VERSION_1_3
#if VK_VERSION_1_1
using DescriptorUpdateTemplateCreateFlags = Flags;
#endif // VK_VERSION_1_1
#if VK_NV_ray_tracing_motion_blur
using AccelerationStructureMotionInfoFlagsNV = Flags;
using AccelerationStructureMotionInstanceFlagsNV = Flags;
#endif // VK_NV_ray_tracing_motion_blur
#if VK_LUNARG_direct_driver_loading
using DirectDriverLoadingFlagsLUNARG = Flags;
#endif // VK_LUNARG_direct_driver_loading
#if VK_KHR_display
using DisplayModeCreateFlagsKHR = Flags;
using DisplaySurfaceCreateFlagsKHR = Flags;
#endif // VK_KHR_display
#if VK_KHR_android_surface
using AndroidSurfaceCreateFlagsKHR = Flags;
#endif // VK_KHR_android_surface
#if VK_NN_vi_surface
using ViSurfaceCreateFlagsNN = Flags;
#endif // VK_NN_vi_surface
#if VK_KHR_wayland_surface
using WaylandSurfaceCreateFlagsKHR = Flags;
#endif // VK_KHR_wayland_surface
#if VK_KHR_win32_surface
using Win32SurfaceCreateFlagsKHR = Flags;
#endif // VK_KHR_win32_surface
#if VK_KHR_xlib_surface
using XlibSurfaceCreateFlagsKHR = Flags;
#endif // VK_KHR_xlib_surface
#if VK_KHR_xcb_surface
using XcbSurfaceCreateFlagsKHR = Flags;
#endif // VK_KHR_xcb_surface
#if VK_EXT_directfb_surface
using DirectFBSurfaceCreateFlagsEXT = Flags;
#endif // VK_EXT_directfb_surface
#if VK_EXT_metal_surface
using MetalSurfaceCreateFlagsEXT = Flags;
#endif // VK_EXT_metal_surface
#if VK_FUCHSIA_imagepipe_surface
using ImagePipeSurfaceCreateFlagsFUCHSIA = Flags;
#endif // VK_FUCHSIA_imagepipe_surface
#if VK_GGP_stream_descriptor_surface
using StreamDescriptorSurfaceCreateFlagsGGP = Flags;
#endif // VK_GGP_stream_descriptor_surface
#if VK_EXT_headless_surface
using HeadlessSurfaceCreateFlagsEXT = Flags;
#endif // VK_EXT_headless_surface
#if VK_QNX_screen_surface
using ScreenSurfaceCreateFlagsQNX = Flags;
#endif // VK_QNX_screen_surface
#if VK_VERSION_1_1
using CommandPoolTrimFlags = Flags;
#endif // VK_VERSION_1_1
#if VK_NV_viewport_swizzle
using PipelineViewportSwizzleStateCreateFlagsNV = Flags;
#endif // VK_NV_viewport_swizzle
#if VK_EXT_discard_rectangles
using PipelineDiscardRectangleStateCreateFlagsEXT = Flags;
#endif // VK_EXT_discard_rectangles
#if VK_NV_fragment_coverage_to_color
using PipelineCoverageToColorStateCreateFlagsNV = Flags;
#endif // VK_NV_fragment_coverage_to_color
#if VK_NV_framebuffer_mixed_samples
using PipelineCoverageModulationStateCreateFlagsNV = Flags;
#endif // VK_NV_framebuffer_mixed_samples
#if VK_NV_coverage_reduction_mode
using PipelineCoverageReductionStateCreateFlagsNV = Flags;
#endif // VK_NV_coverage_reduction_mode
#if VK_EXT_validation_cache
using ValidationCacheCreateFlagsEXT = Flags;
#endif // VK_EXT_validation_cache
#if VK_EXT_debug_utils
using DebugUtilsMessengerCreateFlagsEXT = Flags;
using DebugUtilsMessengerCallbackDataFlagsEXT = Flags;
#endif // VK_EXT_debug_utils
#if VK_EXT_device_memory_report
using DeviceMemoryReportFlagsEXT = Flags;
#endif // VK_EXT_device_memory_report
#if VK_EXT_conservative_rasterization
using PipelineRasterizationConservativeStateCreateFlagsEXT = Flags;
#endif // VK_EXT_conservative_rasterization
#if VK_EXT_transform_feedback
using PipelineRasterizationStateStreamCreateFlagsEXT = Flags;
#endif // VK_EXT_transform_feedback
#if VK_EXT_depth_clip_enable
using PipelineRasterizationDepthClipStateCreateFlagsEXT = Flags;
#endif // VK_EXT_depth_clip_enable
#if VK_FUCHSIA_buffer_collection
using ImageFormatConstraintsFlagsFUCHSIA = Flags;
#endif // VK_FUCHSIA_buffer_collection
#if VK_OHOS_surface
using SurfaceCreateFlagsOHOS = Flags;
#endif // VK_OHOS_surface
#if VK_KHR_video_queue
using VideoBeginCodingFlagsKHR = Flags;
using VideoEndCodingFlagsKHR = Flags;
#endif // VK_KHR_video_queue
#if VK_KHR_video_decode_queue
using VideoDecodeFlagsKHR = Flags;
#endif // VK_KHR_video_decode_queue
#if VK_KHR_video_encode_queue
using VideoEncodeRateControlFlagsKHR = Flags;
#endif // VK_KHR_video_encode_queue

#if VK_VERSION_1_0
using BaseOutStructure = VkBaseOutStructure;
using BaseInStructure = VkBaseInStructure;

struct Offset2D : VkOffset2D {
  Offset2D() noexcept : VkOffset2D{} {}
  Offset2D(int32_t x, int32_t y) noexcept : VkOffset2D{.x = x, .y = y} {}

  void setX(int32_t value) { this->x = value; }
  int32_t getX() const { return this->x; }
  void setY(int32_t value) { this->y = value; }
  int32_t getY() const { return this->y; }
};

struct Offset3D : VkOffset3D {
  Offset3D() noexcept : VkOffset3D{} {}
  Offset3D(int32_t x, int32_t y, int32_t z) noexcept : VkOffset3D{.x = x, .y = y, .z = z} {}

  void setX(int32_t value) { this->x = value; }
  int32_t getX() const { return this->x; }
  void setY(int32_t value) { this->y = value; }
  int32_t getY() const { return this->y; }
  void setZ(int32_t value) { this->z = value; }
  int32_t getZ() const { return this->z; }
};

struct Extent2D : VkExtent2D {
  Extent2D() noexcept : VkExtent2D{} {}
  Extent2D(uint32_t width, uint32_t height) noexcept : VkExtent2D{.width = width, .height = height} {}

  void setWidth(uint32_t value) { this->width = value; }
  uint32_t getWidth() const { return this->width; }
  void setHeight(uint32_t value) { this->height = value; }
  uint32_t getHeight() const { return this->height; }
};

struct Extent3D : VkExtent3D {
  Extent3D() noexcept : VkExtent3D{} {}
  Extent3D(uint32_t width, uint32_t height, uint32_t depth) noexcept : VkExtent3D{.width = width, .height = height, .depth = depth} {}

  void setWidth(uint32_t value) { this->width = value; }
  uint32_t getWidth() const { return this->width; }
  void setHeight(uint32_t value) { this->height = value; }
  uint32_t getHeight() const { return this->height; }
  void setDepth(uint32_t value) { this->depth = value; }
  uint32_t getDepth() const { return this->depth; }
};

struct Viewport : VkViewport {
  Viewport() noexcept : VkViewport{} {}
  Viewport(float x, float y, float width, float height, float minDepth, float maxDepth) noexcept : VkViewport{.x = x, .y = y, .width = width, .height = height, .minDepth = minDepth, .maxDepth = maxDepth} {}

  void setX(float value) { this->x = value; }
  float getX() const { return this->x; }
  void setY(float value) { this->y = value; }
  float getY() const { return this->y; }
  void setWidth(float value) { this->width = value; }
  float getWidth() const { return this->width; }
  void setHeight(float value) { this->height = value; }
  float getHeight() const { return this->height; }
  void setMinDepth(float value) { this->minDepth = value; }
  float getMinDepth() const { return this->minDepth; }
  void setMaxDepth(float value) { this->maxDepth = value; }
  float getMaxDepth() const { return this->maxDepth; }
};

struct ExtensionProperties : VkExtensionProperties {
  ExtensionProperties() noexcept : VkExtensionProperties{} {}

  // extension name
  std::string_view getExtensionName() const { return this->extensionName; }
  // version of the extension specification implemented
  uint32_t getSpecVersion() const { return this->specVersion; }
};

struct LayerProperties : VkLayerProperties {
  LayerProperties() noexcept : VkLayerProperties{} {}

  // layer name
  std::string_view getLayerName() const { return this->layerName; }
  // version of the layer specification implemented
  uint32_t getSpecVersion() const { return this->specVersion; }
  // build or release version of the layer's library
  uint32_t getImplementationVersion() const { return this->implementationVersion; }
  // Free-form description of the layer
  std::string_view getDescription() const { return this->description; }
};

struct AllocationCallbacks : VkAllocationCallbacks {
  AllocationCallbacks() noexcept : VkAllocationCallbacks{} {}

  void setPfnAllocation(PFN_vkAllocationFunction value) { this->pfnAllocation = value; }
  PFN_vkAllocationFunction getPfnAllocation() const { return this->pfnAllocation; }
  void setPfnReallocation(PFN_vkReallocationFunction value) { this->pfnReallocation = value; }
  PFN_vkReallocationFunction getPfnReallocation() const { return this->pfnReallocation; }
  void setPfnFree(PFN_vkFreeFunction value) { this->pfnFree = value; }
  PFN_vkFreeFunction getPfnFree() const { return this->pfnFree; }

  void setUserData(void* value) { this->pUserData = value; }
  void* getUserData() const { return this->pUserData; }
  void setPfnInternalAllocation(PFN_vkInternalAllocationNotification value) { this->pfnInternalAllocation = value; }
  PFN_vkInternalAllocationNotification getPfnInternalAllocation() const { return this->pfnInternalAllocation; }
  void setPfnInternalFree(PFN_vkInternalFreeNotification value) { this->pfnInternalFree = value; }
  PFN_vkInternalFreeNotification getPfnInternalFree() const { return this->pfnInternalFree; }
};

struct SpecializationMapEntry : VkSpecializationMapEntry {
  SpecializationMapEntry() noexcept : VkSpecializationMapEntry{} {}
  SpecializationMapEntry(uint32_t constantID, uint32_t offset, size_t size) noexcept : VkSpecializationMapEntry{.constantID = constantID, .offset = offset, .size = size} {}

  // The SpecConstant ID specified in the BIL
  void setConstantID(uint32_t value) { this->constantID = value; }
  uint32_t getConstantID() const { return this->constantID; }
  // Offset of the value in the data block
  void setOffset(uint32_t value) { this->offset = value; }
  uint32_t getOffset() const { return this->offset; }
  // Size in bytes of the SpecConstant
  void setSize(size_t value) { this->size = value; }
  size_t getSize() const { return this->size; }
};
#endif // VK_VERSION_1_0

#if VK_KHR_pipeline_binary
struct PipelineBinaryDataKHR : VkPipelineBinaryDataKHR {
  PipelineBinaryDataKHR() noexcept : VkPipelineBinaryDataKHR{} {}
  PipelineBinaryDataKHR(size_t dataSize, void* pData) noexcept : VkPipelineBinaryDataKHR{.dataSize = dataSize, .pData = pData} {}

  void setDataSize(size_t value) { this->dataSize = value; }
  size_t getDataSize() const { return this->dataSize; }
  void setData(void* value) { this->pData = value; }
  void* getData() const { return this->pData; }
};
#endif // VK_KHR_pipeline_binary

#if VK_VERSION_1_0
using ClearColorValue = VkClearColorValue;

struct ClearDepthStencilValue : VkClearDepthStencilValue {
  ClearDepthStencilValue() noexcept : VkClearDepthStencilValue{} {}
  ClearDepthStencilValue(float depth, uint32_t stencil) noexcept : VkClearDepthStencilValue{.depth = depth, .stencil = stencil} {}

  void setDepth(float value) { this->depth = value; }
  float getDepth() const { return this->depth; }
  void setStencil(uint32_t value) { this->stencil = value; }
  uint32_t getStencil() const { return this->stencil; }
};

using ClearValue = VkClearValue;

struct DrawIndirectCommand : VkDrawIndirectCommand {
  DrawIndirectCommand() noexcept : VkDrawIndirectCommand{} {}
  DrawIndirectCommand(uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance) noexcept : VkDrawIndirectCommand{.vertexCount = vertexCount, .instanceCount = instanceCount, .firstVertex = firstVertex, .firstInstance = firstInstance} {}

  void setVertexCount(uint32_t value) { this->vertexCount = value; }
  uint32_t getVertexCount() const { return this->vertexCount; }
  void setInstanceCount(uint32_t value) { this->instanceCount = value; }
  uint32_t getInstanceCount() const { return this->instanceCount; }
  void setFirstVertex(uint32_t value) { this->firstVertex = value; }
  uint32_t getFirstVertex() const { return this->firstVertex; }
  void setFirstInstance(uint32_t value) { this->firstInstance = value; }
  uint32_t getFirstInstance() const { return this->firstInstance; }
};

struct DrawIndexedIndirectCommand : VkDrawIndexedIndirectCommand {
  DrawIndexedIndirectCommand() noexcept : VkDrawIndexedIndirectCommand{} {}
  DrawIndexedIndirectCommand(uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t vertexOffset, uint32_t firstInstance) noexcept : VkDrawIndexedIndirectCommand{.indexCount = indexCount, .instanceCount = instanceCount, .firstIndex = firstIndex, .vertexOffset = vertexOffset, .firstInstance = firstInstance} {}

  void setIndexCount(uint32_t value) { this->indexCount = value; }
  uint32_t getIndexCount() const { return this->indexCount; }
  void setInstanceCount(uint32_t value) { this->instanceCount = value; }
  uint32_t getInstanceCount() const { return this->instanceCount; }
  void setFirstIndex(uint32_t value) { this->firstIndex = value; }
  uint32_t getFirstIndex() const { return this->firstIndex; }
  void setVertexOffset(int32_t value) { this->vertexOffset = value; }
  int32_t getVertexOffset() const { return this->vertexOffset; }
  void setFirstInstance(uint32_t value) { this->firstInstance = value; }
  uint32_t getFirstInstance() const { return this->firstInstance; }
};

struct DispatchIndirectCommand : VkDispatchIndirectCommand {
  DispatchIndirectCommand() noexcept : VkDispatchIndirectCommand{} {}
  DispatchIndirectCommand(uint32_t x, uint32_t y, uint32_t z) noexcept : VkDispatchIndirectCommand{.x = x, .y = y, .z = z} {}

  void setX(uint32_t value) { this->x = value; }
  uint32_t getX() const { return this->x; }
  void setY(uint32_t value) { this->y = value; }
  uint32_t getY() const { return this->y; }
  void setZ(uint32_t value) { this->z = value; }
  uint32_t getZ() const { return this->z; }
};
#endif // VK_VERSION_1_0

#if VK_EXT_multi_draw
struct MultiDrawInfoEXT : VkMultiDrawInfoEXT {
  MultiDrawInfoEXT() noexcept : VkMultiDrawInfoEXT{} {}
  MultiDrawInfoEXT(uint32_t firstVertex, uint32_t vertexCount) noexcept : VkMultiDrawInfoEXT{.firstVertex = firstVertex, .vertexCount = vertexCount} {}

  void setFirstVertex(uint32_t value) { this->firstVertex = value; }
  uint32_t getFirstVertex() const { return this->firstVertex; }
  void setVertexCount(uint32_t value) { this->vertexCount = value; }
  uint32_t getVertexCount() const { return this->vertexCount; }
};

struct MultiDrawIndexedInfoEXT : VkMultiDrawIndexedInfoEXT {
  MultiDrawIndexedInfoEXT() noexcept : VkMultiDrawIndexedInfoEXT{} {}
  MultiDrawIndexedInfoEXT(uint32_t firstIndex, uint32_t indexCount, int32_t vertexOffset) noexcept : VkMultiDrawIndexedInfoEXT{.firstIndex = firstIndex, .indexCount = indexCount, .vertexOffset = vertexOffset} {}

  void setFirstIndex(uint32_t value) { this->firstIndex = value; }
  uint32_t getFirstIndex() const { return this->firstIndex; }
  void setIndexCount(uint32_t value) { this->indexCount = value; }
  uint32_t getIndexCount() const { return this->indexCount; }
  void setVertexOffset(int32_t value) { this->vertexOffset = value; }
  int32_t getVertexOffset() const { return this->vertexOffset; }
};
#endif // VK_EXT_multi_draw

#if VK_NV_cluster_acceleration_structure
struct ClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV : VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV {
  ClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV() noexcept : VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV{} {}
  ClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV(uint32_t geometryIndex, uint32_t reserved, uint32_t geometryFlags) noexcept : VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV{.geometryIndex = geometryIndex, .reserved = reserved, .geometryFlags = geometryFlags} {}

  void setGeometryIndex(uint32_t value) { this->geometryIndex = value; }
  uint32_t getGeometryIndex() const { return this->geometryIndex; }
  void setReserved(uint32_t value) { this->reserved = value; }
  uint32_t getReserved() const { return this->reserved; }
  void setGeometryFlags(uint32_t value) { this->geometryFlags = value; }
  uint32_t getGeometryFlags() const { return this->geometryFlags; }
};

using ClusterAccelerationStructureOpInputNV = VkClusterAccelerationStructureOpInputNV;
#endif // VK_NV_cluster_acceleration_structure

#if VK_NV_device_generated_commands
struct BindShaderGroupIndirectCommandNV : VkBindShaderGroupIndirectCommandNV {
  BindShaderGroupIndirectCommandNV() noexcept : VkBindShaderGroupIndirectCommandNV{} {}
  BindShaderGroupIndirectCommandNV(uint32_t groupIndex) noexcept : VkBindShaderGroupIndirectCommandNV{.groupIndex = groupIndex} {}

  void setGroupIndex(uint32_t value) { this->groupIndex = value; }
  uint32_t getGroupIndex() const { return this->groupIndex; }
};

struct SetStateFlagsIndirectCommandNV : VkSetStateFlagsIndirectCommandNV {
  SetStateFlagsIndirectCommandNV() noexcept : VkSetStateFlagsIndirectCommandNV{} {}
  SetStateFlagsIndirectCommandNV(uint32_t data) noexcept : VkSetStateFlagsIndirectCommandNV{.data = data} {}

  void setData(uint32_t value) { this->data = value; }
  uint32_t getData() const { return this->data; }
};
#endif // VK_NV_device_generated_commands

#if VK_VERSION_1_2
struct ConformanceVersion : VkConformanceVersion {
  ConformanceVersion() noexcept : VkConformanceVersion{} {}
  ConformanceVersion(uint8_t major, uint8_t minor, uint8_t subminor, uint8_t patch) noexcept : VkConformanceVersion{.major = major, .minor = minor, .subminor = subminor, .patch = patch} {}

  void setMajor(uint8_t value) { this->major = value; }
  uint8_t getMajor() const { return this->major; }
  void setMinor(uint8_t value) { this->minor = value; }
  uint8_t getMinor() const { return this->minor; }
  void setSubminor(uint8_t value) { this->subminor = value; }
  uint8_t getSubminor() const { return this->subminor; }
  void setPatch(uint8_t value) { this->patch = value; }
  uint8_t getPatch() const { return this->patch; }
};
#endif // VK_VERSION_1_2

#if VK_EXT_hdr_metadata
// Chromaticity coordinate
struct XYColorEXT : VkXYColorEXT {
  XYColorEXT() noexcept : VkXYColorEXT{} {}
  XYColorEXT(float x, float y) noexcept : VkXYColorEXT{.x = x, .y = y} {}

  void setX(float value) { this->x = value; }
  float getX() const { return this->x; }
  void setY(float value) { this->y = value; }
  float getY() const { return this->y; }
};
#endif // VK_EXT_hdr_metadata

#if VK_GOOGLE_display_timing
struct RefreshCycleDurationGOOGLE : VkRefreshCycleDurationGOOGLE {
  RefreshCycleDurationGOOGLE() noexcept : VkRefreshCycleDurationGOOGLE{} {}

  // Number of nanoseconds from the start of one refresh cycle to the next
  uint64_t getRefreshDuration() const { return this->refreshDuration; }
};

struct PastPresentationTimingGOOGLE : VkPastPresentationTimingGOOGLE {
  PastPresentationTimingGOOGLE() noexcept : VkPastPresentationTimingGOOGLE{} {}

  // Application-provided identifier, previously given to vkQueuePresentKHR
  uint32_t getPresentID() const { return this->presentID; }
  // Earliest time an image should have been presented, previously given to vkQueuePresentKHR
  uint64_t getDesiredPresentTime() const { return this->desiredPresentTime; }
  // Time the image was actually displayed
  uint64_t getActualPresentTime() const { return this->actualPresentTime; }
  // Earliest time the image could have been displayed
  uint64_t getEarliestPresentTime() const { return this->earliestPresentTime; }
  // How early vkQueuePresentKHR was processed vs. how soon it needed to be and make earliestPresentTime
  uint64_t getPresentMargin() const { return this->presentMargin; }
};

struct PresentTimeGOOGLE : VkPresentTimeGOOGLE {
  PresentTimeGOOGLE() noexcept : VkPresentTimeGOOGLE{} {}
  PresentTimeGOOGLE(uint32_t presentID, uint64_t desiredPresentTime) noexcept : VkPresentTimeGOOGLE{.presentID = presentID, .desiredPresentTime = desiredPresentTime} {}

  // Application-provided identifier
  void setPresentID(uint32_t value) { this->presentID = value; }
  uint32_t getPresentID() const { return this->presentID; }
  // Earliest time an image should be presented
  void setDesiredPresentTime(uint64_t value) { this->desiredPresentTime = value; }
  uint64_t getDesiredPresentTime() const { return this->desiredPresentTime; }
};
#endif // VK_GOOGLE_display_timing

#if VK_NV_clip_space_w_scaling
struct ViewportWScalingNV : VkViewportWScalingNV {
  ViewportWScalingNV() noexcept : VkViewportWScalingNV{} {}
  ViewportWScalingNV(float xcoeff, float ycoeff) noexcept : VkViewportWScalingNV{.xcoeff = xcoeff, .ycoeff = ycoeff} {}

  void setXcoeff(float value) { this->xcoeff = value; }
  float getXcoeff() const { return this->xcoeff; }
  void setYcoeff(float value) { this->ycoeff = value; }
  float getYcoeff() const { return this->ycoeff; }
};
#endif // VK_NV_clip_space_w_scaling

#if VK_EXT_sample_locations
struct SampleLocationEXT : VkSampleLocationEXT {
  SampleLocationEXT() noexcept : VkSampleLocationEXT{} {}
  SampleLocationEXT(float x, float y) noexcept : VkSampleLocationEXT{.x = x, .y = y} {}

  void setX(float value) { this->x = value; }
  float getX() const { return this->x; }
  void setY(float value) { this->y = value; }
  float getY() const { return this->y; }
};
#endif // VK_EXT_sample_locations

#if VK_AMD_shader_info
struct ShaderResourceUsageAMD : VkShaderResourceUsageAMD {
  ShaderResourceUsageAMD() noexcept : VkShaderResourceUsageAMD{} {}

  uint32_t getNumUsedVgprs() const { return this->numUsedVgprs; }
  uint32_t getNumUsedSgprs() const { return this->numUsedSgprs; }
  uint32_t getLdsSizePerLocalWorkGroup() const { return this->ldsSizePerLocalWorkGroup; }
  size_t getLdsUsageSizeInBytes() const { return this->ldsUsageSizeInBytes; }
  size_t getScratchMemUsageInBytes() const { return this->scratchMemUsageInBytes; }
};
#endif // VK_AMD_shader_info

#if VK_VERSION_1_4
struct VertexInputBindingDivisorDescription : VkVertexInputBindingDivisorDescription {
  VertexInputBindingDivisorDescription() noexcept : VkVertexInputBindingDivisorDescription{} {}
  VertexInputBindingDivisorDescription(uint32_t binding, uint32_t divisor) noexcept : VkVertexInputBindingDivisorDescription{.binding = binding, .divisor = divisor} {}

  void setBinding(uint32_t value) { this->binding = value; }
  uint32_t getBinding() const { return this->binding; }
  void setDivisor(uint32_t value) { this->divisor = value; }
  uint32_t getDivisor() const { return this->divisor; }
};
#endif // VK_VERSION_1_4

#if VK_NV_shading_rate_image
struct CoarseSampleLocationNV : VkCoarseSampleLocationNV {
  CoarseSampleLocationNV() noexcept : VkCoarseSampleLocationNV{} {}
  CoarseSampleLocationNV(uint32_t pixelX, uint32_t pixelY, uint32_t sample) noexcept : VkCoarseSampleLocationNV{.pixelX = pixelX, .pixelY = pixelY, .sample = sample} {}

  void setPixelX(uint32_t value) { this->pixelX = value; }
  uint32_t getPixelX() const { return this->pixelX; }
  void setPixelY(uint32_t value) { this->pixelY = value; }
  uint32_t getPixelY() const { return this->pixelY; }
  void setSample(uint32_t value) { this->sample = value; }
  uint32_t getSample() const { return this->sample; }
};
#endif // VK_NV_shading_rate_image

#if VK_NV_mesh_shader
struct DrawMeshTasksIndirectCommandNV : VkDrawMeshTasksIndirectCommandNV {
  DrawMeshTasksIndirectCommandNV() noexcept : VkDrawMeshTasksIndirectCommandNV{} {}
  DrawMeshTasksIndirectCommandNV(uint32_t taskCount, uint32_t firstTask) noexcept : VkDrawMeshTasksIndirectCommandNV{.taskCount = taskCount, .firstTask = firstTask} {}

  void setTaskCount(uint32_t value) { this->taskCount = value; }
  uint32_t getTaskCount() const { return this->taskCount; }
  void setFirstTask(uint32_t value) { this->firstTask = value; }
  uint32_t getFirstTask() const { return this->firstTask; }
};
#endif // VK_NV_mesh_shader

#if VK_EXT_mesh_shader
struct DrawMeshTasksIndirectCommandEXT : VkDrawMeshTasksIndirectCommandEXT {
  DrawMeshTasksIndirectCommandEXT() noexcept : VkDrawMeshTasksIndirectCommandEXT{} {}
  DrawMeshTasksIndirectCommandEXT(uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ) noexcept : VkDrawMeshTasksIndirectCommandEXT{.groupCountX = groupCountX, .groupCountY = groupCountY, .groupCountZ = groupCountZ} {}

  void setGroupCountX(uint32_t value) { this->groupCountX = value; }
  uint32_t getGroupCountX() const { return this->groupCountX; }
  void setGroupCountY(uint32_t value) { this->groupCountY = value; }
  uint32_t getGroupCountY() const { return this->groupCountY; }
  void setGroupCountZ(uint32_t value) { this->groupCountZ = value; }
  uint32_t getGroupCountZ() const { return this->groupCountZ; }
};
#endif // VK_EXT_mesh_shader

#if VK_KHR_ray_tracing_pipeline
struct TraceRaysIndirectCommandKHR : VkTraceRaysIndirectCommandKHR {
  TraceRaysIndirectCommandKHR() noexcept : VkTraceRaysIndirectCommandKHR{} {}
  TraceRaysIndirectCommandKHR(uint32_t width, uint32_t height, uint32_t depth) noexcept : VkTraceRaysIndirectCommandKHR{.width = width, .height = height, .depth = depth} {}

  void setWidth(uint32_t value) { this->width = value; }
  uint32_t getWidth() const { return this->width; }
  void setHeight(uint32_t value) { this->height = value; }
  uint32_t getHeight() const { return this->height; }
  void setDepth(uint32_t value) { this->depth = value; }
  uint32_t getDepth() const { return this->depth; }
};
#endif // VK_KHR_ray_tracing_pipeline

#if VK_KHR_performance_query
using PerformanceCounterResultKHR = VkPerformanceCounterResultKHR;
#endif // VK_KHR_performance_query
#if VK_INTEL_performance_query
using PerformanceValueDataINTEL = VkPerformanceValueDataINTEL;
#endif // VK_INTEL_performance_query
#if VK_KHR_pipeline_executable_properties
using PipelineExecutableStatisticValueKHR = VkPipelineExecutableStatisticValueKHR;
#endif // VK_KHR_pipeline_executable_properties
#if VK_KHR_acceleration_structure
using DeviceOrHostAddressKHR = VkDeviceOrHostAddressKHR;
using DeviceOrHostAddressConstKHR = VkDeviceOrHostAddressConstKHR;
using AccelerationStructureGeometryDataKHR = VkAccelerationStructureGeometryDataKHR;

struct AccelerationStructureBuildRangeInfoKHR : VkAccelerationStructureBuildRangeInfoKHR {
  AccelerationStructureBuildRangeInfoKHR() noexcept : VkAccelerationStructureBuildRangeInfoKHR{} {}
  AccelerationStructureBuildRangeInfoKHR(uint32_t primitiveCount, uint32_t primitiveOffset, uint32_t firstVertex, uint32_t transformOffset) noexcept : VkAccelerationStructureBuildRangeInfoKHR{.primitiveCount = primitiveCount, .primitiveOffset = primitiveOffset, .firstVertex = firstVertex, .transformOffset = transformOffset} {}

  void setPrimitiveCount(uint32_t value) { this->primitiveCount = value; }
  uint32_t getPrimitiveCount() const { return this->primitiveCount; }
  void setPrimitiveOffset(uint32_t value) { this->primitiveOffset = value; }
  uint32_t getPrimitiveOffset() const { return this->primitiveOffset; }
  void setFirstVertex(uint32_t value) { this->firstVertex = value; }
  uint32_t getFirstVertex() const { return this->firstVertex; }
  void setTransformOffset(uint32_t value) { this->transformOffset = value; }
  uint32_t getTransformOffset() const { return this->transformOffset; }
};

struct AabbPositionsKHR : VkAabbPositionsKHR {
  AabbPositionsKHR() noexcept : VkAabbPositionsKHR{} {}
  AabbPositionsKHR(float minX, float minY, float minZ, float maxX, float maxY, float maxZ) noexcept : VkAabbPositionsKHR{.minX = minX, .minY = minY, .minZ = minZ, .maxX = maxX, .maxY = maxY, .maxZ = maxZ} {}

  void setMinX(float value) { this->minX = value; }
  float getMinX() const { return this->minX; }
  void setMinY(float value) { this->minY = value; }
  float getMinY() const { return this->minY; }
  void setMinZ(float value) { this->minZ = value; }
  float getMinZ() const { return this->minZ; }
  void setMaxX(float value) { this->maxX = value; }
  float getMaxX() const { return this->maxX; }
  void setMaxY(float value) { this->maxY = value; }
  float getMaxY() const { return this->maxY; }
  void setMaxZ(float value) { this->maxZ = value; }
  float getMaxZ() const { return this->maxZ; }
};

struct TransformMatrixKHR : VkTransformMatrixKHR {
  TransformMatrixKHR() noexcept : VkTransformMatrixKHR{} {}
};
#endif // VK_KHR_acceleration_structure

#if VK_NV_partitioned_acceleration_structure
struct PartitionedAccelerationStructureWritePartitionTranslationDataNV : VkPartitionedAccelerationStructureWritePartitionTranslationDataNV {
  PartitionedAccelerationStructureWritePartitionTranslationDataNV() noexcept : VkPartitionedAccelerationStructureWritePartitionTranslationDataNV{} {}
  PartitionedAccelerationStructureWritePartitionTranslationDataNV(uint32_t partitionIndex, std::span<const float, 3> partitionTranslation) noexcept : VkPartitionedAccelerationStructureWritePartitionTranslationDataNV{.partitionIndex = partitionIndex} { setPartitionTranslation(partitionTranslation); }

  void setPartitionIndex(uint32_t value) { this->partitionIndex = value; }
  uint32_t getPartitionIndex() const { return this->partitionIndex; }
  void setPartitionTranslation(std::span<const float, 3> value) { std::memcpy(&this->partitionTranslation, value.data(), value.size_bytes()); }
  std::span<const float, 3> getPartitionTranslation() const { return this->partitionTranslation; }
};
#endif // VK_NV_partitioned_acceleration_structure

#if VK_EXT_device_generated_commands
using IndirectExecutionSetInfoEXT = VkIndirectExecutionSetInfoEXT;

struct IndirectCommandsVertexBufferTokenEXT : VkIndirectCommandsVertexBufferTokenEXT {
  IndirectCommandsVertexBufferTokenEXT() noexcept : VkIndirectCommandsVertexBufferTokenEXT{} {}
  IndirectCommandsVertexBufferTokenEXT(uint32_t vertexBindingUnit) noexcept : VkIndirectCommandsVertexBufferTokenEXT{.vertexBindingUnit = vertexBindingUnit} {}

  void setVertexBindingUnit(uint32_t value) { this->vertexBindingUnit = value; }
  uint32_t getVertexBindingUnit() const { return this->vertexBindingUnit; }
};

using IndirectCommandsTokenDataEXT = VkIndirectCommandsTokenDataEXT;
#endif // VK_EXT_device_generated_commands

#if VK_KHR_video_encode_h264
struct VideoEncodeH264QpKHR : VkVideoEncodeH264QpKHR {
  VideoEncodeH264QpKHR() noexcept : VkVideoEncodeH264QpKHR{} {}
  VideoEncodeH264QpKHR(int32_t qpI, int32_t qpP, int32_t qpB) noexcept : VkVideoEncodeH264QpKHR{.qpI = qpI, .qpP = qpP, .qpB = qpB} {}

  void setQpI(int32_t value) { this->qpI = value; }
  int32_t getQpI() const { return this->qpI; }
  void setQpP(int32_t value) { this->qpP = value; }
  int32_t getQpP() const { return this->qpP; }
  void setQpB(int32_t value) { this->qpB = value; }
  int32_t getQpB() const { return this->qpB; }
};

struct VideoEncodeH264FrameSizeKHR : VkVideoEncodeH264FrameSizeKHR {
  VideoEncodeH264FrameSizeKHR() noexcept : VkVideoEncodeH264FrameSizeKHR{} {}
  VideoEncodeH264FrameSizeKHR(uint32_t frameISize, uint32_t framePSize, uint32_t frameBSize) noexcept : VkVideoEncodeH264FrameSizeKHR{.frameISize = frameISize, .framePSize = framePSize, .frameBSize = frameBSize} {}

  void setFrameISize(uint32_t value) { this->frameISize = value; }
  uint32_t getFrameISize() const { return this->frameISize; }
  void setFramePSize(uint32_t value) { this->framePSize = value; }
  uint32_t getFramePSize() const { return this->framePSize; }
  void setFrameBSize(uint32_t value) { this->frameBSize = value; }
  uint32_t getFrameBSize() const { return this->frameBSize; }
};
#endif // VK_KHR_video_encode_h264

#if VK_KHR_video_encode_h265
struct VideoEncodeH265QpKHR : VkVideoEncodeH265QpKHR {
  VideoEncodeH265QpKHR() noexcept : VkVideoEncodeH265QpKHR{} {}
  VideoEncodeH265QpKHR(int32_t qpI, int32_t qpP, int32_t qpB) noexcept : VkVideoEncodeH265QpKHR{.qpI = qpI, .qpP = qpP, .qpB = qpB} {}

  void setQpI(int32_t value) { this->qpI = value; }
  int32_t getQpI() const { return this->qpI; }
  void setQpP(int32_t value) { this->qpP = value; }
  int32_t getQpP() const { return this->qpP; }
  void setQpB(int32_t value) { this->qpB = value; }
  int32_t getQpB() const { return this->qpB; }
};

struct VideoEncodeH265FrameSizeKHR : VkVideoEncodeH265FrameSizeKHR {
  VideoEncodeH265FrameSizeKHR() noexcept : VkVideoEncodeH265FrameSizeKHR{} {}
  VideoEncodeH265FrameSizeKHR(uint32_t frameISize, uint32_t framePSize, uint32_t frameBSize) noexcept : VkVideoEncodeH265FrameSizeKHR{.frameISize = frameISize, .framePSize = framePSize, .frameBSize = frameBSize} {}

  void setFrameISize(uint32_t value) { this->frameISize = value; }
  uint32_t getFrameISize() const { return this->frameISize; }
  void setFramePSize(uint32_t value) { this->framePSize = value; }
  uint32_t getFramePSize() const { return this->framePSize; }
  void setFrameBSize(uint32_t value) { this->frameBSize = value; }
  uint32_t getFrameBSize() const { return this->frameBSize; }
};
#endif // VK_KHR_video_encode_h265

#if VK_KHR_video_encode_av1
struct VideoEncodeAV1QIndexKHR : VkVideoEncodeAV1QIndexKHR {
  VideoEncodeAV1QIndexKHR() noexcept : VkVideoEncodeAV1QIndexKHR{} {}
  VideoEncodeAV1QIndexKHR(uint32_t intraQIndex, uint32_t predictiveQIndex, uint32_t bipredictiveQIndex) noexcept : VkVideoEncodeAV1QIndexKHR{.intraQIndex = intraQIndex, .predictiveQIndex = predictiveQIndex, .bipredictiveQIndex = bipredictiveQIndex} {}

  void setIntraQIndex(uint32_t value) { this->intraQIndex = value; }
  uint32_t getIntraQIndex() const { return this->intraQIndex; }
  void setPredictiveQIndex(uint32_t value) { this->predictiveQIndex = value; }
  uint32_t getPredictiveQIndex() const { return this->predictiveQIndex; }
  void setBipredictiveQIndex(uint32_t value) { this->bipredictiveQIndex = value; }
  uint32_t getBipredictiveQIndex() const { return this->bipredictiveQIndex; }
};

struct VideoEncodeAV1FrameSizeKHR : VkVideoEncodeAV1FrameSizeKHR {
  VideoEncodeAV1FrameSizeKHR() noexcept : VkVideoEncodeAV1FrameSizeKHR{} {}
  VideoEncodeAV1FrameSizeKHR(uint32_t intraFrameSize, uint32_t predictiveFrameSize, uint32_t bipredictiveFrameSize) noexcept : VkVideoEncodeAV1FrameSizeKHR{.intraFrameSize = intraFrameSize, .predictiveFrameSize = predictiveFrameSize, .bipredictiveFrameSize = bipredictiveFrameSize} {}

  void setIntraFrameSize(uint32_t value) { this->intraFrameSize = value; }
  uint32_t getIntraFrameSize() const { return this->intraFrameSize; }
  void setPredictiveFrameSize(uint32_t value) { this->predictiveFrameSize = value; }
  uint32_t getPredictiveFrameSize() const { return this->predictiveFrameSize; }
  void setBipredictiveFrameSize(uint32_t value) { this->bipredictiveFrameSize = value; }
  uint32_t getBipredictiveFrameSize() const { return this->bipredictiveFrameSize; }
};
#endif // VK_KHR_video_encode_av1

#if VK_EXT_descriptor_buffer
using DescriptorDataEXT = VkDescriptorDataEXT;
#endif // VK_EXT_descriptor_buffer

#if VK_NV_ray_tracing_motion_blur
struct SRTDataNV : VkSRTDataNV {
  SRTDataNV() noexcept : VkSRTDataNV{} {}
  SRTDataNV(float sx, float a, float b, float pvx, float sy, float c, float pvy, float sz, float pvz, float qx, float qy, float qz, float qw, float tx, float ty, float tz) noexcept : VkSRTDataNV{.sx = sx, .a = a, .b = b, .pvx = pvx, .sy = sy, .c = c, .pvy = pvy, .sz = sz, .pvz = pvz, .qx = qx, .qy = qy, .qz = qz, .qw = qw, .tx = tx, .ty = ty, .tz = tz} {}

  void setSx(float value) { this->sx = value; }
  float getSx() const { return this->sx; }
  void setA(float value) { this->a = value; }
  float getA() const { return this->a; }
  void setB(float value) { this->b = value; }
  float getB() const { return this->b; }
  void setPvx(float value) { this->pvx = value; }
  float getPvx() const { return this->pvx; }
  void setSy(float value) { this->sy = value; }
  float getSy() const { return this->sy; }
  void setC(float value) { this->c = value; }
  float getC() const { return this->c; }
  void setPvy(float value) { this->pvy = value; }
  float getPvy() const { return this->pvy; }
  void setSz(float value) { this->sz = value; }
  float getSz() const { return this->sz; }
  void setPvz(float value) { this->pvz = value; }
  float getPvz() const { return this->pvz; }
  void setQx(float value) { this->qx = value; }
  float getQx() const { return this->qx; }
  void setQy(float value) { this->qy = value; }
  float getQy() const { return this->qy; }
  void setQz(float value) { this->qz = value; }
  float getQz() const { return this->qz; }
  void setQw(float value) { this->qw = value; }
  float getQw() const { return this->qw; }
  void setTx(float value) { this->tx = value; }
  float getTx() const { return this->tx; }
  void setTy(float value) { this->ty = value; }
  float getTy() const { return this->ty; }
  void setTz(float value) { this->tz = value; }
  float getTz() const { return this->tz; }
};

using AccelerationStructureMotionInstanceDataNV = VkAccelerationStructureMotionInstanceDataNV;
#endif // VK_NV_ray_tracing_motion_blur
#if VK_NV_external_memory_rdma
using RemoteAddressNV = VkRemoteAddressNV;
#endif // VK_NV_external_memory_rdma

#if VK_EXT_subpass_merge_feedback
struct RenderPassCreationFeedbackInfoEXT : VkRenderPassCreationFeedbackInfoEXT {
  RenderPassCreationFeedbackInfoEXT() noexcept : VkRenderPassCreationFeedbackInfoEXT{} {}

  uint32_t getPostMergeSubpassCount() const { return this->postMergeSubpassCount; }
};
#endif // VK_EXT_subpass_merge_feedback

#if VK_EXT_opacity_micromap
struct MicromapUsageEXT : VkMicromapUsageEXT {
  MicromapUsageEXT() noexcept : VkMicromapUsageEXT{} {}
  MicromapUsageEXT(uint32_t count, uint32_t subdivisionLevel, uint32_t format) noexcept : VkMicromapUsageEXT{.count = count, .subdivisionLevel = subdivisionLevel, .format = format} {}

  void setCount(uint32_t value) { this->count = value; }
  uint32_t getCount() const { return this->count; }
  void setSubdivisionLevel(uint32_t value) { this->subdivisionLevel = value; }
  uint32_t getSubdivisionLevel() const { return this->subdivisionLevel; }
  // Interpretation depends on parent type
  void setFormat(uint32_t value) { this->format = value; }
  uint32_t getFormat() const { return this->format; }
};

struct MicromapTriangleEXT : VkMicromapTriangleEXT {
  MicromapTriangleEXT() noexcept : VkMicromapTriangleEXT{} {}
  MicromapTriangleEXT(uint32_t dataOffset, uint16_t subdivisionLevel, uint16_t format) noexcept : VkMicromapTriangleEXT{.dataOffset = dataOffset, .subdivisionLevel = subdivisionLevel, .format = format} {}

  // Specified in bytes
  void setDataOffset(uint32_t value) { this->dataOffset = value; }
  uint32_t getDataOffset() const { return this->dataOffset; }
  void setSubdivisionLevel(uint16_t value) { this->subdivisionLevel = value; }
  uint16_t getSubdivisionLevel() const { return this->subdivisionLevel; }
  void setFormat(uint16_t value) { this->format = value; }
  uint16_t getFormat() const { return this->format; }
};
#endif // VK_EXT_opacity_micromap

#if VK_EXT_device_fault
struct DeviceFaultVendorInfoEXT : VkDeviceFaultVendorInfoEXT {
  DeviceFaultVendorInfoEXT() noexcept : VkDeviceFaultVendorInfoEXT{} {}
  DeviceFaultVendorInfoEXT(std::string_view description, uint64_t vendorFaultCode, uint64_t vendorFaultData) noexcept : VkDeviceFaultVendorInfoEXT{.vendorFaultCode = vendorFaultCode, .vendorFaultData = vendorFaultData} { setDescription(description); }

  // Free-form description of the fault
  void setDescription(std::string_view value) { const auto len = std::max<std::size_t>(VK_MAX_DESCRIPTION_SIZE - 1, value.size()); std::memcpy(&this->description, value.data(), len); this->description[len] = '\0'; }
  std::string_view getDescription() const { return this->description; }
  void setVendorFaultCode(uint64_t value) { this->vendorFaultCode = value; }
  uint64_t getVendorFaultCode() const { return this->vendorFaultCode; }
  void setVendorFaultData(uint64_t value) { this->vendorFaultData = value; }
  uint64_t getVendorFaultData() const { return this->vendorFaultData; }
};
#endif // VK_EXT_device_fault

#if VK_EXT_depth_clamp_control
struct DepthClampRangeEXT : VkDepthClampRangeEXT {
  DepthClampRangeEXT() noexcept : VkDepthClampRangeEXT{} {}
  DepthClampRangeEXT(float minDepthClamp, float maxDepthClamp) noexcept : VkDepthClampRangeEXT{.minDepthClamp = minDepthClamp, .maxDepthClamp = maxDepthClamp} {}

  void setMinDepthClamp(float value) { this->minDepthClamp = value; }
  float getMinDepthClamp() const { return this->minDepthClamp; }
  void setMaxDepthClamp(float value) { this->maxDepthClamp = value; }
  float getMaxDepthClamp() const { return this->maxDepthClamp; }
};
#endif // VK_EXT_depth_clamp_control

#if VK_VERSION_1_0
enum class ImageLayout : int32_t {
  // Implicit layout an image is when its contents are undefined due to various reasons (e.g. right after creation)
  eUndefined = VK_IMAGE_LAYOUT_UNDEFINED,
  // General layout when image can be used for any kind of access
  eGeneral = VK_IMAGE_LAYOUT_GENERAL,
  // Optimal layout when image is only used for color attachment read/write
  eColorAttachmentOptimal = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL,
  // Optimal layout when image is only used for depth/stencil attachment read/write
  eDepthStencilAttachmentOptimal = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL,
  // Optimal layout when image is used for read only depth/stencil attachment and shader access
  eDepthStencilReadOnlyOptimal = VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL,
  // Optimal layout when image is used for read only shader access
  eShaderReadOnlyOptimal = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,
  // Optimal layout when image is used only as source of transfer operations
  eTransferSrcOptimal = VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,
  // Optimal layout when image is used only as destination of transfer operations
  eTransferDstOptimal = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
  // Initial layout used when the data is populated by the CPU
  ePreinitialized = VK_IMAGE_LAYOUT_PREINITIALIZED,
#if VK_VERSION_1_1
  eDepthReadOnlyStencilAttachmentOptimal = VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL,
  eDepthAttachmentStencilReadOnlyOptimal = VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL,
#endif // VK_VERSION_1_1
#if VK_VERSION_1_2
  eDepthAttachmentOptimal = VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL,
  eDepthReadOnlyOptimal = VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL,
  eStencilAttachmentOptimal = VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL,
  eStencilReadOnlyOptimal = VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL,
#endif // VK_VERSION_1_2
#if VK_VERSION_1_3
  eReadOnlyOptimal = VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL,
  eAttachmentOptimal = VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL,
#endif // VK_VERSION_1_3
#if VK_VERSION_1_4
  eRenderingLocalRead = VK_IMAGE_LAYOUT_RENDERING_LOCAL_READ,
#endif // VK_VERSION_1_4
#if VK_KHR_swapchain
  ePresentSrcKHR = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR,
#endif // VK_KHR_swapchain
#if VK_KHR_video_decode_queue
  eVideoDecodeDstKHR = VK_IMAGE_LAYOUT_VIDEO_DECODE_DST_KHR,
  eVideoDecodeSrcKHR = VK_IMAGE_LAYOUT_VIDEO_DECODE_SRC_KHR,
  eVideoDecodeDpbKHR = VK_IMAGE_LAYOUT_VIDEO_DECODE_DPB_KHR,
#endif // VK_KHR_video_decode_queue
#if VK_KHR_shared_presentable_image
  eSharedPresentKHR = VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR,
#endif // VK_KHR_shared_presentable_image
#if VK_KHR_maintenance2
  eDepthReadOnlyStencilAttachmentOptimalKHR = VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR,
  eDepthAttachmentStencilReadOnlyOptimalKHR = VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR,
#endif // VK_KHR_maintenance2
#if VK_NV_shading_rate_image
  eShadingRateOptimalNV = VK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV,
#endif // VK_NV_shading_rate_image
#if VK_EXT_fragment_density_map
  eFragmentDensityMapOptimalEXT = VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT,
#endif // VK_EXT_fragment_density_map
#if VK_KHR_fragment_shading_rate
  eFragmentShadingRateAttachmentOptimalKHR = VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR,
#endif // VK_KHR_fragment_shading_rate
#if VK_KHR_dynamic_rendering_local_read
  eRenderingLocalReadKHR = VK_IMAGE_LAYOUT_RENDERING_LOCAL_READ_KHR,
#endif // VK_KHR_dynamic_rendering_local_read
#if VK_KHR_separate_depth_stencil_layouts
  eDepthAttachmentOptimalKHR = VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL_KHR,
  eDepthReadOnlyOptimalKHR = VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL_KHR,
  eStencilAttachmentOptimalKHR = VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL_KHR,
  eStencilReadOnlyOptimalKHR = VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL_KHR,
#endif // VK_KHR_separate_depth_stencil_layouts
#if VK_KHR_video_encode_queue
  eVideoEncodeDstKHR = VK_IMAGE_LAYOUT_VIDEO_ENCODE_DST_KHR,
  eVideoEncodeSrcKHR = VK_IMAGE_LAYOUT_VIDEO_ENCODE_SRC_KHR,
  eVideoEncodeDpbKHR = VK_IMAGE_LAYOUT_VIDEO_ENCODE_DPB_KHR,
#endif // VK_KHR_video_encode_queue
#if VK_KHR_synchronization2
  eReadOnlyOptimalKHR = VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL_KHR,
  eAttachmentOptimalKHR = VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL_KHR,
#endif // VK_KHR_synchronization2
#if VK_EXT_attachment_feedback_loop_layout
  eAttachmentFeedbackLoopOptimalEXT = VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT,
#endif // VK_EXT_attachment_feedback_loop_layout
#if VK_ARM_tensors
  eTensorAliasingARM = VK_IMAGE_LAYOUT_TENSOR_ALIASING_ARM,
#endif // VK_ARM_tensors
#if VK_KHR_video_encode_quantization_map
  eVideoEncodeQuantizationMapKHR = VK_IMAGE_LAYOUT_VIDEO_ENCODE_QUANTIZATION_MAP_KHR,
#endif // VK_KHR_video_encode_quantization_map
#if VK_EXT_zero_initialize_device_memory
  eZeroInitializedEXT = VK_IMAGE_LAYOUT_ZERO_INITIALIZED_EXT,
#endif // VK_EXT_zero_initialize_device_memory
};

enum class AttachmentLoadOp : int32_t {
  eLoad = VK_ATTACHMENT_LOAD_OP_LOAD,
  eClear = VK_ATTACHMENT_LOAD_OP_CLEAR,
  eDontCare = VK_ATTACHMENT_LOAD_OP_DONT_CARE,
#if VK_VERSION_1_4
  eNone = VK_ATTACHMENT_LOAD_OP_NONE,
#endif // VK_VERSION_1_4
#if VK_EXT_load_store_op_none
  eNoneEXT = VK_ATTACHMENT_LOAD_OP_NONE_EXT,
#endif // VK_EXT_load_store_op_none
#if VK_KHR_load_store_op_none
  eNoneKHR = VK_ATTACHMENT_LOAD_OP_NONE_KHR,
#endif // VK_KHR_load_store_op_none
};

enum class AttachmentStoreOp : int32_t {
  eStore = VK_ATTACHMENT_STORE_OP_STORE,
  eDontCare = VK_ATTACHMENT_STORE_OP_DONT_CARE,
#if VK_VERSION_1_3
  eNone = VK_ATTACHMENT_STORE_OP_NONE,
#endif // VK_VERSION_1_3
#if VK_KHR_dynamic_rendering
  eNoneKHR = VK_ATTACHMENT_STORE_OP_NONE_KHR,
#endif // VK_KHR_dynamic_rendering
#if VK_QCOM_render_pass_store_ops
  eNoneQCOM = VK_ATTACHMENT_STORE_OP_NONE_QCOM,
#endif // VK_QCOM_render_pass_store_ops
#if VK_EXT_load_store_op_none
  eNoneEXT = VK_ATTACHMENT_STORE_OP_NONE_EXT,
#endif // VK_EXT_load_store_op_none
};

enum class ImageType : int32_t {
  e1D = VK_IMAGE_TYPE_1D,
  e2D = VK_IMAGE_TYPE_2D,
  e3D = VK_IMAGE_TYPE_3D,
};

enum class ImageTiling : int32_t {
  eOptimal = VK_IMAGE_TILING_OPTIMAL,
  eLinear = VK_IMAGE_TILING_LINEAR,
#if VK_EXT_image_drm_format_modifier
  eDrmFormatModifierEXT = VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT,
#endif // VK_EXT_image_drm_format_modifier
};

enum class ImageViewType : int32_t {
  e1D = VK_IMAGE_VIEW_TYPE_1D,
  e2D = VK_IMAGE_VIEW_TYPE_2D,
  e3D = VK_IMAGE_VIEW_TYPE_3D,
  eCube = VK_IMAGE_VIEW_TYPE_CUBE,
  e1DArray = VK_IMAGE_VIEW_TYPE_1D_ARRAY,
  e2DArray = VK_IMAGE_VIEW_TYPE_2D_ARRAY,
  eCubeArray = VK_IMAGE_VIEW_TYPE_CUBE_ARRAY,
};

enum class CommandBufferLevel : int32_t {
  ePrimary = VK_COMMAND_BUFFER_LEVEL_PRIMARY,
  eSecondary = VK_COMMAND_BUFFER_LEVEL_SECONDARY,
};

enum class ComponentSwizzle : int32_t {
  eIdentity = VK_COMPONENT_SWIZZLE_IDENTITY,
  eZero = VK_COMPONENT_SWIZZLE_ZERO,
  eOne = VK_COMPONENT_SWIZZLE_ONE,
  eR = VK_COMPONENT_SWIZZLE_R,
  eG = VK_COMPONENT_SWIZZLE_G,
  eB = VK_COMPONENT_SWIZZLE_B,
  eA = VK_COMPONENT_SWIZZLE_A,
};

enum class DescriptorType : int32_t {
  eSampler = VK_DESCRIPTOR_TYPE_SAMPLER,
  eCombinedImageSampler = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
  eSampledImage = VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
  eStorageImage = VK_DESCRIPTOR_TYPE_STORAGE_IMAGE,
  eUniformTexelBuffer = VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER,
  eStorageTexelBuffer = VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER,
  eUniformBuffer = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
  eStorageBuffer = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER,
  eUniformBufferDynamic = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC,
  eStorageBufferDynamic = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC,
  eInputAttachment = VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT,
#if VK_VERSION_1_3
  eInlineUniformBlock = VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK,
#endif // VK_VERSION_1_3
#if VK_EXT_inline_uniform_block
  eInlineUniformBlockEXT = VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT,
#endif // VK_EXT_inline_uniform_block
#if VK_KHR_acceleration_structure
  eAccelerationStructureKHR = VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR,
#endif // VK_KHR_acceleration_structure
#if VK_VALVE_mutable_descriptor_type
  eMutableVALVE = VK_DESCRIPTOR_TYPE_MUTABLE_VALVE,
#endif // VK_VALVE_mutable_descriptor_type
#if VK_QCOM_image_processing
  eSampleWeightImageQCOM = VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM,
  eBlockMatchImageQCOM = VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM,
#endif // VK_QCOM_image_processing
#if VK_ARM_tensors
  eTensorARM = VK_DESCRIPTOR_TYPE_TENSOR_ARM,
#endif // VK_ARM_tensors
#if VK_EXT_mutable_descriptor_type
  eMutableEXT = VK_DESCRIPTOR_TYPE_MUTABLE_EXT,
#endif // VK_EXT_mutable_descriptor_type
#if VK_NV_partitioned_acceleration_structure
  ePartitionedAccelerationStructureNV = VK_DESCRIPTOR_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_NV,
#endif // VK_NV_partitioned_acceleration_structure
};

enum class QueryType : int32_t {
  eOcclusion = VK_QUERY_TYPE_OCCLUSION,
  // Optional
  ePipelineStatistics = VK_QUERY_TYPE_PIPELINE_STATISTICS,
  eTimestamp = VK_QUERY_TYPE_TIMESTAMP,
#if VK_KHR_video_queue
  eResultStatusOnlyKHR = VK_QUERY_TYPE_RESULT_STATUS_ONLY_KHR,
#endif // VK_KHR_video_queue
#if VK_EXT_transform_feedback
  eTransformFeedbackStreamEXT = VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT,
#endif // VK_EXT_transform_feedback
#if VK_KHR_performance_query
  ePerformanceQueryKHR = VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR,
#endif // VK_KHR_performance_query
#if VK_KHR_acceleration_structure
  eAccelerationStructureCompactedSizeKHR = VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR,
  eAccelerationStructureSerializationSizeKHR = VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR,
#endif // VK_KHR_acceleration_structure
#if VK_INTEL_performance_query
  ePerformanceQueryINTEL = VK_QUERY_TYPE_PERFORMANCE_QUERY_INTEL,
#endif // VK_INTEL_performance_query
#if VK_KHR_video_encode_queue
  eVideoEncodeFeedbackKHR = VK_QUERY_TYPE_VIDEO_ENCODE_FEEDBACK_KHR,
#endif // VK_KHR_video_encode_queue
#if VK_EXT_mesh_shader
  eMeshPrimitivesGeneratedEXT = VK_QUERY_TYPE_MESH_PRIMITIVES_GENERATED_EXT,
#endif // VK_EXT_mesh_shader
#if VK_EXT_primitives_generated_query
  ePrimitivesGeneratedEXT = VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT,
#endif // VK_EXT_primitives_generated_query
#if VK_KHR_ray_tracing_maintenance1
  eAccelerationStructureSerializationBottomLevelPointersKHR = VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_BOTTOM_LEVEL_POINTERS_KHR,
  eAccelerationStructureSizeKHR = VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SIZE_KHR,
#endif // VK_KHR_ray_tracing_maintenance1
#if VK_EXT_opacity_micromap
  eMicromapSerializationSizeEXT = VK_QUERY_TYPE_MICROMAP_SERIALIZATION_SIZE_EXT,
  eMicromapCompactedSizeEXT = VK_QUERY_TYPE_MICROMAP_COMPACTED_SIZE_EXT,
#endif // VK_EXT_opacity_micromap
};

enum class BorderColor : int32_t {
  eFloatTransparentBlack = VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK,
  eIntTransparentBlack = VK_BORDER_COLOR_INT_TRANSPARENT_BLACK,
  eFloatOpaqueBlack = VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK,
  eIntOpaqueBlack = VK_BORDER_COLOR_INT_OPAQUE_BLACK,
  eFloatOpaqueWhite = VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE,
  eIntOpaqueWhite = VK_BORDER_COLOR_INT_OPAQUE_WHITE,
#if VK_EXT_custom_border_color
  eFloatCustomEXT = VK_BORDER_COLOR_FLOAT_CUSTOM_EXT,
  eIntCustomEXT = VK_BORDER_COLOR_INT_CUSTOM_EXT,
#endif // VK_EXT_custom_border_color
};

enum class PipelineBindPoint : int32_t {
  eGraphics = VK_PIPELINE_BIND_POINT_GRAPHICS,
  eCompute = VK_PIPELINE_BIND_POINT_COMPUTE,
#if VK_KHR_ray_tracing_pipeline
  eRayTracingKHR = VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR,
#endif // VK_KHR_ray_tracing_pipeline
#if VK_HUAWEI_subpass_shading
  eSubpassShadingHUAWEI = VK_PIPELINE_BIND_POINT_SUBPASS_SHADING_HUAWEI,
#endif // VK_HUAWEI_subpass_shading
#if VK_ARM_data_graph
  eDataGraphARM = VK_PIPELINE_BIND_POINT_DATA_GRAPH_ARM,
#endif // VK_ARM_data_graph
};

enum class PipelineCacheHeaderVersion : int32_t {
  eOne = VK_PIPELINE_CACHE_HEADER_VERSION_ONE,
};
#endif // VK_VERSION_1_0

#if VK_EXT_pipeline_creation_cache_control
enum class PipelineCacheCreateFlagBits : uint32_t {
#if VK_VERSION_1_3
  bExternallySynchronized = VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT,
#endif // VK_VERSION_1_3
#if VK_EXT_pipeline_creation_cache_control
  bExternallySynchronizedEXT = VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT_EXT,
#endif // VK_EXT_pipeline_creation_cache_control
#if VK_KHR_maintenance8
  bInternallySynchronizedMergeKHR = VK_PIPELINE_CACHE_CREATE_INTERNALLY_SYNCHRONIZED_MERGE_BIT_KHR,
#endif // VK_KHR_maintenance8
};
#endif // VK_EXT_pipeline_creation_cache_control

#if VK_VERSION_1_0
enum class PrimitiveTopology : int32_t {
  ePointList = VK_PRIMITIVE_TOPOLOGY_POINT_LIST,
  eLineList = VK_PRIMITIVE_TOPOLOGY_LINE_LIST,
  eLineStrip = VK_PRIMITIVE_TOPOLOGY_LINE_STRIP,
  eTriangleList = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST,
  eTriangleStrip = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP,
  eTriangleFan = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN,
  eLineListWithAdjacency = VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY,
  eLineStripWithAdjacency = VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY,
  eTriangleListWithAdjacency = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY,
  eTriangleStripWithAdjacency = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY,
  ePatchList = VK_PRIMITIVE_TOPOLOGY_PATCH_LIST,
};

enum class SharingMode : int32_t {
  eExclusive = VK_SHARING_MODE_EXCLUSIVE,
  eConcurrent = VK_SHARING_MODE_CONCURRENT,
};

enum class IndexType : int32_t {
  eUint16 = VK_INDEX_TYPE_UINT16,
  eUint32 = VK_INDEX_TYPE_UINT32,
#if VK_VERSION_1_4
  eUint8 = VK_INDEX_TYPE_UINT8,
#endif // VK_VERSION_1_4
#if VK_KHR_acceleration_structure
  eNoneKHR = VK_INDEX_TYPE_NONE_KHR,
#endif // VK_KHR_acceleration_structure
#if VK_EXT_index_type_uint8
  eUint8EXT = VK_INDEX_TYPE_UINT8_EXT,
#endif // VK_EXT_index_type_uint8
#if VK_KHR_index_type_uint8
  eUint8KHR = VK_INDEX_TYPE_UINT8_KHR,
#endif // VK_KHR_index_type_uint8
};

enum class Filter : int32_t {
  eNearest = VK_FILTER_NEAREST,
  eLinear = VK_FILTER_LINEAR,
#if VK_IMG_filter_cubic
  eCubicIMG = VK_FILTER_CUBIC_IMG,
#endif // VK_IMG_filter_cubic
#if VK_EXT_filter_cubic
  eCubicEXT = VK_FILTER_CUBIC_EXT,
#endif // VK_EXT_filter_cubic
};

enum class SamplerMipmapMode : int32_t {
  // Choose nearest mip level
  eNearest = VK_SAMPLER_MIPMAP_MODE_NEAREST,
  // Linear filter between mip levels
  eLinear = VK_SAMPLER_MIPMAP_MODE_LINEAR,
};

enum class SamplerAddressMode : int32_t {
  eRepeat = VK_SAMPLER_ADDRESS_MODE_REPEAT,
  eMirroredRepeat = VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT,
  eClampToEdge = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE,
  eClampToBorder = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER,
#if VK_VERSION_1_2
  // No need to add an extnumber attribute, since this uses a core enum value
  eMirrorClampToEdge = VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE,
#endif // VK_VERSION_1_2
};

enum class CompareOp : int32_t {
  eNever = VK_COMPARE_OP_NEVER,
  eLess = VK_COMPARE_OP_LESS,
  eEqual = VK_COMPARE_OP_EQUAL,
  eLessOrEqual = VK_COMPARE_OP_LESS_OR_EQUAL,
  eGreater = VK_COMPARE_OP_GREATER,
  eNotEqual = VK_COMPARE_OP_NOT_EQUAL,
  eGreaterOrEqual = VK_COMPARE_OP_GREATER_OR_EQUAL,
  eAlways = VK_COMPARE_OP_ALWAYS,
};

enum class PolygonMode : int32_t {
  eFill = VK_POLYGON_MODE_FILL,
  eLine = VK_POLYGON_MODE_LINE,
  ePoint = VK_POLYGON_MODE_POINT,
#if VK_NV_fill_rectangle
  eFillRectangleNV = VK_POLYGON_MODE_FILL_RECTANGLE_NV,
#endif // VK_NV_fill_rectangle
};

enum class FrontFace : int32_t {
  eCounterClockwise = VK_FRONT_FACE_COUNTER_CLOCKWISE,
  eClockwise = VK_FRONT_FACE_CLOCKWISE,
};

enum class BlendFactor : int32_t {
  eZero = VK_BLEND_FACTOR_ZERO,
  eOne = VK_BLEND_FACTOR_ONE,
  eSrcColor = VK_BLEND_FACTOR_SRC_COLOR,
  eOneMinusSrcColor = VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR,
  eDstColor = VK_BLEND_FACTOR_DST_COLOR,
  eOneMinusDstColor = VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR,
  eSrcAlpha = VK_BLEND_FACTOR_SRC_ALPHA,
  eOneMinusSrcAlpha = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA,
  eDstAlpha = VK_BLEND_FACTOR_DST_ALPHA,
  eOneMinusDstAlpha = VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA,
  eConstantColor = VK_BLEND_FACTOR_CONSTANT_COLOR,
  eOneMinusConstantColor = VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR,
  eConstantAlpha = VK_BLEND_FACTOR_CONSTANT_ALPHA,
  eOneMinusConstantAlpha = VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA,
  eSrcAlphaSaturate = VK_BLEND_FACTOR_SRC_ALPHA_SATURATE,
  eSrc1Color = VK_BLEND_FACTOR_SRC1_COLOR,
  eOneMinusSrc1Color = VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR,
  eSrc1Alpha = VK_BLEND_FACTOR_SRC1_ALPHA,
  eOneMinusSrc1Alpha = VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA,
};

enum class BlendOp : int32_t {
  eAdd = VK_BLEND_OP_ADD,
  eSubtract = VK_BLEND_OP_SUBTRACT,
  eReverseSubtract = VK_BLEND_OP_REVERSE_SUBTRACT,
  eMin = VK_BLEND_OP_MIN,
  eMax = VK_BLEND_OP_MAX,
#if VK_EXT_blend_operation_advanced
  eZeroEXT = VK_BLEND_OP_ZERO_EXT,
  eSrcEXT = VK_BLEND_OP_SRC_EXT,
  eDstEXT = VK_BLEND_OP_DST_EXT,
  eSrcOverEXT = VK_BLEND_OP_SRC_OVER_EXT,
  eDstOverEXT = VK_BLEND_OP_DST_OVER_EXT,
  eSrcInEXT = VK_BLEND_OP_SRC_IN_EXT,
  eDstInEXT = VK_BLEND_OP_DST_IN_EXT,
  eSrcOutEXT = VK_BLEND_OP_SRC_OUT_EXT,
  eDstOutEXT = VK_BLEND_OP_DST_OUT_EXT,
  eSrcAtopEXT = VK_BLEND_OP_SRC_ATOP_EXT,
  eDstAtopEXT = VK_BLEND_OP_DST_ATOP_EXT,
  eXorEXT = VK_BLEND_OP_XOR_EXT,
  eMultiplyEXT = VK_BLEND_OP_MULTIPLY_EXT,
  eScreenEXT = VK_BLEND_OP_SCREEN_EXT,
  eOverlayEXT = VK_BLEND_OP_OVERLAY_EXT,
  eDarkenEXT = VK_BLEND_OP_DARKEN_EXT,
  eLightenEXT = VK_BLEND_OP_LIGHTEN_EXT,
  eColordodgeEXT = VK_BLEND_OP_COLORDODGE_EXT,
  eColorburnEXT = VK_BLEND_OP_COLORBURN_EXT,
  eHardlightEXT = VK_BLEND_OP_HARDLIGHT_EXT,
  eSoftlightEXT = VK_BLEND_OP_SOFTLIGHT_EXT,
  eDifferenceEXT = VK_BLEND_OP_DIFFERENCE_EXT,
  eExclusionEXT = VK_BLEND_OP_EXCLUSION_EXT,
  eInvertEXT = VK_BLEND_OP_INVERT_EXT,
  eInvertRgbEXT = VK_BLEND_OP_INVERT_RGB_EXT,
  eLineardodgeEXT = VK_BLEND_OP_LINEARDODGE_EXT,
  eLinearburnEXT = VK_BLEND_OP_LINEARBURN_EXT,
  eVividlightEXT = VK_BLEND_OP_VIVIDLIGHT_EXT,
  eLinearlightEXT = VK_BLEND_OP_LINEARLIGHT_EXT,
  ePinlightEXT = VK_BLEND_OP_PINLIGHT_EXT,
  eHardmixEXT = VK_BLEND_OP_HARDMIX_EXT,
  eHslHueEXT = VK_BLEND_OP_HSL_HUE_EXT,
  eHslSaturationEXT = VK_BLEND_OP_HSL_SATURATION_EXT,
  eHslColorEXT = VK_BLEND_OP_HSL_COLOR_EXT,
  eHslLuminosityEXT = VK_BLEND_OP_HSL_LUMINOSITY_EXT,
  ePlusEXT = VK_BLEND_OP_PLUS_EXT,
  ePlusClampedEXT = VK_BLEND_OP_PLUS_CLAMPED_EXT,
  ePlusClampedAlphaEXT = VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT,
  ePlusDarkerEXT = VK_BLEND_OP_PLUS_DARKER_EXT,
  eMinusEXT = VK_BLEND_OP_MINUS_EXT,
  eMinusClampedEXT = VK_BLEND_OP_MINUS_CLAMPED_EXT,
  eContrastEXT = VK_BLEND_OP_CONTRAST_EXT,
  eInvertOvgEXT = VK_BLEND_OP_INVERT_OVG_EXT,
  eRedEXT = VK_BLEND_OP_RED_EXT,
  eGreenEXT = VK_BLEND_OP_GREEN_EXT,
  eBlueEXT = VK_BLEND_OP_BLUE_EXT,
#endif // VK_EXT_blend_operation_advanced
};

enum class StencilOp : int32_t {
  eKeep = VK_STENCIL_OP_KEEP,
  eZero = VK_STENCIL_OP_ZERO,
  eReplace = VK_STENCIL_OP_REPLACE,
  eIncrementAndClamp = VK_STENCIL_OP_INCREMENT_AND_CLAMP,
  eDecrementAndClamp = VK_STENCIL_OP_DECREMENT_AND_CLAMP,
  eInvert = VK_STENCIL_OP_INVERT,
  eIncrementAndWrap = VK_STENCIL_OP_INCREMENT_AND_WRAP,
  eDecrementAndWrap = VK_STENCIL_OP_DECREMENT_AND_WRAP,
};

enum class LogicOp : int32_t {
  eClear = VK_LOGIC_OP_CLEAR,
  eAnd = VK_LOGIC_OP_AND,
  eAndReverse = VK_LOGIC_OP_AND_REVERSE,
  eCopy = VK_LOGIC_OP_COPY,
  eAndInverted = VK_LOGIC_OP_AND_INVERTED,
  eNoOp = VK_LOGIC_OP_NO_OP,
  eXor = VK_LOGIC_OP_XOR,
  eOr = VK_LOGIC_OP_OR,
  eNor = VK_LOGIC_OP_NOR,
  eEquivalent = VK_LOGIC_OP_EQUIVALENT,
  eInvert = VK_LOGIC_OP_INVERT,
  eOrReverse = VK_LOGIC_OP_OR_REVERSE,
  eCopyInverted = VK_LOGIC_OP_COPY_INVERTED,
  eOrInverted = VK_LOGIC_OP_OR_INVERTED,
  eNand = VK_LOGIC_OP_NAND,
  eSet = VK_LOGIC_OP_SET,
};

enum class InternalAllocationType : int32_t {
  eExecutable = VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE,
};

enum class SystemAllocationScope : int32_t {
  eCommand = VK_SYSTEM_ALLOCATION_SCOPE_COMMAND,
  eObject = VK_SYSTEM_ALLOCATION_SCOPE_OBJECT,
  eCache = VK_SYSTEM_ALLOCATION_SCOPE_CACHE,
  eDevice = VK_SYSTEM_ALLOCATION_SCOPE_DEVICE,
  eInstance = VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE,
};

enum class PhysicalDeviceType : int32_t {
  eOther = VK_PHYSICAL_DEVICE_TYPE_OTHER,
  eIntegratedGpu = VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU,
  eDiscreteGpu = VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU,
  eVirtualGpu = VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU,
  eCpu = VK_PHYSICAL_DEVICE_TYPE_CPU,
};

enum class VertexInputRate : int32_t {
  eVertex = VK_VERTEX_INPUT_RATE_VERTEX,
  eInstance = VK_VERTEX_INPUT_RATE_INSTANCE,
};

// Vulkan format definitions
enum class Format : int32_t {
  eUndefined = VK_FORMAT_UNDEFINED,
  eR4G4UnormPack8 = VK_FORMAT_R4G4_UNORM_PACK8,
  eR4G4B4A4UnormPack16 = VK_FORMAT_R4G4B4A4_UNORM_PACK16,
  eB4G4R4A4UnormPack16 = VK_FORMAT_B4G4R4A4_UNORM_PACK16,
  eR5G6B5UnormPack16 = VK_FORMAT_R5G6B5_UNORM_PACK16,
  eB5G6R5UnormPack16 = VK_FORMAT_B5G6R5_UNORM_PACK16,
  eR5G5B5A1UnormPack16 = VK_FORMAT_R5G5B5A1_UNORM_PACK16,
  eB5G5R5A1UnormPack16 = VK_FORMAT_B5G5R5A1_UNORM_PACK16,
  eA1R5G5B5UnormPack16 = VK_FORMAT_A1R5G5B5_UNORM_PACK16,
  eR8Unorm = VK_FORMAT_R8_UNORM,
  eR8Snorm = VK_FORMAT_R8_SNORM,
  eR8Uscaled = VK_FORMAT_R8_USCALED,
  eR8Sscaled = VK_FORMAT_R8_SSCALED,
  eR8Uint = VK_FORMAT_R8_UINT,
  eR8Sint = VK_FORMAT_R8_SINT,
  eR8Srgb = VK_FORMAT_R8_SRGB,
  eR8G8Unorm = VK_FORMAT_R8G8_UNORM,
  eR8G8Snorm = VK_FORMAT_R8G8_SNORM,
  eR8G8Uscaled = VK_FORMAT_R8G8_USCALED,
  eR8G8Sscaled = VK_FORMAT_R8G8_SSCALED,
  eR8G8Uint = VK_FORMAT_R8G8_UINT,
  eR8G8Sint = VK_FORMAT_R8G8_SINT,
  eR8G8Srgb = VK_FORMAT_R8G8_SRGB,
  eR8G8B8Unorm = VK_FORMAT_R8G8B8_UNORM,
  eR8G8B8Snorm = VK_FORMAT_R8G8B8_SNORM,
  eR8G8B8Uscaled = VK_FORMAT_R8G8B8_USCALED,
  eR8G8B8Sscaled = VK_FORMAT_R8G8B8_SSCALED,
  eR8G8B8Uint = VK_FORMAT_R8G8B8_UINT,
  eR8G8B8Sint = VK_FORMAT_R8G8B8_SINT,
  eR8G8B8Srgb = VK_FORMAT_R8G8B8_SRGB,
  eB8G8R8Unorm = VK_FORMAT_B8G8R8_UNORM,
  eB8G8R8Snorm = VK_FORMAT_B8G8R8_SNORM,
  eB8G8R8Uscaled = VK_FORMAT_B8G8R8_USCALED,
  eB8G8R8Sscaled = VK_FORMAT_B8G8R8_SSCALED,
  eB8G8R8Uint = VK_FORMAT_B8G8R8_UINT,
  eB8G8R8Sint = VK_FORMAT_B8G8R8_SINT,
  eB8G8R8Srgb = VK_FORMAT_B8G8R8_SRGB,
  eR8G8B8A8Unorm = VK_FORMAT_R8G8B8A8_UNORM,
  eR8G8B8A8Snorm = VK_FORMAT_R8G8B8A8_SNORM,
  eR8G8B8A8Uscaled = VK_FORMAT_R8G8B8A8_USCALED,
  eR8G8B8A8Sscaled = VK_FORMAT_R8G8B8A8_SSCALED,
  eR8G8B8A8Uint = VK_FORMAT_R8G8B8A8_UINT,
  eR8G8B8A8Sint = VK_FORMAT_R8G8B8A8_SINT,
  eR8G8B8A8Srgb = VK_FORMAT_R8G8B8A8_SRGB,
  eB8G8R8A8Unorm = VK_FORMAT_B8G8R8A8_UNORM,
  eB8G8R8A8Snorm = VK_FORMAT_B8G8R8A8_SNORM,
  eB8G8R8A8Uscaled = VK_FORMAT_B8G8R8A8_USCALED,
  eB8G8R8A8Sscaled = VK_FORMAT_B8G8R8A8_SSCALED,
  eB8G8R8A8Uint = VK_FORMAT_B8G8R8A8_UINT,
  eB8G8R8A8Sint = VK_FORMAT_B8G8R8A8_SINT,
  eB8G8R8A8Srgb = VK_FORMAT_B8G8R8A8_SRGB,
  eA8B8G8R8UnormPack32 = VK_FORMAT_A8B8G8R8_UNORM_PACK32,
  eA8B8G8R8SnormPack32 = VK_FORMAT_A8B8G8R8_SNORM_PACK32,
  eA8B8G8R8UscaledPack32 = VK_FORMAT_A8B8G8R8_USCALED_PACK32,
  eA8B8G8R8SscaledPack32 = VK_FORMAT_A8B8G8R8_SSCALED_PACK32,
  eA8B8G8R8UintPack32 = VK_FORMAT_A8B8G8R8_UINT_PACK32,
  eA8B8G8R8SintPack32 = VK_FORMAT_A8B8G8R8_SINT_PACK32,
  eA8B8G8R8SrgbPack32 = VK_FORMAT_A8B8G8R8_SRGB_PACK32,
  eA2R10G10B10UnormPack32 = VK_FORMAT_A2R10G10B10_UNORM_PACK32,
  eA2R10G10B10SnormPack32 = VK_FORMAT_A2R10G10B10_SNORM_PACK32,
  eA2R10G10B10UscaledPack32 = VK_FORMAT_A2R10G10B10_USCALED_PACK32,
  eA2R10G10B10SscaledPack32 = VK_FORMAT_A2R10G10B10_SSCALED_PACK32,
  eA2R10G10B10UintPack32 = VK_FORMAT_A2R10G10B10_UINT_PACK32,
  eA2R10G10B10SintPack32 = VK_FORMAT_A2R10G10B10_SINT_PACK32,
  eA2B10G10R10UnormPack32 = VK_FORMAT_A2B10G10R10_UNORM_PACK32,
  eA2B10G10R10SnormPack32 = VK_FORMAT_A2B10G10R10_SNORM_PACK32,
  eA2B10G10R10UscaledPack32 = VK_FORMAT_A2B10G10R10_USCALED_PACK32,
  eA2B10G10R10SscaledPack32 = VK_FORMAT_A2B10G10R10_SSCALED_PACK32,
  eA2B10G10R10UintPack32 = VK_FORMAT_A2B10G10R10_UINT_PACK32,
  eA2B10G10R10SintPack32 = VK_FORMAT_A2B10G10R10_SINT_PACK32,
  eR16Unorm = VK_FORMAT_R16_UNORM,
  eR16Snorm = VK_FORMAT_R16_SNORM,
  eR16Uscaled = VK_FORMAT_R16_USCALED,
  eR16Sscaled = VK_FORMAT_R16_SSCALED,
  eR16Uint = VK_FORMAT_R16_UINT,
  eR16Sint = VK_FORMAT_R16_SINT,
  eR16Sfloat = VK_FORMAT_R16_SFLOAT,
  eR16G16Unorm = VK_FORMAT_R16G16_UNORM,
  eR16G16Snorm = VK_FORMAT_R16G16_SNORM,
  eR16G16Uscaled = VK_FORMAT_R16G16_USCALED,
  eR16G16Sscaled = VK_FORMAT_R16G16_SSCALED,
  eR16G16Uint = VK_FORMAT_R16G16_UINT,
  eR16G16Sint = VK_FORMAT_R16G16_SINT,
  eR16G16Sfloat = VK_FORMAT_R16G16_SFLOAT,
  eR16G16B16Unorm = VK_FORMAT_R16G16B16_UNORM,
  eR16G16B16Snorm = VK_FORMAT_R16G16B16_SNORM,
  eR16G16B16Uscaled = VK_FORMAT_R16G16B16_USCALED,
  eR16G16B16Sscaled = VK_FORMAT_R16G16B16_SSCALED,
  eR16G16B16Uint = VK_FORMAT_R16G16B16_UINT,
  eR16G16B16Sint = VK_FORMAT_R16G16B16_SINT,
  eR16G16B16Sfloat = VK_FORMAT_R16G16B16_SFLOAT,
  eR16G16B16A16Unorm = VK_FORMAT_R16G16B16A16_UNORM,
  eR16G16B16A16Snorm = VK_FORMAT_R16G16B16A16_SNORM,
  eR16G16B16A16Uscaled = VK_FORMAT_R16G16B16A16_USCALED,
  eR16G16B16A16Sscaled = VK_FORMAT_R16G16B16A16_SSCALED,
  eR16G16B16A16Uint = VK_FORMAT_R16G16B16A16_UINT,
  eR16G16B16A16Sint = VK_FORMAT_R16G16B16A16_SINT,
  eR16G16B16A16Sfloat = VK_FORMAT_R16G16B16A16_SFLOAT,
  eR32Uint = VK_FORMAT_R32_UINT,
  eR32Sint = VK_FORMAT_R32_SINT,
  eR32Sfloat = VK_FORMAT_R32_SFLOAT,
  eR32G32Uint = VK_FORMAT_R32G32_UINT,
  eR32G32Sint = VK_FORMAT_R32G32_SINT,
  eR32G32Sfloat = VK_FORMAT_R32G32_SFLOAT,
  eR32G32B32Uint = VK_FORMAT_R32G32B32_UINT,
  eR32G32B32Sint = VK_FORMAT_R32G32B32_SINT,
  eR32G32B32Sfloat = VK_FORMAT_R32G32B32_SFLOAT,
  eR32G32B32A32Uint = VK_FORMAT_R32G32B32A32_UINT,
  eR32G32B32A32Sint = VK_FORMAT_R32G32B32A32_SINT,
  eR32G32B32A32Sfloat = VK_FORMAT_R32G32B32A32_SFLOAT,
  eR64Uint = VK_FORMAT_R64_UINT,
  eR64Sint = VK_FORMAT_R64_SINT,
  eR64Sfloat = VK_FORMAT_R64_SFLOAT,
  eR64G64Uint = VK_FORMAT_R64G64_UINT,
  eR64G64Sint = VK_FORMAT_R64G64_SINT,
  eR64G64Sfloat = VK_FORMAT_R64G64_SFLOAT,
  eR64G64B64Uint = VK_FORMAT_R64G64B64_UINT,
  eR64G64B64Sint = VK_FORMAT_R64G64B64_SINT,
  eR64G64B64Sfloat = VK_FORMAT_R64G64B64_SFLOAT,
  eR64G64B64A64Uint = VK_FORMAT_R64G64B64A64_UINT,
  eR64G64B64A64Sint = VK_FORMAT_R64G64B64A64_SINT,
  eR64G64B64A64Sfloat = VK_FORMAT_R64G64B64A64_SFLOAT,
  eB10G11R11UfloatPack32 = VK_FORMAT_B10G11R11_UFLOAT_PACK32,
  eE5B9G9R9UfloatPack32 = VK_FORMAT_E5B9G9R9_UFLOAT_PACK32,
  eD16Unorm = VK_FORMAT_D16_UNORM,
  eX8D24UnormPack32 = VK_FORMAT_X8_D24_UNORM_PACK32,
  eD32Sfloat = VK_FORMAT_D32_SFLOAT,
  eS8Uint = VK_FORMAT_S8_UINT,
  eD16UnormS8Uint = VK_FORMAT_D16_UNORM_S8_UINT,
  eD24UnormS8Uint = VK_FORMAT_D24_UNORM_S8_UINT,
  eD32SfloatS8Uint = VK_FORMAT_D32_SFLOAT_S8_UINT,
  eBc1RgbUnormBlock = VK_FORMAT_BC1_RGB_UNORM_BLOCK,
  eBc1RgbSrgbBlock = VK_FORMAT_BC1_RGB_SRGB_BLOCK,
  eBc1RgbaUnormBlock = VK_FORMAT_BC1_RGBA_UNORM_BLOCK,
  eBc1RgbaSrgbBlock = VK_FORMAT_BC1_RGBA_SRGB_BLOCK,
  eBc2UnormBlock = VK_FORMAT_BC2_UNORM_BLOCK,
  eBc2SrgbBlock = VK_FORMAT_BC2_SRGB_BLOCK,
  eBc3UnormBlock = VK_FORMAT_BC3_UNORM_BLOCK,
  eBc3SrgbBlock = VK_FORMAT_BC3_SRGB_BLOCK,
  eBc4UnormBlock = VK_FORMAT_BC4_UNORM_BLOCK,
  eBc4SnormBlock = VK_FORMAT_BC4_SNORM_BLOCK,
  eBc5UnormBlock = VK_FORMAT_BC5_UNORM_BLOCK,
  eBc5SnormBlock = VK_FORMAT_BC5_SNORM_BLOCK,
  eBc6HUfloatBlock = VK_FORMAT_BC6H_UFLOAT_BLOCK,
  eBc6HSfloatBlock = VK_FORMAT_BC6H_SFLOAT_BLOCK,
  eBc7UnormBlock = VK_FORMAT_BC7_UNORM_BLOCK,
  eBc7SrgbBlock = VK_FORMAT_BC7_SRGB_BLOCK,
  eEtc2R8G8B8UnormBlock = VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK,
  eEtc2R8G8B8SrgbBlock = VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK,
  eEtc2R8G8B8A1UnormBlock = VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK,
  eEtc2R8G8B8A1SrgbBlock = VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK,
  eEtc2R8G8B8A8UnormBlock = VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK,
  eEtc2R8G8B8A8SrgbBlock = VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK,
  eEacR11UnormBlock = VK_FORMAT_EAC_R11_UNORM_BLOCK,
  eEacR11SnormBlock = VK_FORMAT_EAC_R11_SNORM_BLOCK,
  eEacR11G11UnormBlock = VK_FORMAT_EAC_R11G11_UNORM_BLOCK,
  eEacR11G11SnormBlock = VK_FORMAT_EAC_R11G11_SNORM_BLOCK,
  eAstc4x4UnormBlock = VK_FORMAT_ASTC_4x4_UNORM_BLOCK,
  eAstc4x4SrgbBlock = VK_FORMAT_ASTC_4x4_SRGB_BLOCK,
  eAstc5x4UnormBlock = VK_FORMAT_ASTC_5x4_UNORM_BLOCK,
  eAstc5x4SrgbBlock = VK_FORMAT_ASTC_5x4_SRGB_BLOCK,
  eAstc5x5UnormBlock = VK_FORMAT_ASTC_5x5_UNORM_BLOCK,
  eAstc5x5SrgbBlock = VK_FORMAT_ASTC_5x5_SRGB_BLOCK,
  eAstc6x5UnormBlock = VK_FORMAT_ASTC_6x5_UNORM_BLOCK,
  eAstc6x5SrgbBlock = VK_FORMAT_ASTC_6x5_SRGB_BLOCK,
  eAstc6x6UnormBlock = VK_FORMAT_ASTC_6x6_UNORM_BLOCK,
  eAstc6x6SrgbBlock = VK_FORMAT_ASTC_6x6_SRGB_BLOCK,
  eAstc8x5UnormBlock = VK_FORMAT_ASTC_8x5_UNORM_BLOCK,
  eAstc8x5SrgbBlock = VK_FORMAT_ASTC_8x5_SRGB_BLOCK,
  eAstc8x6UnormBlock = VK_FORMAT_ASTC_8x6_UNORM_BLOCK,
  eAstc8x6SrgbBlock = VK_FORMAT_ASTC_8x6_SRGB_BLOCK,
  eAstc8x8UnormBlock = VK_FORMAT_ASTC_8x8_UNORM_BLOCK,
  eAstc8x8SrgbBlock = VK_FORMAT_ASTC_8x8_SRGB_BLOCK,
  eAstc10x5UnormBlock = VK_FORMAT_ASTC_10x5_UNORM_BLOCK,
  eAstc10x5SrgbBlock = VK_FORMAT_ASTC_10x5_SRGB_BLOCK,
  eAstc10x6UnormBlock = VK_FORMAT_ASTC_10x6_UNORM_BLOCK,
  eAstc10x6SrgbBlock = VK_FORMAT_ASTC_10x6_SRGB_BLOCK,
  eAstc10x8UnormBlock = VK_FORMAT_ASTC_10x8_UNORM_BLOCK,
  eAstc10x8SrgbBlock = VK_FORMAT_ASTC_10x8_SRGB_BLOCK,
  eAstc10x10UnormBlock = VK_FORMAT_ASTC_10x10_UNORM_BLOCK,
  eAstc10x10SrgbBlock = VK_FORMAT_ASTC_10x10_SRGB_BLOCK,
  eAstc12x10UnormBlock = VK_FORMAT_ASTC_12x10_UNORM_BLOCK,
  eAstc12x10SrgbBlock = VK_FORMAT_ASTC_12x10_SRGB_BLOCK,
  eAstc12x12UnormBlock = VK_FORMAT_ASTC_12x12_UNORM_BLOCK,
  eAstc12x12SrgbBlock = VK_FORMAT_ASTC_12x12_SRGB_BLOCK,
#if VK_VERSION_1_1
  eG8B8G8R8422Unorm = VK_FORMAT_G8B8G8R8_422_UNORM,
  eB8G8R8G8422Unorm = VK_FORMAT_B8G8R8G8_422_UNORM,
  eG8B8R83Plane420Unorm = VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM,
  eG8B8R82Plane420Unorm = VK_FORMAT_G8_B8R8_2PLANE_420_UNORM,
  eG8B8R83Plane422Unorm = VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM,
  eG8B8R82Plane422Unorm = VK_FORMAT_G8_B8R8_2PLANE_422_UNORM,
  eG8B8R83Plane444Unorm = VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM,
  eR10X6UnormPack16 = VK_FORMAT_R10X6_UNORM_PACK16,
  eR10X6G10X6Unorm2Pack16 = VK_FORMAT_R10X6G10X6_UNORM_2PACK16,
  eR10X6G10X6B10X6A10X6Unorm4Pack16 = VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16,
  eG10X6B10X6G10X6R10X6422Unorm4Pack16 = VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16,
  eB10X6G10X6R10X6G10X6422Unorm4Pack16 = VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16,
  eG10X6B10X6R10X63Plane420Unorm3Pack16 = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16,
  eG10X6B10X6R10X62Plane420Unorm3Pack16 = VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16,
  eG10X6B10X6R10X63Plane422Unorm3Pack16 = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16,
  eG10X6B10X6R10X62Plane422Unorm3Pack16 = VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16,
  eG10X6B10X6R10X63Plane444Unorm3Pack16 = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16,
  eR12X4UnormPack16 = VK_FORMAT_R12X4_UNORM_PACK16,
  eR12X4G12X4Unorm2Pack16 = VK_FORMAT_R12X4G12X4_UNORM_2PACK16,
  eR12X4G12X4B12X4A12X4Unorm4Pack16 = VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16,
  eG12X4B12X4G12X4R12X4422Unorm4Pack16 = VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16,
  eB12X4G12X4R12X4G12X4422Unorm4Pack16 = VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16,
  eG12X4B12X4R12X43Plane420Unorm3Pack16 = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16,
  eG12X4B12X4R12X42Plane420Unorm3Pack16 = VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16,
  eG12X4B12X4R12X43Plane422Unorm3Pack16 = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16,
  eG12X4B12X4R12X42Plane422Unorm3Pack16 = VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16,
  eG12X4B12X4R12X43Plane444Unorm3Pack16 = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16,
  eG16B16G16R16422Unorm = VK_FORMAT_G16B16G16R16_422_UNORM,
  eB16G16R16G16422Unorm = VK_FORMAT_B16G16R16G16_422_UNORM,
  eG16B16R163Plane420Unorm = VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM,
  eG16B16R162Plane420Unorm = VK_FORMAT_G16_B16R16_2PLANE_420_UNORM,
  eG16B16R163Plane422Unorm = VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM,
  eG16B16R162Plane422Unorm = VK_FORMAT_G16_B16R16_2PLANE_422_UNORM,
  eG16B16R163Plane444Unorm = VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM,
#endif // VK_VERSION_1_1
#if VK_VERSION_1_3
  eG8B8R82Plane444Unorm = VK_FORMAT_G8_B8R8_2PLANE_444_UNORM,
  eG10X6B10X6R10X62Plane444Unorm3Pack16 = VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16,
  eG12X4B12X4R12X42Plane444Unorm3Pack16 = VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16,
  eG16B16R162Plane444Unorm = VK_FORMAT_G16_B16R16_2PLANE_444_UNORM,
  eA4R4G4B4UnormPack16 = VK_FORMAT_A4R4G4B4_UNORM_PACK16,
  eA4B4G4R4UnormPack16 = VK_FORMAT_A4B4G4R4_UNORM_PACK16,
  eAstc4x4SfloatBlock = VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK,
  eAstc5x4SfloatBlock = VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK,
  eAstc5x5SfloatBlock = VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK,
  eAstc6x5SfloatBlock = VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK,
  eAstc6x6SfloatBlock = VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK,
  eAstc8x5SfloatBlock = VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK,
  eAstc8x6SfloatBlock = VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK,
  eAstc8x8SfloatBlock = VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK,
  eAstc10x5SfloatBlock = VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK,
  eAstc10x6SfloatBlock = VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK,
  eAstc10x8SfloatBlock = VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK,
  eAstc10x10SfloatBlock = VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK,
  eAstc12x10SfloatBlock = VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK,
  eAstc12x12SfloatBlock = VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK,
#endif // VK_VERSION_1_3
#if VK_VERSION_1_4
  eA1B5G5R5UnormPack16 = VK_FORMAT_A1B5G5R5_UNORM_PACK16,
  eA8Unorm = VK_FORMAT_A8_UNORM,
#endif // VK_VERSION_1_4
#if VK_EXT_texture_compression_astc_hdr
  eAstc4x4SfloatBlockEXT = VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT,
  eAstc5x4SfloatBlockEXT = VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT,
  eAstc5x5SfloatBlockEXT = VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT,
  eAstc6x5SfloatBlockEXT = VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT,
  eAstc6x6SfloatBlockEXT = VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT,
  eAstc8x5SfloatBlockEXT = VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT,
  eAstc8x6SfloatBlockEXT = VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT,
  eAstc8x8SfloatBlockEXT = VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT,
  eAstc10x5SfloatBlockEXT = VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT,
  eAstc10x6SfloatBlockEXT = VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT,
  eAstc10x8SfloatBlockEXT = VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT,
  eAstc10x10SfloatBlockEXT = VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT,
  eAstc12x10SfloatBlockEXT = VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT,
  eAstc12x12SfloatBlockEXT = VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT,
#endif // VK_EXT_texture_compression_astc_hdr
#if VK_KHR_sampler_ycbcr_conversion
  eG8B8G8R8422UnormKHR = VK_FORMAT_G8B8G8R8_422_UNORM_KHR,
  eB8G8R8G8422UnormKHR = VK_FORMAT_B8G8R8G8_422_UNORM_KHR,
  eG8B8R83Plane420UnormKHR = VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR,
  eG8B8R82Plane420UnormKHR = VK_FORMAT_G8_B8R8_2PLANE_420_UNORM_KHR,
  eG8B8R83Plane422UnormKHR = VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM_KHR,
  eG8B8R82Plane422UnormKHR = VK_FORMAT_G8_B8R8_2PLANE_422_UNORM_KHR,
  eG8B8R83Plane444UnormKHR = VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM_KHR,
  eR10X6UnormPack16KHR = VK_FORMAT_R10X6_UNORM_PACK16_KHR,
  eR10X6G10X6Unorm2Pack16KHR = VK_FORMAT_R10X6G10X6_UNORM_2PACK16_KHR,
  eR10X6G10X6B10X6A10X6Unorm4Pack16KHR = VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR,
  eG10X6B10X6G10X6R10X6422Unorm4Pack16KHR = VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR,
  eB10X6G10X6R10X6G10X6422Unorm4Pack16KHR = VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR,
  eG10X6B10X6R10X63Plane420Unorm3Pack16KHR = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR,
  eG10X6B10X6R10X62Plane420Unorm3Pack16KHR = VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR,
  eG10X6B10X6R10X63Plane422Unorm3Pack16KHR = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR,
  eG10X6B10X6R10X62Plane422Unorm3Pack16KHR = VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR,
  eG10X6B10X6R10X63Plane444Unorm3Pack16KHR = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR,
  eR12X4UnormPack16KHR = VK_FORMAT_R12X4_UNORM_PACK16_KHR,
  eR12X4G12X4Unorm2Pack16KHR = VK_FORMAT_R12X4G12X4_UNORM_2PACK16_KHR,
  eR12X4G12X4B12X4A12X4Unorm4Pack16KHR = VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR,
  eG12X4B12X4G12X4R12X4422Unorm4Pack16KHR = VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR,
  eB12X4G12X4R12X4G12X4422Unorm4Pack16KHR = VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR,
  eG12X4B12X4R12X43Plane420Unorm3Pack16KHR = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR,
  eG12X4B12X4R12X42Plane420Unorm3Pack16KHR = VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR,
  eG12X4B12X4R12X43Plane422Unorm3Pack16KHR = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR,
  eG12X4B12X4R12X42Plane422Unorm3Pack16KHR = VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR,
  eG12X4B12X4R12X43Plane444Unorm3Pack16KHR = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR,
  eG16B16G16R16422UnormKHR = VK_FORMAT_G16B16G16R16_422_UNORM_KHR,
  eB16G16R16G16422UnormKHR = VK_FORMAT_B16G16R16G16_422_UNORM_KHR,
  eG16B16R163Plane420UnormKHR = VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM_KHR,
  eG16B16R162Plane420UnormKHR = VK_FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR,
  eG16B16R163Plane422UnormKHR = VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR,
  eG16B16R162Plane422UnormKHR = VK_FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR,
  eG16B16R163Plane444UnormKHR = VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR,
#endif // VK_KHR_sampler_ycbcr_conversion
#if VK_EXT_ycbcr_2plane_444_formats
  eG8B8R82Plane444UnormEXT = VK_FORMAT_G8_B8R8_2PLANE_444_UNORM_EXT,
  eG10X6B10X6R10X62Plane444Unorm3Pack16EXT = VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16_EXT,
  eG12X4B12X4R12X42Plane444Unorm3Pack16EXT = VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16_EXT,
  eG16B16R162Plane444UnormEXT = VK_FORMAT_G16_B16R16_2PLANE_444_UNORM_EXT,
#endif // VK_EXT_ycbcr_2plane_444_formats
#if VK_EXT_4444_formats
  eA4R4G4B4UnormPack16EXT = VK_FORMAT_A4R4G4B4_UNORM_PACK16_EXT,
  eA4B4G4R4UnormPack16EXT = VK_FORMAT_A4B4G4R4_UNORM_PACK16_EXT,
#endif // VK_EXT_4444_formats
#if VK_ARM_tensors
  eR8BoolARM = VK_FORMAT_R8_BOOL_ARM,
#endif // VK_ARM_tensors
#if VK_NV_optical_flow
  eR16G16Sfixed5NV = VK_FORMAT_R16G16_SFIXED5_NV,
#endif // VK_NV_optical_flow
#if VK_KHR_maintenance5
  eA1B5G5R5UnormPack16KHR = VK_FORMAT_A1B5G5R5_UNORM_PACK16_KHR,
  eA8UnormKHR = VK_FORMAT_A8_UNORM_KHR,
#endif // VK_KHR_maintenance5
#if VK_ARM_format_pack
  eR10X6UintPack16ARM = VK_FORMAT_R10X6_UINT_PACK16_ARM,
  eR10X6G10X6Uint2Pack16ARM = VK_FORMAT_R10X6G10X6_UINT_2PACK16_ARM,
  eR10X6G10X6B10X6A10X6Uint4Pack16ARM = VK_FORMAT_R10X6G10X6B10X6A10X6_UINT_4PACK16_ARM,
  eR12X4UintPack16ARM = VK_FORMAT_R12X4_UINT_PACK16_ARM,
  eR12X4G12X4Uint2Pack16ARM = VK_FORMAT_R12X4G12X4_UINT_2PACK16_ARM,
  eR12X4G12X4B12X4A12X4Uint4Pack16ARM = VK_FORMAT_R12X4G12X4B12X4A12X4_UINT_4PACK16_ARM,
  eR14X2UintPack16ARM = VK_FORMAT_R14X2_UINT_PACK16_ARM,
  eR14X2G14X2Uint2Pack16ARM = VK_FORMAT_R14X2G14X2_UINT_2PACK16_ARM,
  eR14X2G14X2B14X2A14X2Uint4Pack16ARM = VK_FORMAT_R14X2G14X2B14X2A14X2_UINT_4PACK16_ARM,
  eR14X2UnormPack16ARM = VK_FORMAT_R14X2_UNORM_PACK16_ARM,
  eR14X2G14X2Unorm2Pack16ARM = VK_FORMAT_R14X2G14X2_UNORM_2PACK16_ARM,
  eR14X2G14X2B14X2A14X2Unorm4Pack16ARM = VK_FORMAT_R14X2G14X2B14X2A14X2_UNORM_4PACK16_ARM,
  eG14X2B14X2R14X22Plane420Unorm3Pack16ARM = VK_FORMAT_G14X2_B14X2R14X2_2PLANE_420_UNORM_3PACK16_ARM,
  eG14X2B14X2R14X22Plane422Unorm3Pack16ARM = VK_FORMAT_G14X2_B14X2R14X2_2PLANE_422_UNORM_3PACK16_ARM,
#endif // VK_ARM_format_pack
};

// Structure type enumerant
enum class StructureType : int32_t {
  eApplicationInfo = VK_STRUCTURE_TYPE_APPLICATION_INFO,
  eInstanceCreateInfo = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO,
  eDeviceQueueCreateInfo = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO,
  eDeviceCreateInfo = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
  eSubmitInfo = VK_STRUCTURE_TYPE_SUBMIT_INFO,
  eMemoryAllocateInfo = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
  eMappedMemoryRange = VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE,
  eBindSparseInfo = VK_STRUCTURE_TYPE_BIND_SPARSE_INFO,
  eFenceCreateInfo = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO,
  eSemaphoreCreateInfo = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO,
  eEventCreateInfo = VK_STRUCTURE_TYPE_EVENT_CREATE_INFO,
  eQueryPoolCreateInfo = VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO,
  eBufferCreateInfo = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,
  eBufferViewCreateInfo = VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO,
  eImageCreateInfo = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,
  eImageViewCreateInfo = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO,
  eShaderModuleCreateInfo = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO,
  ePipelineCacheCreateInfo = VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO,
  ePipelineShaderStageCreateInfo = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO,
  ePipelineVertexInputStateCreateInfo = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO,
  ePipelineInputAssemblyStateCreateInfo = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO,
  ePipelineTessellationStateCreateInfo = VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO,
  ePipelineViewportStateCreateInfo = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO,
  ePipelineRasterizationStateCreateInfo = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO,
  ePipelineMultisampleStateCreateInfo = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO,
  ePipelineDepthStencilStateCreateInfo = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO,
  ePipelineColorBlendStateCreateInfo = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO,
  ePipelineDynamicStateCreateInfo = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO,
  eGraphicsPipelineCreateInfo = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO,
  eComputePipelineCreateInfo = VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO,
  ePipelineLayoutCreateInfo = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO,
  eSamplerCreateInfo = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO,
  eDescriptorSetLayoutCreateInfo = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO,
  eDescriptorPoolCreateInfo = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO,
  eDescriptorSetAllocateInfo = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO,
  eWriteDescriptorSet = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,
  eCopyDescriptorSet = VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET,
  eFramebufferCreateInfo = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO,
  eRenderPassCreateInfo = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO,
  eCommandPoolCreateInfo = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO,
  eCommandBufferAllocateInfo = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO,
  eCommandBufferInheritanceInfo = VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO,
  eCommandBufferBeginInfo = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO,
  eRenderPassBeginInfo = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO,
  eBufferMemoryBarrier = VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER,
  eImageMemoryBarrier = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER,
  eMemoryBarrier = VK_STRUCTURE_TYPE_MEMORY_BARRIER,
  // Reserved for internal use by the loader, layers, and ICDs
  eLoaderInstanceCreateInfo = VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO,
  // Reserved for internal use by the loader, layers, and ICDs
  eLoaderDeviceCreateInfo = VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO,
#if VK_VERSION_1_1
  ePhysicalDeviceSubgroupProperties = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES,
  eBindBufferMemoryInfo = VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO,
  eBindImageMemoryInfo = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO,
  ePhysicalDevice16BitStorageFeatures = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES,
  eMemoryDedicatedRequirements = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS,
  eMemoryDedicatedAllocateInfo = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO,
  eMemoryAllocateFlagsInfo = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO,
  eDeviceGroupRenderPassBeginInfo = VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO,
  eDeviceGroupCommandBufferBeginInfo = VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO,
  eDeviceGroupSubmitInfo = VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO,
  eDeviceGroupBindSparseInfo = VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO,
  eBindBufferMemoryDeviceGroupInfo = VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO,
  eBindImageMemoryDeviceGroupInfo = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO,
  ePhysicalDeviceGroupProperties = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES,
  eDeviceGroupDeviceCreateInfo = VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO,
  eBufferMemoryRequirementsInfo2 = VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2,
  eImageMemoryRequirementsInfo2 = VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2,
  eImageSparseMemoryRequirementsInfo2 = VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2,
  eMemoryRequirements2 = VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2,
  eSparseImageMemoryRequirements2 = VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2,
  ePhysicalDeviceFeatures2 = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
  ePhysicalDeviceProperties2 = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
  eFormatProperties2 = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2,
  eImageFormatProperties2 = VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2,
  ePhysicalDeviceImageFormatInfo2 = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2,
  eQueueFamilyProperties2 = VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2,
  ePhysicalDeviceMemoryProperties2 = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2,
  eSparseImageFormatProperties2 = VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2,
  ePhysicalDeviceSparseImageFormatInfo2 = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2,
  ePhysicalDevicePointClippingProperties = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES,
  eRenderPassInputAttachmentAspectCreateInfo = VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO,
  eImageViewUsageCreateInfo = VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO,
  ePipelineTessellationDomainOriginStateCreateInfo = VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO,
  eRenderPassMultiviewCreateInfo = VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO,
  ePhysicalDeviceMultiviewFeatures = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES,
  ePhysicalDeviceMultiviewProperties = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES,
  ePhysicalDeviceVariablePointersFeatures = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES,
  ePhysicalDeviceVariablePointerFeatures = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES,
  eProtectedSubmitInfo = VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO,
  ePhysicalDeviceProtectedMemoryFeatures = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES,
  ePhysicalDeviceProtectedMemoryProperties = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES,
  eDeviceQueueInfo2 = VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2,
  eSamplerYcbcrConversionCreateInfo = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO,
  eSamplerYcbcrConversionInfo = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO,
  eBindImagePlaneMemoryInfo = VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO,
  eImagePlaneMemoryRequirementsInfo = VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO,
  ePhysicalDeviceSamplerYcbcrConversionFeatures = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES,
  eSamplerYcbcrConversionImageFormatProperties = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES,
  eDescriptorUpdateTemplateCreateInfo = VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO,
  ePhysicalDeviceExternalImageFormatInfo = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO,
  eExternalImageFormatProperties = VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES,
  ePhysicalDeviceExternalBufferInfo = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO,
  eExternalBufferProperties = VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES,
  ePhysicalDeviceIdProperties = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES,
  eExternalMemoryBufferCreateInfo = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO,
  eExternalMemoryImageCreateInfo = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO,
  eExportMemoryAllocateInfo = VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO,
  ePhysicalDeviceExternalFenceInfo = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO,
  eExternalFenceProperties = VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES,
  eExportFenceCreateInfo = VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO,
  eExportSemaphoreCreateInfo = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO,
  ePhysicalDeviceExternalSemaphoreInfo = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO,
  eExternalSemaphoreProperties = VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES,
  ePhysicalDeviceMaintenance3Properties = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES,
  eDescriptorSetLayoutSupport = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT,
  ePhysicalDeviceShaderDrawParametersFeatures = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES,
  ePhysicalDeviceShaderDrawParameterFeatures = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES,
#endif // VK_VERSION_1_1
#if VK_VERSION_1_2
  ePhysicalDeviceVulkan11Features = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES,
  ePhysicalDeviceVulkan11Properties = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES,
  ePhysicalDeviceVulkan12Features = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES,
  ePhysicalDeviceVulkan12Properties = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES,
  eImageFormatListCreateInfo = VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO,
  eAttachmentDescription2 = VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2,
  eAttachmentReference2 = VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2,
  eSubpassDescription2 = VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2,
  eSubpassDependency2 = VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2,
  eRenderPassCreateInfo2 = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2,
  eSubpassBeginInfo = VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO,
  eSubpassEndInfo = VK_STRUCTURE_TYPE_SUBPASS_END_INFO,
  ePhysicalDevice8BitStorageFeatures = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES,
  ePhysicalDeviceDriverProperties = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES,
  ePhysicalDeviceShaderAtomicInt64Features = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES,
  ePhysicalDeviceShaderFloat16Int8Features = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES,
  ePhysicalDeviceFloatControlsProperties = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES,
  eDescriptorSetLayoutBindingFlagsCreateInfo = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO,
  ePhysicalDeviceDescriptorIndexingFeatures = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES,
  ePhysicalDeviceDescriptorIndexingProperties = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES,
  eDescriptorSetVariableDescriptorCountAllocateInfo = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO,
  eDescriptorSetVariableDescriptorCountLayoutSupport = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT,
  ePhysicalDeviceDepthStencilResolveProperties = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES,
  eSubpassDescriptionDepthStencilResolve = VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE,
  ePhysicalDeviceScalarBlockLayoutFeatures = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES,
  eImageStencilUsageCreateInfo = VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO,
  ePhysicalDeviceSamplerFilterMinmaxProperties = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES,
  eSamplerReductionModeCreateInfo = VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO,
  ePhysicalDeviceVulkanMemoryModelFeatures = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES,
  ePhysicalDeviceImagelessFramebufferFeatures = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES,
  eFramebufferAttachmentsCreateInfo = VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO,
  eFramebufferAttachmentImageInfo = VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO,
  eRenderPassAttachmentBeginInfo = VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO,
  ePhysicalDeviceUniformBufferStandardLayoutFeatures = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES,
  ePhysicalDeviceShaderSubgroupExtendedTypesFeatures = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES,
  ePhysicalDeviceSeparateDepthStencilLayoutsFeatures = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES,
  eAttachmentReferenceStencilLayout = VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT,
  eAttachmentDescriptionStencilLayout = VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT,
  ePhysicalDeviceHostQueryResetFeatures = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES,
  ePhysicalDeviceTimelineSemaphoreFeatures = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES,
  ePhysicalDeviceTimelineSemaphoreProperties = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES,
  eSemaphoreTypeCreateInfo = VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO,
  eTimelineSemaphoreSubmitInfo = VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO,
  eSemaphoreWaitInfo = VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO,
  eSemaphoreSignalInfo = VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO,
  ePhysicalDeviceBufferDeviceAddressFeatures = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES,
  eBufferDeviceAddressInfo = VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO,
  eBufferOpaqueCaptureAddressCreateInfo = VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO,
  eMemoryOpaqueCaptureAddressAllocateInfo = VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO,
  eDeviceMemoryOpaqueCaptureAddressInfo = VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO,
#endif // VK_VERSION_1_2
#if VK_VERSION_1_3
  ePhysicalDeviceVulkan13Features = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES,
  ePhysicalDeviceVulkan13Properties = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES,
  ePipelineCreationFeedbackCreateInfo = VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO,
  ePhysicalDeviceShaderTerminateInvocationFeatures = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES,
  ePhysicalDeviceToolProperties = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES,
  ePhysicalDeviceShaderDemoteToHelperInvocationFeatures = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES,
  ePhysicalDevicePrivateDataFeatures = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES,
  eDevicePrivateDataCreateInfo = VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO,
  ePrivateDataSlotCreateInfo = VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO,
  ePhysicalDevicePipelineCreationCacheControlFeatures = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES,
  eMemoryBarrier2 = VK_STRUCTURE_TYPE_MEMORY_BARRIER_2,
  eBufferMemoryBarrier2 = VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2,
  eImageMemoryBarrier2 = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2,
  eDependencyInfo = VK_STRUCTURE_TYPE_DEPENDENCY_INFO,
  eSubmitInfo2 = VK_STRUCTURE_TYPE_SUBMIT_INFO_2,
  eSemaphoreSubmitInfo = VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO,
  eCommandBufferSubmitInfo = VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO,
  ePhysicalDeviceSynchronization2Features = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES,
  ePhysicalDeviceZeroInitializeWorkgroupMemoryFeatures = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES,
  ePhysicalDeviceImageRobustnessFeatures = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES,
  eCopyBufferInfo2 = VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2,
  eCopyImageInfo2 = VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2,
  eCopyBufferToImageInfo2 = VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2,
  eCopyImageToBufferInfo2 = VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2,
  eBlitImageInfo2 = VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2,
  eResolveImageInfo2 = VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2,
  eBufferCopy2 = VK_STRUCTURE_TYPE_BUFFER_COPY_2,
  eImageCopy2 = VK_STRUCTURE_TYPE_IMAGE_COPY_2,
  eImageBlit2 = VK_STRUCTURE_TYPE_IMAGE_BLIT_2,
  eBufferImageCopy2 = VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2,
  eImageResolve2 = VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2,
  ePhysicalDeviceSubgroupSizeControlProperties = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES,
  ePipelineShaderStageRequiredSubgroupSizeCreateInfo = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO,
  ePhysicalDeviceSubgroupSizeControlFeatures = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES,
  ePhysicalDeviceInlineUniformBlockFeatures = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES,
  ePhysicalDeviceInlineUniformBlockProperties = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES,
  eWriteDescriptorSetInlineUniformBlock = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK,
  eDescriptorPoolInlineUniformBlockCreateInfo = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO,
  ePhysicalDeviceTextureCompressionAstcHdrFeatures = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES,
  eRenderingInfo = VK_STRUCTURE_TYPE_RENDERING_INFO,
  eRenderingAttachmentInfo = VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO,
  ePipelineRenderingCreateInfo = VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO,
  ePhysicalDeviceDynamicRenderingFeatures = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES,
  eCommandBufferInheritanceRenderingInfo = VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO,
  ePhysicalDeviceShaderIntegerDotProductFeatures = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES,
  ePhysicalDeviceShaderIntegerDotProductProperties = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES,
  ePhysicalDeviceTexelBufferAlignmentProperties = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES,
  eFormatProperties3 = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3,
  ePhysicalDeviceMaintenance4Features = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES,
  ePhysicalDeviceMaintenance4Properties = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES,
  eDeviceBufferMemoryRequirements = VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS,
  eDeviceImageMemoryRequirements = VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS,
#endif // VK_VERSION_1_3
#if VK_VERSION_1_4
  ePhysicalDeviceVulkan14Features = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_FEATURES,
  ePhysicalDeviceVulkan14Properties = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_PROPERTIES,
  eDeviceQueueGlobalPriorityCreateInfo = VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO,
  ePhysicalDeviceGlobalPriorityQueryFeatures = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES,
  eQueueFamilyGlobalPriorityProperties = VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES,
  ePhysicalDeviceShaderSubgroupRotateFeatures = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES,
  ePhysicalDeviceShaderFloatControls2Features = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES,
  ePhysicalDeviceShaderExpectAssumeFeatures = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES,
  ePhysicalDeviceLineRasterizationFeatures = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES,
  ePipelineRasterizationLineStateCreateInfo = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO,
  ePhysicalDeviceLineRasterizationProperties = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES,
  ePhysicalDeviceVertexAttributeDivisorProperties = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES,
  ePipelineVertexInputDivisorStateCreateInfo = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO,
  ePhysicalDeviceVertexAttributeDivisorFeatures = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES,
  ePhysicalDeviceIndexTypeUint8Features = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES,
  eMemoryMapInfo = VK_STRUCTURE_TYPE_MEMORY_MAP_INFO,
  eMemoryUnmapInfo = VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO,
  ePhysicalDeviceMaintenance5Features = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES,
  ePhysicalDeviceMaintenance5Properties = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES,
  eRenderingAreaInfo = VK_STRUCTURE_TYPE_RENDERING_AREA_INFO,
  eDeviceImageSubresourceInfo = VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO,
  eSubresourceLayout2 = VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2,
  eImageSubresource2 = VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2,
  ePipelineCreateFlags2CreateInfo = VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO,
  eBufferUsageFlags2CreateInfo = VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO,
  ePhysicalDevicePushDescriptorProperties = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES,
  ePhysicalDeviceDynamicRenderingLocalReadFeatures = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES,
  eRenderingAttachmentLocationInfo = VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO,
  eRenderingInputAttachmentIndexInfo = VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO,
  ePhysicalDeviceMaintenance6Features = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES,
  ePhysicalDeviceMaintenance6Properties = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES,
  eBindMemoryStatus = VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS,
  eBindDescriptorSetsInfo = VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_SETS_INFO,
  ePushConstantsInfo = VK_STRUCTURE_TYPE_PUSH_CONSTANTS_INFO,
  ePushDescriptorSetInfo = VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_INFO,
  ePushDescriptorSetWithTemplateInfo = VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_WITH_TEMPLATE_INFO,
  ePhysicalDevicePipelineProtectedAccessFeatures = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES,
  ePipelineRobustnessCreateInfo = VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO,
  ePhysicalDevicePipelineRobustnessFeatures = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES,
  ePhysicalDevicePipelineRobustnessProperties = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES,
  ePhysicalDeviceHostImageCopyFeatures = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES,
  ePhysicalDeviceHostImageCopyProperties = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES,
  eMemoryToImageCopy = VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY,
  eImageToMemoryCopy = VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY,
  eCopyImageToMemoryInfo = VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO,
  eCopyMemoryToImageInfo = VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO,
  eHostImageLayoutTransitionInfo = VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO,
  eCopyImageToImageInfo = VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO,
  eSubresourceHostMemcpySize = VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE,
  eHostImageCopyDevicePerformanceQuery = VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY,
#endif // VK_VERSION_1_4
#if VK_KHR_swapchain
  eSwapchainCreateInfoKHR = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR,
  ePresentInfoKHR = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR,
  eDeviceGroupPresentCapabilitiesKHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR,
  eImageSwapchainCreateInfoKHR = VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR,
  eBindImageMemorySwapchainInfoKHR = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR,
  eAcquireNextImageInfoKHR = VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR,
  eDeviceGroupPresentInfoKHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR,
  eDeviceGroupSwapchainCreateInfoKHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR,
#endif // VK_KHR_swapchain
#if VK_KHR_display
  eDisplayModeCreateInfoKHR = VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR,
  eDisplaySurfaceCreateInfoKHR = VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR,
#endif // VK_KHR_display
#if VK_KHR_display_swapchain
  eDisplayPresentInfoKHR = VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR,
#endif // VK_KHR_display_swapchain
#if VK_KHR_xlib_surface
  eXlibSurfaceCreateInfoKHR = VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR,
#endif // VK_KHR_xlib_surface
#if VK_KHR_xcb_surface
  eXcbSurfaceCreateInfoKHR = VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR,
#endif // VK_KHR_xcb_surface
#if VK_KHR_wayland_surface
  eWaylandSurfaceCreateInfoKHR = VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR,
#endif // VK_KHR_wayland_surface
#if VK_KHR_android_surface
  eAndroidSurfaceCreateInfoKHR = VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR,
#endif // VK_KHR_android_surface
#if VK_KHR_win32_surface
  eWin32SurfaceCreateInfoKHR = VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR,
#endif // VK_KHR_win32_surface
#if VK_AMD_rasterization_order
  ePipelineRasterizationStateRasterizationOrderAMD = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD,
#endif // VK_AMD_rasterization_order
#if VK_EXT_debug_marker
  eDebugMarkerObjectNameInfoEXT = VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT,
  eDebugMarkerObjectTagInfoEXT = VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT,
  eDebugMarkerMarkerInfoEXT = VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT,
#endif // VK_EXT_debug_marker
#if VK_KHR_video_queue
  eVideoProfileInfoKHR = VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR,
  eVideoCapabilitiesKHR = VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR,
  eVideoPictureResourceInfoKHR = VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR,
  eVideoSessionMemoryRequirementsKHR = VK_STRUCTURE_TYPE_VIDEO_SESSION_MEMORY_REQUIREMENTS_KHR,
  eBindVideoSessionMemoryInfoKHR = VK_STRUCTURE_TYPE_BIND_VIDEO_SESSION_MEMORY_INFO_KHR,
  eVideoSessionCreateInfoKHR = VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR,
  eVideoSessionParametersCreateInfoKHR = VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR,
  eVideoSessionParametersUpdateInfoKHR = VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR,
  eVideoBeginCodingInfoKHR = VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR,
  eVideoEndCodingInfoKHR = VK_STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR,
  eVideoCodingControlInfoKHR = VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR,
  eVideoReferenceSlotInfoKHR = VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR,
  eQueueFamilyVideoPropertiesKHR = VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR,
  eVideoProfileListInfoKHR = VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR,
  ePhysicalDeviceVideoFormatInfoKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR,
  eVideoFormatPropertiesKHR = VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR,
  eQueueFamilyQueryResultStatusPropertiesKHR = VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR,
#endif // VK_KHR_video_queue
#if VK_KHR_video_decode_queue
  eVideoDecodeInfoKHR = VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR,
  eVideoDecodeCapabilitiesKHR = VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR,
  eVideoDecodeUsageInfoKHR = VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR,
#endif // VK_KHR_video_decode_queue
#if VK_EXT_transform_feedback
  ePhysicalDeviceTransformFeedbackFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT,
  ePhysicalDeviceTransformFeedbackPropertiesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT,
  ePipelineRasterizationStateStreamCreateInfoEXT = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT,
#endif // VK_EXT_transform_feedback
#if VK_NVX_binary_import
  eCuModuleCreateInfoNVX = VK_STRUCTURE_TYPE_CU_MODULE_CREATE_INFO_NVX,
  eCuFunctionCreateInfoNVX = VK_STRUCTURE_TYPE_CU_FUNCTION_CREATE_INFO_NVX,
  eCuLaunchInfoNVX = VK_STRUCTURE_TYPE_CU_LAUNCH_INFO_NVX,
  eCuModuleTexturingModeCreateInfoNVX = VK_STRUCTURE_TYPE_CU_MODULE_TEXTURING_MODE_CREATE_INFO_NVX,
#endif // VK_NVX_binary_import
#if VK_NVX_image_view_handle
  eImageViewHandleInfoNVX = VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX,
  eImageViewAddressPropertiesNVX = VK_STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX,
#endif // VK_NVX_image_view_handle
#if VK_KHR_video_encode_h264
  eVideoEncodeH264CapabilitiesKHR = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_KHR,
  eVideoEncodeH264SessionParametersCreateInfoKHR = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR,
  eVideoEncodeH264SessionParametersAddInfoKHR = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR,
  eVideoEncodeH264PictureInfoKHR = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PICTURE_INFO_KHR,
  eVideoEncodeH264DpbSlotInfoKHR = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_KHR,
  eVideoEncodeH264NaluSliceInfoKHR = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_NALU_SLICE_INFO_KHR,
  eVideoEncodeH264GopRemainingFrameInfoKHR = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_GOP_REMAINING_FRAME_INFO_KHR,
  eVideoEncodeH264ProfileInfoKHR = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_KHR,
  eVideoEncodeH264RateControlInfoKHR = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_KHR,
  eVideoEncodeH264RateControlLayerInfoKHR = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_LAYER_INFO_KHR,
  eVideoEncodeH264SessionCreateInfoKHR = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_CREATE_INFO_KHR,
  eVideoEncodeH264QualityLevelPropertiesKHR = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUALITY_LEVEL_PROPERTIES_KHR,
  eVideoEncodeH264SessionParametersGetInfoKHR = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_GET_INFO_KHR,
  eVideoEncodeH264SessionParametersFeedbackInfoKHR = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_FEEDBACK_INFO_KHR,
#endif // VK_KHR_video_encode_h264
#if VK_KHR_video_encode_h265
  eVideoEncodeH265CapabilitiesKHR = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_CAPABILITIES_KHR,
  eVideoEncodeH265SessionParametersCreateInfoKHR = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR,
  eVideoEncodeH265SessionParametersAddInfoKHR = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR,
  eVideoEncodeH265PictureInfoKHR = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PICTURE_INFO_KHR,
  eVideoEncodeH265DpbSlotInfoKHR = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_KHR,
  eVideoEncodeH265NaluSliceSegmentInfoKHR = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_NALU_SLICE_SEGMENT_INFO_KHR,
  eVideoEncodeH265GopRemainingFrameInfoKHR = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_GOP_REMAINING_FRAME_INFO_KHR,
  eVideoEncodeH265ProfileInfoKHR = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_INFO_KHR,
  eVideoEncodeH265RateControlInfoKHR = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_INFO_KHR,
  eVideoEncodeH265RateControlLayerInfoKHR = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_LAYER_INFO_KHR,
  eVideoEncodeH265SessionCreateInfoKHR = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_CREATE_INFO_KHR,
  eVideoEncodeH265QualityLevelPropertiesKHR = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUALITY_LEVEL_PROPERTIES_KHR,
  eVideoEncodeH265SessionParametersGetInfoKHR = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_GET_INFO_KHR,
  eVideoEncodeH265SessionParametersFeedbackInfoKHR = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_FEEDBACK_INFO_KHR,
#endif // VK_KHR_video_encode_h265
#if VK_KHR_video_decode_h264
  eVideoDecodeH264CapabilitiesKHR = VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_KHR,
  eVideoDecodeH264PictureInfoKHR = VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_KHR,
  eVideoDecodeH264ProfileInfoKHR = VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR,
  eVideoDecodeH264SessionParametersCreateInfoKHR = VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR,
  eVideoDecodeH264SessionParametersAddInfoKHR = VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR,
  eVideoDecodeH264DpbSlotInfoKHR = VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR,
#endif // VK_KHR_video_decode_h264
#if VK_AMD_texture_gather_bias_lod
  eTextureLodGatherFormatPropertiesAMD = VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD,
#endif // VK_AMD_texture_gather_bias_lod
#if VK_KHR_dynamic_rendering
  eRenderingInfoKHR = VK_STRUCTURE_TYPE_RENDERING_INFO_KHR,
  eRenderingAttachmentInfoKHR = VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO_KHR,
  ePipelineRenderingCreateInfoKHR = VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO_KHR,
  ePhysicalDeviceDynamicRenderingFeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES_KHR,
  eCommandBufferInheritanceRenderingInfoKHR = VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO_KHR,
#endif // VK_KHR_dynamic_rendering
#if VK_GGP_stream_descriptor_surface
  eStreamDescriptorSurfaceCreateInfoGGP = VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP,
#endif // VK_GGP_stream_descriptor_surface
#if VK_NV_corner_sampled_image
  ePhysicalDeviceCornerSampledImageFeaturesNV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV,
#endif // VK_NV_corner_sampled_image
#if VK_KHR_multiview
  eRenderPassMultiviewCreateInfoKHR = VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR,
  ePhysicalDeviceMultiviewFeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR,
  ePhysicalDeviceMultiviewPropertiesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR,
#endif // VK_KHR_multiview
#if VK_NV_win32_keyed_mutex
  eWin32KeyedMutexAcquireReleaseInfoNV = VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV,
#endif // VK_NV_win32_keyed_mutex
#if VK_KHR_get_physical_device_properties2
  ePhysicalDeviceFeatures2KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR,
  ePhysicalDeviceProperties2KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR,
  eFormatProperties2KHR = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2_KHR,
  eImageFormatProperties2KHR = VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2_KHR,
  ePhysicalDeviceImageFormatInfo2KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR,
  eQueueFamilyProperties2KHR = VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2_KHR,
  ePhysicalDeviceMemoryProperties2KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR,
  eSparseImageFormatProperties2KHR = VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR,
  ePhysicalDeviceSparseImageFormatInfo2KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR,
#endif // VK_KHR_get_physical_device_properties2
#if VK_KHR_device_group
  eMemoryAllocateFlagsInfoKHR = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHR,
  eDeviceGroupRenderPassBeginInfoKHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHR,
  eDeviceGroupCommandBufferBeginInfoKHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHR,
  eDeviceGroupSubmitInfoKHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO_KHR,
  eDeviceGroupBindSparseInfoKHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO_KHR,
#endif // VK_KHR_device_group
#if VK_NN_vi_surface
  eViSurfaceCreateInfoNN = VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN,
#endif // VK_NN_vi_surface
#if VK_EXT_texture_compression_astc_hdr
  ePhysicalDeviceTextureCompressionAstcHdrFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT,
#endif // VK_EXT_texture_compression_astc_hdr
#if VK_EXT_astc_decode_mode
  eImageViewAstcDecodeModeEXT = VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT,
  ePhysicalDeviceAstcDecodeFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT,
#endif // VK_EXT_astc_decode_mode
#if VK_EXT_pipeline_robustness
  ePipelineRobustnessCreateInfoEXT = VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT,
  ePhysicalDevicePipelineRobustnessFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES_EXT,
  ePhysicalDevicePipelineRobustnessPropertiesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES_EXT,
#endif // VK_EXT_pipeline_robustness
#if VK_KHR_device_group_creation
  ePhysicalDeviceGroupPropertiesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHR,
  eDeviceGroupDeviceCreateInfoKHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO_KHR,
#endif // VK_KHR_device_group_creation
#if VK_KHR_external_memory_capabilities
  ePhysicalDeviceExternalImageFormatInfoKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR,
  eExternalImageFormatPropertiesKHR = VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR,
  ePhysicalDeviceExternalBufferInfoKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR,
  eExternalBufferPropertiesKHR = VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES_KHR,
  ePhysicalDeviceIdPropertiesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR,
#endif // VK_KHR_external_memory_capabilities
#if VK_KHR_external_memory
  eExternalMemoryBufferCreateInfoKHR = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR,
  eExternalMemoryImageCreateInfoKHR = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR,
  eExportMemoryAllocateInfoKHR = VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR,
#endif // VK_KHR_external_memory
#if VK_KHR_external_memory_win32
  eImportMemoryWin32HandleInfoKHR = VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR,
  eExportMemoryWin32HandleInfoKHR = VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR,
  eMemoryWin32HandlePropertiesKHR = VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR,
  eMemoryGetWin32HandleInfoKHR = VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR,
#endif // VK_KHR_external_memory_win32
#if VK_KHR_external_memory_fd
  eImportMemoryFdInfoKHR = VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR,
  eMemoryFdPropertiesKHR = VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR,
  eMemoryGetFdInfoKHR = VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR,
#endif // VK_KHR_external_memory_fd
#if VK_KHR_win32_keyed_mutex
  eWin32KeyedMutexAcquireReleaseInfoKHR = VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR,
#endif // VK_KHR_win32_keyed_mutex
#if VK_KHR_external_semaphore_capabilities
  ePhysicalDeviceExternalSemaphoreInfoKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR,
  eExternalSemaphorePropertiesKHR = VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHR,
#endif // VK_KHR_external_semaphore_capabilities
#if VK_KHR_external_semaphore
  eExportSemaphoreCreateInfoKHR = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHR,
#endif // VK_KHR_external_semaphore
#if VK_KHR_external_semaphore_win32
  eImportSemaphoreWin32HandleInfoKHR = VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR,
  eExportSemaphoreWin32HandleInfoKHR = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR,
  eD3D12FenceSubmitInfoKHR = VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR,
  eSemaphoreGetWin32HandleInfoKHR = VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR,
#endif // VK_KHR_external_semaphore_win32
#if VK_KHR_external_semaphore_fd
  eImportSemaphoreFdInfoKHR = VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR,
  eSemaphoreGetFdInfoKHR = VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR,
#endif // VK_KHR_external_semaphore_fd
#if VK_KHR_push_descriptor
  ePhysicalDevicePushDescriptorPropertiesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR,
#endif // VK_KHR_push_descriptor
#if VK_EXT_conditional_rendering
  eCommandBufferInheritanceConditionalRenderingInfoEXT = VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT,
  ePhysicalDeviceConditionalRenderingFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT,
  eConditionalRenderingBeginInfoEXT = VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT,
#endif // VK_EXT_conditional_rendering
#if VK_KHR_shader_float16_int8
  ePhysicalDeviceShaderFloat16Int8FeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES_KHR,
  ePhysicalDeviceFloat16Int8FeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT16_INT8_FEATURES_KHR,
#endif // VK_KHR_shader_float16_int8
#if VK_KHR_16bit_storage
  ePhysicalDevice16BitStorageFeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR,
#endif // VK_KHR_16bit_storage
#if VK_KHR_incremental_present
  ePresentRegionsKHR = VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR,
#endif // VK_KHR_incremental_present
#if VK_KHR_descriptor_update_template
  eDescriptorUpdateTemplateCreateInfoKHR = VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR,
#endif // VK_KHR_descriptor_update_template
#if VK_NV_clip_space_w_scaling
  ePipelineViewportWScalingStateCreateInfoNV = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV,
#endif // VK_NV_clip_space_w_scaling
#if VK_EXT_display_surface_counter
  eSurfaceCapabilities2EXT = VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT,
#endif // VK_EXT_display_surface_counter
#if VK_EXT_display_control
  eDisplayPowerInfoEXT = VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT,
  eDeviceEventInfoEXT = VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT,
  eDisplayEventInfoEXT = VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT,
  eSwapchainCounterCreateInfoEXT = VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT,
#endif // VK_EXT_display_control
#if VK_GOOGLE_display_timing
  ePresentTimesInfoGOOGLE = VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE,
#endif // VK_GOOGLE_display_timing
#if VK_NVX_multiview_per_view_attributes
  ePhysicalDeviceMultiviewPerViewAttributesPropertiesNVX = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX,
  eMultiviewPerViewAttributesInfoNVX = VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX,
#endif // VK_NVX_multiview_per_view_attributes
#if VK_NV_viewport_swizzle
  ePipelineViewportSwizzleStateCreateInfoNV = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV,
#endif // VK_NV_viewport_swizzle
#if VK_EXT_discard_rectangles
  ePhysicalDeviceDiscardRectanglePropertiesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT,
  ePipelineDiscardRectangleStateCreateInfoEXT = VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT,
#endif // VK_EXT_discard_rectangles
#if VK_EXT_conservative_rasterization
  ePhysicalDeviceConservativeRasterizationPropertiesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT,
  ePipelineRasterizationConservativeStateCreateInfoEXT = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT,
#endif // VK_EXT_conservative_rasterization
#if VK_EXT_depth_clip_enable
  ePhysicalDeviceDepthClipEnableFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT,
  ePipelineRasterizationDepthClipStateCreateInfoEXT = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT,
#endif // VK_EXT_depth_clip_enable
#if VK_EXT_hdr_metadata
  eHdrMetadataEXT = VK_STRUCTURE_TYPE_HDR_METADATA_EXT,
#endif // VK_EXT_hdr_metadata
#if VK_KHR_imageless_framebuffer
  ePhysicalDeviceImagelessFramebufferFeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES_KHR,
  eFramebufferAttachmentsCreateInfoKHR = VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO_KHR,
  eFramebufferAttachmentImageInfoKHR = VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO_KHR,
  eRenderPassAttachmentBeginInfoKHR = VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO_KHR,
#endif // VK_KHR_imageless_framebuffer
#if VK_KHR_create_renderpass2
  eAttachmentDescription2KHR = VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2_KHR,
  eAttachmentReference2KHR = VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2_KHR,
  eSubpassDescription2KHR = VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2_KHR,
  eSubpassDependency2KHR = VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR,
  eRenderPassCreateInfo2KHR = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR,
  eSubpassBeginInfoKHR = VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR,
  eSubpassEndInfoKHR = VK_STRUCTURE_TYPE_SUBPASS_END_INFO_KHR,
#endif // VK_KHR_create_renderpass2
#if VK_IMG_relaxed_line_rasterization
  ePhysicalDeviceRelaxedLineRasterizationFeaturesIMG = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RELAXED_LINE_RASTERIZATION_FEATURES_IMG,
#endif // VK_IMG_relaxed_line_rasterization
#if VK_KHR_shared_presentable_image
  eSharedPresentSurfaceCapabilitiesKHR = VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR,
#endif // VK_KHR_shared_presentable_image
#if VK_KHR_external_fence_capabilities
  ePhysicalDeviceExternalFenceInfoKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR,
  eExternalFencePropertiesKHR = VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES_KHR,
#endif // VK_KHR_external_fence_capabilities
#if VK_KHR_external_fence
  eExportFenceCreateInfoKHR = VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO_KHR,
#endif // VK_KHR_external_fence
#if VK_KHR_external_fence_win32
  eImportFenceWin32HandleInfoKHR = VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR,
  eExportFenceWin32HandleInfoKHR = VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR,
  eFenceGetWin32HandleInfoKHR = VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR,
#endif // VK_KHR_external_fence_win32
#if VK_KHR_external_fence_fd
  eImportFenceFdInfoKHR = VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR,
  eFenceGetFdInfoKHR = VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR,
#endif // VK_KHR_external_fence_fd
#if VK_KHR_performance_query
  ePhysicalDevicePerformanceQueryFeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR,
  ePhysicalDevicePerformanceQueryPropertiesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR,
  eQueryPoolPerformanceCreateInfoKHR = VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR,
  ePerformanceQuerySubmitInfoKHR = VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR,
  eAcquireProfilingLockInfoKHR = VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR,
  ePerformanceCounterKHR = VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR,
  ePerformanceCounterDescriptionKHR = VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR,
#endif // VK_KHR_performance_query
#if VK_KHR_maintenance2
  ePhysicalDevicePointClippingPropertiesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR,
  eRenderPassInputAttachmentAspectCreateInfoKHR = VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR,
  eImageViewUsageCreateInfoKHR = VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO_KHR,
  ePipelineTessellationDomainOriginStateCreateInfoKHR = VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO_KHR,
#endif // VK_KHR_maintenance2
#if VK_KHR_get_surface_capabilities2
  ePhysicalDeviceSurfaceInfo2KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR,
  eSurfaceCapabilities2KHR = VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR,
  eSurfaceFormat2KHR = VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR,
#endif // VK_KHR_get_surface_capabilities2
#if VK_KHR_variable_pointers
  ePhysicalDeviceVariablePointersFeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR,
  ePhysicalDeviceVariablePointerFeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR,
#endif // VK_KHR_variable_pointers
#if VK_KHR_get_display_properties2
  eDisplayProperties2KHR = VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR,
  eDisplayPlaneProperties2KHR = VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR,
  eDisplayModeProperties2KHR = VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR,
  eDisplayPlaneInfo2KHR = VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR,
  eDisplayPlaneCapabilities2KHR = VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR,
#endif // VK_KHR_get_display_properties2
#if VK_KHR_dedicated_allocation
  eMemoryDedicatedRequirementsKHR = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR,
  eMemoryDedicatedAllocateInfoKHR = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR,
#endif // VK_KHR_dedicated_allocation
#if VK_EXT_debug_utils
  eDebugUtilsObjectNameInfoEXT = VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT,
  eDebugUtilsObjectTagInfoEXT = VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT,
  eDebugUtilsLabelEXT = VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT,
  eDebugUtilsMessengerCallbackDataEXT = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT,
  eDebugUtilsMessengerCreateInfoEXT = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT,
#endif // VK_EXT_debug_utils
#if VK_ANDROID_external_memory_android_hardware_buffer
  eAndroidHardwareBufferUsageANDROID = VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID,
  eAndroidHardwareBufferPropertiesANDROID = VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID,
  eAndroidHardwareBufferFormatPropertiesANDROID = VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID,
  eImportAndroidHardwareBufferInfoANDROID = VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID,
  eMemoryGetAndroidHardwareBufferInfoANDROID = VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID,
  eExternalFormatANDROID = VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID,
#endif // VK_ANDROID_external_memory_android_hardware_buffer
#if VK_EXT_sampler_filter_minmax
  ePhysicalDeviceSamplerFilterMinmaxPropertiesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT,
  eSamplerReductionModeCreateInfoEXT = VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT,
#endif // VK_EXT_sampler_filter_minmax
#if VK_AMD_mixed_attachment_samples
  eAttachmentSampleCountInfoAMD = VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD,
#endif // VK_AMD_mixed_attachment_samples
#if VK_EXT_inline_uniform_block
  ePhysicalDeviceInlineUniformBlockFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT,
  ePhysicalDeviceInlineUniformBlockPropertiesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT,
  eWriteDescriptorSetInlineUniformBlockEXT = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT,
  eDescriptorPoolInlineUniformBlockCreateInfoEXT = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT,
#endif // VK_EXT_inline_uniform_block
#if VK_KHR_shader_bfloat16
  ePhysicalDeviceShaderBfloat16FeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_BFLOAT16_FEATURES_KHR,
#endif // VK_KHR_shader_bfloat16
#if VK_EXT_sample_locations
  eSampleLocationsInfoEXT = VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT,
  eRenderPassSampleLocationsBeginInfoEXT = VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT,
  ePipelineSampleLocationsStateCreateInfoEXT = VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT,
  ePhysicalDeviceSampleLocationsPropertiesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT,
  eMultisamplePropertiesEXT = VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT,
#endif // VK_EXT_sample_locations
#if VK_KHR_get_memory_requirements2
  eBufferMemoryRequirementsInfo2KHR = VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR,
  eImageMemoryRequirementsInfo2KHR = VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR,
  eImageSparseMemoryRequirementsInfo2KHR = VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR,
  eMemoryRequirements2KHR = VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR,
  eSparseImageMemoryRequirements2KHR = VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR,
#endif // VK_KHR_get_memory_requirements2
#if VK_KHR_image_format_list
  eImageFormatListCreateInfoKHR = VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR,
#endif // VK_KHR_image_format_list
#if VK_EXT_blend_operation_advanced
  ePhysicalDeviceBlendOperationAdvancedFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT,
  ePhysicalDeviceBlendOperationAdvancedPropertiesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT,
  ePipelineColorBlendAdvancedStateCreateInfoEXT = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT,
#endif // VK_EXT_blend_operation_advanced
#if VK_NV_fragment_coverage_to_color
  ePipelineCoverageToColorStateCreateInfoNV = VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV,
#endif // VK_NV_fragment_coverage_to_color
#if VK_KHR_acceleration_structure
  eWriteDescriptorSetAccelerationStructureKHR = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR,
  eAccelerationStructureBuildGeometryInfoKHR = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR,
  eAccelerationStructureDeviceAddressInfoKHR = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR,
  eAccelerationStructureGeometryAabbsDataKHR = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR,
  eAccelerationStructureGeometryInstancesDataKHR = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR,
  eAccelerationStructureGeometryTrianglesDataKHR = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR,
  eAccelerationStructureGeometryKHR = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR,
  eAccelerationStructureVersionInfoKHR = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR,
  eCopyAccelerationStructureInfoKHR = VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR,
  eCopyAccelerationStructureToMemoryInfoKHR = VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR,
  eCopyMemoryToAccelerationStructureInfoKHR = VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR,
  ePhysicalDeviceAccelerationStructureFeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR,
  ePhysicalDeviceAccelerationStructurePropertiesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR,
  eAccelerationStructureCreateInfoKHR = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR,
  eAccelerationStructureBuildSizesInfoKHR = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR,
#endif // VK_KHR_acceleration_structure
#if VK_KHR_ray_tracing_pipeline
  ePhysicalDeviceRayTracingPipelineFeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR,
  ePhysicalDeviceRayTracingPipelinePropertiesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR,
  eRayTracingPipelineCreateInfoKHR = VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR,
  eRayTracingShaderGroupCreateInfoKHR = VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR,
  eRayTracingPipelineInterfaceCreateInfoKHR = VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR,
#endif // VK_KHR_ray_tracing_pipeline
#if VK_KHR_ray_query
  ePhysicalDeviceRayQueryFeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR,
#endif // VK_KHR_ray_query
#if VK_NV_framebuffer_mixed_samples
  ePipelineCoverageModulationStateCreateInfoNV = VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV,
  eAttachmentSampleCountInfoNV = VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_NV,
#endif // VK_NV_framebuffer_mixed_samples
#if VK_NV_shader_sm_builtins
  ePhysicalDeviceShaderSmBuiltinsFeaturesNV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV,
  ePhysicalDeviceShaderSmBuiltinsPropertiesNV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV,
#endif // VK_NV_shader_sm_builtins
#if VK_KHR_sampler_ycbcr_conversion
  eSamplerYcbcrConversionCreateInfoKHR = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR,
  eSamplerYcbcrConversionInfoKHR = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO_KHR,
  eBindImagePlaneMemoryInfoKHR = VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO_KHR,
  eImagePlaneMemoryRequirementsInfoKHR = VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR,
  ePhysicalDeviceSamplerYcbcrConversionFeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES_KHR,
  eSamplerYcbcrConversionImageFormatPropertiesKHR = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES_KHR,
#endif // VK_KHR_sampler_ycbcr_conversion
#if VK_KHR_bind_memory2
  eBindBufferMemoryInfoKHR = VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHR,
  eBindImageMemoryInfoKHR = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHR,
#endif // VK_KHR_bind_memory2
#if VK_EXT_image_drm_format_modifier
  eDrmFormatModifierPropertiesListEXT = VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT,
  ePhysicalDeviceImageDrmFormatModifierInfoEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT,
  eImageDrmFormatModifierListCreateInfoEXT = VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT,
  eImageDrmFormatModifierExplicitCreateInfoEXT = VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT,
  eImageDrmFormatModifierPropertiesEXT = VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT,
#endif // VK_EXT_image_drm_format_modifier
#if VK_EXT_validation_cache
  eValidationCacheCreateInfoEXT = VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT,
  eShaderModuleValidationCacheCreateInfoEXT = VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT,
#endif // VK_EXT_validation_cache
#if VK_EXT_descriptor_indexing
  eDescriptorSetLayoutBindingFlagsCreateInfoEXT = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT,
  ePhysicalDeviceDescriptorIndexingFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT,
  ePhysicalDeviceDescriptorIndexingPropertiesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT,
  eDescriptorSetVariableDescriptorCountAllocateInfoEXT = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT,
  eDescriptorSetVariableDescriptorCountLayoutSupportEXT = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT,
#endif // VK_EXT_descriptor_indexing
#if VK_NV_shading_rate_image
  ePipelineViewportShadingRateImageStateCreateInfoNV = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV,
  ePhysicalDeviceShadingRateImageFeaturesNV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV,
  ePhysicalDeviceShadingRateImagePropertiesNV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV,
  ePipelineViewportCoarseSampleOrderStateCreateInfoNV = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV,
#endif // VK_NV_shading_rate_image
#if VK_NV_representative_fragment_test
  ePhysicalDeviceRepresentativeFragmentTestFeaturesNV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV,
  ePipelineRepresentativeFragmentTestStateCreateInfoNV = VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV,
#endif // VK_NV_representative_fragment_test
#if VK_KHR_maintenance3
  ePhysicalDeviceMaintenance3PropertiesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES_KHR,
  eDescriptorSetLayoutSupportKHR = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT_KHR,
#endif // VK_KHR_maintenance3
#if VK_EXT_filter_cubic
  ePhysicalDeviceImageViewImageFormatInfoEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT,
  eFilterCubicImageViewImageFormatPropertiesEXT = VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT,
#endif // VK_EXT_filter_cubic
#if VK_EXT_global_priority
  eDeviceQueueGlobalPriorityCreateInfoEXT = VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT,
#endif // VK_EXT_global_priority
#if VK_KHR_shader_subgroup_extended_types
  ePhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES_KHR,
#endif // VK_KHR_shader_subgroup_extended_types
#if VK_KHR_8bit_storage
  ePhysicalDevice8BitStorageFeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR,
#endif // VK_KHR_8bit_storage
#if VK_EXT_external_memory_host
  eImportMemoryHostPointerInfoEXT = VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT,
  eMemoryHostPointerPropertiesEXT = VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT,
  ePhysicalDeviceExternalMemoryHostPropertiesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT,
#endif // VK_EXT_external_memory_host
#if VK_KHR_shader_atomic_int64
  ePhysicalDeviceShaderAtomicInt64FeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR,
#endif // VK_KHR_shader_atomic_int64
#if VK_KHR_shader_clock
  ePhysicalDeviceShaderClockFeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR,
#endif // VK_KHR_shader_clock
#if VK_AMD_pipeline_compiler_control
  ePipelineCompilerControlCreateInfoAMD = VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD,
#endif // VK_AMD_pipeline_compiler_control
#if VK_EXT_calibrated_timestamps
  eCalibratedTimestampInfoEXT = VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT,
#endif // VK_EXT_calibrated_timestamps
#if VK_AMD_shader_core_properties
  ePhysicalDeviceShaderCorePropertiesAMD = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD,
#endif // VK_AMD_shader_core_properties
#if VK_KHR_video_decode_h265
  eVideoDecodeH265CapabilitiesKHR = VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_CAPABILITIES_KHR,
  eVideoDecodeH265SessionParametersCreateInfoKHR = VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR,
  eVideoDecodeH265SessionParametersAddInfoKHR = VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR,
  eVideoDecodeH265ProfileInfoKHR = VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_KHR,
  eVideoDecodeH265PictureInfoKHR = VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_KHR,
  eVideoDecodeH265DpbSlotInfoKHR = VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR,
#endif // VK_KHR_video_decode_h265
#if VK_KHR_global_priority
  eDeviceQueueGlobalPriorityCreateInfoKHR = VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR,
  ePhysicalDeviceGlobalPriorityQueryFeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR,
  eQueueFamilyGlobalPriorityPropertiesKHR = VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR,
#endif // VK_KHR_global_priority
#if VK_AMD_memory_overallocation_behavior
  eDeviceMemoryOverallocationCreateInfoAMD = VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD,
#endif // VK_AMD_memory_overallocation_behavior
#if VK_EXT_vertex_attribute_divisor
  ePhysicalDeviceVertexAttributeDivisorPropertiesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT,
  ePipelineVertexInputDivisorStateCreateInfoEXT = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT,
  ePhysicalDeviceVertexAttributeDivisorFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT,
#endif // VK_EXT_vertex_attribute_divisor
#if VK_GGP_frame_token
  ePresentFrameTokenGGP = VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP,
#endif // VK_GGP_frame_token
#if VK_EXT_pipeline_creation_feedback
  ePipelineCreationFeedbackCreateInfoEXT = VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT,
#endif // VK_EXT_pipeline_creation_feedback
#if VK_KHR_driver_properties
  ePhysicalDeviceDriverPropertiesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR,
#endif // VK_KHR_driver_properties
#if VK_KHR_shader_float_controls
  ePhysicalDeviceFloatControlsPropertiesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR,
#endif // VK_KHR_shader_float_controls
#if VK_KHR_depth_stencil_resolve
  ePhysicalDeviceDepthStencilResolvePropertiesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR,
  eSubpassDescriptionDepthStencilResolveKHR = VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR,
#endif // VK_KHR_depth_stencil_resolve
#if VK_NV_compute_shader_derivatives
  ePhysicalDeviceComputeShaderDerivativesFeaturesNV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV,
#endif // VK_NV_compute_shader_derivatives
#if VK_NV_mesh_shader
  ePhysicalDeviceMeshShaderFeaturesNV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV,
  ePhysicalDeviceMeshShaderPropertiesNV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV,
#endif // VK_NV_mesh_shader
#if VK_NV_fragment_shader_barycentric
  ePhysicalDeviceFragmentShaderBarycentricFeaturesNV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV,
#endif // VK_NV_fragment_shader_barycentric
#if VK_NV_shader_image_footprint
  ePhysicalDeviceShaderImageFootprintFeaturesNV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV,
#endif // VK_NV_shader_image_footprint
#if VK_NV_scissor_exclusive
  ePipelineViewportExclusiveScissorStateCreateInfoNV = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV,
  ePhysicalDeviceExclusiveScissorFeaturesNV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV,
#endif // VK_NV_scissor_exclusive
#if VK_NV_device_diagnostic_checkpoints
  eCheckpointDataNV = VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV,
  eQueueFamilyCheckpointPropertiesNV = VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV,
#endif // VK_NV_device_diagnostic_checkpoints
#if VK_KHR_timeline_semaphore
  ePhysicalDeviceTimelineSemaphoreFeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES_KHR,
  ePhysicalDeviceTimelineSemaphorePropertiesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES_KHR,
  eSemaphoreTypeCreateInfoKHR = VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO_KHR,
  eTimelineSemaphoreSubmitInfoKHR = VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO_KHR,
  eSemaphoreWaitInfoKHR = VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO_KHR,
  eSemaphoreSignalInfoKHR = VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO_KHR,
#endif // VK_KHR_timeline_semaphore
#if VK_INTEL_shader_integer_functions2
  ePhysicalDeviceShaderIntegerFunctions2FeaturesINTEL = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL,
#endif // VK_INTEL_shader_integer_functions2
#if VK_INTEL_performance_query
  eQueryPoolPerformanceQueryCreateInfoINTEL = VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL,
  eInitializePerformanceApiInfoINTEL = VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL,
  ePerformanceMarkerInfoINTEL = VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL,
  ePerformanceStreamMarkerInfoINTEL = VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL,
  ePerformanceOverrideInfoINTEL = VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL,
  ePerformanceConfigurationAcquireInfoINTEL = VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL,
#endif // VK_INTEL_performance_query
#if VK_KHR_vulkan_memory_model
  ePhysicalDeviceVulkanMemoryModelFeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR,
#endif // VK_KHR_vulkan_memory_model
#if VK_EXT_pci_bus_info
  ePhysicalDevicePciBusInfoPropertiesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT,
#endif // VK_EXT_pci_bus_info
#if VK_AMD_display_native_hdr
  eDisplayNativeHdrSurfaceCapabilitiesAMD = VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD,
  eSwapchainDisplayNativeHdrCreateInfoAMD = VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD,
#endif // VK_AMD_display_native_hdr
#if VK_FUCHSIA_imagepipe_surface
  eImagepipeSurfaceCreateInfoFUCHSIA = VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA,
#endif // VK_FUCHSIA_imagepipe_surface
#if VK_KHR_shader_terminate_invocation
  ePhysicalDeviceShaderTerminateInvocationFeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES_KHR,
#endif // VK_KHR_shader_terminate_invocation
#if VK_EXT_metal_surface
  eMetalSurfaceCreateInfoEXT = VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT,
#endif // VK_EXT_metal_surface
#if VK_EXT_fragment_density_map
  ePhysicalDeviceFragmentDensityMapFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT,
  ePhysicalDeviceFragmentDensityMapPropertiesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT,
  eRenderPassFragmentDensityMapCreateInfoEXT = VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT,
  eRenderingFragmentDensityMapAttachmentInfoEXT = VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT,
#endif // VK_EXT_fragment_density_map
#if VK_EXT_scalar_block_layout
  ePhysicalDeviceScalarBlockLayoutFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT,
#endif // VK_EXT_scalar_block_layout
#if VK_EXT_subgroup_size_control
  ePhysicalDeviceSubgroupSizeControlPropertiesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT,
  ePipelineShaderStageRequiredSubgroupSizeCreateInfoEXT = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT,
  ePhysicalDeviceSubgroupSizeControlFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT,
#endif // VK_EXT_subgroup_size_control
#if VK_KHR_fragment_shading_rate
  eFragmentShadingRateAttachmentInfoKHR = VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR,
  ePipelineFragmentShadingRateStateCreateInfoKHR = VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR,
  ePhysicalDeviceFragmentShadingRatePropertiesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR,
  ePhysicalDeviceFragmentShadingRateFeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR,
  ePhysicalDeviceFragmentShadingRateKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR,
  eRenderingFragmentShadingRateAttachmentInfoKHR = VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR,
#endif // VK_KHR_fragment_shading_rate
#if VK_AMD_shader_core_properties2
  ePhysicalDeviceShaderCoreProperties2AMD = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD,
#endif // VK_AMD_shader_core_properties2
#if VK_AMD_device_coherent_memory
  ePhysicalDeviceCoherentMemoryFeaturesAMD = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD,
#endif // VK_AMD_device_coherent_memory
#if VK_KHR_dynamic_rendering_local_read
  ePhysicalDeviceDynamicRenderingLocalReadFeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES_KHR,
  eRenderingAttachmentLocationInfoKHR = VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO_KHR,
  eRenderingInputAttachmentIndexInfoKHR = VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO_KHR,
#endif // VK_KHR_dynamic_rendering_local_read
#if VK_EXT_shader_image_atomic_int64
  ePhysicalDeviceShaderImageAtomicInt64FeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT,
#endif // VK_EXT_shader_image_atomic_int64
#if VK_KHR_shader_quad_control
  ePhysicalDeviceShaderQuadControlFeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_QUAD_CONTROL_FEATURES_KHR,
#endif // VK_KHR_shader_quad_control
#if VK_EXT_memory_budget
  ePhysicalDeviceMemoryBudgetPropertiesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT,
#endif // VK_EXT_memory_budget
#if VK_EXT_memory_priority
  ePhysicalDeviceMemoryPriorityFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT,
  eMemoryPriorityAllocateInfoEXT = VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT,
#endif // VK_EXT_memory_priority
#if VK_KHR_surface_protected_capabilities
  eSurfaceProtectedCapabilitiesKHR = VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR,
#endif // VK_KHR_surface_protected_capabilities
#if VK_NV_dedicated_allocation_image_aliasing
  ePhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV,
#endif // VK_NV_dedicated_allocation_image_aliasing
#if VK_KHR_separate_depth_stencil_layouts
  ePhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES_KHR,
  eAttachmentReferenceStencilLayoutKHR = VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT_KHR,
  eAttachmentDescriptionStencilLayoutKHR = VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT_KHR,
#endif // VK_KHR_separate_depth_stencil_layouts
#if VK_EXT_tooling_info
  ePhysicalDeviceToolPropertiesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES_EXT,
#endif // VK_EXT_tooling_info
#if VK_EXT_separate_stencil_usage
  eImageStencilUsageCreateInfoEXT = VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO_EXT,
#endif // VK_EXT_separate_stencil_usage
#if VK_KHR_present_wait
  ePhysicalDevicePresentWaitFeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR,
#endif // VK_KHR_present_wait
#if VK_NV_cooperative_matrix
  ePhysicalDeviceCooperativeMatrixFeaturesNV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV,
  eCooperativeMatrixPropertiesNV = VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV,
  ePhysicalDeviceCooperativeMatrixPropertiesNV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV,
#endif // VK_NV_cooperative_matrix
#if VK_NV_coverage_reduction_mode
  ePhysicalDeviceCoverageReductionModeFeaturesNV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV,
  ePipelineCoverageReductionStateCreateInfoNV = VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV,
  eFramebufferMixedSamplesCombinationNV = VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV,
#endif // VK_NV_coverage_reduction_mode
#if VK_EXT_fragment_shader_interlock
  ePhysicalDeviceFragmentShaderInterlockFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT,
#endif // VK_EXT_fragment_shader_interlock
#if VK_EXT_ycbcr_image_arrays
  ePhysicalDeviceYcbcrImageArraysFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT,
#endif // VK_EXT_ycbcr_image_arrays
#if VK_KHR_uniform_buffer_standard_layout
  ePhysicalDeviceUniformBufferStandardLayoutFeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES_KHR,
#endif // VK_KHR_uniform_buffer_standard_layout
#if VK_EXT_provoking_vertex
  ePhysicalDeviceProvokingVertexFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT,
  ePipelineRasterizationProvokingVertexStateCreateInfoEXT = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT,
  ePhysicalDeviceProvokingVertexPropertiesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT,
#endif // VK_EXT_provoking_vertex
#if VK_EXT_full_screen_exclusive
  eSurfaceFullScreenExclusiveInfoEXT = VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT,
  eSurfaceCapabilitiesFullScreenExclusiveEXT = VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT,
  eSurfaceFullScreenExclusiveWin32InfoEXT = VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT,
#endif // VK_EXT_full_screen_exclusive
#if VK_EXT_headless_surface
  eHeadlessSurfaceCreateInfoEXT = VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT,
#endif // VK_EXT_headless_surface
#if VK_KHR_buffer_device_address
  ePhysicalDeviceBufferDeviceAddressFeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_KHR,
  eBufferDeviceAddressInfoKHR = VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_KHR,
  eBufferOpaqueCaptureAddressCreateInfoKHR = VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO_KHR,
  eMemoryOpaqueCaptureAddressAllocateInfoKHR = VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO_KHR,
  eDeviceMemoryOpaqueCaptureAddressInfoKHR = VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO_KHR,
#endif // VK_KHR_buffer_device_address
#if VK_EXT_line_rasterization
  ePhysicalDeviceLineRasterizationFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT,
  ePipelineRasterizationLineStateCreateInfoEXT = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT,
  ePhysicalDeviceLineRasterizationPropertiesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT,
#endif // VK_EXT_line_rasterization
#if VK_EXT_shader_atomic_float
  ePhysicalDeviceShaderAtomicFloatFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT,
#endif // VK_EXT_shader_atomic_float
#if VK_EXT_host_query_reset
  ePhysicalDeviceHostQueryResetFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT,
#endif // VK_EXT_host_query_reset
#if VK_EXT_index_type_uint8
  ePhysicalDeviceIndexTypeUint8FeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT,
#endif // VK_EXT_index_type_uint8
#if VK_EXT_extended_dynamic_state
  // Not promoted to 1.3
  ePhysicalDeviceExtendedDynamicStateFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT,
#endif // VK_EXT_extended_dynamic_state
#if VK_KHR_pipeline_executable_properties
  ePhysicalDevicePipelineExecutablePropertiesFeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR,
  ePipelineInfoKHR = VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR,
  ePipelineExecutablePropertiesKHR = VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR,
  ePipelineExecutableInfoKHR = VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR,
  ePipelineExecutableStatisticKHR = VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR,
  ePipelineExecutableInternalRepresentationKHR = VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR,
#endif // VK_KHR_pipeline_executable_properties
#if VK_EXT_host_image_copy
  ePhysicalDeviceHostImageCopyFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES_EXT,
  ePhysicalDeviceHostImageCopyPropertiesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES_EXT,
  eMemoryToImageCopyEXT = VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY_EXT,
  eImageToMemoryCopyEXT = VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY_EXT,
  eCopyImageToMemoryInfoEXT = VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO_EXT,
  eCopyMemoryToImageInfoEXT = VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO_EXT,
  eHostImageLayoutTransitionInfoEXT = VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO_EXT,
  eCopyImageToImageInfoEXT = VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO_EXT,
  eSubresourceHostMemcpySizeEXT = VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE_EXT,
  eHostImageCopyDevicePerformanceQueryEXT = VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY_EXT,
#endif // VK_EXT_host_image_copy
#if VK_KHR_map_memory2
  eMemoryMapInfoKHR = VK_STRUCTURE_TYPE_MEMORY_MAP_INFO_KHR,
  eMemoryUnmapInfoKHR = VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO_KHR,
#endif // VK_KHR_map_memory2
#if VK_EXT_map_memory_placed
  ePhysicalDeviceMapMemoryPlacedFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_FEATURES_EXT,
  ePhysicalDeviceMapMemoryPlacedPropertiesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_PROPERTIES_EXT,
  eMemoryMapPlacedInfoEXT = VK_STRUCTURE_TYPE_MEMORY_MAP_PLACED_INFO_EXT,
#endif // VK_EXT_map_memory_placed
#if VK_EXT_shader_atomic_float2
  ePhysicalDeviceShaderAtomicFloat2FeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT,
#endif // VK_EXT_shader_atomic_float2
#if VK_EXT_surface_maintenance1
  eSurfacePresentModeEXT = VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_EXT,
  eSurfacePresentScalingCapabilitiesEXT = VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_EXT,
  eSurfacePresentModeCompatibilityEXT = VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_EXT,
#endif // VK_EXT_surface_maintenance1
#if VK_EXT_swapchain_maintenance1
  ePhysicalDeviceSwapchainMaintenance1FeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_EXT,
  eSwapchainPresentFenceInfoEXT = VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_EXT,
  eSwapchainPresentModesCreateInfoEXT = VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_EXT,
  eSwapchainPresentModeInfoEXT = VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_EXT,
  eSwapchainPresentScalingCreateInfoEXT = VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_EXT,
  eReleaseSwapchainImagesInfoEXT = VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_EXT,
#endif // VK_EXT_swapchain_maintenance1
#if VK_EXT_shader_demote_to_helper_invocation
  ePhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT,
#endif // VK_EXT_shader_demote_to_helper_invocation
#if VK_NV_device_generated_commands
  ePhysicalDeviceDeviceGeneratedCommandsPropertiesNV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV,
  eGraphicsShaderGroupCreateInfoNV = VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV,
  eGraphicsPipelineShaderGroupsCreateInfoNV = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV,
  eIndirectCommandsLayoutTokenNV = VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV,
  eIndirectCommandsLayoutCreateInfoNV = VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV,
  eGeneratedCommandsInfoNV = VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV,
  eGeneratedCommandsMemoryRequirementsInfoNV = VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV,
  ePhysicalDeviceDeviceGeneratedCommandsFeaturesNV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV,
#endif // VK_NV_device_generated_commands
#if VK_NV_inherited_viewport_scissor
  ePhysicalDeviceInheritedViewportScissorFeaturesNV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV,
  eCommandBufferInheritanceViewportScissorInfoNV = VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV,
#endif // VK_NV_inherited_viewport_scissor
#if VK_KHR_shader_integer_dot_product
  ePhysicalDeviceShaderIntegerDotProductFeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES_KHR,
  ePhysicalDeviceShaderIntegerDotProductPropertiesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES_KHR,
#endif // VK_KHR_shader_integer_dot_product
#if VK_EXT_texel_buffer_alignment
  // Not promoted to 1.3
  ePhysicalDeviceTexelBufferAlignmentFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT,
  ePhysicalDeviceTexelBufferAlignmentPropertiesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT,
#endif // VK_EXT_texel_buffer_alignment
#if VK_QCOM_render_pass_transform
  eCommandBufferInheritanceRenderPassTransformInfoQCOM = VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM,
  eRenderPassTransformBeginInfoQCOM = VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM,
#endif // VK_QCOM_render_pass_transform
#if VK_EXT_depth_bias_control
  ePhysicalDeviceDepthBiasControlFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT,
  eDepthBiasInfoEXT = VK_STRUCTURE_TYPE_DEPTH_BIAS_INFO_EXT,
  eDepthBiasRepresentationInfoEXT = VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT,
#endif // VK_EXT_depth_bias_control
#if VK_EXT_device_memory_report
  ePhysicalDeviceDeviceMemoryReportFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT,
  eDeviceDeviceMemoryReportCreateInfoEXT = VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT,
  eDeviceMemoryReportCallbackDataEXT = VK_STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT,
#endif // VK_EXT_device_memory_report
#if VK_EXT_robustness2
  ePhysicalDeviceRobustness2FeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT,
  ePhysicalDeviceRobustness2PropertiesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT,
#endif // VK_EXT_robustness2
#if VK_EXT_custom_border_color
  eSamplerCustomBorderColorCreateInfoEXT = VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT,
  ePhysicalDeviceCustomBorderColorPropertiesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT,
  ePhysicalDeviceCustomBorderColorFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT,
#endif // VK_EXT_custom_border_color
#if VK_KHR_pipeline_library
  ePipelineLibraryCreateInfoKHR = VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR,
#endif // VK_KHR_pipeline_library
#if VK_NV_present_barrier
  ePhysicalDevicePresentBarrierFeaturesNV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV,
  eSurfaceCapabilitiesPresentBarrierNV = VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV,
  eSwapchainPresentBarrierCreateInfoNV = VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV,
#endif // VK_NV_present_barrier
#if VK_KHR_present_id
  ePresentIdKHR = VK_STRUCTURE_TYPE_PRESENT_ID_KHR,
  ePhysicalDevicePresentIdFeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR,
#endif // VK_KHR_present_id
#if VK_EXT_private_data
  ePhysicalDevicePrivateDataFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES_EXT,
  eDevicePrivateDataCreateInfoEXT = VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO_EXT,
  ePrivateDataSlotCreateInfoEXT = VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO_EXT,
#endif // VK_EXT_private_data
#if VK_EXT_pipeline_creation_cache_control
  ePhysicalDevicePipelineCreationCacheControlFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES_EXT,
#endif // VK_EXT_pipeline_creation_cache_control
#if VK_KHR_video_encode_queue
  eVideoEncodeInfoKHR = VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR,
  eVideoEncodeRateControlInfoKHR = VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR,
  eVideoEncodeRateControlLayerInfoKHR = VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR,
  eVideoEncodeCapabilitiesKHR = VK_STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR,
  eVideoEncodeUsageInfoKHR = VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR,
  eQueryPoolVideoEncodeFeedbackCreateInfoKHR = VK_STRUCTURE_TYPE_QUERY_POOL_VIDEO_ENCODE_FEEDBACK_CREATE_INFO_KHR,
  ePhysicalDeviceVideoEncodeQualityLevelInfoKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR,
  eVideoEncodeQualityLevelPropertiesKHR = VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_PROPERTIES_KHR,
  eVideoEncodeQualityLevelInfoKHR = VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR,
  eVideoEncodeSessionParametersGetInfoKHR = VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_GET_INFO_KHR,
  eVideoEncodeSessionParametersFeedbackInfoKHR = VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_FEEDBACK_INFO_KHR,
#endif // VK_KHR_video_encode_queue
#if VK_NV_device_diagnostics_config
  ePhysicalDeviceDiagnosticsConfigFeaturesNV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV,
  eDeviceDiagnosticsConfigCreateInfoNV = VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV,
#endif // VK_NV_device_diagnostics_config
#if VK_QCOM_tile_shading
  ePhysicalDeviceTileShadingFeaturesQCOM = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_FEATURES_QCOM,
  ePhysicalDeviceTileShadingPropertiesQCOM = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_PROPERTIES_QCOM,
  eRenderPassTileShadingCreateInfoQCOM = VK_STRUCTURE_TYPE_RENDER_PASS_TILE_SHADING_CREATE_INFO_QCOM,
  ePerTileBeginInfoQCOM = VK_STRUCTURE_TYPE_PER_TILE_BEGIN_INFO_QCOM,
  ePerTileEndInfoQCOM = VK_STRUCTURE_TYPE_PER_TILE_END_INFO_QCOM,
  eDispatchTileInfoQCOM = VK_STRUCTURE_TYPE_DISPATCH_TILE_INFO_QCOM,
#endif // VK_QCOM_tile_shading
#if VK_NV_low_latency
  eQueryLowLatencySupportNV = VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV,
#endif // VK_NV_low_latency
#if VK_EXT_metal_objects
  eExportMetalObjectCreateInfoEXT = VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT,
  eExportMetalObjectsInfoEXT = VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECTS_INFO_EXT,
  eExportMetalDeviceInfoEXT = VK_STRUCTURE_TYPE_EXPORT_METAL_DEVICE_INFO_EXT,
  eExportMetalCommandQueueInfoEXT = VK_STRUCTURE_TYPE_EXPORT_METAL_COMMAND_QUEUE_INFO_EXT,
  eExportMetalBufferInfoEXT = VK_STRUCTURE_TYPE_EXPORT_METAL_BUFFER_INFO_EXT,
  eImportMetalBufferInfoEXT = VK_STRUCTURE_TYPE_IMPORT_METAL_BUFFER_INFO_EXT,
  eExportMetalTextureInfoEXT = VK_STRUCTURE_TYPE_EXPORT_METAL_TEXTURE_INFO_EXT,
  eImportMetalTextureInfoEXT = VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT,
  eExportMetalIoSurfaceInfoEXT = VK_STRUCTURE_TYPE_EXPORT_METAL_IO_SURFACE_INFO_EXT,
  eImportMetalIoSurfaceInfoEXT = VK_STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT,
  eExportMetalSharedEventInfoEXT = VK_STRUCTURE_TYPE_EXPORT_METAL_SHARED_EVENT_INFO_EXT,
  eImportMetalSharedEventInfoEXT = VK_STRUCTURE_TYPE_IMPORT_METAL_SHARED_EVENT_INFO_EXT,
#endif // VK_EXT_metal_objects
#if VK_KHR_synchronization2
  eMemoryBarrier2KHR = VK_STRUCTURE_TYPE_MEMORY_BARRIER_2_KHR,
  eBufferMemoryBarrier2KHR = VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2_KHR,
  eImageMemoryBarrier2KHR = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2_KHR,
  eDependencyInfoKHR = VK_STRUCTURE_TYPE_DEPENDENCY_INFO_KHR,
  eSubmitInfo2KHR = VK_STRUCTURE_TYPE_SUBMIT_INFO_2_KHR,
  eSemaphoreSubmitInfoKHR = VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO_KHR,
  eCommandBufferSubmitInfoKHR = VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO_KHR,
  ePhysicalDeviceSynchronization2FeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES_KHR,
#endif // VK_KHR_synchronization2
#if VK_EXT_descriptor_buffer
  ePhysicalDeviceDescriptorBufferPropertiesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT,
  ePhysicalDeviceDescriptorBufferDensityMapPropertiesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT,
  ePhysicalDeviceDescriptorBufferFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT,
  eDescriptorAddressInfoEXT = VK_STRUCTURE_TYPE_DESCRIPTOR_ADDRESS_INFO_EXT,
  eDescriptorGetInfoEXT = VK_STRUCTURE_TYPE_DESCRIPTOR_GET_INFO_EXT,
  eBufferCaptureDescriptorDataInfoEXT = VK_STRUCTURE_TYPE_BUFFER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT,
  eImageCaptureDescriptorDataInfoEXT = VK_STRUCTURE_TYPE_IMAGE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT,
  eImageViewCaptureDescriptorDataInfoEXT = VK_STRUCTURE_TYPE_IMAGE_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_EXT,
  eSamplerCaptureDescriptorDataInfoEXT = VK_STRUCTURE_TYPE_SAMPLER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT,
  eOpaqueCaptureDescriptorDataCreateInfoEXT = VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT,
  eDescriptorBufferBindingInfoEXT = VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_INFO_EXT,
  eDescriptorBufferBindingPushDescriptorBufferHandleEXT = VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT,
#endif // VK_EXT_descriptor_buffer
#if VK_EXT_graphics_pipeline_library
  ePhysicalDeviceGraphicsPipelineLibraryFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT,
  ePhysicalDeviceGraphicsPipelineLibraryPropertiesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT,
  eGraphicsPipelineLibraryCreateInfoEXT = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT,
#endif // VK_EXT_graphics_pipeline_library
#if VK_AMD_shader_early_and_late_fragment_tests
  ePhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD,
#endif // VK_AMD_shader_early_and_late_fragment_tests
#if VK_KHR_fragment_shader_barycentric
  ePhysicalDeviceFragmentShaderBarycentricFeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR,
  ePhysicalDeviceFragmentShaderBarycentricPropertiesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR,
#endif // VK_KHR_fragment_shader_barycentric
#if VK_KHR_shader_subgroup_uniform_control_flow
  ePhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR,
#endif // VK_KHR_shader_subgroup_uniform_control_flow
#if VK_KHR_zero_initialize_workgroup_memory
  ePhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES_KHR,
#endif // VK_KHR_zero_initialize_workgroup_memory
#if VK_NV_fragment_shading_rate_enums
  ePhysicalDeviceFragmentShadingRateEnumsPropertiesNV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV,
  ePhysicalDeviceFragmentShadingRateEnumsFeaturesNV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV,
  ePipelineFragmentShadingRateEnumStateCreateInfoNV = VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV,
#endif // VK_NV_fragment_shading_rate_enums
#if VK_NV_ray_tracing_motion_blur
  eAccelerationStructureGeometryMotionTrianglesDataNV = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV,
  ePhysicalDeviceRayTracingMotionBlurFeaturesNV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV,
  eAccelerationStructureMotionInfoNV = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV,
#endif // VK_NV_ray_tracing_motion_blur
#if VK_EXT_mesh_shader
  ePhysicalDeviceMeshShaderFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT,
  ePhysicalDeviceMeshShaderPropertiesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT,
#endif // VK_EXT_mesh_shader
#if VK_EXT_ycbcr_2plane_444_formats
  ePhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT,
#endif // VK_EXT_ycbcr_2plane_444_formats
#if VK_EXT_fragment_density_map2
  ePhysicalDeviceFragmentDensityMap2FeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT,
  ePhysicalDeviceFragmentDensityMap2PropertiesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT,
#endif // VK_EXT_fragment_density_map2
#if VK_QCOM_rotated_copy_commands
  eCopyCommandTransformInfoQCOM = VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM,
#endif // VK_QCOM_rotated_copy_commands
#if VK_EXT_image_robustness
  ePhysicalDeviceImageRobustnessFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES_EXT,
#endif // VK_EXT_image_robustness
#if VK_KHR_workgroup_memory_explicit_layout
  ePhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR,
#endif // VK_KHR_workgroup_memory_explicit_layout
#if VK_KHR_copy_commands2
  eCopyBufferInfo2KHR = VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2_KHR,
  eCopyImageInfo2KHR = VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2_KHR,
  eCopyBufferToImageInfo2KHR = VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2_KHR,
  eCopyImageToBufferInfo2KHR = VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2_KHR,
  eBlitImageInfo2KHR = VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2_KHR,
  eResolveImageInfo2KHR = VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2_KHR,
  eBufferCopy2KHR = VK_STRUCTURE_TYPE_BUFFER_COPY_2_KHR,
  eImageCopy2KHR = VK_STRUCTURE_TYPE_IMAGE_COPY_2_KHR,
  eImageBlit2KHR = VK_STRUCTURE_TYPE_IMAGE_BLIT_2_KHR,
  eBufferImageCopy2KHR = VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2_KHR,
  eImageResolve2KHR = VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2_KHR,
#endif // VK_KHR_copy_commands2
#if VK_EXT_image_compression_control
  ePhysicalDeviceImageCompressionControlFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT,
  eImageCompressionControlEXT = VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT,
  eSubresourceLayout2EXT = VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_EXT,
  eImageSubresource2EXT = VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_EXT,
  eImageCompressionPropertiesEXT = VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT,
#endif // VK_EXT_image_compression_control
#if VK_EXT_attachment_feedback_loop_layout
  ePhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT,
#endif // VK_EXT_attachment_feedback_loop_layout
#if VK_EXT_4444_formats
  ePhysicalDevice4444FormatsFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT,
#endif // VK_EXT_4444_formats
#if VK_EXT_device_fault
  ePhysicalDeviceFaultFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT,
  eDeviceFaultCountsEXT = VK_STRUCTURE_TYPE_DEVICE_FAULT_COUNTS_EXT,
  eDeviceFaultInfoEXT = VK_STRUCTURE_TYPE_DEVICE_FAULT_INFO_EXT,
#endif // VK_EXT_device_fault
#if VK_ARM_rasterization_order_attachment_access
  ePhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_ARM,
#endif // VK_ARM_rasterization_order_attachment_access
#if VK_EXT_rgba10x6_formats
  ePhysicalDeviceRgba10X6FormatsFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT,
#endif // VK_EXT_rgba10x6_formats
#if VK_EXT_directfb_surface
  eDirectfbSurfaceCreateInfoEXT = VK_STRUCTURE_TYPE_DIRECTFB_SURFACE_CREATE_INFO_EXT,
#endif // VK_EXT_directfb_surface
#if VK_VALVE_mutable_descriptor_type
  ePhysicalDeviceMutableDescriptorTypeFeaturesVALVE = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_VALVE,
  eMutableDescriptorTypeCreateInfoVALVE = VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_VALVE,
#endif // VK_VALVE_mutable_descriptor_type
#if VK_EXT_vertex_input_dynamic_state
  ePhysicalDeviceVertexInputDynamicStateFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT,
  eVertexInputBindingDescription2EXT = VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT,
  eVertexInputAttributeDescription2EXT = VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT,
#endif // VK_EXT_vertex_input_dynamic_state
#if VK_EXT_physical_device_drm
  ePhysicalDeviceDrmPropertiesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT,
#endif // VK_EXT_physical_device_drm
#if VK_EXT_device_address_binding_report
  ePhysicalDeviceAddressBindingReportFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT,
  eDeviceAddressBindingCallbackDataEXT = VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT,
#endif // VK_EXT_device_address_binding_report
#if VK_EXT_depth_clip_control
  ePhysicalDeviceDepthClipControlFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT,
  ePipelineViewportDepthClipControlCreateInfoEXT = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT,
#endif // VK_EXT_depth_clip_control
#if VK_EXT_primitive_topology_list_restart
  ePhysicalDevicePrimitiveTopologyListRestartFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT,
#endif // VK_EXT_primitive_topology_list_restart
#if VK_KHR_format_feature_flags2
  eFormatProperties3KHR = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3_KHR,
#endif // VK_KHR_format_feature_flags2
#if VK_EXT_present_mode_fifo_latest_ready
  ePhysicalDevicePresentModeFifoLatestReadyFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_EXT,
#endif // VK_EXT_present_mode_fifo_latest_ready
#if VK_FUCHSIA_external_memory
  eImportMemoryZirconHandleInfoFUCHSIA = VK_STRUCTURE_TYPE_IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA,
  eMemoryZirconHandlePropertiesFUCHSIA = VK_STRUCTURE_TYPE_MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA,
  eMemoryGetZirconHandleInfoFUCHSIA = VK_STRUCTURE_TYPE_MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA,
#endif // VK_FUCHSIA_external_memory
#if VK_FUCHSIA_external_semaphore
  eImportSemaphoreZirconHandleInfoFUCHSIA = VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA,
  eSemaphoreGetZirconHandleInfoFUCHSIA = VK_STRUCTURE_TYPE_SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA,
#endif // VK_FUCHSIA_external_semaphore
#if VK_FUCHSIA_buffer_collection
  eBufferCollectionCreateInfoFUCHSIA = VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CREATE_INFO_FUCHSIA,
  eImportMemoryBufferCollectionFUCHSIA = VK_STRUCTURE_TYPE_IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA,
  eBufferCollectionImageCreateInfoFUCHSIA = VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA,
  eBufferCollectionPropertiesFUCHSIA = VK_STRUCTURE_TYPE_BUFFER_COLLECTION_PROPERTIES_FUCHSIA,
  eBufferConstraintsInfoFUCHSIA = VK_STRUCTURE_TYPE_BUFFER_CONSTRAINTS_INFO_FUCHSIA,
  eBufferCollectionBufferCreateInfoFUCHSIA = VK_STRUCTURE_TYPE_BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA,
  eImageConstraintsInfoFUCHSIA = VK_STRUCTURE_TYPE_IMAGE_CONSTRAINTS_INFO_FUCHSIA,
  eImageFormatConstraintsInfoFUCHSIA = VK_STRUCTURE_TYPE_IMAGE_FORMAT_CONSTRAINTS_INFO_FUCHSIA,
  eSysmemColorSpaceFUCHSIA = VK_STRUCTURE_TYPE_SYSMEM_COLOR_SPACE_FUCHSIA,
  eBufferCollectionConstraintsInfoFUCHSIA = VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CONSTRAINTS_INFO_FUCHSIA,
#endif // VK_FUCHSIA_buffer_collection
#if VK_HUAWEI_subpass_shading
  eSubpassShadingPipelineCreateInfoHUAWEI = VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI,
  ePhysicalDeviceSubpassShadingFeaturesHUAWEI = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI,
  ePhysicalDeviceSubpassShadingPropertiesHUAWEI = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI,
#endif // VK_HUAWEI_subpass_shading
#if VK_HUAWEI_invocation_mask
  ePhysicalDeviceInvocationMaskFeaturesHUAWEI = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI,
#endif // VK_HUAWEI_invocation_mask
#if VK_NV_external_memory_rdma
  eMemoryGetRemoteAddressInfoNV = VK_STRUCTURE_TYPE_MEMORY_GET_REMOTE_ADDRESS_INFO_NV,
  ePhysicalDeviceExternalMemoryRdmaFeaturesNV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV,
#endif // VK_NV_external_memory_rdma
#if VK_EXT_pipeline_properties
  ePipelinePropertiesIdentifierEXT = VK_STRUCTURE_TYPE_PIPELINE_PROPERTIES_IDENTIFIER_EXT,
  ePhysicalDevicePipelinePropertiesFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT,
  ePipelineInfoEXT = VK_STRUCTURE_TYPE_PIPELINE_INFO_EXT,
#endif // VK_EXT_pipeline_properties
#if VK_EXT_frame_boundary
  ePhysicalDeviceFrameBoundaryFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT,
  eFrameBoundaryEXT = VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT,
#endif // VK_EXT_frame_boundary
#if VK_EXT_multisampled_render_to_single_sampled
  ePhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT,
  eSubpassResolvePerformanceQueryEXT = VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT,
  eMultisampledRenderToSingleSampledInfoEXT = VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT,
#endif // VK_EXT_multisampled_render_to_single_sampled
#if VK_EXT_extended_dynamic_state2
  // Not promoted to 1.3
  ePhysicalDeviceExtendedDynamicState2FeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT,
#endif // VK_EXT_extended_dynamic_state2
#if VK_QNX_screen_surface
  eScreenSurfaceCreateInfoQNX = VK_STRUCTURE_TYPE_SCREEN_SURFACE_CREATE_INFO_QNX,
#endif // VK_QNX_screen_surface
#if VK_EXT_color_write_enable
  ePhysicalDeviceColorWriteEnableFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT,
  ePipelineColorWriteCreateInfoEXT = VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT,
#endif // VK_EXT_color_write_enable
#if VK_EXT_primitives_generated_query
  ePhysicalDevicePrimitivesGeneratedQueryFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT,
#endif // VK_EXT_primitives_generated_query
#if VK_KHR_ray_tracing_maintenance1
  ePhysicalDeviceRayTracingMaintenance1FeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR,
#endif // VK_KHR_ray_tracing_maintenance1
#if VK_EXT_global_priority_query
  ePhysicalDeviceGlobalPriorityQueryFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_EXT,
  eQueueFamilyGlobalPriorityPropertiesEXT = VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_EXT,
#endif // VK_EXT_global_priority_query
#if VK_EXT_image_view_min_lod
  ePhysicalDeviceImageViewMinLodFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT,
  eImageViewMinLodCreateInfoEXT = VK_STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT,
#endif // VK_EXT_image_view_min_lod
#if VK_EXT_multi_draw
  ePhysicalDeviceMultiDrawFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT,
  ePhysicalDeviceMultiDrawPropertiesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT,
#endif // VK_EXT_multi_draw
#if VK_EXT_image_2d_view_of_3d
  ePhysicalDeviceImage2DViewOf3DFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT,
#endif // VK_EXT_image_2d_view_of_3d
#if VK_EXT_shader_tile_image
  ePhysicalDeviceShaderTileImageFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT,
  ePhysicalDeviceShaderTileImagePropertiesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT,
#endif // VK_EXT_shader_tile_image
#if VK_EXT_opacity_micromap
  eMicromapBuildInfoEXT = VK_STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT,
  eMicromapVersionInfoEXT = VK_STRUCTURE_TYPE_MICROMAP_VERSION_INFO_EXT,
  eCopyMicromapInfoEXT = VK_STRUCTURE_TYPE_COPY_MICROMAP_INFO_EXT,
  eCopyMicromapToMemoryInfoEXT = VK_STRUCTURE_TYPE_COPY_MICROMAP_TO_MEMORY_INFO_EXT,
  eCopyMemoryToMicromapInfoEXT = VK_STRUCTURE_TYPE_COPY_MEMORY_TO_MICROMAP_INFO_EXT,
  ePhysicalDeviceOpacityMicromapFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT,
  ePhysicalDeviceOpacityMicromapPropertiesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT,
  eMicromapCreateInfoEXT = VK_STRUCTURE_TYPE_MICROMAP_CREATE_INFO_EXT,
  eMicromapBuildSizesInfoEXT = VK_STRUCTURE_TYPE_MICROMAP_BUILD_SIZES_INFO_EXT,
  eAccelerationStructureTrianglesOpacityMicromapEXT = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT,
#endif // VK_EXT_opacity_micromap
#if VK_HUAWEI_cluster_culling_shader
  ePhysicalDeviceClusterCullingShaderFeaturesHUAWEI = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI,
  ePhysicalDeviceClusterCullingShaderPropertiesHUAWEI = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI,
  ePhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_VRS_FEATURES_HUAWEI,
#endif // VK_HUAWEI_cluster_culling_shader
#if VK_EXT_border_color_swizzle
  ePhysicalDeviceBorderColorSwizzleFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT,
  eSamplerBorderColorComponentMappingCreateInfoEXT = VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT,
#endif // VK_EXT_border_color_swizzle
#if VK_EXT_pageable_device_local_memory
  ePhysicalDevicePageableDeviceLocalMemoryFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT,
#endif // VK_EXT_pageable_device_local_memory
#if VK_KHR_maintenance4
  ePhysicalDeviceMaintenance4FeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES_KHR,
  ePhysicalDeviceMaintenance4PropertiesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES_KHR,
  eDeviceBufferMemoryRequirementsKHR = VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS_KHR,
  eDeviceImageMemoryRequirementsKHR = VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS_KHR,
#endif // VK_KHR_maintenance4
#if VK_ARM_shader_core_properties
  ePhysicalDeviceShaderCorePropertiesARM = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM,
#endif // VK_ARM_shader_core_properties
#if VK_KHR_shader_subgroup_rotate
  ePhysicalDeviceShaderSubgroupRotateFeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES_KHR,
#endif // VK_KHR_shader_subgroup_rotate
#if VK_ARM_scheduling_controls
  eDeviceQueueShaderCoreControlCreateInfoARM = VK_STRUCTURE_TYPE_DEVICE_QUEUE_SHADER_CORE_CONTROL_CREATE_INFO_ARM,
  ePhysicalDeviceSchedulingControlsFeaturesARM = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_FEATURES_ARM,
  ePhysicalDeviceSchedulingControlsPropertiesARM = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_PROPERTIES_ARM,
#endif // VK_ARM_scheduling_controls
#if VK_EXT_image_sliced_view_of_3d
  ePhysicalDeviceImageSlicedViewOf3DFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT,
  eImageViewSlicedCreateInfoEXT = VK_STRUCTURE_TYPE_IMAGE_VIEW_SLICED_CREATE_INFO_EXT,
#endif // VK_EXT_image_sliced_view_of_3d
#if VK_VALVE_descriptor_set_host_mapping
  ePhysicalDeviceDescriptorSetHostMappingFeaturesVALVE = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE,
  eDescriptorSetBindingReferenceVALVE = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_BINDING_REFERENCE_VALVE,
  eDescriptorSetLayoutHostMappingInfoVALVE = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE,
#endif // VK_VALVE_descriptor_set_host_mapping
#if VK_EXT_depth_clamp_zero_one
  ePhysicalDeviceDepthClampZeroOneFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_EXT,
#endif // VK_EXT_depth_clamp_zero_one
#if VK_EXT_non_seamless_cube_map
  ePhysicalDeviceNonSeamlessCubeMapFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT,
#endif // VK_EXT_non_seamless_cube_map
#if VK_ARM_render_pass_striped
  ePhysicalDeviceRenderPassStripedFeaturesARM = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_FEATURES_ARM,
  ePhysicalDeviceRenderPassStripedPropertiesARM = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_PROPERTIES_ARM,
  eRenderPassStripeBeginInfoARM = VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_BEGIN_INFO_ARM,
  eRenderPassStripeInfoARM = VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_INFO_ARM,
  eRenderPassStripeSubmitInfoARM = VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_SUBMIT_INFO_ARM,
#endif // VK_ARM_render_pass_striped
#if VK_QCOM_fragment_density_map_offset
  ePhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM,
  ePhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_QCOM,
  eSubpassFragmentDensityMapOffsetEndInfoQCOM = VK_STRUCTURE_TYPE_SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM,
#endif // VK_QCOM_fragment_density_map_offset
#if VK_NV_copy_memory_indirect
  ePhysicalDeviceCopyMemoryIndirectFeaturesNV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV,
  ePhysicalDeviceCopyMemoryIndirectPropertiesNV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_NV,
#endif // VK_NV_copy_memory_indirect
#if VK_NV_memory_decompression
  ePhysicalDeviceMemoryDecompressionFeaturesNV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV,
  ePhysicalDeviceMemoryDecompressionPropertiesNV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_NV,
#endif // VK_NV_memory_decompression
#if VK_NV_device_generated_commands_compute
  ePhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV,
  eComputePipelineIndirectBufferInfoNV = VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_INDIRECT_BUFFER_INFO_NV,
  ePipelineIndirectDeviceAddressInfoNV = VK_STRUCTURE_TYPE_PIPELINE_INDIRECT_DEVICE_ADDRESS_INFO_NV,
#endif // VK_NV_device_generated_commands_compute
#if VK_NV_ray_tracing_linear_swept_spheres
  ePhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_LINEAR_SWEPT_SPHERES_FEATURES_NV,
  eAccelerationStructureGeometryLinearSweptSpheresDataNV = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_LINEAR_SWEPT_SPHERES_DATA_NV,
  eAccelerationStructureGeometrySpheresDataNV = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_SPHERES_DATA_NV,
#endif // VK_NV_ray_tracing_linear_swept_spheres
#if VK_NV_linear_color_attachment
  ePhysicalDeviceLinearColorAttachmentFeaturesNV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV,
#endif // VK_NV_linear_color_attachment
#if VK_KHR_shader_maximal_reconvergence
  ePhysicalDeviceShaderMaximalReconvergenceFeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MAXIMAL_RECONVERGENCE_FEATURES_KHR,
#endif // VK_KHR_shader_maximal_reconvergence
#if VK_EXT_image_compression_control_swapchain
  ePhysicalDeviceImageCompressionControlSwapchainFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT,
#endif // VK_EXT_image_compression_control_swapchain
#if VK_QCOM_image_processing
  ePhysicalDeviceImageProcessingFeaturesQCOM = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM,
  ePhysicalDeviceImageProcessingPropertiesQCOM = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM,
  eImageViewSampleWeightCreateInfoQCOM = VK_STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM,
#endif // VK_QCOM_image_processing
#if VK_EXT_nested_command_buffer
  ePhysicalDeviceNestedCommandBufferFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT,
  ePhysicalDeviceNestedCommandBufferPropertiesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_PROPERTIES_EXT,
#endif // VK_EXT_nested_command_buffer
#if VK_EXT_external_memory_acquire_unmodified
  eExternalMemoryAcquireUnmodifiedEXT = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT,
#endif // VK_EXT_external_memory_acquire_unmodified
#if VK_EXT_extended_dynamic_state3
  ePhysicalDeviceExtendedDynamicState3FeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT,
  ePhysicalDeviceExtendedDynamicState3PropertiesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT,
#endif // VK_EXT_extended_dynamic_state3
#if VK_EXT_subpass_merge_feedback
  ePhysicalDeviceSubpassMergeFeedbackFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT,
  eRenderPassCreationControlEXT = VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT,
  eRenderPassCreationFeedbackCreateInfoEXT = VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT,
  eRenderPassSubpassFeedbackCreateInfoEXT = VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT,
#endif // VK_EXT_subpass_merge_feedback
#if VK_LUNARG_direct_driver_loading
  eDirectDriverLoadingInfoLUNARG = VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_INFO_LUNARG,
  eDirectDriverLoadingListLUNARG = VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_LIST_LUNARG,
#endif // VK_LUNARG_direct_driver_loading
#if VK_ARM_tensors
  eTensorCreateInfoARM = VK_STRUCTURE_TYPE_TENSOR_CREATE_INFO_ARM,
  eTensorViewCreateInfoARM = VK_STRUCTURE_TYPE_TENSOR_VIEW_CREATE_INFO_ARM,
  eBindTensorMemoryInfoARM = VK_STRUCTURE_TYPE_BIND_TENSOR_MEMORY_INFO_ARM,
  eWriteDescriptorSetTensorARM = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_TENSOR_ARM,
  ePhysicalDeviceTensorPropertiesARM = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_PROPERTIES_ARM,
  eTensorFormatPropertiesARM = VK_STRUCTURE_TYPE_TENSOR_FORMAT_PROPERTIES_ARM,
  eTensorDescriptionARM = VK_STRUCTURE_TYPE_TENSOR_DESCRIPTION_ARM,
  eTensorMemoryRequirementsInfoARM = VK_STRUCTURE_TYPE_TENSOR_MEMORY_REQUIREMENTS_INFO_ARM,
  eTensorMemoryBarrierARM = VK_STRUCTURE_TYPE_TENSOR_MEMORY_BARRIER_ARM,
  ePhysicalDeviceTensorFeaturesARM = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_FEATURES_ARM,
  eDeviceTensorMemoryRequirementsARM = VK_STRUCTURE_TYPE_DEVICE_TENSOR_MEMORY_REQUIREMENTS_ARM,
  eCopyTensorInfoARM = VK_STRUCTURE_TYPE_COPY_TENSOR_INFO_ARM,
  eTensorCopyARM = VK_STRUCTURE_TYPE_TENSOR_COPY_ARM,
  eTensorDependencyInfoARM = VK_STRUCTURE_TYPE_TENSOR_DEPENDENCY_INFO_ARM,
  eMemoryDedicatedAllocateInfoTensorARM = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_TENSOR_ARM,
  ePhysicalDeviceExternalTensorInfoARM = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_TENSOR_INFO_ARM,
  eExternalTensorPropertiesARM = VK_STRUCTURE_TYPE_EXTERNAL_TENSOR_PROPERTIES_ARM,
  eExternalMemoryTensorCreateInfoARM = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_TENSOR_CREATE_INFO_ARM,
  ePhysicalDeviceDescriptorBufferTensorFeaturesARM = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_FEATURES_ARM,
  ePhysicalDeviceDescriptorBufferTensorPropertiesARM = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_PROPERTIES_ARM,
  eDescriptorGetTensorInfoARM = VK_STRUCTURE_TYPE_DESCRIPTOR_GET_TENSOR_INFO_ARM,
  eTensorCaptureDescriptorDataInfoARM = VK_STRUCTURE_TYPE_TENSOR_CAPTURE_DESCRIPTOR_DATA_INFO_ARM,
  eTensorViewCaptureDescriptorDataInfoARM = VK_STRUCTURE_TYPE_TENSOR_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_ARM,
  eFrameBoundaryTensorsARM = VK_STRUCTURE_TYPE_FRAME_BOUNDARY_TENSORS_ARM,
#endif // VK_ARM_tensors
#if VK_EXT_shader_module_identifier
  ePhysicalDeviceShaderModuleIdentifierFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT,
  ePhysicalDeviceShaderModuleIdentifierPropertiesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT,
  ePipelineShaderStageModuleIdentifierCreateInfoEXT = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT,
  eShaderModuleIdentifierEXT = VK_STRUCTURE_TYPE_SHADER_MODULE_IDENTIFIER_EXT,
#endif // VK_EXT_shader_module_identifier
#if VK_EXT_rasterization_order_attachment_access
  ePhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT,
#endif // VK_EXT_rasterization_order_attachment_access
#if VK_NV_optical_flow
  ePhysicalDeviceOpticalFlowFeaturesNV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV,
  ePhysicalDeviceOpticalFlowPropertiesNV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV,
  eOpticalFlowImageFormatInfoNV = VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV,
  eOpticalFlowImageFormatPropertiesNV = VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_PROPERTIES_NV,
  eOpticalFlowSessionCreateInfoNV = VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_INFO_NV,
  eOpticalFlowExecuteInfoNV = VK_STRUCTURE_TYPE_OPTICAL_FLOW_EXECUTE_INFO_NV,
  eOpticalFlowSessionCreatePrivateDataInfoNV = VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV,
#endif // VK_NV_optical_flow
#if VK_EXT_legacy_dithering
  ePhysicalDeviceLegacyDitheringFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT,
#endif // VK_EXT_legacy_dithering
#if VK_EXT_pipeline_protected_access
  ePhysicalDevicePipelineProtectedAccessFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES_EXT,
#endif // VK_EXT_pipeline_protected_access
#if VK_ANDROID_external_format_resolve
  ePhysicalDeviceExternalFormatResolveFeaturesANDROID = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_FEATURES_ANDROID,
  ePhysicalDeviceExternalFormatResolvePropertiesANDROID = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_PROPERTIES_ANDROID,
  eAndroidHardwareBufferFormatResolvePropertiesANDROID = VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_RESOLVE_PROPERTIES_ANDROID,
#endif // VK_ANDROID_external_format_resolve
#if VK_KHR_maintenance5
  ePhysicalDeviceMaintenance5FeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES_KHR,
  ePhysicalDeviceMaintenance5PropertiesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES_KHR,
  eRenderingAreaInfoKHR = VK_STRUCTURE_TYPE_RENDERING_AREA_INFO_KHR,
  eDeviceImageSubresourceInfoKHR = VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO_KHR,
  eSubresourceLayout2KHR = VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_KHR,
  eImageSubresource2KHR = VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_KHR,
  ePipelineCreateFlags2CreateInfoKHR = VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO_KHR,
  eBufferUsageFlags2CreateInfoKHR = VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO_KHR,
#endif // VK_KHR_maintenance5
#if VK_AMD_anti_lag
  ePhysicalDeviceAntiLagFeaturesAMD = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ANTI_LAG_FEATURES_AMD,
  eAntiLagDataAMD = VK_STRUCTURE_TYPE_ANTI_LAG_DATA_AMD,
  eAntiLagPresentationInfoAMD = VK_STRUCTURE_TYPE_ANTI_LAG_PRESENTATION_INFO_AMD,
#endif // VK_AMD_anti_lag
#if VK_KHR_present_id2
  eSurfaceCapabilitiesPresentId2KHR = VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_ID_2_KHR,
  ePresentId2KHR = VK_STRUCTURE_TYPE_PRESENT_ID_2_KHR,
  ePhysicalDevicePresentId2FeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_2_FEATURES_KHR,
#endif // VK_KHR_present_id2
#if VK_KHR_present_wait2
  eSurfaceCapabilitiesPresentWait2KHR = VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_WAIT_2_KHR,
  ePhysicalDevicePresentWait2FeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_2_FEATURES_KHR,
  ePresentWait2InfoKHR = VK_STRUCTURE_TYPE_PRESENT_WAIT_2_INFO_KHR,
#endif // VK_KHR_present_wait2
#if VK_KHR_ray_tracing_position_fetch
  ePhysicalDeviceRayTracingPositionFetchFeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR,
#endif // VK_KHR_ray_tracing_position_fetch
#if VK_EXT_shader_object
  ePhysicalDeviceShaderObjectFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT,
  ePhysicalDeviceShaderObjectPropertiesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT,
  eShaderCreateInfoEXT = VK_STRUCTURE_TYPE_SHADER_CREATE_INFO_EXT,
  eShaderRequiredSubgroupSizeCreateInfoEXT = VK_STRUCTURE_TYPE_SHADER_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT,
#endif // VK_EXT_shader_object
#if VK_KHR_pipeline_binary
  ePhysicalDevicePipelineBinaryFeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_FEATURES_KHR,
  ePipelineBinaryCreateInfoKHR = VK_STRUCTURE_TYPE_PIPELINE_BINARY_CREATE_INFO_KHR,
  ePipelineBinaryInfoKHR = VK_STRUCTURE_TYPE_PIPELINE_BINARY_INFO_KHR,
  ePipelineBinaryKeyKHR = VK_STRUCTURE_TYPE_PIPELINE_BINARY_KEY_KHR,
  ePhysicalDevicePipelineBinaryPropertiesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_PROPERTIES_KHR,
  eReleaseCapturedPipelineDataInfoKHR = VK_STRUCTURE_TYPE_RELEASE_CAPTURED_PIPELINE_DATA_INFO_KHR,
  ePipelineBinaryDataInfoKHR = VK_STRUCTURE_TYPE_PIPELINE_BINARY_DATA_INFO_KHR,
  ePipelineCreateInfoKHR = VK_STRUCTURE_TYPE_PIPELINE_CREATE_INFO_KHR,
  eDevicePipelineBinaryInternalCacheControlKHR = VK_STRUCTURE_TYPE_DEVICE_PIPELINE_BINARY_INTERNAL_CACHE_CONTROL_KHR,
  ePipelineBinaryHandlesInfoKHR = VK_STRUCTURE_TYPE_PIPELINE_BINARY_HANDLES_INFO_KHR,
#endif // VK_KHR_pipeline_binary
#if VK_QCOM_tile_properties
  ePhysicalDeviceTilePropertiesFeaturesQCOM = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM,
  eTilePropertiesQCOM = VK_STRUCTURE_TYPE_TILE_PROPERTIES_QCOM,
#endif // VK_QCOM_tile_properties
#if VK_SEC_amigo_profiling
  ePhysicalDeviceAmigoProfilingFeaturesSEC = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC,
  eAmigoProfilingSubmitInfoSEC = VK_STRUCTURE_TYPE_AMIGO_PROFILING_SUBMIT_INFO_SEC,
#endif // VK_SEC_amigo_profiling
#if VK_KHR_surface_maintenance1
  eSurfacePresentModeKHR = VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_KHR,
  eSurfacePresentScalingCapabilitiesKHR = VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_KHR,
  eSurfacePresentModeCompatibilityKHR = VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_KHR,
#endif // VK_KHR_surface_maintenance1
#if VK_KHR_swapchain_maintenance1
  ePhysicalDeviceSwapchainMaintenance1FeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_KHR,
  eSwapchainPresentFenceInfoKHR = VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_KHR,
  eSwapchainPresentModesCreateInfoKHR = VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_KHR,
  eSwapchainPresentModeInfoKHR = VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_KHR,
  eSwapchainPresentScalingCreateInfoKHR = VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_KHR,
  eReleaseSwapchainImagesInfoKHR = VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_KHR,
#endif // VK_KHR_swapchain_maintenance1
#if VK_QCOM_multiview_per_view_viewports
  ePhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM,
#endif // VK_QCOM_multiview_per_view_viewports
#if VK_NV_ray_tracing_invocation_reorder
  ePhysicalDeviceRayTracingInvocationReorderFeaturesNV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV,
  ePhysicalDeviceRayTracingInvocationReorderPropertiesNV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV,
#endif // VK_NV_ray_tracing_invocation_reorder
#if VK_NV_cooperative_vector
  ePhysicalDeviceCooperativeVectorFeaturesNV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_FEATURES_NV,
  ePhysicalDeviceCooperativeVectorPropertiesNV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_PROPERTIES_NV,
  eCooperativeVectorPropertiesNV = VK_STRUCTURE_TYPE_COOPERATIVE_VECTOR_PROPERTIES_NV,
  eConvertCooperativeVectorMatrixInfoNV = VK_STRUCTURE_TYPE_CONVERT_COOPERATIVE_VECTOR_MATRIX_INFO_NV,
#endif // VK_NV_cooperative_vector
#if VK_NV_extended_sparse_address_space
  ePhysicalDeviceExtendedSparseAddressSpaceFeaturesNV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_FEATURES_NV,
  ePhysicalDeviceExtendedSparseAddressSpacePropertiesNV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_PROPERTIES_NV,
#endif // VK_NV_extended_sparse_address_space
#if VK_EXT_mutable_descriptor_type
  ePhysicalDeviceMutableDescriptorTypeFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT,
  eMutableDescriptorTypeCreateInfoEXT = VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT,
#endif // VK_EXT_mutable_descriptor_type
#if VK_EXT_legacy_vertex_attributes
  ePhysicalDeviceLegacyVertexAttributesFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_FEATURES_EXT,
  ePhysicalDeviceLegacyVertexAttributesPropertiesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_PROPERTIES_EXT,
#endif // VK_EXT_legacy_vertex_attributes
#if VK_EXT_layer_settings
  eLayerSettingsCreateInfoEXT = VK_STRUCTURE_TYPE_LAYER_SETTINGS_CREATE_INFO_EXT,
#endif // VK_EXT_layer_settings
#if VK_ARM_shader_core_builtins
  ePhysicalDeviceShaderCoreBuiltinsFeaturesARM = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM,
  ePhysicalDeviceShaderCoreBuiltinsPropertiesARM = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM,
#endif // VK_ARM_shader_core_builtins
#if VK_EXT_pipeline_library_group_handles
  ePhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT,
#endif // VK_EXT_pipeline_library_group_handles
#if VK_EXT_dynamic_rendering_unused_attachments
  ePhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT,
#endif // VK_EXT_dynamic_rendering_unused_attachments
#if VK_NV_low_latency2
  eLatencySleepModeInfoNV = VK_STRUCTURE_TYPE_LATENCY_SLEEP_MODE_INFO_NV,
  eLatencySleepInfoNV = VK_STRUCTURE_TYPE_LATENCY_SLEEP_INFO_NV,
  eSetLatencyMarkerInfoNV = VK_STRUCTURE_TYPE_SET_LATENCY_MARKER_INFO_NV,
  eGetLatencyMarkerInfoNV = VK_STRUCTURE_TYPE_GET_LATENCY_MARKER_INFO_NV,
  eLatencyTimingsFrameReportNV = VK_STRUCTURE_TYPE_LATENCY_TIMINGS_FRAME_REPORT_NV,
  eLatencySubmissionPresentIdNV = VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV,
  eOutOfBandQueueTypeInfoNV = VK_STRUCTURE_TYPE_OUT_OF_BAND_QUEUE_TYPE_INFO_NV,
  eSwapchainLatencyCreateInfoNV = VK_STRUCTURE_TYPE_SWAPCHAIN_LATENCY_CREATE_INFO_NV,
  eLatencySurfaceCapabilitiesNV = VK_STRUCTURE_TYPE_LATENCY_SURFACE_CAPABILITIES_NV,
#endif // VK_NV_low_latency2
#if VK_KHR_cooperative_matrix
  ePhysicalDeviceCooperativeMatrixFeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR,
  eCooperativeMatrixPropertiesKHR = VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_KHR,
  ePhysicalDeviceCooperativeMatrixPropertiesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR,
#endif // VK_KHR_cooperative_matrix
#if VK_ARM_data_graph
  eDataGraphPipelineCreateInfoARM = VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CREATE_INFO_ARM,
  eDataGraphPipelineSessionCreateInfoARM = VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_CREATE_INFO_ARM,
  eDataGraphPipelineResourceInfoARM = VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_RESOURCE_INFO_ARM,
  eDataGraphPipelineConstantARM = VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CONSTANT_ARM,
  eDataGraphPipelineSessionMemoryRequirementsInfoARM = VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_MEMORY_REQUIREMENTS_INFO_ARM,
  eBindDataGraphPipelineSessionMemoryInfoARM = VK_STRUCTURE_TYPE_BIND_DATA_GRAPH_PIPELINE_SESSION_MEMORY_INFO_ARM,
  ePhysicalDeviceDataGraphFeaturesARM = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DATA_GRAPH_FEATURES_ARM,
  eDataGraphPipelineShaderModuleCreateInfoARM = VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SHADER_MODULE_CREATE_INFO_ARM,
  eDataGraphPipelinePropertyQueryResultARM = VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_PROPERTY_QUERY_RESULT_ARM,
  eDataGraphPipelineInfoARM = VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_INFO_ARM,
  eDataGraphPipelineCompilerControlCreateInfoARM = VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_COMPILER_CONTROL_CREATE_INFO_ARM,
  eDataGraphPipelineSessionBindPointRequirementsInfoARM = VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_REQUIREMENTS_INFO_ARM,
  eDataGraphPipelineSessionBindPointRequirementARM = VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_REQUIREMENT_ARM,
  eDataGraphPipelineIdentifierCreateInfoARM = VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_IDENTIFIER_CREATE_INFO_ARM,
  eDataGraphPipelineDispatchInfoARM = VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_DISPATCH_INFO_ARM,
  eDataGraphProcessingEngineCreateInfoARM = VK_STRUCTURE_TYPE_DATA_GRAPH_PROCESSING_ENGINE_CREATE_INFO_ARM,
  eQueueFamilyDataGraphProcessingEnginePropertiesARM = VK_STRUCTURE_TYPE_QUEUE_FAMILY_DATA_GRAPH_PROCESSING_ENGINE_PROPERTIES_ARM,
  eQueueFamilyDataGraphPropertiesARM = VK_STRUCTURE_TYPE_QUEUE_FAMILY_DATA_GRAPH_PROPERTIES_ARM,
  ePhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_QUEUE_FAMILY_DATA_GRAPH_PROCESSING_ENGINE_INFO_ARM,
  eDataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM = VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CONSTANT_TENSOR_SEMI_STRUCTURED_SPARSITY_INFO_ARM,
#endif // VK_ARM_data_graph
#if VK_QCOM_multiview_per_view_render_areas
  ePhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM,
  eMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM = VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM,
#endif // VK_QCOM_multiview_per_view_render_areas
#if VK_KHR_compute_shader_derivatives
  ePhysicalDeviceComputeShaderDerivativesFeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_KHR,
  ePhysicalDeviceComputeShaderDerivativesPropertiesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_PROPERTIES_KHR,
#endif // VK_KHR_compute_shader_derivatives
#if VK_KHR_video_decode_av1
  eVideoDecodeAv1CapabilitiesKHR = VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_CAPABILITIES_KHR,
  eVideoDecodeAv1PictureInfoKHR = VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PICTURE_INFO_KHR,
  eVideoDecodeAv1ProfileInfoKHR = VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PROFILE_INFO_KHR,
  eVideoDecodeAv1SessionParametersCreateInfoKHR = VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR,
  eVideoDecodeAv1DpbSlotInfoKHR = VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_DPB_SLOT_INFO_KHR,
#endif // VK_KHR_video_decode_av1
#if VK_KHR_video_encode_av1
  eVideoEncodeAv1CapabilitiesKHR = VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_CAPABILITIES_KHR,
  eVideoEncodeAv1SessionParametersCreateInfoKHR = VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR,
  eVideoEncodeAv1PictureInfoKHR = VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PICTURE_INFO_KHR,
  eVideoEncodeAv1DpbSlotInfoKHR = VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_DPB_SLOT_INFO_KHR,
  ePhysicalDeviceVideoEncodeAv1FeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_AV1_FEATURES_KHR,
  eVideoEncodeAv1ProfileInfoKHR = VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PROFILE_INFO_KHR,
  eVideoEncodeAv1RateControlInfoKHR = VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_INFO_KHR,
  eVideoEncodeAv1RateControlLayerInfoKHR = VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_LAYER_INFO_KHR,
  eVideoEncodeAv1QualityLevelPropertiesKHR = VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUALITY_LEVEL_PROPERTIES_KHR,
  eVideoEncodeAv1SessionCreateInfoKHR = VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_CREATE_INFO_KHR,
  eVideoEncodeAv1GopRemainingFrameInfoKHR = VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_GOP_REMAINING_FRAME_INFO_KHR,
#endif // VK_KHR_video_encode_av1
#if VK_KHR_video_decode_vp9
  ePhysicalDeviceVideoDecodeVp9FeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_DECODE_VP9_FEATURES_KHR,
  eVideoDecodeVp9CapabilitiesKHR = VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_CAPABILITIES_KHR,
  eVideoDecodeVp9PictureInfoKHR = VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_PICTURE_INFO_KHR,
  eVideoDecodeVp9ProfileInfoKHR = VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_PROFILE_INFO_KHR,
#endif // VK_KHR_video_decode_vp9
#if VK_KHR_video_maintenance1
  ePhysicalDeviceVideoMaintenance1FeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_1_FEATURES_KHR,
  eVideoInlineQueryInfoKHR = VK_STRUCTURE_TYPE_VIDEO_INLINE_QUERY_INFO_KHR,
#endif // VK_KHR_video_maintenance1
#if VK_NV_per_stage_descriptor_set
  ePhysicalDevicePerStageDescriptorSetFeaturesNV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PER_STAGE_DESCRIPTOR_SET_FEATURES_NV,
#endif // VK_NV_per_stage_descriptor_set
#if VK_QCOM_image_processing2
  ePhysicalDeviceImageProcessing2FeaturesQCOM = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM,
  ePhysicalDeviceImageProcessing2PropertiesQCOM = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_PROPERTIES_QCOM,
  eSamplerBlockMatchWindowCreateInfoQCOM = VK_STRUCTURE_TYPE_SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_QCOM,
#endif // VK_QCOM_image_processing2
#if VK_QCOM_filter_cubic_weights
  eSamplerCubicWeightsCreateInfoQCOM = VK_STRUCTURE_TYPE_SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_QCOM,
  ePhysicalDeviceCubicWeightsFeaturesQCOM = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM,
  eBlitImageCubicWeightsInfoQCOM = VK_STRUCTURE_TYPE_BLIT_IMAGE_CUBIC_WEIGHTS_INFO_QCOM,
#endif // VK_QCOM_filter_cubic_weights
#if VK_QCOM_ycbcr_degamma
  ePhysicalDeviceYcbcrDegammaFeaturesQCOM = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM,
  eSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_YCBCR_DEGAMMA_CREATE_INFO_QCOM,
#endif // VK_QCOM_ycbcr_degamma
#if VK_QCOM_filter_cubic_clamp
  ePhysicalDeviceCubicClampFeaturesQCOM = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM,
#endif // VK_QCOM_filter_cubic_clamp
#if VK_EXT_attachment_feedback_loop_dynamic_state
  ePhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT,
#endif // VK_EXT_attachment_feedback_loop_dynamic_state
#if VK_KHR_vertex_attribute_divisor
  ePhysicalDeviceVertexAttributeDivisorPropertiesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_KHR,
  ePipelineVertexInputDivisorStateCreateInfoKHR = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_KHR,
  ePhysicalDeviceVertexAttributeDivisorFeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_KHR,
#endif // VK_KHR_vertex_attribute_divisor
#if VK_KHR_unified_image_layouts
  ePhysicalDeviceUnifiedImageLayoutsFeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFIED_IMAGE_LAYOUTS_FEATURES_KHR,
#endif // VK_KHR_unified_image_layouts
#if VK_KHR_shader_float_controls2
  ePhysicalDeviceShaderFloatControls2FeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES_KHR,
#endif // VK_KHR_shader_float_controls2
#if VK_QNX_external_memory_screen_buffer
  eScreenBufferPropertiesQNX = VK_STRUCTURE_TYPE_SCREEN_BUFFER_PROPERTIES_QNX,
  eScreenBufferFormatPropertiesQNX = VK_STRUCTURE_TYPE_SCREEN_BUFFER_FORMAT_PROPERTIES_QNX,
  eImportScreenBufferInfoQNX = VK_STRUCTURE_TYPE_IMPORT_SCREEN_BUFFER_INFO_QNX,
  eExternalFormatQNX = VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX,
  ePhysicalDeviceExternalMemoryScreenBufferFeaturesQNX = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCREEN_BUFFER_FEATURES_QNX,
#endif // VK_QNX_external_memory_screen_buffer
#if VK_MSFT_layered_driver
  ePhysicalDeviceLayeredDriverPropertiesMSFT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT,
#endif // VK_MSFT_layered_driver
#if VK_KHR_index_type_uint8
  ePhysicalDeviceIndexTypeUint8FeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_KHR,
#endif // VK_KHR_index_type_uint8
#if VK_KHR_line_rasterization
  ePhysicalDeviceLineRasterizationFeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_KHR,
  ePipelineRasterizationLineStateCreateInfoKHR = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_KHR,
  ePhysicalDeviceLineRasterizationPropertiesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_KHR,
#endif // VK_KHR_line_rasterization
#if VK_KHR_calibrated_timestamps
  eCalibratedTimestampInfoKHR = VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_KHR,
#endif // VK_KHR_calibrated_timestamps
#if VK_KHR_shader_expect_assume
  ePhysicalDeviceShaderExpectAssumeFeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES_KHR,
#endif // VK_KHR_shader_expect_assume
#if VK_KHR_maintenance6
  ePhysicalDeviceMaintenance6FeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES_KHR,
  ePhysicalDeviceMaintenance6PropertiesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES_KHR,
  eBindMemoryStatusKHR = VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS_KHR,
  eBindDescriptorSetsInfoKHR = VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_SETS_INFO_KHR,
  ePushConstantsInfoKHR = VK_STRUCTURE_TYPE_PUSH_CONSTANTS_INFO_KHR,
  ePushDescriptorSetInfoKHR = VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_INFO_KHR,
  ePushDescriptorSetWithTemplateInfoKHR = VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_WITH_TEMPLATE_INFO_KHR,
  eSetDescriptorBufferOffsetsInfoEXT = VK_STRUCTURE_TYPE_SET_DESCRIPTOR_BUFFER_OFFSETS_INFO_EXT,
  eBindDescriptorBufferEmbeddedSamplersInfoEXT = VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_BUFFER_EMBEDDED_SAMPLERS_INFO_EXT,
#endif // VK_KHR_maintenance6
#if VK_NV_descriptor_pool_overallocation
  ePhysicalDeviceDescriptorPoolOverallocationFeaturesNV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV,
#endif // VK_NV_descriptor_pool_overallocation
#if VK_QCOM_tile_memory_heap
  ePhysicalDeviceTileMemoryHeapFeaturesQCOM = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_FEATURES_QCOM,
  ePhysicalDeviceTileMemoryHeapPropertiesQCOM = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_PROPERTIES_QCOM,
  eTileMemoryRequirementsQCOM = VK_STRUCTURE_TYPE_TILE_MEMORY_REQUIREMENTS_QCOM,
  eTileMemoryBindInfoQCOM = VK_STRUCTURE_TYPE_TILE_MEMORY_BIND_INFO_QCOM,
  eTileMemorySizeInfoQCOM = VK_STRUCTURE_TYPE_TILE_MEMORY_SIZE_INFO_QCOM,
#endif // VK_QCOM_tile_memory_heap
#if VK_NV_display_stereo
  eDisplaySurfaceStereoCreateInfoNV = VK_STRUCTURE_TYPE_DISPLAY_SURFACE_STEREO_CREATE_INFO_NV,
  eDisplayModeStereoPropertiesNV = VK_STRUCTURE_TYPE_DISPLAY_MODE_STEREO_PROPERTIES_NV,
#endif // VK_NV_display_stereo
#if VK_KHR_video_encode_intra_refresh
  eVideoEncodeIntraRefreshCapabilitiesKHR = VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_CAPABILITIES_KHR,
  eVideoEncodeSessionIntraRefreshCreateInfoKHR = VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_INTRA_REFRESH_CREATE_INFO_KHR,
  eVideoEncodeIntraRefreshInfoKHR = VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_INFO_KHR,
  eVideoReferenceIntraRefreshInfoKHR = VK_STRUCTURE_TYPE_VIDEO_REFERENCE_INTRA_REFRESH_INFO_KHR,
  ePhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_INTRA_REFRESH_FEATURES_KHR,
#endif // VK_KHR_video_encode_intra_refresh
#if VK_KHR_video_encode_quantization_map
  eVideoEncodeQuantizationMapCapabilitiesKHR = VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_CAPABILITIES_KHR,
  eVideoFormatQuantizationMapPropertiesKHR = VK_STRUCTURE_TYPE_VIDEO_FORMAT_QUANTIZATION_MAP_PROPERTIES_KHR,
  eVideoEncodeQuantizationMapInfoKHR = VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_INFO_KHR,
  eVideoEncodeQuantizationMapSessionParametersCreateInfoKHR = VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_SESSION_PARAMETERS_CREATE_INFO_KHR,
  ePhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUANTIZATION_MAP_FEATURES_KHR,
  eVideoEncodeH264QuantizationMapCapabilitiesKHR = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUANTIZATION_MAP_CAPABILITIES_KHR,
  eVideoEncodeH265QuantizationMapCapabilitiesKHR = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUANTIZATION_MAP_CAPABILITIES_KHR,
  eVideoFormatH265QuantizationMapPropertiesKHR = VK_STRUCTURE_TYPE_VIDEO_FORMAT_H265_QUANTIZATION_MAP_PROPERTIES_KHR,
  eVideoEncodeAv1QuantizationMapCapabilitiesKHR = VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUANTIZATION_MAP_CAPABILITIES_KHR,
  eVideoFormatAv1QuantizationMapPropertiesKHR = VK_STRUCTURE_TYPE_VIDEO_FORMAT_AV1_QUANTIZATION_MAP_PROPERTIES_KHR,
#endif // VK_KHR_video_encode_quantization_map
#if VK_NV_raw_access_chains
  ePhysicalDeviceRawAccessChainsFeaturesNV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAW_ACCESS_CHAINS_FEATURES_NV,
#endif // VK_NV_raw_access_chains
#if VK_NV_external_compute_queue
  eExternalComputeQueueDeviceCreateInfoNV = VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_DEVICE_CREATE_INFO_NV,
  eExternalComputeQueueCreateInfoNV = VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_CREATE_INFO_NV,
  eExternalComputeQueueDataParamsNV = VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_DATA_PARAMS_NV,
  ePhysicalDeviceExternalComputeQueuePropertiesNV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_COMPUTE_QUEUE_PROPERTIES_NV,
#endif // VK_NV_external_compute_queue
#if VK_KHR_shader_relaxed_extended_instruction
  ePhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_RELAXED_EXTENDED_INSTRUCTION_FEATURES_KHR,
#endif // VK_KHR_shader_relaxed_extended_instruction
#if VK_NV_command_buffer_inheritance
  ePhysicalDeviceCommandBufferInheritanceFeaturesNV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMMAND_BUFFER_INHERITANCE_FEATURES_NV,
#endif // VK_NV_command_buffer_inheritance
#if VK_KHR_maintenance7
  ePhysicalDeviceMaintenance7FeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_FEATURES_KHR,
  ePhysicalDeviceMaintenance7PropertiesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_PROPERTIES_KHR,
  ePhysicalDeviceLayeredApiPropertiesListKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_LIST_KHR,
  ePhysicalDeviceLayeredApiPropertiesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_KHR,
  ePhysicalDeviceLayeredApiVulkanPropertiesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_VULKAN_PROPERTIES_KHR,
#endif // VK_KHR_maintenance7
#if VK_NV_shader_atomic_float16_vector
  ePhysicalDeviceShaderAtomicFloat16VectorFeaturesNV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT16_VECTOR_FEATURES_NV,
#endif // VK_NV_shader_atomic_float16_vector
#if VK_EXT_shader_replicated_composites
  ePhysicalDeviceShaderReplicatedCompositesFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_REPLICATED_COMPOSITES_FEATURES_EXT,
#endif // VK_EXT_shader_replicated_composites
#if VK_EXT_shader_float8
  ePhysicalDeviceShaderFloat8FeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT8_FEATURES_EXT,
#endif // VK_EXT_shader_float8
#if VK_NV_ray_tracing_validation
  ePhysicalDeviceRayTracingValidationFeaturesNV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_VALIDATION_FEATURES_NV,
#endif // VK_NV_ray_tracing_validation
#if VK_NV_cluster_acceleration_structure
  ePhysicalDeviceClusterAccelerationStructureFeaturesNV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_FEATURES_NV,
  ePhysicalDeviceClusterAccelerationStructurePropertiesNV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_PROPERTIES_NV,
  eClusterAccelerationStructureClustersBottomLevelInputNV = VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_CLUSTERS_BOTTOM_LEVEL_INPUT_NV,
  eClusterAccelerationStructureTriangleClusterInputNV = VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_TRIANGLE_CLUSTER_INPUT_NV,
  eClusterAccelerationStructureMoveObjectsInputNV = VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_MOVE_OBJECTS_INPUT_NV,
  eClusterAccelerationStructureInputInfoNV = VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_INPUT_INFO_NV,
  eClusterAccelerationStructureCommandsInfoNV = VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_COMMANDS_INFO_NV,
  eRayTracingPipelineClusterAccelerationStructureCreateInfoNV = VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CLUSTER_ACCELERATION_STRUCTURE_CREATE_INFO_NV,
#endif // VK_NV_cluster_acceleration_structure
#if VK_NV_partitioned_acceleration_structure
  ePhysicalDevicePartitionedAccelerationStructureFeaturesNV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_FEATURES_NV,
  ePhysicalDevicePartitionedAccelerationStructurePropertiesNV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_PROPERTIES_NV,
  eWriteDescriptorSetPartitionedAccelerationStructureNV = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_PARTITIONED_ACCELERATION_STRUCTURE_NV,
  ePartitionedAccelerationStructureInstancesInputNV = VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCES_INPUT_NV,
  eBuildPartitionedAccelerationStructureInfoNV = VK_STRUCTURE_TYPE_BUILD_PARTITIONED_ACCELERATION_STRUCTURE_INFO_NV,
  ePartitionedAccelerationStructureFlagsNV = VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_FLAGS_NV,
#endif // VK_NV_partitioned_acceleration_structure
#if VK_EXT_device_generated_commands
  ePhysicalDeviceDeviceGeneratedCommandsFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_EXT,
  ePhysicalDeviceDeviceGeneratedCommandsPropertiesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_EXT,
  eGeneratedCommandsMemoryRequirementsInfoEXT = VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_EXT,
  eIndirectExecutionSetCreateInfoEXT = VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_CREATE_INFO_EXT,
  eGeneratedCommandsInfoEXT = VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_EXT,
  eIndirectCommandsLayoutCreateInfoEXT = VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_EXT,
  eIndirectCommandsLayoutTokenEXT = VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_EXT,
  eWriteIndirectExecutionSetPipelineEXT = VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_PIPELINE_EXT,
  eWriteIndirectExecutionSetShaderEXT = VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_SHADER_EXT,
  eIndirectExecutionSetPipelineInfoEXT = VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_PIPELINE_INFO_EXT,
  eIndirectExecutionSetShaderInfoEXT = VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_INFO_EXT,
  eIndirectExecutionSetShaderLayoutInfoEXT = VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_LAYOUT_INFO_EXT,
  eGeneratedCommandsPipelineInfoEXT = VK_STRUCTURE_TYPE_GENERATED_COMMANDS_PIPELINE_INFO_EXT,
  eGeneratedCommandsShaderInfoEXT = VK_STRUCTURE_TYPE_GENERATED_COMMANDS_SHADER_INFO_EXT,
#endif // VK_EXT_device_generated_commands
#if VK_KHR_maintenance8
  ePhysicalDeviceMaintenance8FeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_8_FEATURES_KHR,
  eMemoryBarrierAccessFlags3KHR = VK_STRUCTURE_TYPE_MEMORY_BARRIER_ACCESS_FLAGS_3_KHR,
#endif // VK_KHR_maintenance8
#if VK_MESA_image_alignment_control
  ePhysicalDeviceImageAlignmentControlFeaturesMESA = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_FEATURES_MESA,
  ePhysicalDeviceImageAlignmentControlPropertiesMESA = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_PROPERTIES_MESA,
  eImageAlignmentControlCreateInfoMESA = VK_STRUCTURE_TYPE_IMAGE_ALIGNMENT_CONTROL_CREATE_INFO_MESA,
#endif // VK_MESA_image_alignment_control
#if VK_EXT_depth_clamp_control
  ePhysicalDeviceDepthClampControlFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_CONTROL_FEATURES_EXT,
  ePipelineViewportDepthClampControlCreateInfoEXT = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLAMP_CONTROL_CREATE_INFO_EXT,
#endif // VK_EXT_depth_clamp_control
#if VK_KHR_maintenance9
  ePhysicalDeviceMaintenance9FeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_FEATURES_KHR,
  ePhysicalDeviceMaintenance9PropertiesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_PROPERTIES_KHR,
  eQueueFamilyOwnershipTransferPropertiesKHR = VK_STRUCTURE_TYPE_QUEUE_FAMILY_OWNERSHIP_TRANSFER_PROPERTIES_KHR,
#endif // VK_KHR_maintenance9
#if VK_KHR_video_maintenance2
  ePhysicalDeviceVideoMaintenance2FeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_2_FEATURES_KHR,
  eVideoDecodeH264InlineSessionParametersInfoKHR = VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_INLINE_SESSION_PARAMETERS_INFO_KHR,
  eVideoDecodeH265InlineSessionParametersInfoKHR = VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_INLINE_SESSION_PARAMETERS_INFO_KHR,
  eVideoDecodeAv1InlineSessionParametersInfoKHR = VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_INLINE_SESSION_PARAMETERS_INFO_KHR,
#endif // VK_KHR_video_maintenance2
#if VK_OHOS_surface
  eOhSurfaceCreateInfoOHOS = VK_STRUCTURE_TYPE_OH_SURFACE_CREATE_INFO_OHOS,
#endif // VK_OHOS_surface
#if VK_HUAWEI_hdr_vivid
  ePhysicalDeviceHdrVividFeaturesHUAWEI = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HDR_VIVID_FEATURES_HUAWEI,
  eHdrVividDynamicMetadataHUAWEI = VK_STRUCTURE_TYPE_HDR_VIVID_DYNAMIC_METADATA_HUAWEI,
#endif // VK_HUAWEI_hdr_vivid
#if VK_NV_cooperative_matrix2
  ePhysicalDeviceCooperativeMatrix2FeaturesNV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_FEATURES_NV,
  eCooperativeMatrixFlexibleDimensionsPropertiesNV = VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_FLEXIBLE_DIMENSIONS_PROPERTIES_NV,
  ePhysicalDeviceCooperativeMatrix2PropertiesNV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_PROPERTIES_NV,
#endif // VK_NV_cooperative_matrix2
#if VK_ARM_pipeline_opacity_micromap
  ePhysicalDevicePipelineOpacityMicromapFeaturesARM = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_OPACITY_MICROMAP_FEATURES_ARM,
#endif // VK_ARM_pipeline_opacity_micromap
#if VK_EXT_external_memory_metal
  eImportMemoryMetalHandleInfoEXT = VK_STRUCTURE_TYPE_IMPORT_MEMORY_METAL_HANDLE_INFO_EXT,
  eMemoryMetalHandlePropertiesEXT = VK_STRUCTURE_TYPE_MEMORY_METAL_HANDLE_PROPERTIES_EXT,
  eMemoryGetMetalHandleInfoEXT = VK_STRUCTURE_TYPE_MEMORY_GET_METAL_HANDLE_INFO_EXT,
#endif // VK_EXT_external_memory_metal
#if VK_KHR_depth_clamp_zero_one
  ePhysicalDeviceDepthClampZeroOneFeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_KHR,
#endif // VK_KHR_depth_clamp_zero_one
#if VK_EXT_vertex_attribute_robustness
  ePhysicalDeviceVertexAttributeRobustnessFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_ROBUSTNESS_FEATURES_EXT,
#endif // VK_EXT_vertex_attribute_robustness
#if VK_ARM_format_pack
  ePhysicalDeviceFormatPackFeaturesARM = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FORMAT_PACK_FEATURES_ARM,
#endif // VK_ARM_format_pack
#if VK_VALVE_fragment_density_map_layered
  ePhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_FEATURES_VALVE,
  ePhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_PROPERTIES_VALVE,
  ePipelineFragmentDensityMapLayeredCreateInfoVALVE = VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_DENSITY_MAP_LAYERED_CREATE_INFO_VALVE,
#endif // VK_VALVE_fragment_density_map_layered
#if VK_KHR_robustness2
  ePhysicalDeviceRobustness2FeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_KHR,
  ePhysicalDeviceRobustness2PropertiesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_KHR,
#endif // VK_KHR_robustness2
#if VK_EXT_fragment_density_map_offset
  ePhysicalDeviceFragmentDensityMapOffsetFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_EXT,
  ePhysicalDeviceFragmentDensityMapOffsetPropertiesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_EXT,
  eRenderPassFragmentDensityMapOffsetEndInfoEXT = VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_EXT,
  eRenderingEndInfoEXT = VK_STRUCTURE_TYPE_RENDERING_END_INFO_EXT,
#endif // VK_EXT_fragment_density_map_offset
#if VK_EXT_zero_initialize_device_memory
  ePhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_DEVICE_MEMORY_FEATURES_EXT,
#endif // VK_EXT_zero_initialize_device_memory
#if VK_KHR_present_mode_fifo_latest_ready
  ePhysicalDevicePresentModeFifoLatestReadyFeaturesKHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_KHR,
#endif // VK_KHR_present_mode_fifo_latest_ready
#if VK_SEC_pipeline_cache_incremental_mode
  ePhysicalDevicePipelineCacheIncrementalModeFeaturesSEC = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CACHE_INCREMENTAL_MODE_FEATURES_SEC,
#endif // VK_SEC_pipeline_cache_incremental_mode
};

enum class SubpassContents : int32_t {
  eInline = VK_SUBPASS_CONTENTS_INLINE,
  eSecondaryCommandBuffers = VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS,
#if VK_EXT_nested_command_buffer
  eInlineAndSecondaryCommandBuffersEXT = VK_SUBPASS_CONTENTS_INLINE_AND_SECONDARY_COMMAND_BUFFERS_EXT,
#endif // VK_EXT_nested_command_buffer
#if VK_KHR_maintenance7
  eInlineAndSecondaryCommandBuffersKHR = VK_SUBPASS_CONTENTS_INLINE_AND_SECONDARY_COMMAND_BUFFERS_KHR,
#endif // VK_KHR_maintenance7
};

// API result codes
enum class Result : int32_t {
  // Command completed successfully
  eSuccess = VK_SUCCESS,
  // A fence or query has not yet completed
  eNotReady = VK_NOT_READY,
  // A wait operation has not completed in the specified time
  eTimeout = VK_TIMEOUT,
  // An event is signaled
  eEventSet = VK_EVENT_SET,
  // An event is unsignaled
  eEventReset = VK_EVENT_RESET,
  // A return array was too small for the result
  eIncomplete = VK_INCOMPLETE,
  // A host memory allocation has failed
  eErrorOutOfHostMemory = VK_ERROR_OUT_OF_HOST_MEMORY,
  // A device memory allocation has failed
  eErrorOutOfDeviceMemory = VK_ERROR_OUT_OF_DEVICE_MEMORY,
  // Initialization of an object has failed
  eErrorInitializationFailed = VK_ERROR_INITIALIZATION_FAILED,
  // The logical device has been lost. See <<devsandqueues-lost-device>>
  eErrorDeviceLost = VK_ERROR_DEVICE_LOST,
  // Mapping of a memory object has failed
  eErrorMemoryMapFailed = VK_ERROR_MEMORY_MAP_FAILED,
  // Layer specified does not exist
  eErrorLayerNotPresent = VK_ERROR_LAYER_NOT_PRESENT,
  // Extension specified does not exist
  eErrorExtensionNotPresent = VK_ERROR_EXTENSION_NOT_PRESENT,
  // Requested feature is not available on this device
  eErrorFeatureNotPresent = VK_ERROR_FEATURE_NOT_PRESENT,
  // Unable to find a Vulkan driver
  eErrorIncompatibleDriver = VK_ERROR_INCOMPATIBLE_DRIVER,
  // Too many objects of the type have already been created
  eErrorTooManyObjects = VK_ERROR_TOO_MANY_OBJECTS,
  // Requested format is not supported on this device
  eErrorFormatNotSupported = VK_ERROR_FORMAT_NOT_SUPPORTED,
  // A requested pool allocation has failed due to fragmentation of the pool's memory
  eErrorFragmentedPool = VK_ERROR_FRAGMENTED_POOL,
  // An unknown error has occurred, due to an implementation or application bug
  eErrorUnknown = VK_ERROR_UNKNOWN,
#if VK_VERSION_1_1
  eErrorOutOfPoolMemory = VK_ERROR_OUT_OF_POOL_MEMORY,
  eErrorInvalidExternalHandle = VK_ERROR_INVALID_EXTERNAL_HANDLE,
#endif // VK_VERSION_1_1
#if VK_VERSION_1_2
  eErrorFragmentation = VK_ERROR_FRAGMENTATION,
  eErrorInvalidOpaqueCaptureAddress = VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS,
#endif // VK_VERSION_1_2
#if VK_VERSION_1_3
  ePipelineCompileRequired = VK_PIPELINE_COMPILE_REQUIRED,
#endif // VK_VERSION_1_3
#if VK_VERSION_1_4
  eErrorNotPermitted = VK_ERROR_NOT_PERMITTED,
#endif // VK_VERSION_1_4
#if VK_KHR_surface
  eErrorSurfaceLostKHR = VK_ERROR_SURFACE_LOST_KHR,
  eErrorNativeWindowInUseKHR = VK_ERROR_NATIVE_WINDOW_IN_USE_KHR,
#endif // VK_KHR_surface
#if VK_KHR_swapchain
  eSuboptimalKHR = VK_SUBOPTIMAL_KHR,
  eErrorOutOfDateKHR = VK_ERROR_OUT_OF_DATE_KHR,
#endif // VK_KHR_swapchain
#if VK_KHR_display_swapchain
  eErrorIncompatibleDisplayKHR = VK_ERROR_INCOMPATIBLE_DISPLAY_KHR,
#endif // VK_KHR_display_swapchain
#if VK_KHR_video_queue
  eErrorImageUsageNotSupportedKHR = VK_ERROR_IMAGE_USAGE_NOT_SUPPORTED_KHR,
  eErrorVideoPictureLayoutNotSupportedKHR = VK_ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR,
  eErrorVideoProfileOperationNotSupportedKHR = VK_ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR,
  eErrorVideoProfileFormatNotSupportedKHR = VK_ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR,
  eErrorVideoProfileCodecNotSupportedKHR = VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR,
  eErrorVideoStdVersionNotSupportedKHR = VK_ERROR_VIDEO_STD_VERSION_NOT_SUPPORTED_KHR,
#endif // VK_KHR_video_queue
#if VK_KHR_maintenance1
  eErrorOutOfPoolMemoryKHR = VK_ERROR_OUT_OF_POOL_MEMORY_KHR,
#endif // VK_KHR_maintenance1
#if VK_KHR_external_memory
  eErrorInvalidExternalHandleKHR = VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR,
#endif // VK_KHR_external_memory
#if VK_EXT_image_drm_format_modifier
  eErrorInvalidDrmFormatModifierPlaneLayoutEXT = VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT,
#endif // VK_EXT_image_drm_format_modifier
#if VK_EXT_descriptor_indexing
  eErrorFragmentationEXT = VK_ERROR_FRAGMENTATION_EXT,
#endif // VK_EXT_descriptor_indexing
#if VK_EXT_global_priority
  eErrorNotPermittedEXT = VK_ERROR_NOT_PERMITTED_EXT,
#endif // VK_EXT_global_priority
#if VK_KHR_global_priority
  eErrorNotPermittedKHR = VK_ERROR_NOT_PERMITTED_KHR,
#endif // VK_KHR_global_priority
#if VK_EXT_full_screen_exclusive
  eErrorFullScreenExclusiveModeLostEXT = VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT,
#endif // VK_EXT_full_screen_exclusive
#if VK_KHR_buffer_device_address
  eErrorInvalidOpaqueCaptureAddressKHR = VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR,
#endif // VK_KHR_buffer_device_address
#if VK_KHR_deferred_host_operations
  eThreadIdleKHR = VK_THREAD_IDLE_KHR,
  eThreadDoneKHR = VK_THREAD_DONE_KHR,
  eOperationDeferredKHR = VK_OPERATION_DEFERRED_KHR,
  eOperationNotDeferredKHR = VK_OPERATION_NOT_DEFERRED_KHR,
#endif // VK_KHR_deferred_host_operations
#if VK_EXT_pipeline_creation_cache_control
  ePipelineCompileRequiredEXT = VK_PIPELINE_COMPILE_REQUIRED_EXT,
  eErrorPipelineCompileRequiredEXT = VK_ERROR_PIPELINE_COMPILE_REQUIRED_EXT,
#endif // VK_EXT_pipeline_creation_cache_control
#if VK_KHR_video_encode_queue
  eErrorInvalidVideoStdParametersKHR = VK_ERROR_INVALID_VIDEO_STD_PARAMETERS_KHR,
#endif // VK_KHR_video_encode_queue
#if VK_EXT_image_compression_control
  eErrorCompressionExhaustedEXT = VK_ERROR_COMPRESSION_EXHAUSTED_EXT,
#endif // VK_EXT_image_compression_control
#if VK_EXT_shader_object
  eIncompatibleShaderBinaryEXT = VK_INCOMPATIBLE_SHADER_BINARY_EXT,
#endif // VK_EXT_shader_object
#if VK_KHR_pipeline_binary
  ePipelineBinaryMissingKHR = VK_PIPELINE_BINARY_MISSING_KHR,
  eErrorNotEnoughSpaceKHR = VK_ERROR_NOT_ENOUGH_SPACE_KHR,
#endif // VK_KHR_pipeline_binary
};

inline const char* getResultText(Result r) noexcept {
  using enum Result;
  switch (r) {
  case eSuccess: return "Success";
  case eNotReady: return "NotReady";
  case eTimeout: return "Timeout";
  case eEventSet: return "EventSet";
  case eEventReset: return "EventReset";
  case eIncomplete: return "Incomplete";
  case eErrorOutOfHostMemory: return "ErrorOutOfHostMemory";
  case eErrorOutOfDeviceMemory: return "ErrorOutOfDeviceMemory";
  case eErrorInitializationFailed: return "ErrorInitializationFailed";
  case eErrorDeviceLost: return "ErrorDeviceLost";
  case eErrorMemoryMapFailed: return "ErrorMemoryMapFailed";
  case eErrorLayerNotPresent: return "ErrorLayerNotPresent";
  case eErrorExtensionNotPresent: return "ErrorExtensionNotPresent";
  case eErrorFeatureNotPresent: return "ErrorFeatureNotPresent";
  case eErrorIncompatibleDriver: return "ErrorIncompatibleDriver";
  case eErrorTooManyObjects: return "ErrorTooManyObjects";
  case eErrorFormatNotSupported: return "ErrorFormatNotSupported";
  case eErrorFragmentedPool: return "ErrorFragmentedPool";
  case eErrorUnknown: return "ErrorUnknown";
#if VK_VERSION_1_1
  case eErrorOutOfPoolMemory: return "ErrorOutOfPoolMemory";
  case eErrorInvalidExternalHandle: return "ErrorInvalidExternalHandle";
#endif // VK_VERSION_1_1
#if VK_VERSION_1_2
  case eErrorFragmentation: return "ErrorFragmentation";
  case eErrorInvalidOpaqueCaptureAddress: return "ErrorInvalidOpaqueCaptureAddress";
#endif // VK_VERSION_1_2
#if VK_VERSION_1_3
  case ePipelineCompileRequired: return "PipelineCompileRequired";
#endif // VK_VERSION_1_3
#if VK_VERSION_1_4
  case eErrorNotPermitted: return "ErrorNotPermitted";
#endif // VK_VERSION_1_4
#if VK_KHR_surface
  case eErrorSurfaceLostKHR: return "ErrorSurfaceLostKHR";
  case eErrorNativeWindowInUseKHR: return "ErrorNativeWindowInUseKHR";
#endif // VK_KHR_surface
#if VK_KHR_swapchain
  case eSuboptimalKHR: return "SuboptimalKHR";
  case eErrorOutOfDateKHR: return "ErrorOutOfDateKHR";
#endif // VK_KHR_swapchain
#if VK_KHR_display_swapchain
  case eErrorIncompatibleDisplayKHR: return "ErrorIncompatibleDisplayKHR";
#endif // VK_KHR_display_swapchain
#if VK_KHR_video_queue
  case eErrorImageUsageNotSupportedKHR: return "ErrorImageUsageNotSupportedKHR";
  case eErrorVideoPictureLayoutNotSupportedKHR: return "ErrorVideoPictureLayoutNotSupportedKHR";
  case eErrorVideoProfileOperationNotSupportedKHR: return "ErrorVideoProfileOperationNotSupportedKHR";
  case eErrorVideoProfileFormatNotSupportedKHR: return "ErrorVideoProfileFormatNotSupportedKHR";
  case eErrorVideoProfileCodecNotSupportedKHR: return "ErrorVideoProfileCodecNotSupportedKHR";
  case eErrorVideoStdVersionNotSupportedKHR: return "ErrorVideoStdVersionNotSupportedKHR";
#endif // VK_KHR_video_queue
#if VK_EXT_image_drm_format_modifier
  case eErrorInvalidDrmFormatModifierPlaneLayoutEXT: return "ErrorInvalidDrmFormatModifierPlaneLayoutEXT";
#endif // VK_EXT_image_drm_format_modifier
#if VK_EXT_full_screen_exclusive
  case eErrorFullScreenExclusiveModeLostEXT: return "ErrorFullScreenExclusiveModeLostEXT";
#endif // VK_EXT_full_screen_exclusive
#if VK_KHR_deferred_host_operations
  case eThreadIdleKHR: return "ThreadIdleKHR";
  case eThreadDoneKHR: return "ThreadDoneKHR";
  case eOperationDeferredKHR: return "OperationDeferredKHR";
  case eOperationNotDeferredKHR: return "OperationNotDeferredKHR";
#endif // VK_KHR_deferred_host_operations
#if VK_KHR_video_encode_queue
  case eErrorInvalidVideoStdParametersKHR: return "ErrorInvalidVideoStdParametersKHR";
#endif // VK_KHR_video_encode_queue
#if VK_EXT_image_compression_control
  case eErrorCompressionExhaustedEXT: return "ErrorCompressionExhaustedEXT";
#endif // VK_EXT_image_compression_control
#if VK_EXT_shader_object
  case eIncompatibleShaderBinaryEXT: return "IncompatibleShaderBinaryEXT";
#endif // VK_EXT_shader_object
#if VK_KHR_pipeline_binary
  case ePipelineBinaryMissingKHR: return "PipelineBinaryMissingKHR";
  case eErrorNotEnoughSpaceKHR: return "ErrorNotEnoughSpaceKHR";
#endif // VK_KHR_pipeline_binary
  default: return "";
  }
}

enum class DynamicState : int32_t {
  eViewport = VK_DYNAMIC_STATE_VIEWPORT,
  eScissor = VK_DYNAMIC_STATE_SCISSOR,
  eLineWidth = VK_DYNAMIC_STATE_LINE_WIDTH,
  eDepthBias = VK_DYNAMIC_STATE_DEPTH_BIAS,
  eBlendConstants = VK_DYNAMIC_STATE_BLEND_CONSTANTS,
  eDepthBounds = VK_DYNAMIC_STATE_DEPTH_BOUNDS,
  eStencilCompareMask = VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK,
  eStencilWriteMask = VK_DYNAMIC_STATE_STENCIL_WRITE_MASK,
  eStencilReference = VK_DYNAMIC_STATE_STENCIL_REFERENCE,
#if VK_VERSION_1_3
  eCullMode = VK_DYNAMIC_STATE_CULL_MODE,
  eFrontFace = VK_DYNAMIC_STATE_FRONT_FACE,
  ePrimitiveTopology = VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY,
  eViewportWithCount = VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT,
  eScissorWithCount = VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT,
  eVertexInputBindingStride = VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE,
  eDepthTestEnable = VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE,
  eDepthWriteEnable = VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE,
  eDepthCompareOp = VK_DYNAMIC_STATE_DEPTH_COMPARE_OP,
  eDepthBoundsTestEnable = VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE,
  eStencilTestEnable = VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE,
  eStencilOp = VK_DYNAMIC_STATE_STENCIL_OP,
  eRasterizerDiscardEnable = VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE,
  eDepthBiasEnable = VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE,
  ePrimitiveRestartEnable = VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE,
#endif // VK_VERSION_1_3
#if VK_VERSION_1_4
  eLineStipple = VK_DYNAMIC_STATE_LINE_STIPPLE,
#endif // VK_VERSION_1_4
#if VK_NV_clip_space_w_scaling
  eViewportWScalingNV = VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV,
#endif // VK_NV_clip_space_w_scaling
#if VK_EXT_discard_rectangles
  eDiscardRectangleEXT = VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT,
  eDiscardRectangleEnableEXT = VK_DYNAMIC_STATE_DISCARD_RECTANGLE_ENABLE_EXT,
  eDiscardRectangleModeEXT = VK_DYNAMIC_STATE_DISCARD_RECTANGLE_MODE_EXT,
#endif // VK_EXT_discard_rectangles
#if VK_EXT_sample_locations
  eSampleLocationsEXT = VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT,
#endif // VK_EXT_sample_locations
#if VK_KHR_ray_tracing_pipeline
  eRayTracingPipelineStackSizeKHR = VK_DYNAMIC_STATE_RAY_TRACING_PIPELINE_STACK_SIZE_KHR,
#endif // VK_KHR_ray_tracing_pipeline
#if VK_NV_shading_rate_image
  eViewportShadingRatePaletteNV = VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV,
  eViewportCoarseSampleOrderNV = VK_DYNAMIC_STATE_VIEWPORT_COARSE_SAMPLE_ORDER_NV,
#endif // VK_NV_shading_rate_image
#if VK_NV_scissor_exclusive
  eExclusiveScissorEnableNV = VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_ENABLE_NV,
  eExclusiveScissorNV = VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV,
#endif // VK_NV_scissor_exclusive
#if VK_KHR_fragment_shading_rate
  eFragmentShadingRateKHR = VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR,
#endif // VK_KHR_fragment_shading_rate
#if VK_EXT_line_rasterization
  eLineStippleEXT = VK_DYNAMIC_STATE_LINE_STIPPLE_EXT,
#endif // VK_EXT_line_rasterization
#if VK_EXT_extended_dynamic_state
  eCullModeEXT = VK_DYNAMIC_STATE_CULL_MODE_EXT,
  eFrontFaceEXT = VK_DYNAMIC_STATE_FRONT_FACE_EXT,
  ePrimitiveTopologyEXT = VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY_EXT,
  eViewportWithCountEXT = VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT_EXT,
  eScissorWithCountEXT = VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT_EXT,
  eVertexInputBindingStrideEXT = VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT,
  eDepthTestEnableEXT = VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE_EXT,
  eDepthWriteEnableEXT = VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE_EXT,
  eDepthCompareOpEXT = VK_DYNAMIC_STATE_DEPTH_COMPARE_OP_EXT,
  eDepthBoundsTestEnableEXT = VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE_EXT,
  eStencilTestEnableEXT = VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE_EXT,
  eStencilOpEXT = VK_DYNAMIC_STATE_STENCIL_OP_EXT,
#endif // VK_EXT_extended_dynamic_state
#if VK_EXT_vertex_input_dynamic_state
  eVertexInputEXT = VK_DYNAMIC_STATE_VERTEX_INPUT_EXT,
#endif // VK_EXT_vertex_input_dynamic_state
#if VK_EXT_extended_dynamic_state2
  // Not promoted to 1.3
  ePatchControlPointsEXT = VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT,
  eRasterizerDiscardEnableEXT = VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE_EXT,
  eDepthBiasEnableEXT = VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE_EXT,
  // Not promoted to 1.3
  eLogicOpEXT = VK_DYNAMIC_STATE_LOGIC_OP_EXT,
  ePrimitiveRestartEnableEXT = VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE_EXT,
#endif // VK_EXT_extended_dynamic_state2
#if VK_EXT_color_write_enable
  eColorWriteEnableEXT = VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT,
#endif // VK_EXT_color_write_enable
#if VK_EXT_extended_dynamic_state3
  eDepthClampEnableEXT = VK_DYNAMIC_STATE_DEPTH_CLAMP_ENABLE_EXT,
  ePolygonModeEXT = VK_DYNAMIC_STATE_POLYGON_MODE_EXT,
  eRasterizationSamplesEXT = VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT,
  eSampleMaskEXT = VK_DYNAMIC_STATE_SAMPLE_MASK_EXT,
  eAlphaToCoverageEnableEXT = VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT,
  eAlphaToOneEnableEXT = VK_DYNAMIC_STATE_ALPHA_TO_ONE_ENABLE_EXT,
  eLogicOpEnableEXT = VK_DYNAMIC_STATE_LOGIC_OP_ENABLE_EXT,
  eColorBlendEnableEXT = VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT,
  eColorBlendEquationEXT = VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT,
  eColorWriteMaskEXT = VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT,
  eTessellationDomainOriginEXT = VK_DYNAMIC_STATE_TESSELLATION_DOMAIN_ORIGIN_EXT,
  eRasterizationStreamEXT = VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT,
  eConservativeRasterizationModeEXT = VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT,
  eExtraPrimitiveOverestimationSizeEXT = VK_DYNAMIC_STATE_EXTRA_PRIMITIVE_OVERESTIMATION_SIZE_EXT,
  eDepthClipEnableEXT = VK_DYNAMIC_STATE_DEPTH_CLIP_ENABLE_EXT,
  eSampleLocationsEnableEXT = VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT,
  eColorBlendAdvancedEXT = VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT,
  eProvokingVertexModeEXT = VK_DYNAMIC_STATE_PROVOKING_VERTEX_MODE_EXT,
  eLineRasterizationModeEXT = VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT,
  eLineStippleEnableEXT = VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT,
  eDepthClipNegativeOneToOneEXT = VK_DYNAMIC_STATE_DEPTH_CLIP_NEGATIVE_ONE_TO_ONE_EXT,
  eViewportWScalingEnableNV = VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_ENABLE_NV,
  eViewportSwizzleNV = VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV,
  eCoverageToColorEnableNV = VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV,
  eCoverageToColorLocationNV = VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_LOCATION_NV,
  eCoverageModulationModeNV = VK_DYNAMIC_STATE_COVERAGE_MODULATION_MODE_NV,
  eCoverageModulationTableEnableNV = VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV,
  eCoverageModulationTableNV = VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_NV,
  eShadingRateImageEnableNV = VK_DYNAMIC_STATE_SHADING_RATE_IMAGE_ENABLE_NV,
  eRepresentativeFragmentTestEnableNV = VK_DYNAMIC_STATE_REPRESENTATIVE_FRAGMENT_TEST_ENABLE_NV,
  eCoverageReductionModeNV = VK_DYNAMIC_STATE_COVERAGE_REDUCTION_MODE_NV,
#endif // VK_EXT_extended_dynamic_state3
#if VK_EXT_attachment_feedback_loop_dynamic_state
  eAttachmentFeedbackLoopEnableEXT = VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT,
#endif // VK_EXT_attachment_feedback_loop_dynamic_state
#if VK_KHR_line_rasterization
  eLineStippleKHR = VK_DYNAMIC_STATE_LINE_STIPPLE_KHR,
#endif // VK_KHR_line_rasterization
#if VK_EXT_depth_clamp_control
  eDepthClampRangeEXT = VK_DYNAMIC_STATE_DEPTH_CLAMP_RANGE_EXT,
#endif // VK_EXT_depth_clamp_control
};
#endif // VK_VERSION_1_0

#if VK_VERSION_1_1
enum class DescriptorUpdateTemplateType : int32_t {
  // Create descriptor update template for descriptor set updates
  eDescriptorSet = VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET,
#if VK_VERSION_1_4
  ePushDescriptors = VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS,
#endif // VK_VERSION_1_4
#if VK_KHR_descriptor_update_template
  eDescriptorSetKHR = VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR,
  // Create descriptor update template for pushed descriptor updates
  ePushDescriptorsKHR = VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR,
#endif // VK_KHR_descriptor_update_template
};
#endif // VK_VERSION_1_1

#if VK_VERSION_1_0
// Enums to track objects of various types - also see objtypeenum attributes on type tags
enum class ObjectType : int32_t {
  eUnknown = VK_OBJECT_TYPE_UNKNOWN,
  eInstance = VK_OBJECT_TYPE_INSTANCE,
  ePhysicalDevice = VK_OBJECT_TYPE_PHYSICAL_DEVICE,
  eDevice = VK_OBJECT_TYPE_DEVICE,
  eQueue = VK_OBJECT_TYPE_QUEUE,
  eSemaphore = VK_OBJECT_TYPE_SEMAPHORE,
  eCommandBuffer = VK_OBJECT_TYPE_COMMAND_BUFFER,
  eFence = VK_OBJECT_TYPE_FENCE,
  eDeviceMemory = VK_OBJECT_TYPE_DEVICE_MEMORY,
  eBuffer = VK_OBJECT_TYPE_BUFFER,
  eImage = VK_OBJECT_TYPE_IMAGE,
  eEvent = VK_OBJECT_TYPE_EVENT,
  eQueryPool = VK_OBJECT_TYPE_QUERY_POOL,
  eBufferView = VK_OBJECT_TYPE_BUFFER_VIEW,
  eImageView = VK_OBJECT_TYPE_IMAGE_VIEW,
  eShaderModule = VK_OBJECT_TYPE_SHADER_MODULE,
  ePipelineCache = VK_OBJECT_TYPE_PIPELINE_CACHE,
  ePipelineLayout = VK_OBJECT_TYPE_PIPELINE_LAYOUT,
  eRenderPass = VK_OBJECT_TYPE_RENDER_PASS,
  ePipeline = VK_OBJECT_TYPE_PIPELINE,
  eDescriptorSetLayout = VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT,
  eSampler = VK_OBJECT_TYPE_SAMPLER,
  eDescriptorPool = VK_OBJECT_TYPE_DESCRIPTOR_POOL,
  eDescriptorSet = VK_OBJECT_TYPE_DESCRIPTOR_SET,
  eFramebuffer = VK_OBJECT_TYPE_FRAMEBUFFER,
  eCommandPool = VK_OBJECT_TYPE_COMMAND_POOL,
#if VK_VERSION_1_1
  eSamplerYcbcrConversion = VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION,
  eDescriptorUpdateTemplate = VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE,
#endif // VK_VERSION_1_1
#if VK_VERSION_1_3
  ePrivateDataSlot = VK_OBJECT_TYPE_PRIVATE_DATA_SLOT,
#endif // VK_VERSION_1_3
#if VK_KHR_surface
  eSurfaceKHR = VK_OBJECT_TYPE_SURFACE_KHR,
#endif // VK_KHR_surface
#if VK_KHR_swapchain
  eSwapchainKHR = VK_OBJECT_TYPE_SWAPCHAIN_KHR,
#endif // VK_KHR_swapchain
#if VK_KHR_display
  eDisplayKHR = VK_OBJECT_TYPE_DISPLAY_KHR,
  eDisplayModeKHR = VK_OBJECT_TYPE_DISPLAY_MODE_KHR,
#endif // VK_KHR_display
#if VK_KHR_video_queue
  // VkVideoSessionKHR
  eVideoSessionKHR = VK_OBJECT_TYPE_VIDEO_SESSION_KHR,
  // VkVideoSessionParametersKHR
  eVideoSessionParametersKHR = VK_OBJECT_TYPE_VIDEO_SESSION_PARAMETERS_KHR,
#endif // VK_KHR_video_queue
#if VK_NVX_binary_import
  eCuModuleNVX = VK_OBJECT_TYPE_CU_MODULE_NVX,
  eCuFunctionNVX = VK_OBJECT_TYPE_CU_FUNCTION_NVX,
#endif // VK_NVX_binary_import
#if VK_KHR_descriptor_update_template
  eDescriptorUpdateTemplateKHR = VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR,
#endif // VK_KHR_descriptor_update_template
#if VK_EXT_debug_utils
  eDebugUtilsMessengerEXT = VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT,
#endif // VK_EXT_debug_utils
#if VK_KHR_acceleration_structure
  eAccelerationStructureKHR = VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR,
#endif // VK_KHR_acceleration_structure
#if VK_KHR_sampler_ycbcr_conversion
  eSamplerYcbcrConversionKHR = VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR,
#endif // VK_KHR_sampler_ycbcr_conversion
#if VK_EXT_validation_cache
  eValidationCacheEXT = VK_OBJECT_TYPE_VALIDATION_CACHE_EXT,
#endif // VK_EXT_validation_cache
#if VK_INTEL_performance_query
  ePerformanceConfigurationINTEL = VK_OBJECT_TYPE_PERFORMANCE_CONFIGURATION_INTEL,
#endif // VK_INTEL_performance_query
#if VK_KHR_deferred_host_operations
  eDeferredOperationKHR = VK_OBJECT_TYPE_DEFERRED_OPERATION_KHR,
#endif // VK_KHR_deferred_host_operations
#if VK_NV_device_generated_commands
  eIndirectCommandsLayoutNV = VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NV,
#endif // VK_NV_device_generated_commands
#if VK_EXT_private_data
  ePrivateDataSlotEXT = VK_OBJECT_TYPE_PRIVATE_DATA_SLOT_EXT,
#endif // VK_EXT_private_data
#if VK_FUCHSIA_buffer_collection
  // VkBufferCollectionFUCHSIA
  eBufferCollectionFUCHSIA = VK_OBJECT_TYPE_BUFFER_COLLECTION_FUCHSIA,
#endif // VK_FUCHSIA_buffer_collection
#if VK_EXT_opacity_micromap
  eMicromapEXT = VK_OBJECT_TYPE_MICROMAP_EXT,
#endif // VK_EXT_opacity_micromap
#if VK_ARM_tensors
  eTensorARM = VK_OBJECT_TYPE_TENSOR_ARM,
  eTensorViewARM = VK_OBJECT_TYPE_TENSOR_VIEW_ARM,
#endif // VK_ARM_tensors
#if VK_NV_optical_flow
  eOpticalFlowSessionNV = VK_OBJECT_TYPE_OPTICAL_FLOW_SESSION_NV,
#endif // VK_NV_optical_flow
#if VK_EXT_shader_object
  eShaderEXT = VK_OBJECT_TYPE_SHADER_EXT,
#endif // VK_EXT_shader_object
#if VK_KHR_pipeline_binary
  ePipelineBinaryKHR = VK_OBJECT_TYPE_PIPELINE_BINARY_KHR,
#endif // VK_KHR_pipeline_binary
#if VK_ARM_data_graph
  eDataGraphPipelineSessionARM = VK_OBJECT_TYPE_DATA_GRAPH_PIPELINE_SESSION_ARM,
#endif // VK_ARM_data_graph
#if VK_NV_external_compute_queue
  eExternalComputeQueueNV = VK_OBJECT_TYPE_EXTERNAL_COMPUTE_QUEUE_NV,
#endif // VK_NV_external_compute_queue
#if VK_EXT_device_generated_commands
  eIndirectCommandsLayoutEXT = VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_EXT,
  eIndirectExecutionSetEXT = VK_OBJECT_TYPE_INDIRECT_EXECUTION_SET_EXT,
#endif // VK_EXT_device_generated_commands
};
#endif // VK_VERSION_1_0

#if VK_NV_ray_tracing_invocation_reorder
enum class RayTracingInvocationReorderModeNV : int32_t {
  eNone = VK_RAY_TRACING_INVOCATION_REORDER_MODE_NONE_NV,
  eReorder = VK_RAY_TRACING_INVOCATION_REORDER_MODE_REORDER_NV,
};
#endif // VK_NV_ray_tracing_invocation_reorder

#if VK_NV_ray_tracing_linear_swept_spheres
enum class RayTracingLssIndexingModeNV : int32_t {
  eList = VK_RAY_TRACING_LSS_INDEXING_MODE_LIST_NV,
  eSuccessive = VK_RAY_TRACING_LSS_INDEXING_MODE_SUCCESSIVE_NV,
};

enum class RayTracingLssPrimitiveEndCapsModeNV : int32_t {
  eNone = VK_RAY_TRACING_LSS_PRIMITIVE_END_CAPS_MODE_NONE_NV,
  eChained = VK_RAY_TRACING_LSS_PRIMITIVE_END_CAPS_MODE_CHAINED_NV,
};
#endif // VK_NV_ray_tracing_linear_swept_spheres

#if VK_LUNARG_direct_driver_loading
enum class DirectDriverLoadingModeLUNARG : int32_t {
  eExclusive = VK_DIRECT_DRIVER_LOADING_MODE_EXCLUSIVE_LUNARG,
  eInclusive = VK_DIRECT_DRIVER_LOADING_MODE_INCLUSIVE_LUNARG,
};
#endif // VK_LUNARG_direct_driver_loading

#if VK_AMD_anti_lag
enum class AntiLagModeAMD : int32_t {
  eDriverControl = VK_ANTI_LAG_MODE_DRIVER_CONTROL_AMD,
  eOn = VK_ANTI_LAG_MODE_ON_AMD,
  eOff = VK_ANTI_LAG_MODE_OFF_AMD,
};

enum class AntiLagStageAMD : int32_t {
  eInput = VK_ANTI_LAG_STAGE_INPUT_AMD,
  ePresent = VK_ANTI_LAG_STAGE_PRESENT_AMD,
};
#endif // VK_AMD_anti_lag

#if VK_VERSION_1_0
enum class QueueFlagBits : uint32_t {
  // Queue supports graphics operations
  bGraphics = VK_QUEUE_GRAPHICS_BIT,
  // Queue supports compute operations
  bCompute = VK_QUEUE_COMPUTE_BIT,
  // Queue supports transfer operations
  bTransfer = VK_QUEUE_TRANSFER_BIT,
  // Queue supports sparse resource memory management operations
  bSparseBinding = VK_QUEUE_SPARSE_BINDING_BIT,
#if VK_VERSION_1_1
  // Queues may support protected operations
  bProtected = VK_QUEUE_PROTECTED_BIT,
#endif // VK_VERSION_1_1
#if VK_KHR_video_decode_queue
  bVideoDecodeKHR = VK_QUEUE_VIDEO_DECODE_BIT_KHR,
#endif // VK_KHR_video_decode_queue
#if VK_KHR_video_encode_queue
  bVideoEncodeKHR = VK_QUEUE_VIDEO_ENCODE_BIT_KHR,
#endif // VK_KHR_video_encode_queue
#if VK_NV_optical_flow
  bOpticalFlowNV = VK_QUEUE_OPTICAL_FLOW_BIT_NV,
#endif // VK_NV_optical_flow
#if VK_ARM_data_graph
  bDataGraphARM = VK_QUEUE_DATA_GRAPH_BIT_ARM,
#endif // VK_ARM_data_graph
};

enum class CullModeFlagBits : uint32_t {
  eNone = VK_CULL_MODE_NONE,
  bFront = VK_CULL_MODE_FRONT_BIT,
  bBack = VK_CULL_MODE_BACK_BIT,
  eFrontAndBack = VK_CULL_MODE_FRONT_AND_BACK,
};

enum class RenderPassCreateFlagBits : uint32_t {
#if VK_QCOM_render_pass_transform
  bTransformQCOM = VK_RENDER_PASS_CREATE_TRANSFORM_BIT_QCOM,
#endif // VK_QCOM_render_pass_transform
#if VK_VALVE_fragment_density_map_layered
  bPerLayerFragmentDensityVALVE = VK_RENDER_PASS_CREATE_PER_LAYER_FRAGMENT_DENSITY_BIT_VALVE,
#endif // VK_VALVE_fragment_density_map_layered
};
#endif // VK_VERSION_1_0

#if VK_VERSION_1_1
enum class DeviceQueueCreateFlagBits : uint32_t {
#if VK_VERSION_1_1
  // Queue is a protected-capable device queue
  bProtected = VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT,
#endif // VK_VERSION_1_1
};
#endif // VK_VERSION_1_1

#if VK_VERSION_1_0
enum class MemoryPropertyFlagBits : uint32_t {
  // If otherwise stated, then allocate memory on device
  bDeviceLocal = VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT,
  // Memory is mappable by host
  bHostVisible = VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT,
  // Memory will have i/o coherency. If not set, application may need to use vkFlushMappedMemoryRanges and vkInvalidateMappedMemoryRanges to flush/invalidate host cache
  bHostCoherent = VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,
  // Memory will be cached by the host
  bHostCached = VK_MEMORY_PROPERTY_HOST_CACHED_BIT,
  // Memory may be allocated by the driver when it is required
  bLazilyAllocated = VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT,
#if VK_VERSION_1_1
  // Memory is protected
  bProtected = VK_MEMORY_PROPERTY_PROTECTED_BIT,
#endif // VK_VERSION_1_1
#if VK_AMD_device_coherent_memory
  bDeviceCoherentAMD = VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD,
  bDeviceUncachedAMD = VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD,
#endif // VK_AMD_device_coherent_memory
#if VK_NV_external_memory_rdma
  bRdmaCapableNV = VK_MEMORY_PROPERTY_RDMA_CAPABLE_BIT_NV,
#endif // VK_NV_external_memory_rdma
};

enum class MemoryHeapFlagBits : uint32_t {
  // If set, heap represents device memory
  bDeviceLocal = VK_MEMORY_HEAP_DEVICE_LOCAL_BIT,
#if VK_VERSION_1_1
  // If set, heap allocations allocate multiple instances by default
  bMultiInstance = VK_MEMORY_HEAP_MULTI_INSTANCE_BIT,
#endif // VK_VERSION_1_1
#if VK_KHR_device_group_creation
  bMultiInstanceKHR = VK_MEMORY_HEAP_MULTI_INSTANCE_BIT_KHR,
#endif // VK_KHR_device_group_creation
#if VK_QCOM_tile_memory_heap
  bTileMemoryQCOM = VK_MEMORY_HEAP_TILE_MEMORY_BIT_QCOM,
#endif // VK_QCOM_tile_memory_heap
};

enum class AccessFlagBits : uint32_t {
  // Controls coherency of indirect command reads
  bIndirectCommandRead = VK_ACCESS_INDIRECT_COMMAND_READ_BIT,
  // Controls coherency of index reads
  bIndexRead = VK_ACCESS_INDEX_READ_BIT,
  // Controls coherency of vertex attribute reads
  bVertexAttributeRead = VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT,
  // Controls coherency of uniform buffer reads
  bUniformRead = VK_ACCESS_UNIFORM_READ_BIT,
  // Controls coherency of input attachment reads
  bInputAttachmentRead = VK_ACCESS_INPUT_ATTACHMENT_READ_BIT,
  // Controls coherency of shader reads
  bShaderRead = VK_ACCESS_SHADER_READ_BIT,
  // Controls coherency of shader writes
  bShaderWrite = VK_ACCESS_SHADER_WRITE_BIT,
  // Controls coherency of color attachment reads
  bColorAttachmentRead = VK_ACCESS_COLOR_ATTACHMENT_READ_BIT,
  // Controls coherency of color attachment writes
  bColorAttachmentWrite = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT,
  // Controls coherency of depth/stencil attachment reads
  bDepthStencilAttachmentRead = VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT,
  // Controls coherency of depth/stencil attachment writes
  bDepthStencilAttachmentWrite = VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT,
  // Controls coherency of transfer reads
  bTransferRead = VK_ACCESS_TRANSFER_READ_BIT,
  // Controls coherency of transfer writes
  bTransferWrite = VK_ACCESS_TRANSFER_WRITE_BIT,
  // Controls coherency of host reads
  bHostRead = VK_ACCESS_HOST_READ_BIT,
  // Controls coherency of host writes
  bHostWrite = VK_ACCESS_HOST_WRITE_BIT,
  // Controls coherency of memory reads
  bMemoryRead = VK_ACCESS_MEMORY_READ_BIT,
  // Controls coherency of memory writes
  bMemoryWrite = VK_ACCESS_MEMORY_WRITE_BIT,
#if VK_VERSION_1_3
  eNone = VK_ACCESS_NONE,
#endif // VK_VERSION_1_3
#if VK_EXT_transform_feedback
  bTransformFeedbackWriteEXT = VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT,
  bTransformFeedbackCounterReadEXT = VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT,
  bTransformFeedbackCounterWriteEXT = VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT,
#endif // VK_EXT_transform_feedback
#if VK_EXT_conditional_rendering
  // read access flag for reading conditional rendering predicate
  bConditionalRenderingReadEXT = VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT,
#endif // VK_EXT_conditional_rendering
#if VK_EXT_blend_operation_advanced
  bColorAttachmentReadNoncoherentEXT = VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT,
#endif // VK_EXT_blend_operation_advanced
#if VK_KHR_acceleration_structure
  bAccelerationStructureReadKHR = VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR,
  bAccelerationStructureWriteKHR = VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR,
#endif // VK_KHR_acceleration_structure
#if VK_NV_shading_rate_image
  bShadingRateImageReadNV = VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV,
#endif // VK_NV_shading_rate_image
#if VK_EXT_fragment_density_map
  bFragmentDensityMapReadEXT = VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT,
#endif // VK_EXT_fragment_density_map
#if VK_KHR_fragment_shading_rate
  bFragmentShadingRateAttachmentReadKHR = VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR,
#endif // VK_KHR_fragment_shading_rate
#if VK_NV_device_generated_commands
  bCommandPreprocessReadNV = VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_NV,
  bCommandPreprocessWriteNV = VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_NV,
#endif // VK_NV_device_generated_commands
#if VK_KHR_synchronization2
  eNoneKHR = VK_ACCESS_NONE_KHR,
#endif // VK_KHR_synchronization2
#if VK_EXT_device_generated_commands
  bCommandPreprocessReadEXT = VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_EXT,
  bCommandPreprocessWriteEXT = VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_EXT,
#endif // VK_EXT_device_generated_commands
};

enum class BufferUsageFlagBits : uint32_t {
  // Can be used as a source of transfer operations
  bTransferSrc = VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
  // Can be used as a destination of transfer operations
  bTransferDst = VK_BUFFER_USAGE_TRANSFER_DST_BIT,
  // Can be used as TBO
  bUniformTexelBuffer = VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT,
  // Can be used as IBO
  bStorageTexelBuffer = VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT,
  // Can be used as UBO
  bUniformBuffer = VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT,
  // Can be used as SSBO
  bStorageBuffer = VK_BUFFER_USAGE_STORAGE_BUFFER_BIT,
  // Can be used as source of fixed-function index fetch (index buffer)
  bIndexBuffer = VK_BUFFER_USAGE_INDEX_BUFFER_BIT,
  // Can be used as source of fixed-function vertex fetch (VBO)
  bVertexBuffer = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT,
  // Can be the source of indirect parameters (e.g. indirect buffer, parameter buffer)
  bIndirectBuffer = VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT,
#if VK_VERSION_1_2
  bShaderDeviceAddress = VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT,
#endif // VK_VERSION_1_2
#if VK_KHR_video_decode_queue
  bVideoDecodeSrcKHR = VK_BUFFER_USAGE_VIDEO_DECODE_SRC_BIT_KHR,
  bVideoDecodeDstKHR = VK_BUFFER_USAGE_VIDEO_DECODE_DST_BIT_KHR,
#endif // VK_KHR_video_decode_queue
#if VK_EXT_transform_feedback
  bTransformFeedbackBufferEXT = VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT,
  bTransformFeedbackCounterBufferEXT = VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT,
#endif // VK_EXT_transform_feedback
#if VK_EXT_conditional_rendering
  // Specifies the buffer can be used as predicate in conditional rendering
  bConditionalRenderingEXT = VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT,
#endif // VK_EXT_conditional_rendering
#if VK_KHR_acceleration_structure
  bAccelerationStructureBuildInputReadOnlyKHR = VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR,
  bAccelerationStructureStorageKHR = VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR,
#endif // VK_KHR_acceleration_structure
#if VK_KHR_ray_tracing_pipeline
  bShaderBindingTableKHR = VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR,
#endif // VK_KHR_ray_tracing_pipeline
#if VK_KHR_buffer_device_address
  bShaderDeviceAddressKHR = VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_KHR,
#endif // VK_KHR_buffer_device_address
#if VK_KHR_video_encode_queue
  bVideoEncodeDstKHR = VK_BUFFER_USAGE_VIDEO_ENCODE_DST_BIT_KHR,
  bVideoEncodeSrcKHR = VK_BUFFER_USAGE_VIDEO_ENCODE_SRC_BIT_KHR,
#endif // VK_KHR_video_encode_queue
#if VK_EXT_descriptor_buffer
  bSamplerDescriptorBufferEXT = VK_BUFFER_USAGE_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT,
  bResourceDescriptorBufferEXT = VK_BUFFER_USAGE_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT,
  bPushDescriptorsDescriptorBufferEXT = VK_BUFFER_USAGE_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT,
#endif // VK_EXT_descriptor_buffer
#if VK_EXT_opacity_micromap
  bMicromapBuildInputReadOnlyEXT = VK_BUFFER_USAGE_MICROMAP_BUILD_INPUT_READ_ONLY_BIT_EXT,
  bMicromapStorageEXT = VK_BUFFER_USAGE_MICROMAP_STORAGE_BIT_EXT,
#endif // VK_EXT_opacity_micromap
#if VK_QCOM_tile_memory_heap
  bTileMemoryQCOM = VK_BUFFER_USAGE_TILE_MEMORY_BIT_QCOM,
#endif // VK_QCOM_tile_memory_heap
};
#endif // VK_VERSION_1_0

#if VK_VERSION_1_4
enum class BufferUsageFlagBits2 : uint64_t {
  bTransferSrc = VK_BUFFER_USAGE_2_TRANSFER_SRC_BIT,
  bTransferDst = VK_BUFFER_USAGE_2_TRANSFER_DST_BIT,
  bUniformTexelBuffer = VK_BUFFER_USAGE_2_UNIFORM_TEXEL_BUFFER_BIT,
  bStorageTexelBuffer = VK_BUFFER_USAGE_2_STORAGE_TEXEL_BUFFER_BIT,
  bUniformBuffer = VK_BUFFER_USAGE_2_UNIFORM_BUFFER_BIT,
  bStorageBuffer = VK_BUFFER_USAGE_2_STORAGE_BUFFER_BIT,
  bIndexBuffer = VK_BUFFER_USAGE_2_INDEX_BUFFER_BIT,
  bVertexBuffer = VK_BUFFER_USAGE_2_VERTEX_BUFFER_BIT,
  bIndirectBuffer = VK_BUFFER_USAGE_2_INDIRECT_BUFFER_BIT,
#if VK_VERSION_1_4
  bShaderDeviceAddress = VK_BUFFER_USAGE_2_SHADER_DEVICE_ADDRESS_BIT,
#endif // VK_VERSION_1_4
#if VK_KHR_maintenance5
  bTransferSrcKHR = VK_BUFFER_USAGE_2_TRANSFER_SRC_BIT_KHR,
  bTransferDstKHR = VK_BUFFER_USAGE_2_TRANSFER_DST_BIT_KHR,
  bUniformTexelBufferKHR = VK_BUFFER_USAGE_2_UNIFORM_TEXEL_BUFFER_BIT_KHR,
  bStorageTexelBufferKHR = VK_BUFFER_USAGE_2_STORAGE_TEXEL_BUFFER_BIT_KHR,
  bUniformBufferKHR = VK_BUFFER_USAGE_2_UNIFORM_BUFFER_BIT_KHR,
  bStorageBufferKHR = VK_BUFFER_USAGE_2_STORAGE_BUFFER_BIT_KHR,
  bIndexBufferKHR = VK_BUFFER_USAGE_2_INDEX_BUFFER_BIT_KHR,
  bVertexBufferKHR = VK_BUFFER_USAGE_2_VERTEX_BUFFER_BIT_KHR,
  bIndirectBufferKHR = VK_BUFFER_USAGE_2_INDIRECT_BUFFER_BIT_KHR,
  bConditionalRenderingEXT = VK_BUFFER_USAGE_2_CONDITIONAL_RENDERING_BIT_EXT,
  bShaderBindingTableKHR = VK_BUFFER_USAGE_2_SHADER_BINDING_TABLE_BIT_KHR,
  bTransformFeedbackBufferEXT = VK_BUFFER_USAGE_2_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT,
  bTransformFeedbackCounterBufferEXT = VK_BUFFER_USAGE_2_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT,
  bVideoDecodeSrcKHR = VK_BUFFER_USAGE_2_VIDEO_DECODE_SRC_BIT_KHR,
  bVideoDecodeDstKHR = VK_BUFFER_USAGE_2_VIDEO_DECODE_DST_BIT_KHR,
  bVideoEncodeDstKHR = VK_BUFFER_USAGE_2_VIDEO_ENCODE_DST_BIT_KHR,
  bVideoEncodeSrcKHR = VK_BUFFER_USAGE_2_VIDEO_ENCODE_SRC_BIT_KHR,
  bAccelerationStructureBuildInputReadOnlyKHR = VK_BUFFER_USAGE_2_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR,
  bAccelerationStructureStorageKHR = VK_BUFFER_USAGE_2_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR,
  bSamplerDescriptorBufferEXT = VK_BUFFER_USAGE_2_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT,
  bResourceDescriptorBufferEXT = VK_BUFFER_USAGE_2_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT,
  bPushDescriptorsDescriptorBufferEXT = VK_BUFFER_USAGE_2_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT,
  bMicromapBuildInputReadOnlyEXT = VK_BUFFER_USAGE_2_MICROMAP_BUILD_INPUT_READ_ONLY_BIT_EXT,
  bMicromapStorageEXT = VK_BUFFER_USAGE_2_MICROMAP_STORAGE_BIT_EXT,
#endif // VK_KHR_maintenance5
#if VK_ARM_data_graph
  bDataGraphForeignDescriptorARM = VK_BUFFER_USAGE_2_DATA_GRAPH_FOREIGN_DESCRIPTOR_BIT_ARM,
#endif // VK_ARM_data_graph
#if VK_QCOM_tile_memory_heap
  bTileMemoryQCOM = VK_BUFFER_USAGE_2_TILE_MEMORY_BIT_QCOM,
#endif // VK_QCOM_tile_memory_heap
#if VK_EXT_device_generated_commands
  bPreprocessBufferEXT = VK_BUFFER_USAGE_2_PREPROCESS_BUFFER_BIT_EXT,
#endif // VK_EXT_device_generated_commands
};
#endif // VK_VERSION_1_4

#if VK_VERSION_1_0
enum class BufferCreateFlagBits : uint32_t {
  // Buffer should support sparse backing
  bSparseBinding = VK_BUFFER_CREATE_SPARSE_BINDING_BIT,
  // Buffer should support sparse backing with partial residency
  bSparseResidency = VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT,
  // Buffer should support constant data access to physical memory ranges mapped into multiple locations of sparse buffers
  bSparseAliased = VK_BUFFER_CREATE_SPARSE_ALIASED_BIT,
#if VK_VERSION_1_1
  // Buffer requires protected memory
  bProtected = VK_BUFFER_CREATE_PROTECTED_BIT,
#endif // VK_VERSION_1_1
#if VK_VERSION_1_2
  bDeviceAddressCaptureReplay = VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT,
#endif // VK_VERSION_1_2
#if VK_KHR_buffer_device_address
  bDeviceAddressCaptureReplayKHR = VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR,
#endif // VK_KHR_buffer_device_address
#if VK_EXT_descriptor_buffer
  bDescriptorBufferCaptureReplayEXT = VK_BUFFER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT,
#endif // VK_EXT_descriptor_buffer
#if VK_KHR_video_maintenance1
  bVideoProfileIndependentKHR = VK_BUFFER_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR,
#endif // VK_KHR_video_maintenance1
};

enum class ShaderStageFlagBits : uint32_t {
  bVertex = VK_SHADER_STAGE_VERTEX_BIT,
  bTessellationControl = VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT,
  bTessellationEvaluation = VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT,
  bGeometry = VK_SHADER_STAGE_GEOMETRY_BIT,
  bFragment = VK_SHADER_STAGE_FRAGMENT_BIT,
  bCompute = VK_SHADER_STAGE_COMPUTE_BIT,
  eAllGraphics = VK_SHADER_STAGE_ALL_GRAPHICS,
  eAll = VK_SHADER_STAGE_ALL,
#if VK_KHR_ray_tracing_pipeline
  bRaygenKHR = VK_SHADER_STAGE_RAYGEN_BIT_KHR,
  bAnyHitKHR = VK_SHADER_STAGE_ANY_HIT_BIT_KHR,
  bClosestHitKHR = VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR,
  bMissKHR = VK_SHADER_STAGE_MISS_BIT_KHR,
  bIntersectionKHR = VK_SHADER_STAGE_INTERSECTION_BIT_KHR,
  bCallableKHR = VK_SHADER_STAGE_CALLABLE_BIT_KHR,
#endif // VK_KHR_ray_tracing_pipeline
#if VK_NV_mesh_shader
  bTaskNV = VK_SHADER_STAGE_TASK_BIT_NV,
  bMeshNV = VK_SHADER_STAGE_MESH_BIT_NV,
#endif // VK_NV_mesh_shader
#if VK_EXT_mesh_shader
  bTaskEXT = VK_SHADER_STAGE_TASK_BIT_EXT,
  bMeshEXT = VK_SHADER_STAGE_MESH_BIT_EXT,
#endif // VK_EXT_mesh_shader
#if VK_HUAWEI_subpass_shading
  bSubpassShadingHUAWEI = VK_SHADER_STAGE_SUBPASS_SHADING_BIT_HUAWEI,
#endif // VK_HUAWEI_subpass_shading
#if VK_HUAWEI_cluster_culling_shader
  bClusterCullingHUAWEI = VK_SHADER_STAGE_CLUSTER_CULLING_BIT_HUAWEI,
#endif // VK_HUAWEI_cluster_culling_shader
};

enum class ImageUsageFlagBits : uint32_t {
  // Can be used as a source of transfer operations
  bTransferSrc = VK_IMAGE_USAGE_TRANSFER_SRC_BIT,
  // Can be used as a destination of transfer operations
  bTransferDst = VK_IMAGE_USAGE_TRANSFER_DST_BIT,
  // Can be sampled from (SAMPLED_IMAGE and COMBINED_IMAGE_SAMPLER descriptor types)
  bSampled = VK_IMAGE_USAGE_SAMPLED_BIT,
  // Can be used as storage image (STORAGE_IMAGE descriptor type)
  bStorage = VK_IMAGE_USAGE_STORAGE_BIT,
  // Can be used as framebuffer color attachment
  bColorAttachment = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT,
  // Can be used as framebuffer depth/stencil attachment
  bDepthStencilAttachment = VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT,
  // Image data not needed outside of rendering
  bTransientAttachment = VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT,
  // Can be used as framebuffer input attachment
  bInputAttachment = VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT,
#if VK_VERSION_1_4
  bHostTransfer = VK_IMAGE_USAGE_HOST_TRANSFER_BIT,
#endif // VK_VERSION_1_4
#if VK_KHR_video_decode_queue
  bVideoDecodeDstKHR = VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR,
  bVideoDecodeSrcKHR = VK_IMAGE_USAGE_VIDEO_DECODE_SRC_BIT_KHR,
  bVideoDecodeDpbKHR = VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR,
#endif // VK_KHR_video_decode_queue
#if VK_NV_shading_rate_image
  bShadingRateImageNV = VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV,
#endif // VK_NV_shading_rate_image
#if VK_EXT_fragment_density_map
  bFragmentDensityMapEXT = VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT,
#endif // VK_EXT_fragment_density_map
#if VK_KHR_fragment_shading_rate
  bFragmentShadingRateAttachmentKHR = VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR,
#endif // VK_KHR_fragment_shading_rate
#if VK_EXT_host_image_copy
  // Can be used with host image copies
  bHostTransferEXT = VK_IMAGE_USAGE_HOST_TRANSFER_BIT_EXT,
#endif // VK_EXT_host_image_copy
#if VK_KHR_video_encode_queue
  bVideoEncodeDstKHR = VK_IMAGE_USAGE_VIDEO_ENCODE_DST_BIT_KHR,
  bVideoEncodeSrcKHR = VK_IMAGE_USAGE_VIDEO_ENCODE_SRC_BIT_KHR,
  bVideoEncodeDpbKHR = VK_IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR,
#endif // VK_KHR_video_encode_queue
#if VK_EXT_attachment_feedback_loop_layout
  bAttachmentFeedbackLoopEXT = VK_IMAGE_USAGE_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT,
#endif // VK_EXT_attachment_feedback_loop_layout
#if VK_HUAWEI_invocation_mask
  bInvocationMaskHUAWEI = VK_IMAGE_USAGE_INVOCATION_MASK_BIT_HUAWEI,
#endif // VK_HUAWEI_invocation_mask
#if VK_QCOM_image_processing
  bSampleWeightQCOM = VK_IMAGE_USAGE_SAMPLE_WEIGHT_BIT_QCOM,
  bSampleBlockMatchQCOM = VK_IMAGE_USAGE_SAMPLE_BLOCK_MATCH_BIT_QCOM,
#endif // VK_QCOM_image_processing
#if VK_ARM_tensors
  bTensorAliasingARM = VK_IMAGE_USAGE_TENSOR_ALIASING_BIT_ARM,
#endif // VK_ARM_tensors
#if VK_QCOM_tile_memory_heap
  bTileMemoryQCOM = VK_IMAGE_USAGE_TILE_MEMORY_BIT_QCOM,
#endif // VK_QCOM_tile_memory_heap
#if VK_KHR_video_encode_quantization_map
  bVideoEncodeQuantizationDeltaMapKHR = VK_IMAGE_USAGE_VIDEO_ENCODE_QUANTIZATION_DELTA_MAP_BIT_KHR,
  bVideoEncodeEmphasisMapKHR = VK_IMAGE_USAGE_VIDEO_ENCODE_EMPHASIS_MAP_BIT_KHR,
#endif // VK_KHR_video_encode_quantization_map
};

enum class ImageCreateFlagBits : uint32_t {
  // Image should support sparse backing
  bSparseBinding = VK_IMAGE_CREATE_SPARSE_BINDING_BIT,
  // Image should support sparse backing with partial residency
  bSparseResidency = VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT,
  // Image should support constant data access to physical memory ranges mapped into multiple locations of sparse images
  bSparseAliased = VK_IMAGE_CREATE_SPARSE_ALIASED_BIT,
  // Allows image views to have different format than the base image
  bMutableFormat = VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT,
  // Allows creating image views with cube type from the created image
  bCubeCompatible = VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT,
#if VK_VERSION_1_1
  bAlias = VK_IMAGE_CREATE_ALIAS_BIT,
  // Allows using VkBindImageMemoryDeviceGroupInfo::pSplitInstanceBindRegions when binding memory to the image
  bSplitInstanceBindRegions = VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT,
  // The 3D image can be viewed as a 2D or 2D array image
  b2DArrayCompatible = VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT,
  bBlockTexelViewCompatible = VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT,
  bExtendedUsage = VK_IMAGE_CREATE_EXTENDED_USAGE_BIT,
  // Image requires protected memory
  bProtected = VK_IMAGE_CREATE_PROTECTED_BIT,
  bDisjoint = VK_IMAGE_CREATE_DISJOINT_BIT,
#endif // VK_VERSION_1_1
#if VK_NV_corner_sampled_image
  bCornerSampledNV = VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV,
#endif // VK_NV_corner_sampled_image
#if VK_KHR_maintenance1
  b2DArrayCompatibleKHR = VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR,
#endif // VK_KHR_maintenance1
#if VK_KHR_maintenance2
  bBlockTexelViewCompatibleKHR = VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR,
  bExtendedUsageKHR = VK_IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR,
#endif // VK_KHR_maintenance2
#if VK_EXT_sample_locations
  bSampleLocationsCompatibleDepthEXT = VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT,
#endif // VK_EXT_sample_locations
#if VK_KHR_sampler_ycbcr_conversion
  bDisjointKHR = VK_IMAGE_CREATE_DISJOINT_BIT_KHR,
#endif // VK_KHR_sampler_ycbcr_conversion
#if VK_KHR_bind_memory2
  bAliasKHR = VK_IMAGE_CREATE_ALIAS_BIT_KHR,
#endif // VK_KHR_bind_memory2
#if VK_EXT_fragment_density_map
  bSubsampledEXT = VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT,
#endif // VK_EXT_fragment_density_map
#if VK_EXT_descriptor_buffer
  bDescriptorBufferCaptureReplayEXT = VK_IMAGE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT,
#endif // VK_EXT_descriptor_buffer
#if VK_EXT_multisampled_render_to_single_sampled
  bMultisampledRenderToSingleSampledEXT = VK_IMAGE_CREATE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_BIT_EXT,
#endif // VK_EXT_multisampled_render_to_single_sampled
#if VK_EXT_image_2d_view_of_3d
  // Image is created with a layout where individual slices are capable of being used as 2D images
  b2DViewCompatibleEXT = VK_IMAGE_CREATE_2D_VIEW_COMPATIBLE_BIT_EXT,
#endif // VK_EXT_image_2d_view_of_3d
#if VK_QCOM_fragment_density_map_offset
  bFragmentDensityMapOffsetQCOM = VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM,
#endif // VK_QCOM_fragment_density_map_offset
#if VK_KHR_video_maintenance1
  bVideoProfileIndependentKHR = VK_IMAGE_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR,
#endif // VK_KHR_video_maintenance1
#if VK_EXT_fragment_density_map_offset
  bFragmentDensityMapOffsetEXT = VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_EXT,
#endif // VK_EXT_fragment_density_map_offset
};

enum class ImageViewCreateFlagBits : uint32_t {
#if VK_EXT_fragment_density_map
  bFragmentDensityMapDynamicEXT = VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT,
#endif // VK_EXT_fragment_density_map
#if VK_EXT_descriptor_buffer
  bDescriptorBufferCaptureReplayEXT = VK_IMAGE_VIEW_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT,
#endif // VK_EXT_descriptor_buffer
#if VK_EXT_fragment_density_map2
  bFragmentDensityMapDeferredEXT = VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DEFERRED_BIT_EXT,
#endif // VK_EXT_fragment_density_map2
};

enum class SamplerCreateFlagBits : uint32_t {
#if VK_EXT_fragment_density_map
  bSubsampledEXT = VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT,
  bSubsampledCoarseReconstructionEXT = VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT,
#endif // VK_EXT_fragment_density_map
#if VK_EXT_descriptor_buffer
  bDescriptorBufferCaptureReplayEXT = VK_SAMPLER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT,
#endif // VK_EXT_descriptor_buffer
#if VK_EXT_non_seamless_cube_map
  bNonSeamlessCubeMapEXT = VK_SAMPLER_CREATE_NON_SEAMLESS_CUBE_MAP_BIT_EXT,
#endif // VK_EXT_non_seamless_cube_map
#if VK_QCOM_image_processing
  bImageProcessingQCOM = VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM,
#endif // VK_QCOM_image_processing
};

enum class PipelineCreateFlagBits : uint32_t {
  bDisableOptimization = VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT,
  bAllowDerivatives = VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT,
  bDerivative = VK_PIPELINE_CREATE_DERIVATIVE_BIT,
#if VK_VERSION_1_1
  bViewIndexFromDeviceIndex = VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT,
  bDispatchBase = VK_PIPELINE_CREATE_DISPATCH_BASE_BIT,
#endif // VK_VERSION_1_1
#if VK_VERSION_1_3
  bFailOnPipelineCompileRequired = VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT,
  bEarlyReturnOnFailure = VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT,
#endif // VK_VERSION_1_3
#if VK_VERSION_1_4
  bNoProtectedAccess = VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT,
  bProtectedAccessOnly = VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT,
#endif // VK_VERSION_1_4
#if VK_KHR_device_group
  bViewIndexFromDeviceIndexKHR = VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR,
  bDispatchBaseKHR = VK_PIPELINE_CREATE_DISPATCH_BASE_BIT_KHR,
#endif // VK_KHR_device_group
#if VK_KHR_ray_tracing_pipeline
  bRayTracingNoNullAnyHitShadersKHR = VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR,
  bRayTracingNoNullClosestHitShadersKHR = VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR,
  bRayTracingNoNullMissShadersKHR = VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR,
  bRayTracingNoNullIntersectionShadersKHR = VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR,
  bRayTracingSkipTrianglesKHR = VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR,
  bRayTracingSkipAabbsKHR = VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR,
  bRayTracingShaderGroupHandleCaptureReplayKHR = VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR,
#endif // VK_KHR_ray_tracing_pipeline
#if VK_EXT_fragment_density_map
  bRenderingFragmentDensityMapAttachmentEXT = VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT,
#endif // VK_EXT_fragment_density_map
#if VK_KHR_fragment_shading_rate
  bRenderingFragmentShadingRateAttachmentKHR = VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR,
#endif // VK_KHR_fragment_shading_rate
#if VK_KHR_pipeline_executable_properties
  bCaptureStatisticsKHR = VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR,
  bCaptureInternalRepresentationsKHR = VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR,
#endif // VK_KHR_pipeline_executable_properties
#if VK_NV_device_generated_commands
  bIndirectBindableNV = VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV,
#endif // VK_NV_device_generated_commands
#if VK_KHR_pipeline_library
  bLibraryKHR = VK_PIPELINE_CREATE_LIBRARY_BIT_KHR,
#endif // VK_KHR_pipeline_library
#if VK_EXT_pipeline_creation_cache_control
  bFailOnPipelineCompileRequiredEXT = VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_EXT,
  bEarlyReturnOnFailureEXT = VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT_EXT,
#endif // VK_EXT_pipeline_creation_cache_control
#if VK_EXT_descriptor_buffer
  bDescriptorBufferEXT = VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT,
#endif // VK_EXT_descriptor_buffer
#if VK_EXT_graphics_pipeline_library
  bRetainLinkTimeOptimizationInfoEXT = VK_PIPELINE_CREATE_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT,
  bLinkTimeOptimizationEXT = VK_PIPELINE_CREATE_LINK_TIME_OPTIMIZATION_BIT_EXT,
#endif // VK_EXT_graphics_pipeline_library
#if VK_NV_ray_tracing_motion_blur
  bRayTracingAllowMotionNV = VK_PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV,
#endif // VK_NV_ray_tracing_motion_blur
#if VK_EXT_attachment_feedback_loop_layout
  bColorAttachmentFeedbackLoopEXT = VK_PIPELINE_CREATE_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT,
  bDepthStencilAttachmentFeedbackLoopEXT = VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT,
#endif // VK_EXT_attachment_feedback_loop_layout
#if VK_EXT_opacity_micromap
  bRayTracingOpacityMicromapEXT = VK_PIPELINE_CREATE_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT,
#endif // VK_EXT_opacity_micromap
#if VK_EXT_pipeline_protected_access
  bNoProtectedAccessEXT = VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT_EXT,
  bProtectedAccessOnlyEXT = VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT_EXT,
#endif // VK_EXT_pipeline_protected_access
};
#endif // VK_VERSION_1_0

#if VK_VERSION_1_4
enum class PipelineCreateFlagBits2 : uint64_t {
  bDisableOptimization = VK_PIPELINE_CREATE_2_DISABLE_OPTIMIZATION_BIT,
  bAllowDerivatives = VK_PIPELINE_CREATE_2_ALLOW_DERIVATIVES_BIT,
  bDerivative = VK_PIPELINE_CREATE_2_DERIVATIVE_BIT,
  bViewIndexFromDeviceIndex = VK_PIPELINE_CREATE_2_VIEW_INDEX_FROM_DEVICE_INDEX_BIT,
  bDispatchBase = VK_PIPELINE_CREATE_2_DISPATCH_BASE_BIT,
  bFailOnPipelineCompileRequired = VK_PIPELINE_CREATE_2_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT,
  bEarlyReturnOnFailure = VK_PIPELINE_CREATE_2_EARLY_RETURN_ON_FAILURE_BIT,
  bNoProtectedAccess = VK_PIPELINE_CREATE_2_NO_PROTECTED_ACCESS_BIT,
  bProtectedAccessOnly = VK_PIPELINE_CREATE_2_PROTECTED_ACCESS_ONLY_BIT,
#if VK_KHR_ray_tracing_pipeline
  bRayTracingSkipBuiltInPrimitivesKHR = VK_PIPELINE_CREATE_2_RAY_TRACING_SKIP_BUILT_IN_PRIMITIVES_BIT_KHR,
#endif // VK_KHR_ray_tracing_pipeline
#if VK_NV_ray_tracing_linear_swept_spheres
  bRayTracingAllowSpheresAndLinearSweptSpheresNV = VK_PIPELINE_CREATE_2_RAY_TRACING_ALLOW_SPHERES_AND_LINEAR_SWEPT_SPHERES_BIT_NV,
#endif // VK_NV_ray_tracing_linear_swept_spheres
#if VK_KHR_maintenance5
  bDisableOptimizationKHR = VK_PIPELINE_CREATE_2_DISABLE_OPTIMIZATION_BIT_KHR,
  bAllowDerivativesKHR = VK_PIPELINE_CREATE_2_ALLOW_DERIVATIVES_BIT_KHR,
  bDerivativeKHR = VK_PIPELINE_CREATE_2_DERIVATIVE_BIT_KHR,
  bViewIndexFromDeviceIndexKHR = VK_PIPELINE_CREATE_2_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR,
  bDispatchBaseKHR = VK_PIPELINE_CREATE_2_DISPATCH_BASE_BIT_KHR,
  bCaptureStatisticsKHR = VK_PIPELINE_CREATE_2_CAPTURE_STATISTICS_BIT_KHR,
  bCaptureInternalRepresentationsKHR = VK_PIPELINE_CREATE_2_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR,
  bFailOnPipelineCompileRequiredKHR = VK_PIPELINE_CREATE_2_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_KHR,
  bEarlyReturnOnFailureKHR = VK_PIPELINE_CREATE_2_EARLY_RETURN_ON_FAILURE_BIT_KHR,
  bLinkTimeOptimizationEXT = VK_PIPELINE_CREATE_2_LINK_TIME_OPTIMIZATION_BIT_EXT,
  bRetainLinkTimeOptimizationInfoEXT = VK_PIPELINE_CREATE_2_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT,
  bLibraryKHR = VK_PIPELINE_CREATE_2_LIBRARY_BIT_KHR,
  bRayTracingSkipTrianglesKHR = VK_PIPELINE_CREATE_2_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR,
  bRayTracingSkipAabbsKHR = VK_PIPELINE_CREATE_2_RAY_TRACING_SKIP_AABBS_BIT_KHR,
  bRayTracingNoNullAnyHitShadersKHR = VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR,
  bRayTracingNoNullClosestHitShadersKHR = VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR,
  bRayTracingNoNullMissShadersKHR = VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR,
  bRayTracingNoNullIntersectionShadersKHR = VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR,
  bRayTracingShaderGroupHandleCaptureReplayKHR = VK_PIPELINE_CREATE_2_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR,
  bIndirectBindableNV = VK_PIPELINE_CREATE_2_INDIRECT_BINDABLE_BIT_NV,
  bRayTracingAllowMotionNV = VK_PIPELINE_CREATE_2_RAY_TRACING_ALLOW_MOTION_BIT_NV,
  bRayTracingOpacityMicromapEXT = VK_PIPELINE_CREATE_2_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT,
  bColorAttachmentFeedbackLoopEXT = VK_PIPELINE_CREATE_2_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT,
  bDepthStencilAttachmentFeedbackLoopEXT = VK_PIPELINE_CREATE_2_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT,
  bNoProtectedAccessEXT = VK_PIPELINE_CREATE_2_NO_PROTECTED_ACCESS_BIT_EXT,
  bProtectedAccessOnlyEXT = VK_PIPELINE_CREATE_2_PROTECTED_ACCESS_ONLY_BIT_EXT,
  bDescriptorBufferEXT = VK_PIPELINE_CREATE_2_DESCRIPTOR_BUFFER_BIT_EXT,
#endif // VK_KHR_maintenance5
#if VK_KHR_pipeline_binary
  bCaptureDataKHR = VK_PIPELINE_CREATE_2_CAPTURE_DATA_BIT_KHR,
#endif // VK_KHR_pipeline_binary
#if VK_EXT_device_generated_commands
  bIndirectBindableEXT = VK_PIPELINE_CREATE_2_INDIRECT_BINDABLE_BIT_EXT,
#endif // VK_EXT_device_generated_commands
#if VK_ARM_pipeline_opacity_micromap
  bDisallowOpacityMicromapARM = VK_PIPELINE_CREATE_2_DISALLOW_OPACITY_MICROMAP_BIT_ARM,
#endif // VK_ARM_pipeline_opacity_micromap
#if VK_VALVE_fragment_density_map_layered
  bPerLayerFragmentDensityVALVE = VK_PIPELINE_CREATE_2_PER_LAYER_FRAGMENT_DENSITY_BIT_VALVE,
#endif // VK_VALVE_fragment_density_map_layered
};
#endif // VK_VERSION_1_4

#if VK_VERSION_1_0
enum class PipelineShaderStageCreateFlagBits : uint32_t {
#if VK_VERSION_1_3
  bAllowVaryingSubgroupSize = VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT,
  bRequireFullSubgroups = VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT,
#endif // VK_VERSION_1_3
#if VK_EXT_subgroup_size_control
  bAllowVaryingSubgroupSizeEXT = VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT,
  bRequireFullSubgroupsEXT = VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT,
#endif // VK_EXT_subgroup_size_control
};

enum class ColorComponentFlagBits : uint32_t {
  bR = VK_COLOR_COMPONENT_R_BIT,
  bG = VK_COLOR_COMPONENT_G_BIT,
  bB = VK_COLOR_COMPONENT_B_BIT,
  bA = VK_COLOR_COMPONENT_A_BIT,
};

enum class FenceCreateFlagBits : uint32_t {
  bSignaled = VK_FENCE_CREATE_SIGNALED_BIT,
};

enum class FormatFeatureFlagBits : uint32_t {
  // Format can be used for sampled images (SAMPLED_IMAGE and COMBINED_IMAGE_SAMPLER descriptor types)
  bSampledImage = VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT,
  // Format can be used for storage images (STORAGE_IMAGE descriptor type)
  bStorageImage = VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT,
  // Format supports atomic operations in case it is used for storage images
  bStorageImageAtomic = VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT,
  // Format can be used for uniform texel buffers (TBOs)
  bUniformTexelBuffer = VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT,
  // Format can be used for storage texel buffers (IBOs)
  bStorageTexelBuffer = VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT,
  // Format supports atomic operations in case it is used for storage texel buffers
  bStorageTexelBufferAtomic = VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT,
  // Format can be used for vertex buffers (VBOs)
  bVertexBuffer = VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT,
  // Format can be used for color attachment images
  bColorAttachment = VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT,
  // Format supports blending in case it is used for color attachment images
  bColorAttachmentBlend = VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT,
  // Format can be used for depth/stencil attachment images
  bDepthStencilAttachment = VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT,
  // Format can be used as the source image of blits with vkCmdBlitImage
  bBlitSrc = VK_FORMAT_FEATURE_BLIT_SRC_BIT,
  // Format can be used as the destination image of blits with vkCmdBlitImage
  bBlitDst = VK_FORMAT_FEATURE_BLIT_DST_BIT,
  // Format can be filtered with VK_FILTER_LINEAR when being sampled
  bSampledImageFilterLinear = VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT,
#if VK_VERSION_1_1
  // Format can be used as the source image of image transfer commands
  bTransferSrc = VK_FORMAT_FEATURE_TRANSFER_SRC_BIT,
  // Format can be used as the destination image of image transfer commands
  bTransferDst = VK_FORMAT_FEATURE_TRANSFER_DST_BIT,
  // Format can have midpoint rather than cosited chroma samples
  bMidpointChromaSamples = VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT,
  // Format can be used with linear filtering whilst color conversion is enabled
  bSampledImageYcbcrConversionLinearFilter = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT,
  // Format can have different chroma, min and mag filters
  bSampledImageYcbcrConversionSeparateReconstructionFilter = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT,
  bSampledImageYcbcrConversionChromaReconstructionExplicit = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT,
  bSampledImageYcbcrConversionChromaReconstructionExplicitForceable = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT,
  // Format supports disjoint planes
  bDisjoint = VK_FORMAT_FEATURE_DISJOINT_BIT,
  // Format can have cosited rather than midpoint chroma samples
  bCositedChromaSamples = VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT,
#endif // VK_VERSION_1_1
#if VK_VERSION_1_2
  // Format can be used with min/max reduction filtering
  bSampledImageFilterMinmax = VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT,
#endif // VK_VERSION_1_2
#if VK_IMG_filter_cubic
  // Format can be filtered with VK_FILTER_CUBIC_IMG when being sampled
  bSampledImageFilterCubicIMG = VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG,
#endif // VK_IMG_filter_cubic
#if VK_KHR_video_decode_queue
  bVideoDecodeOutputKHR = VK_FORMAT_FEATURE_VIDEO_DECODE_OUTPUT_BIT_KHR,
  bVideoDecodeDpbKHR = VK_FORMAT_FEATURE_VIDEO_DECODE_DPB_BIT_KHR,
#endif // VK_KHR_video_decode_queue
#if VK_KHR_maintenance1
  bTransferSrcKHR = VK_FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR,
  bTransferDstKHR = VK_FORMAT_FEATURE_TRANSFER_DST_BIT_KHR,
#endif // VK_KHR_maintenance1
#if VK_EXT_sampler_filter_minmax
  bSampledImageFilterMinmaxEXT = VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT,
#endif // VK_EXT_sampler_filter_minmax
#if VK_KHR_acceleration_structure
  bAccelerationStructureVertexBufferKHR = VK_FORMAT_FEATURE_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR,
#endif // VK_KHR_acceleration_structure
#if VK_KHR_sampler_ycbcr_conversion
  bMidpointChromaSamplesKHR = VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT_KHR,
  bSampledImageYcbcrConversionLinearFilterKHR = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR,
  bSampledImageYcbcrConversionSeparateReconstructionFilterKHR = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR,
  bSampledImageYcbcrConversionChromaReconstructionExplicitKHR = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR,
  bSampledImageYcbcrConversionChromaReconstructionExplicitForceableKHR = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR,
  bDisjointKHR = VK_FORMAT_FEATURE_DISJOINT_BIT_KHR,
  bCositedChromaSamplesKHR = VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT_KHR,
#endif // VK_KHR_sampler_ycbcr_conversion
#if VK_EXT_filter_cubic
  bSampledImageFilterCubicEXT = VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT,
#endif // VK_EXT_filter_cubic
#if VK_EXT_fragment_density_map
  bFragmentDensityMapEXT = VK_FORMAT_FEATURE_FRAGMENT_DENSITY_MAP_BIT_EXT,
#endif // VK_EXT_fragment_density_map
#if VK_KHR_fragment_shading_rate
  bFragmentShadingRateAttachmentKHR = VK_FORMAT_FEATURE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR,
#endif // VK_KHR_fragment_shading_rate
#if VK_KHR_video_encode_queue
  bVideoEncodeInputKHR = VK_FORMAT_FEATURE_VIDEO_ENCODE_INPUT_BIT_KHR,
  bVideoEncodeDpbKHR = VK_FORMAT_FEATURE_VIDEO_ENCODE_DPB_BIT_KHR,
#endif // VK_KHR_video_encode_queue
};

enum class QueryControlFlagBits : uint32_t {
  // Require precise results to be collected by the query
  bPrecise = VK_QUERY_CONTROL_PRECISE_BIT,
};

enum class QueryResultFlagBits : uint32_t {
  // Results of the queries are written to the destination buffer as 64-bit values
  b64 = VK_QUERY_RESULT_64_BIT,
  // Results of the queries are waited on before proceeding with the result copy
  bWait = VK_QUERY_RESULT_WAIT_BIT,
  // Besides the results of the query, the availability of the results is also written
  bWithAvailability = VK_QUERY_RESULT_WITH_AVAILABILITY_BIT,
  // Copy the partial results of the query even if the final results are not available
  bPartial = VK_QUERY_RESULT_PARTIAL_BIT,
#if VK_KHR_video_queue
  bWithStatusKHR = VK_QUERY_RESULT_WITH_STATUS_BIT_KHR,
#endif // VK_KHR_video_queue
};

enum class CommandBufferUsageFlagBits : uint32_t {
  bOneTimeSubmit = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT,
  bRenderPassContinue = VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT,
  // Command buffer may be submitted/executed more than once simultaneously
  bSimultaneousUse = VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT,
};

enum class QueryPipelineStatisticFlagBits : uint32_t {
  // Optional
  bInputAssemblyVertices = VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT,
  // Optional
  bInputAssemblyPrimitives = VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT,
  // Optional
  bVertexShaderInvocations = VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT,
  // Optional
  bGeometryShaderInvocations = VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT,
  // Optional
  bGeometryShaderPrimitives = VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT,
  // Optional
  bClippingInvocations = VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT,
  // Optional
  bClippingPrimitives = VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT,
  // Optional
  bFragmentShaderInvocations = VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT,
  // Optional
  bTessellationControlShaderPatches = VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT,
  // Optional
  bTessellationEvaluationShaderInvocations = VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT,
  // Optional
  bComputeShaderInvocations = VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT,
#if VK_EXT_mesh_shader
  bTaskShaderInvocationsEXT = VK_QUERY_PIPELINE_STATISTIC_TASK_SHADER_INVOCATIONS_BIT_EXT,
  bMeshShaderInvocationsEXT = VK_QUERY_PIPELINE_STATISTIC_MESH_SHADER_INVOCATIONS_BIT_EXT,
#endif // VK_EXT_mesh_shader
#if VK_HUAWEI_cluster_culling_shader
  bClusterCullingShaderInvocationsHUAWEI = VK_QUERY_PIPELINE_STATISTIC_CLUSTER_CULLING_SHADER_INVOCATIONS_BIT_HUAWEI,
#endif // VK_HUAWEI_cluster_culling_shader
};

enum class MemoryMapFlagBits : uint32_t {
#if VK_EXT_map_memory_placed
  bPlacedEXT = VK_MEMORY_MAP_PLACED_BIT_EXT,
#endif // VK_EXT_map_memory_placed
};

enum class ImageAspectFlagBits : uint32_t {
  bColor = VK_IMAGE_ASPECT_COLOR_BIT,
  bDepth = VK_IMAGE_ASPECT_DEPTH_BIT,
  bStencil = VK_IMAGE_ASPECT_STENCIL_BIT,
  bMetadata = VK_IMAGE_ASPECT_METADATA_BIT,
#if VK_VERSION_1_1
  bPlane0 = VK_IMAGE_ASPECT_PLANE_0_BIT,
  bPlane1 = VK_IMAGE_ASPECT_PLANE_1_BIT,
  bPlane2 = VK_IMAGE_ASPECT_PLANE_2_BIT,
#endif // VK_VERSION_1_1
#if VK_VERSION_1_3
  eNone = VK_IMAGE_ASPECT_NONE,
#endif // VK_VERSION_1_3
#if VK_KHR_sampler_ycbcr_conversion
  bPlane0KHR = VK_IMAGE_ASPECT_PLANE_0_BIT_KHR,
  bPlane1KHR = VK_IMAGE_ASPECT_PLANE_1_BIT_KHR,
  bPlane2KHR = VK_IMAGE_ASPECT_PLANE_2_BIT_KHR,
#endif // VK_KHR_sampler_ycbcr_conversion
#if VK_EXT_image_drm_format_modifier
  bMemoryPlane0EXT = VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT,
  bMemoryPlane1EXT = VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT,
  bMemoryPlane2EXT = VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT,
  bMemoryPlane3EXT = VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT,
#endif // VK_EXT_image_drm_format_modifier
#if VK_KHR_maintenance4
  eNoneKHR = VK_IMAGE_ASPECT_NONE_KHR,
#endif // VK_KHR_maintenance4
};

enum class SparseImageFormatFlagBits : uint32_t {
  // Image uses a single mip tail region for all array layers
  bSingleMiptail = VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT,
  // Image requires mip level dimensions to be an integer multiple of the sparse image block dimensions for non-tail mip levels.
  bAlignedMipSize = VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT,
  // Image uses a non-standard sparse image block dimensions
  bNonstandardBlockSize = VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT,
};

enum class SparseMemoryBindFlagBits : uint32_t {
  // Operation binds resource metadata to memory
  bMetadata = VK_SPARSE_MEMORY_BIND_METADATA_BIT,
};

enum class PipelineStageFlagBits : uint32_t {
  // Before subsequent commands are processed
  bTopOfPipe = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT,
  // Draw/DispatchIndirect command fetch
  bDrawIndirect = VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT,
  // Vertex/index fetch
  bVertexInput = VK_PIPELINE_STAGE_VERTEX_INPUT_BIT,
  // Vertex shading
  bVertexShader = VK_PIPELINE_STAGE_VERTEX_SHADER_BIT,
  // Tessellation control shading
  bTessellationControlShader = VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT,
  // Tessellation evaluation shading
  bTessellationEvaluationShader = VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT,
  // Geometry shading
  bGeometryShader = VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT,
  // Fragment shading
  bFragmentShader = VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT,
  // Early fragment (depth and stencil) tests
  bEarlyFragmentTests = VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT,
  // Late fragment (depth and stencil) tests
  bLateFragmentTests = VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT,
  // Color attachment writes
  bColorAttachmentOutput = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT,
  // Compute shading
  bComputeShader = VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,
  // Transfer/copy operations
  bTransfer = VK_PIPELINE_STAGE_TRANSFER_BIT,
  // After previous commands have completed
  bBottomOfPipe = VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT,
  // Indicates host (CPU) is a source/sink of the dependency
  bHost = VK_PIPELINE_STAGE_HOST_BIT,
  // All stages of the graphics pipeline
  bAllGraphics = VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT,
  // All stages supported on the queue
  bAllCommands = VK_PIPELINE_STAGE_ALL_COMMANDS_BIT,
#if VK_VERSION_1_3
  eNone = VK_PIPELINE_STAGE_NONE,
#endif // VK_VERSION_1_3
#if VK_EXT_transform_feedback
  bTransformFeedbackEXT = VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT,
#endif // VK_EXT_transform_feedback
#if VK_EXT_conditional_rendering
  // A pipeline stage for conditional rendering predicate fetch
  bConditionalRenderingEXT = VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT,
#endif // VK_EXT_conditional_rendering
#if VK_KHR_acceleration_structure
  bAccelerationStructureBuildKHR = VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR,
#endif // VK_KHR_acceleration_structure
#if VK_KHR_ray_tracing_pipeline
  bRayTracingShaderKHR = VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR,
#endif // VK_KHR_ray_tracing_pipeline
#if VK_NV_shading_rate_image
  bShadingRateImageNV = VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV,
#endif // VK_NV_shading_rate_image
#if VK_NV_mesh_shader
  bTaskShaderNV = VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV,
  bMeshShaderNV = VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV,
#endif // VK_NV_mesh_shader
#if VK_EXT_fragment_density_map
  bFragmentDensityProcessEXT = VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT,
#endif // VK_EXT_fragment_density_map
#if VK_KHR_fragment_shading_rate
  bFragmentShadingRateAttachmentKHR = VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR,
#endif // VK_KHR_fragment_shading_rate
#if VK_NV_device_generated_commands
  bCommandPreprocessNV = VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_NV,
#endif // VK_NV_device_generated_commands
#if VK_KHR_synchronization2
  eNoneKHR = VK_PIPELINE_STAGE_NONE_KHR,
#endif // VK_KHR_synchronization2
#if VK_EXT_mesh_shader
  bTaskShaderEXT = VK_PIPELINE_STAGE_TASK_SHADER_BIT_EXT,
  bMeshShaderEXT = VK_PIPELINE_STAGE_MESH_SHADER_BIT_EXT,
#endif // VK_EXT_mesh_shader
#if VK_EXT_device_generated_commands
  bCommandPreprocessEXT = VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_EXT,
#endif // VK_EXT_device_generated_commands
};

enum class CommandPoolCreateFlagBits : uint32_t {
  // Command buffers have a short lifetime
  bTransient = VK_COMMAND_POOL_CREATE_TRANSIENT_BIT,
  // Command buffers may release their memory individually
  bResetCommandBuffer = VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT,
#if VK_VERSION_1_1
  // Command buffers allocated from pool are protected command buffers
  bProtected = VK_COMMAND_POOL_CREATE_PROTECTED_BIT,
#endif // VK_VERSION_1_1
};

enum class CommandPoolResetFlagBits : uint32_t {
  // Release resources owned by the pool
  bReleaseResources = VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT,
};

enum class CommandBufferResetFlagBits : uint32_t {
  // Release resources owned by the buffer
  bReleaseResources = VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT,
};

enum class SampleCountFlagBits : uint32_t {
  // Sample count 1 supported
  b1 = VK_SAMPLE_COUNT_1_BIT,
  // Sample count 2 supported
  b2 = VK_SAMPLE_COUNT_2_BIT,
  // Sample count 4 supported
  b4 = VK_SAMPLE_COUNT_4_BIT,
  // Sample count 8 supported
  b8 = VK_SAMPLE_COUNT_8_BIT,
  // Sample count 16 supported
  b16 = VK_SAMPLE_COUNT_16_BIT,
  // Sample count 32 supported
  b32 = VK_SAMPLE_COUNT_32_BIT,
  // Sample count 64 supported
  b64 = VK_SAMPLE_COUNT_64_BIT,
};

enum class AttachmentDescriptionFlagBits : uint32_t {
  // The attachment may alias physical memory of another attachment in the same render pass
  bMayAlias = VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT,
};

enum class StencilFaceFlagBits : uint32_t {
  // Front face
  bFront = VK_STENCIL_FACE_FRONT_BIT,
  // Back face
  bBack = VK_STENCIL_FACE_BACK_BIT,
  // Front and back faces
  eFrontAndBack = VK_STENCIL_FACE_FRONT_AND_BACK,
};

enum class DescriptorPoolCreateFlagBits : uint32_t {
  // Descriptor sets may be freed individually
  bFreeDescriptorSet = VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT,
#if VK_VERSION_1_2
  bUpdateAfterBind = VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT,
#endif // VK_VERSION_1_2
#if VK_EXT_descriptor_indexing
  bUpdateAfterBindEXT = VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT,
#endif // VK_EXT_descriptor_indexing
#if VK_VALVE_mutable_descriptor_type
  bHostOnlyVALVE = VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_VALVE,
#endif // VK_VALVE_mutable_descriptor_type
#if VK_EXT_mutable_descriptor_type
  bHostOnlyEXT = VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_EXT,
#endif // VK_EXT_mutable_descriptor_type
#if VK_NV_descriptor_pool_overallocation
  bAllowOverallocationSetsNV = VK_DESCRIPTOR_POOL_CREATE_ALLOW_OVERALLOCATION_SETS_BIT_NV,
  bAllowOverallocationPoolsNV = VK_DESCRIPTOR_POOL_CREATE_ALLOW_OVERALLOCATION_POOLS_BIT_NV,
#endif // VK_NV_descriptor_pool_overallocation
};

enum class DependencyFlagBits : uint32_t {
  // Dependency is per pixel region 
  bByRegion = VK_DEPENDENCY_BY_REGION_BIT,
#if VK_VERSION_1_1
  // Dependency is across devices
  bDeviceGroup = VK_DEPENDENCY_DEVICE_GROUP_BIT,
  bViewLocal = VK_DEPENDENCY_VIEW_LOCAL_BIT,
#endif // VK_VERSION_1_1
#if VK_KHR_multiview
  bViewLocalKHR = VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR,
#endif // VK_KHR_multiview
#if VK_KHR_device_group
  bDeviceGroupKHR = VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR,
#endif // VK_KHR_device_group
#if VK_EXT_attachment_feedback_loop_layout
  // Dependency may be a feedback loop
  bFeedbackLoopEXT = VK_DEPENDENCY_FEEDBACK_LOOP_BIT_EXT,
#endif // VK_EXT_attachment_feedback_loop_layout
#if VK_KHR_maintenance8
  bQueueFamilyOwnershipTransferUseAllStagesKHR = VK_DEPENDENCY_QUEUE_FAMILY_OWNERSHIP_TRANSFER_USE_ALL_STAGES_BIT_KHR,
#endif // VK_KHR_maintenance8
#if VK_KHR_maintenance9
  bAsymmetricEventKHR = VK_DEPENDENCY_ASYMMETRIC_EVENT_BIT_KHR,
#endif // VK_KHR_maintenance9
};
#endif // VK_VERSION_1_0

#if VK_VERSION_1_2
enum class SemaphoreType : int32_t {
  eBinary = VK_SEMAPHORE_TYPE_BINARY,
  eTimeline = VK_SEMAPHORE_TYPE_TIMELINE,
#if VK_KHR_timeline_semaphore
  eBinaryKHR = VK_SEMAPHORE_TYPE_BINARY_KHR,
  eTimelineKHR = VK_SEMAPHORE_TYPE_TIMELINE_KHR,
#endif // VK_KHR_timeline_semaphore
};

enum class SemaphoreWaitFlagBits : uint32_t {
  bAny = VK_SEMAPHORE_WAIT_ANY_BIT,
#if VK_KHR_timeline_semaphore
  bAnyKHR = VK_SEMAPHORE_WAIT_ANY_BIT_KHR,
#endif // VK_KHR_timeline_semaphore
};
#endif // VK_VERSION_1_2

#if VK_KHR_surface
enum class PresentModeKHR : int32_t {
  eImmediate = VK_PRESENT_MODE_IMMEDIATE_KHR,
  eMailbox = VK_PRESENT_MODE_MAILBOX_KHR,
  eFifo = VK_PRESENT_MODE_FIFO_KHR,
  eFifoRelaxed = VK_PRESENT_MODE_FIFO_RELAXED_KHR,
#if VK_KHR_shared_presentable_image
  eSharedDemandRefresh = VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR,
  eSharedContinuousRefresh = VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR,
#endif // VK_KHR_shared_presentable_image
#if VK_EXT_present_mode_fifo_latest_ready
  eFifoLatestReadyEXT = VK_PRESENT_MODE_FIFO_LATEST_READY_EXT,
#endif // VK_EXT_present_mode_fifo_latest_ready
#if VK_KHR_present_mode_fifo_latest_ready
  eFifoLatestReady = VK_PRESENT_MODE_FIFO_LATEST_READY_KHR,
#endif // VK_KHR_present_mode_fifo_latest_ready
};

enum class ColorSpaceKHR : int32_t {
  eSrgbNonlinear = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR,
#if VK_EXT_swapchain_colorspace
  eDisplayP3NonlinearEXT = VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT,
  eExtendedSrgbLinearEXT = VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT,
  eDisplayP3LinearEXT = VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT,
  eDciP3NonlinearEXT = VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT,
  eBt709LinearEXT = VK_COLOR_SPACE_BT709_LINEAR_EXT,
  eBt709NonlinearEXT = VK_COLOR_SPACE_BT709_NONLINEAR_EXT,
  eBt2020LinearEXT = VK_COLOR_SPACE_BT2020_LINEAR_EXT,
  eHdr10St2084EXT = VK_COLOR_SPACE_HDR10_ST2084_EXT,
  eHdr10HlgEXT = VK_COLOR_SPACE_HDR10_HLG_EXT,
  eAdobergbLinearEXT = VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT,
  eAdobergbNonlinearEXT = VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT,
  ePassThroughEXT = VK_COLOR_SPACE_PASS_THROUGH_EXT,
  eExtendedSrgbNonlinearEXT = VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT,
#endif // VK_EXT_swapchain_colorspace
#if VK_AMD_display_native_hdr
  eDisplayNativeAMD = VK_COLOR_SPACE_DISPLAY_NATIVE_AMD,
#endif // VK_AMD_display_native_hdr
};
#endif // VK_KHR_surface

#if VK_KHR_display
enum class DisplayPlaneAlphaFlagBitsKHR : uint32_t {
  bOpaque = VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR,
  bGlobal = VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR,
  bPerPixel = VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR,
  bPerPixelPremultiplied = VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR,
};
#endif // VK_KHR_display

#if VK_KHR_surface
enum class CompositeAlphaFlagBitsKHR : uint32_t {
  bOpaque = VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR,
  bPreMultiplied = VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR,
  bPostMultiplied = VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR,
  bInherit = VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR,
};

enum class SurfaceTransformFlagBitsKHR : uint32_t {
  bIdentity = VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR,
  bRotate90 = VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR,
  bRotate180 = VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR,
  bRotate270 = VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR,
  bHorizontalMirror = VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR,
  bHorizontalMirrorRotate90 = VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR,
  bHorizontalMirrorRotate180 = VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR,
  bHorizontalMirrorRotate270 = VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR,
  bInherit = VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR,
};
#endif // VK_KHR_surface

#if VK_NV_display_stereo
enum class DisplaySurfaceStereoTypeNV : int32_t {
  eNone = VK_DISPLAY_SURFACE_STEREO_TYPE_NONE_NV,
  eOnboardDin = VK_DISPLAY_SURFACE_STEREO_TYPE_ONBOARD_DIN_NV,
  eHdmi3D = VK_DISPLAY_SURFACE_STEREO_TYPE_HDMI_3D_NV,
  eInbandDisplayport = VK_DISPLAY_SURFACE_STEREO_TYPE_INBAND_DISPLAYPORT_NV,
};
#endif // VK_NV_display_stereo

#if VK_KHR_calibrated_timestamps
enum class TimeDomainKHR : int32_t {
  eDevice = VK_TIME_DOMAIN_DEVICE_KHR,
  eClockMonotonic = VK_TIME_DOMAIN_CLOCK_MONOTONIC_KHR,
  eClockMonotonicRaw = VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_KHR,
  eQueryPerformanceCounter = VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_KHR,
#if VK_EXT_calibrated_timestamps
  eDeviceEXT = VK_TIME_DOMAIN_DEVICE_EXT,
  eClockMonotonicEXT = VK_TIME_DOMAIN_CLOCK_MONOTONIC_EXT,
  eClockMonotonicRawEXT = VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_EXT,
  eQueryPerformanceCounterEXT = VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_EXT,
#endif // VK_EXT_calibrated_timestamps
};
#endif // VK_KHR_calibrated_timestamps

#if VK_EXT_debug_marker
enum class DebugReportObjectTypeEXT : int32_t {
  eUnknown = VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT,
  eInstance = VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT,
  ePhysicalDevice = VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT,
  eDevice = VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT,
  eQueue = VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT,
  eSemaphore = VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT,
  eCommandBuffer = VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT,
  eFence = VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT,
  eDeviceMemory = VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT,
  eBuffer = VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT,
  eImage = VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT,
  eEvent = VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT,
  eQueryPool = VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT,
  eBufferView = VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT,
  eImageView = VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT,
  eShaderModule = VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT,
  ePipelineCache = VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT,
  ePipelineLayout = VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT,
  eRenderPass = VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT,
  ePipeline = VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT,
  eDescriptorSetLayout = VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT,
  eSampler = VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT,
  eDescriptorPool = VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT,
  eDescriptorSet = VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT,
  eFramebuffer = VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT,
  eCommandPool = VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT,
  eSurfaceKhr = VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT,
  eSwapchainKhr = VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT,
  eDebugReportCallbackExt = VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT,
  eDisplayKhr = VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT,
  eDisplayModeKhr = VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT,
  eValidationCacheExt = VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT,
};
#endif // VK_EXT_debug_marker

#if VK_EXT_device_memory_report
enum class DeviceMemoryReportEventTypeEXT : int32_t {
  eAllocate = VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATE_EXT,
  eFree = VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_FREE_EXT,
  eImport = VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_IMPORT_EXT,
  eUnimport = VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_UNIMPORT_EXT,
  eAllocationFailed = VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATION_FAILED_EXT,
};
#endif // VK_EXT_device_memory_report

#if VK_AMD_rasterization_order
enum class RasterizationOrderAMD : int32_t {
  eStrict = VK_RASTERIZATION_ORDER_STRICT_AMD,
  eRelaxed = VK_RASTERIZATION_ORDER_RELAXED_AMD,
};
#endif // VK_AMD_rasterization_order

#if VK_NV_cluster_acceleration_structure
enum class ClusterAccelerationStructureIndexFormatFlagBitsNV : uint32_t {
  e8Bit = VK_CLUSTER_ACCELERATION_STRUCTURE_INDEX_FORMAT_8BIT_NV,
  e16Bit = VK_CLUSTER_ACCELERATION_STRUCTURE_INDEX_FORMAT_16BIT_NV,
  e32Bit = VK_CLUSTER_ACCELERATION_STRUCTURE_INDEX_FORMAT_32BIT_NV,
};

enum class ClusterAccelerationStructureTypeNV : int32_t {
  eClustersBottomLevel = VK_CLUSTER_ACCELERATION_STRUCTURE_TYPE_CLUSTERS_BOTTOM_LEVEL_NV,
  eTriangleCluster = VK_CLUSTER_ACCELERATION_STRUCTURE_TYPE_TRIANGLE_CLUSTER_NV,
  eTriangleClusterTemplate = VK_CLUSTER_ACCELERATION_STRUCTURE_TYPE_TRIANGLE_CLUSTER_TEMPLATE_NV,
};

enum class ClusterAccelerationStructureOpTypeNV : int32_t {
  eMoveObjects = VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_MOVE_OBJECTS_NV,
  eBuildClustersBottomLevel = VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_CLUSTERS_BOTTOM_LEVEL_NV,
  eBuildTriangleCluster = VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_TRIANGLE_CLUSTER_NV,
  eBuildTriangleClusterTemplate = VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_TRIANGLE_CLUSTER_TEMPLATE_NV,
  eInstantiateTriangleCluster = VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_INSTANTIATE_TRIANGLE_CLUSTER_NV,
  eGetClusterTemplateIndices = VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_GET_CLUSTER_TEMPLATE_INDICES_NV,
};

enum class ClusterAccelerationStructureOpModeNV : int32_t {
  eImplicitDestinations = VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_IMPLICIT_DESTINATIONS_NV,
  eExplicitDestinations = VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_EXPLICIT_DESTINATIONS_NV,
  eComputeSizes = VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_COMPUTE_SIZES_NV,
};

enum class ClusterAccelerationStructureClusterFlagBitsNV : uint32_t {
  eAllowDisableOpacityMicromaps = VK_CLUSTER_ACCELERATION_STRUCTURE_CLUSTER_ALLOW_DISABLE_OPACITY_MICROMAPS_NV,
};

enum class ClusterAccelerationStructureGeometryFlagBitsNV : uint32_t {
  bCullDisable = VK_CLUSTER_ACCELERATION_STRUCTURE_GEOMETRY_CULL_DISABLE_BIT_NV,
  bNoDuplicateAnyhitInvocation = VK_CLUSTER_ACCELERATION_STRUCTURE_GEOMETRY_NO_DUPLICATE_ANYHIT_INVOCATION_BIT_NV,
  bOpaque = VK_CLUSTER_ACCELERATION_STRUCTURE_GEOMETRY_OPAQUE_BIT_NV,
};

enum class ClusterAccelerationStructureAddressResolutionFlagBitsNV : uint32_t {
  eNone = VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_NONE_NV,
  bIndirectedDstImplicitData = VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_DST_IMPLICIT_DATA_BIT_NV,
  bIndirectedScratchData = VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_SCRATCH_DATA_BIT_NV,
  bIndirectedDstAddressArray = VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_DST_ADDRESS_ARRAY_BIT_NV,
  bIndirectedDstSizesArray = VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_DST_SIZES_ARRAY_BIT_NV,
  bIndirectedSrcInfosArray = VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_SRC_INFOS_ARRAY_BIT_NV,
  bIndirectedSrcInfosCount = VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_SRC_INFOS_COUNT_BIT_NV,
};
#endif // VK_NV_cluster_acceleration_structure

#if VK_EXT_layer_settings
enum class LayerSettingTypeEXT : int32_t {
  eBool32 = VK_LAYER_SETTING_TYPE_BOOL32_EXT,
  eInt32 = VK_LAYER_SETTING_TYPE_INT32_EXT,
  eInt64 = VK_LAYER_SETTING_TYPE_INT64_EXT,
  eUint32 = VK_LAYER_SETTING_TYPE_UINT32_EXT,
  eUint64 = VK_LAYER_SETTING_TYPE_UINT64_EXT,
  eFloat32 = VK_LAYER_SETTING_TYPE_FLOAT32_EXT,
  eFloat64 = VK_LAYER_SETTING_TYPE_FLOAT64_EXT,
  eString = VK_LAYER_SETTING_TYPE_STRING_EXT,
};
#endif // VK_EXT_layer_settings

#if VK_VERSION_1_1
enum class SubgroupFeatureFlagBits : uint32_t {
  // Basic subgroup operations
  bBasic = VK_SUBGROUP_FEATURE_BASIC_BIT,
  // Vote subgroup operations
  bVote = VK_SUBGROUP_FEATURE_VOTE_BIT,
  // Arithmetic subgroup operations
  bArithmetic = VK_SUBGROUP_FEATURE_ARITHMETIC_BIT,
  // Ballot subgroup operations
  bBallot = VK_SUBGROUP_FEATURE_BALLOT_BIT,
  // Shuffle subgroup operations
  bShuffle = VK_SUBGROUP_FEATURE_SHUFFLE_BIT,
  // Shuffle relative subgroup operations
  bShuffleRelative = VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT,
  // Clustered subgroup operations
  bClustered = VK_SUBGROUP_FEATURE_CLUSTERED_BIT,
  // Quad subgroup operations
  bQuad = VK_SUBGROUP_FEATURE_QUAD_BIT,
#if VK_VERSION_1_4
  bRotate = VK_SUBGROUP_FEATURE_ROTATE_BIT,
  bRotateClustered = VK_SUBGROUP_FEATURE_ROTATE_CLUSTERED_BIT,
#endif // VK_VERSION_1_4
#if VK_NV_shader_subgroup_partitioned
  bPartitionedNV = VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV,
#endif // VK_NV_shader_subgroup_partitioned
#if VK_KHR_shader_subgroup_rotate
  bRotateKHR = VK_SUBGROUP_FEATURE_ROTATE_BIT_KHR,
  bRotateClusteredKHR = VK_SUBGROUP_FEATURE_ROTATE_CLUSTERED_BIT_KHR,
#endif // VK_KHR_shader_subgroup_rotate
};
#endif // VK_VERSION_1_1

#if VK_NV_device_generated_commands
enum class IndirectCommandsLayoutUsageFlagBitsNV : uint32_t {
  bExplicitPreprocess = VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_NV,
  bIndexedSequences = VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NV,
  bUnorderedSequences = VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NV,
};

enum class IndirectStateFlagBitsNV : uint32_t {
  bFlagFrontface = VK_INDIRECT_STATE_FLAG_FRONTFACE_BIT_NV,
};

enum class IndirectCommandsTokenTypeNV : int32_t {
  eShaderGroup = VK_INDIRECT_COMMANDS_TOKEN_TYPE_SHADER_GROUP_NV,
  eStateFlags = VK_INDIRECT_COMMANDS_TOKEN_TYPE_STATE_FLAGS_NV,
  eIndexBuffer = VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NV,
  eVertexBuffer = VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NV,
  ePushConstant = VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV,
  eDrawIndexed = VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NV,
  eDraw = VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NV,
  eDrawTasks = VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_TASKS_NV,
#if VK_EXT_mesh_shader
  eDrawMeshTasks = VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_NV,
#endif // VK_EXT_mesh_shader
#if VK_NV_device_generated_commands_compute
  ePipeline = VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NV,
  eDispatch = VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NV,
#endif // VK_NV_device_generated_commands_compute
};
#endif // VK_NV_device_generated_commands

#if VK_VERSION_1_0
enum class DescriptorSetLayoutCreateFlagBits : uint32_t {
#if VK_VERSION_1_2
  bUpdateAfterBindPool = VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT,
#endif // VK_VERSION_1_2
#if VK_VERSION_1_4
  bPushDescriptor = VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT,
#endif // VK_VERSION_1_4
#if VK_KHR_push_descriptor
  // Descriptors are pushed via flink:vkCmdPushDescriptorSet
  bPushDescriptorKHR = VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR,
#endif // VK_KHR_push_descriptor
#if VK_EXT_descriptor_indexing
  bUpdateAfterBindPoolEXT = VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT,
#endif // VK_EXT_descriptor_indexing
#if VK_EXT_descriptor_buffer
  bDescriptorBufferEXT = VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT,
  bEmbeddedImmutableSamplersEXT = VK_DESCRIPTOR_SET_LAYOUT_CREATE_EMBEDDED_IMMUTABLE_SAMPLERS_BIT_EXT,
#endif // VK_EXT_descriptor_buffer
#if VK_VALVE_mutable_descriptor_type
  bHostOnlyPoolVALVE = VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_VALVE,
#endif // VK_VALVE_mutable_descriptor_type
#if VK_NV_device_generated_commands_compute
  bIndirectBindableNV = VK_DESCRIPTOR_SET_LAYOUT_CREATE_INDIRECT_BINDABLE_BIT_NV,
#endif // VK_NV_device_generated_commands_compute
#if VK_EXT_mutable_descriptor_type
  bHostOnlyPoolEXT = VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_EXT,
#endif // VK_EXT_mutable_descriptor_type
#if VK_NV_per_stage_descriptor_set
  bPerStageNV = VK_DESCRIPTOR_SET_LAYOUT_CREATE_PER_STAGE_BIT_NV,
#endif // VK_NV_per_stage_descriptor_set
};
#endif // VK_VERSION_1_0

#if VK_VERSION_1_1
enum class ExternalMemoryHandleTypeFlagBits : uint32_t {
  bOpaqueFd = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT,
  bOpaqueWin32 = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT,
  bOpaqueWin32Kmt = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
  bD3D11Texture = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT,
  bD3D11TextureKmt = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT,
  bD3D12Heap = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT,
  bD3D12Resource = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT,
#if VK_KHR_external_memory_capabilities
  bOpaqueFdKHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR,
  bOpaqueWin32KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR,
  bOpaqueWin32KmtKHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR,
  bD3D11TextureKHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR,
  bD3D11TextureKmtKHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR,
  bD3D12HeapKHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR,
  bD3D12ResourceKHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR,
#endif // VK_KHR_external_memory_capabilities
#if VK_EXT_external_memory_dma_buf
  bDmaBufEXT = VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT,
#endif // VK_EXT_external_memory_dma_buf
#if VK_ANDROID_external_memory_android_hardware_buffer
  bAndroidHardwareBufferANDROID = VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID,
#endif // VK_ANDROID_external_memory_android_hardware_buffer
#if VK_EXT_external_memory_host
  bHostAllocationEXT = VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT,
  bHostMappedForeignMemoryEXT = VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT,
#endif // VK_EXT_external_memory_host
#if VK_FUCHSIA_external_memory
  bZirconVmoFUCHSIA = VK_EXTERNAL_MEMORY_HANDLE_TYPE_ZIRCON_VMO_BIT_FUCHSIA,
#endif // VK_FUCHSIA_external_memory
#if VK_NV_external_memory_rdma
  bRdmaAddressNV = VK_EXTERNAL_MEMORY_HANDLE_TYPE_RDMA_ADDRESS_BIT_NV,
#endif // VK_NV_external_memory_rdma
#if VK_QNX_external_memory_screen_buffer
  bScreenBufferQNX = VK_EXTERNAL_MEMORY_HANDLE_TYPE_SCREEN_BUFFER_BIT_QNX,
#endif // VK_QNX_external_memory_screen_buffer
#if VK_EXT_external_memory_metal
  bMtlbufferEXT = VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLBUFFER_BIT_EXT,
  bMtltextureEXT = VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLTEXTURE_BIT_EXT,
  bMtlheapEXT = VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLHEAP_BIT_EXT,
#endif // VK_EXT_external_memory_metal
};

enum class ExternalMemoryFeatureFlagBits : uint32_t {
  bDedicatedOnly = VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT,
  bExportable = VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT,
  bImportable = VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT,
#if VK_KHR_external_memory_capabilities
  bDedicatedOnlyKHR = VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR,
  bExportableKHR = VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR,
  bImportableKHR = VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR,
#endif // VK_KHR_external_memory_capabilities
};

enum class ExternalSemaphoreHandleTypeFlagBits : uint32_t {
  bOpaqueFd = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT,
  bOpaqueWin32 = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT,
  bOpaqueWin32Kmt = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
  bD3D12Fence = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT,
  bD3D11Fence = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE_BIT,
  bSyncFd = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT,
#if VK_KHR_external_semaphore_capabilities
  bOpaqueFdKHR = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR,
  bOpaqueWin32KHR = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR,
  bOpaqueWin32KmtKHR = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR,
  bD3D12FenceKHR = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR,
  bSyncFdKHR = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR,
#endif // VK_KHR_external_semaphore_capabilities
#if VK_FUCHSIA_external_semaphore
  bZirconEventFUCHSIA = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_ZIRCON_EVENT_BIT_FUCHSIA,
#endif // VK_FUCHSIA_external_semaphore
};

enum class ExternalSemaphoreFeatureFlagBits : uint32_t {
  bExportable = VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT,
  bImportable = VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT,
#if VK_KHR_external_semaphore_capabilities
  bExportableKHR = VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR,
  bImportableKHR = VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR,
#endif // VK_KHR_external_semaphore_capabilities
};

enum class SemaphoreImportFlagBits : uint32_t {
  bTemporary = VK_SEMAPHORE_IMPORT_TEMPORARY_BIT,
#if VK_KHR_external_semaphore
  bTemporaryKHR = VK_SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR,
#endif // VK_KHR_external_semaphore
};

enum class ExternalFenceHandleTypeFlagBits : uint32_t {
  bOpaqueFd = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT,
  bOpaqueWin32 = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT,
  bOpaqueWin32Kmt = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
  bSyncFd = VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT,
#if VK_KHR_external_fence_capabilities
  bOpaqueFdKHR = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR,
  bOpaqueWin32KHR = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR,
  bOpaqueWin32KmtKHR = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR,
  bSyncFdKHR = VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR,
#endif // VK_KHR_external_fence_capabilities
};

enum class ExternalFenceFeatureFlagBits : uint32_t {
  bExportable = VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT,
  bImportable = VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT,
#if VK_KHR_external_fence_capabilities
  bExportableKHR = VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR,
  bImportableKHR = VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR,
#endif // VK_KHR_external_fence_capabilities
};

enum class FenceImportFlagBits : uint32_t {
  bTemporary = VK_FENCE_IMPORT_TEMPORARY_BIT,
#if VK_KHR_external_fence
  bTemporaryKHR = VK_FENCE_IMPORT_TEMPORARY_BIT_KHR,
#endif // VK_KHR_external_fence
};
#endif // VK_VERSION_1_1

#if VK_EXT_display_surface_counter
enum class SurfaceCounterFlagBitsEXT : uint32_t {
  bVblank = VK_SURFACE_COUNTER_VBLANK_BIT_EXT,
};
#endif // VK_EXT_display_surface_counter

#if VK_EXT_display_control
enum class DisplayPowerStateEXT : int32_t {
  eOff = VK_DISPLAY_POWER_STATE_OFF_EXT,
  eSuspend = VK_DISPLAY_POWER_STATE_SUSPEND_EXT,
  eOn = VK_DISPLAY_POWER_STATE_ON_EXT,
};

enum class DeviceEventTypeEXT : int32_t {
  eDisplayHotplug = VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT,
};

enum class DisplayEventTypeEXT : int32_t {
  eFirstPixelOut = VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT,
};
#endif // VK_EXT_display_control

#if VK_VERSION_1_1
enum class PeerMemoryFeatureFlagBits : uint32_t {
  // Can read with vkCmdCopy commands
  bCopySrc = VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT,
  // Can write with vkCmdCopy commands
  bCopyDst = VK_PEER_MEMORY_FEATURE_COPY_DST_BIT,
  // Can read with any access type/command
  bGenericSrc = VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT,
  // Can write with and access type/command
  bGenericDst = VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT,
#if VK_KHR_device_group
  bCopySrcKHR = VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHR,
  bCopyDstKHR = VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHR,
  bGenericSrcKHR = VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHR,
  bGenericDstKHR = VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHR,
#endif // VK_KHR_device_group
};

enum class MemoryAllocateFlagBits : uint32_t {
  // Force allocation on specific devices
  bDeviceMask = VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT,
#if VK_VERSION_1_2
  bDeviceAddress = VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT,
  bDeviceAddressCaptureReplay = VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT,
#endif // VK_VERSION_1_2
#if VK_KHR_device_group
  bDeviceMaskKHR = VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHR,
#endif // VK_KHR_device_group
#if VK_KHR_buffer_device_address
  bDeviceAddressKHR = VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT_KHR,
  bDeviceAddressCaptureReplayKHR = VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR,
#endif // VK_KHR_buffer_device_address
#if VK_EXT_zero_initialize_device_memory
  bZeroInitializeEXT = VK_MEMORY_ALLOCATE_ZERO_INITIALIZE_BIT_EXT,
#endif // VK_EXT_zero_initialize_device_memory
};
#endif // VK_VERSION_1_1

#if VK_KHR_swapchain
enum class DeviceGroupPresentModeFlagBitsKHR : uint32_t {
  // Present from local memory
  bLocal = VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR,
  // Present from remote memory
  bRemote = VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR,
  // Present sum of local and/or remote memory
  bSum = VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR,
  // Each physical device presents from local memory
  bLocalMultiDevice = VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR,
};

enum class SwapchainCreateFlagBitsKHR : uint32_t {
#if VK_KHR_swapchain
  // Allow images with VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT
  bSplitInstanceBindRegions = VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR,
  // Swapchain is protected
  bProtected = VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR,
#endif // VK_KHR_swapchain
#if VK_KHR_swapchain_mutable_format
  bMutableFormat = VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR,
#endif // VK_KHR_swapchain_mutable_format
#if VK_EXT_swapchain_maintenance1
  bDeferredMemoryAllocationEXT = VK_SWAPCHAIN_CREATE_DEFERRED_MEMORY_ALLOCATION_BIT_EXT,
#endif // VK_EXT_swapchain_maintenance1
#if VK_KHR_present_id2
  // Allow use of VK_KHR_present_id2 with this swapchain
  bPresentId2 = VK_SWAPCHAIN_CREATE_PRESENT_ID_2_BIT_KHR,
#endif // VK_KHR_present_id2
#if VK_KHR_present_wait2
  // Allow use of VK_KHR_present_wait2 with this swapchain
  bPresentWait2 = VK_SWAPCHAIN_CREATE_PRESENT_WAIT_2_BIT_KHR,
#endif // VK_KHR_present_wait2
#if VK_KHR_swapchain_maintenance1
  bDeferredMemoryAllocation = VK_SWAPCHAIN_CREATE_DEFERRED_MEMORY_ALLOCATION_BIT_KHR,
#endif // VK_KHR_swapchain_maintenance1
};
#endif // VK_KHR_swapchain

#if VK_NV_viewport_swizzle
enum class ViewportCoordinateSwizzleNV : int32_t {
  ePositiveX = VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV,
  eNegativeX = VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV,
  ePositiveY = VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV,
  eNegativeY = VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV,
  ePositiveZ = VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV,
  eNegativeZ = VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV,
  ePositiveW = VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV,
  eNegativeW = VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV,
};
#endif // VK_NV_viewport_swizzle

#if VK_EXT_discard_rectangles
enum class DiscardRectangleModeEXT : int32_t {
  eInclusive = VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT,
  eExclusive = VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT,
};
#endif // VK_EXT_discard_rectangles

#if VK_VERSION_1_0
enum class SubpassDescriptionFlagBits : uint32_t {
#if VK_NVX_multiview_per_view_attributes
  bPerViewAttributesNVX = VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX,
  bPerViewPositionXOnlyNVX = VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX,
#endif // VK_NVX_multiview_per_view_attributes
#if VK_QCOM_render_pass_shader_resolve
  bFragmentRegionQCOM = VK_SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_QCOM,
  bShaderResolveQCOM = VK_SUBPASS_DESCRIPTION_SHADER_RESOLVE_BIT_QCOM,
#endif // VK_QCOM_render_pass_shader_resolve
#if VK_QCOM_tile_shading
  bTileShadingApronQCOM = VK_SUBPASS_DESCRIPTION_TILE_SHADING_APRON_BIT_QCOM,
#endif // VK_QCOM_tile_shading
#if VK_ARM_rasterization_order_attachment_access
  bRasterizationOrderAttachmentColorAccessARM = VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_ARM,
  bRasterizationOrderAttachmentDepthAccessARM = VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_ARM,
  bRasterizationOrderAttachmentStencilAccessARM = VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_ARM,
#endif // VK_ARM_rasterization_order_attachment_access
#if VK_EXT_rasterization_order_attachment_access
  bRasterizationOrderAttachmentColorAccessEXT = VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_EXT,
  bRasterizationOrderAttachmentDepthAccessEXT = VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT,
  bRasterizationOrderAttachmentStencilAccessEXT = VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT,
#endif // VK_EXT_rasterization_order_attachment_access
#if VK_EXT_legacy_dithering
  bEnableLegacyDitheringEXT = VK_SUBPASS_DESCRIPTION_ENABLE_LEGACY_DITHERING_BIT_EXT,
#endif // VK_EXT_legacy_dithering
};
#endif // VK_VERSION_1_0

#if VK_VERSION_1_1
enum class PointClippingBehavior : int32_t {
  eAllClipPlanes = VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES,
  eUserClipPlanesOnly = VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY,
#if VK_KHR_maintenance2
  eAllClipPlanesKHR = VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES_KHR,
  eUserClipPlanesOnlyKHR = VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY_KHR,
#endif // VK_KHR_maintenance2
};
#endif // VK_VERSION_1_1

#if VK_VERSION_1_2
enum class SamplerReductionMode : int32_t {
  eWeightedAverage = VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE,
  eMin = VK_SAMPLER_REDUCTION_MODE_MIN,
  eMax = VK_SAMPLER_REDUCTION_MODE_MAX,
#if VK_EXT_sampler_filter_minmax
  eWeightedAverageEXT = VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT,
  eMinEXT = VK_SAMPLER_REDUCTION_MODE_MIN_EXT,
  eMaxEXT = VK_SAMPLER_REDUCTION_MODE_MAX_EXT,
#endif // VK_EXT_sampler_filter_minmax
#if VK_QCOM_filter_cubic_clamp
  eWeightedAverageRangeclampQCOM = VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM,
#endif // VK_QCOM_filter_cubic_clamp
};
#endif // VK_VERSION_1_2

#if VK_VERSION_1_1
enum class TessellationDomainOrigin : int32_t {
  eUpperLeft = VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT,
  eLowerLeft = VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT,
#if VK_KHR_maintenance2
  eUpperLeftKHR = VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT_KHR,
  eLowerLeftKHR = VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT_KHR,
#endif // VK_KHR_maintenance2
};

enum class SamplerYcbcrModelConversion : int32_t {
  eRgbIdentity = VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY,
  // just range expansion
  eYcbcrIdentity = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY,
  // aka HD YUV
  eYcbcr709 = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709,
  // aka SD YUV
  eYcbcr601 = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601,
  // aka UHD YUV
  eYcbcr2020 = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020,
#if VK_KHR_sampler_ycbcr_conversion
  eRgbIdentityKHR = VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY_KHR,
  eYcbcrIdentityKHR = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY_KHR,
  eYcbcr709KHR = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709_KHR,
  eYcbcr601KHR = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601_KHR,
  eYcbcr2020KHR = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020_KHR,
#endif // VK_KHR_sampler_ycbcr_conversion
};

enum class SamplerYcbcrRange : int32_t {
  // Luma 0..1 maps to 0..255, chroma -0.5..0.5 to 1..255 (clamped)
  eItuFull = VK_SAMPLER_YCBCR_RANGE_ITU_FULL,
  // Luma 0..1 maps to 16..235, chroma -0.5..0.5 to 16..240
  eItuNarrow = VK_SAMPLER_YCBCR_RANGE_ITU_NARROW,
#if VK_KHR_sampler_ycbcr_conversion
  eItuFullKHR = VK_SAMPLER_YCBCR_RANGE_ITU_FULL_KHR,
  eItuNarrowKHR = VK_SAMPLER_YCBCR_RANGE_ITU_NARROW_KHR,
#endif // VK_KHR_sampler_ycbcr_conversion
};

enum class ChromaLocation : int32_t {
  eCositedEven = VK_CHROMA_LOCATION_COSITED_EVEN,
  eMidpoint = VK_CHROMA_LOCATION_MIDPOINT,
#if VK_KHR_sampler_ycbcr_conversion
  eCositedEvenKHR = VK_CHROMA_LOCATION_COSITED_EVEN_KHR,
  eMidpointKHR = VK_CHROMA_LOCATION_MIDPOINT_KHR,
#endif // VK_KHR_sampler_ycbcr_conversion
};
#endif // VK_VERSION_1_1

#if VK_EXT_blend_operation_advanced
enum class BlendOverlapEXT : int32_t {
  eUncorrelated = VK_BLEND_OVERLAP_UNCORRELATED_EXT,
  eDisjoint = VK_BLEND_OVERLAP_DISJOINT_EXT,
  eConjoint = VK_BLEND_OVERLAP_CONJOINT_EXT,
};
#endif // VK_EXT_blend_operation_advanced

#if VK_NV_framebuffer_mixed_samples
enum class CoverageModulationModeNV : int32_t {
  eNone = VK_COVERAGE_MODULATION_MODE_NONE_NV,
  eRgb = VK_COVERAGE_MODULATION_MODE_RGB_NV,
  eAlpha = VK_COVERAGE_MODULATION_MODE_ALPHA_NV,
  eRgba = VK_COVERAGE_MODULATION_MODE_RGBA_NV,
};
#endif // VK_NV_framebuffer_mixed_samples

#if VK_NV_coverage_reduction_mode
enum class CoverageReductionModeNV : int32_t {
  eMerge = VK_COVERAGE_REDUCTION_MODE_MERGE_NV,
  eTruncate = VK_COVERAGE_REDUCTION_MODE_TRUNCATE_NV,
};
#endif // VK_NV_coverage_reduction_mode

#if VK_EXT_validation_cache
enum class ValidationCacheHeaderVersionEXT : int32_t {
  eOne = VK_VALIDATION_CACHE_HEADER_VERSION_ONE_EXT,
};
#endif // VK_EXT_validation_cache

#if VK_AMD_shader_info
enum class ShaderInfoTypeAMD : int32_t {
  eStatistics = VK_SHADER_INFO_TYPE_STATISTICS_AMD,
  eBinary = VK_SHADER_INFO_TYPE_BINARY_AMD,
  eDisassembly = VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD,
};
#endif // VK_AMD_shader_info

#if VK_VERSION_1_4
enum class QueueGlobalPriority : int32_t {
  eLow = VK_QUEUE_GLOBAL_PRIORITY_LOW,
  eMedium = VK_QUEUE_GLOBAL_PRIORITY_MEDIUM,
  eHigh = VK_QUEUE_GLOBAL_PRIORITY_HIGH,
  eRealtime = VK_QUEUE_GLOBAL_PRIORITY_REALTIME,
#if VK_EXT_global_priority
  eLowEXT = VK_QUEUE_GLOBAL_PRIORITY_LOW_EXT,
  eMediumEXT = VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT,
  eHighEXT = VK_QUEUE_GLOBAL_PRIORITY_HIGH_EXT,
  eRealtimeEXT = VK_QUEUE_GLOBAL_PRIORITY_REALTIME_EXT,
#endif // VK_EXT_global_priority
#if VK_KHR_global_priority
  eLowKHR = VK_QUEUE_GLOBAL_PRIORITY_LOW_KHR,
  eMediumKHR = VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_KHR,
  eHighKHR = VK_QUEUE_GLOBAL_PRIORITY_HIGH_KHR,
  eRealtimeKHR = VK_QUEUE_GLOBAL_PRIORITY_REALTIME_KHR,
#endif // VK_KHR_global_priority
};
#endif // VK_VERSION_1_4

#if VK_EXT_debug_utils
enum class DebugUtilsMessageSeverityFlagBitsEXT : uint32_t {
  bVerbose = VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT,
  bInfo = VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT,
  bWarning = VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT,
  bError = VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT,
};

enum class DebugUtilsMessageTypeFlagBitsEXT : uint32_t {
  bGeneral = VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT,
  bValidation = VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT,
  bPerformance = VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT,
#if VK_EXT_device_address_binding_report
  bDeviceAddressBinding = VK_DEBUG_UTILS_MESSAGE_TYPE_DEVICE_ADDRESS_BINDING_BIT_EXT,
#endif // VK_EXT_device_address_binding_report
};
#endif // VK_EXT_debug_utils

#if VK_EXT_conservative_rasterization
enum class ConservativeRasterizationModeEXT : int32_t {
  eDisabled = VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT,
  eOverestimate = VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT,
  eUnderestimate = VK_CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT,
};
#endif // VK_EXT_conservative_rasterization

#if VK_VERSION_1_2
enum class DescriptorBindingFlagBits : uint32_t {
  bUpdateAfterBind = VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT,
  bUpdateUnusedWhilePending = VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT,
  bPartiallyBound = VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT,
  bVariableDescriptorCount = VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT,
#if VK_EXT_descriptor_indexing
  bUpdateAfterBindEXT = VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT,
  bUpdateUnusedWhilePendingEXT = VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT,
  bPartiallyBoundEXT = VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT,
  bVariableDescriptorCountEXT = VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT,
#endif // VK_EXT_descriptor_indexing
};
#endif // VK_VERSION_1_2

#if VK_VERSION_1_0
enum class VendorId : int32_t {
  // Khronos vendor ID
  eKhronos = VK_VENDOR_ID_KHRONOS,
  // Vivante vendor ID
  eViv = VK_VENDOR_ID_VIV,
  // VeriSilicon vendor ID
  eVsi = VK_VENDOR_ID_VSI,
  // Kazan Software Renderer
  eKazan = VK_VENDOR_ID_KAZAN,
  // Codeplay Software Ltd. vendor ID
  eCodeplay = VK_VENDOR_ID_CODEPLAY,
  // Mesa vendor ID
  eMesa = VK_VENDOR_ID_MESA,
  // PoCL vendor ID
  ePocl = VK_VENDOR_ID_POCL,
  // Mobileye vendor ID
  eMobileye = VK_VENDOR_ID_MOBILEYE,
};
#endif // VK_VERSION_1_0

#if VK_VERSION_1_2
enum class DriverId : int32_t {
  // Advanced Micro Devices, Inc.
  eAmdProprietary = VK_DRIVER_ID_AMD_PROPRIETARY,
  // Advanced Micro Devices, Inc.
  eAmdOpenSource = VK_DRIVER_ID_AMD_OPEN_SOURCE,
  // Mesa open source project
  eMesaRadv = VK_DRIVER_ID_MESA_RADV,
  // NVIDIA Corporation
  eNvidiaProprietary = VK_DRIVER_ID_NVIDIA_PROPRIETARY,
  // Intel Corporation
  eIntelProprietaryWindows = VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS,
  // Intel Corporation
  eIntelOpenSourceMESA = VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA,
  // Imagination Technologies
  eImaginationProprietary = VK_DRIVER_ID_IMAGINATION_PROPRIETARY,
  // Qualcomm Technologies, Inc.
  eQualcommProprietary = VK_DRIVER_ID_QUALCOMM_PROPRIETARY,
  // Arm Limited
  eArmProprietary = VK_DRIVER_ID_ARM_PROPRIETARY,
  // Google LLC
  eGoogleSwiftshader = VK_DRIVER_ID_GOOGLE_SWIFTSHADER,
  // Google LLC
  eGgpProprietary = VK_DRIVER_ID_GGP_PROPRIETARY,
  // Broadcom Inc.
  eBroadcomProprietary = VK_DRIVER_ID_BROADCOM_PROPRIETARY,
  // Mesa
  eMesaLlvmpipe = VK_DRIVER_ID_MESA_LLVMPIPE,
  // MoltenVK
  eMoltenvk = VK_DRIVER_ID_MOLTENVK,
  // Core Avionics & Industrial Inc.
  eCoreaviProprietary = VK_DRIVER_ID_COREAVI_PROPRIETARY,
  // Juice Technologies, Inc.
  eJuiceProprietary = VK_DRIVER_ID_JUICE_PROPRIETARY,
  // Verisilicon, Inc.
  eVerisiliconProprietary = VK_DRIVER_ID_VERISILICON_PROPRIETARY,
  // Mesa open source project
  eMesaTurnip = VK_DRIVER_ID_MESA_TURNIP,
  // Mesa open source project
  eMesaV3Dv = VK_DRIVER_ID_MESA_V3DV,
  // Mesa open source project
  eMesaPanvk = VK_DRIVER_ID_MESA_PANVK,
  // Samsung Electronics Co., Ltd.
  eSamsungProprietary = VK_DRIVER_ID_SAMSUNG_PROPRIETARY,
  // Mesa open source project
  eMesaVenus = VK_DRIVER_ID_MESA_VENUS,
  // Mesa open source project
  eMesaDozen = VK_DRIVER_ID_MESA_DOZEN,
  // Mesa open source project
  eMesaNvk = VK_DRIVER_ID_MESA_NVK,
  // Imagination Technologies
  eImaginationOpenSourceMESA = VK_DRIVER_ID_IMAGINATION_OPEN_SOURCE_MESA,
  // Mesa open source project
  eMesaHoneykrisp = VK_DRIVER_ID_MESA_HONEYKRISP,
  // Vulkan SC Emulation on Vulkan
  eVulkanScEmulationOnVulkan = VK_DRIVER_ID_VULKAN_SC_EMULATION_ON_VULKAN,
#if VK_KHR_driver_properties
  eAmdProprietaryKHR = VK_DRIVER_ID_AMD_PROPRIETARY_KHR,
  eAmdOpenSourceKHR = VK_DRIVER_ID_AMD_OPEN_SOURCE_KHR,
  eMesaRadvKHR = VK_DRIVER_ID_MESA_RADV_KHR,
  eNvidiaProprietaryKHR = VK_DRIVER_ID_NVIDIA_PROPRIETARY_KHR,
  eIntelProprietaryWindowsKHR = VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS_KHR,
  eIntelOpenSourceMesaKHR = VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA_KHR,
  eImaginationProprietaryKHR = VK_DRIVER_ID_IMAGINATION_PROPRIETARY_KHR,
  eQualcommProprietaryKHR = VK_DRIVER_ID_QUALCOMM_PROPRIETARY_KHR,
  eArmProprietaryKHR = VK_DRIVER_ID_ARM_PROPRIETARY_KHR,
  eGoogleSwiftshaderKHR = VK_DRIVER_ID_GOOGLE_SWIFTSHADER_KHR,
  eGgpProprietaryKHR = VK_DRIVER_ID_GGP_PROPRIETARY_KHR,
  eBroadcomProprietaryKHR = VK_DRIVER_ID_BROADCOM_PROPRIETARY_KHR,
#endif // VK_KHR_driver_properties
};
#endif // VK_VERSION_1_2

#if VK_EXT_conditional_rendering
enum class ConditionalRenderingFlagBitsEXT : uint32_t {
  bInverted = VK_CONDITIONAL_RENDERING_INVERTED_BIT_EXT,
};
#endif // VK_EXT_conditional_rendering

#if VK_VERSION_1_2
enum class ResolveModeFlagBits : uint32_t {
  eNone = VK_RESOLVE_MODE_NONE,
  bSampleZero = VK_RESOLVE_MODE_SAMPLE_ZERO_BIT,
  bAverage = VK_RESOLVE_MODE_AVERAGE_BIT,
  bMin = VK_RESOLVE_MODE_MIN_BIT,
  bMax = VK_RESOLVE_MODE_MAX_BIT,
#if VK_KHR_depth_stencil_resolve
  eNoneKHR = VK_RESOLVE_MODE_NONE_KHR,
  bSampleZeroKHR = VK_RESOLVE_MODE_SAMPLE_ZERO_BIT_KHR,
  bAverageKHR = VK_RESOLVE_MODE_AVERAGE_BIT_KHR,
  bMinKHR = VK_RESOLVE_MODE_MIN_BIT_KHR,
  bMaxKHR = VK_RESOLVE_MODE_MAX_BIT_KHR,
#endif // VK_KHR_depth_stencil_resolve
#if VK_ANDROID_external_format_resolve
  bExternalFormatDownsampleANDROID = VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_BIT_ANDROID,
#endif // VK_ANDROID_external_format_resolve
};
#endif // VK_VERSION_1_2

#if VK_NV_shading_rate_image
enum class ShadingRatePaletteEntryNV : int32_t {
  eNoInvocations = VK_SHADING_RATE_PALETTE_ENTRY_NO_INVOCATIONS_NV,
  e16InvocationsPerPixel = VK_SHADING_RATE_PALETTE_ENTRY_16_INVOCATIONS_PER_PIXEL_NV,
  e8InvocationsPerPixel = VK_SHADING_RATE_PALETTE_ENTRY_8_INVOCATIONS_PER_PIXEL_NV,
  e4InvocationsPerPixel = VK_SHADING_RATE_PALETTE_ENTRY_4_INVOCATIONS_PER_PIXEL_NV,
  e2InvocationsPerPixel = VK_SHADING_RATE_PALETTE_ENTRY_2_INVOCATIONS_PER_PIXEL_NV,
  e1InvocationPerPixel = VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_PIXEL_NV,
  e1InvocationPer2X1Pixels = VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X1_PIXELS_NV,
  e1InvocationPer1X2Pixels = VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_1X2_PIXELS_NV,
  e1InvocationPer2X2Pixels = VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X2_PIXELS_NV,
  e1InvocationPer4X2Pixels = VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X2_PIXELS_NV,
  e1InvocationPer2X4Pixels = VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X4_PIXELS_NV,
  e1InvocationPer4X4Pixels = VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X4_PIXELS_NV,
};

enum class CoarseSampleOrderTypeNV : int32_t {
  eDefault = VK_COARSE_SAMPLE_ORDER_TYPE_DEFAULT_NV,
  eCustom = VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV,
  ePixelMajor = VK_COARSE_SAMPLE_ORDER_TYPE_PIXEL_MAJOR_NV,
  eSampleMajor = VK_COARSE_SAMPLE_ORDER_TYPE_SAMPLE_MAJOR_NV,
};
#endif // VK_NV_shading_rate_image

#if VK_KHR_acceleration_structure
enum class GeometryInstanceFlagBitsKHR : uint32_t {
  bTriangleFacingCullDisable = VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR,
  bTriangleFlipFacing = VK_GEOMETRY_INSTANCE_TRIANGLE_FLIP_FACING_BIT_KHR,
  bForceOpaque = VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_KHR,
  bForceNoOpaque = VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_KHR,
  bTriangleFrontCounterclockwise = VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_KHR,
#if VK_EXT_opacity_micromap
  bForceOpacityMicromap2StateEXT = VK_GEOMETRY_INSTANCE_FORCE_OPACITY_MICROMAP_2_STATE_BIT_EXT,
  bDisableOpacityMicromapsEXT = VK_GEOMETRY_INSTANCE_DISABLE_OPACITY_MICROMAPS_BIT_EXT,
#endif // VK_EXT_opacity_micromap
};

enum class GeometryFlagBitsKHR : uint32_t {
  bOpaque = VK_GEOMETRY_OPAQUE_BIT_KHR,
  bNoDuplicateAnyHitInvocation = VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR,
};

enum class BuildAccelerationStructureFlagBitsKHR : uint32_t {
  bAllowUpdate = VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR,
  bAllowCompaction = VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR,
  bPreferFastTrace = VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR,
  bPreferFastBuild = VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_KHR,
  bLowMemory = VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_KHR,
#if VK_NV_ray_tracing_motion_blur
  bMotionNV = VK_BUILD_ACCELERATION_STRUCTURE_MOTION_BIT_NV,
#endif // VK_NV_ray_tracing_motion_blur
#if VK_EXT_opacity_micromap
  bAllowOpacityMicromapUpdateEXT = VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_UPDATE_BIT_EXT,
  bAllowDisableOpacityMicromapsEXT = VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISABLE_OPACITY_MICROMAPS_BIT_EXT,
  bAllowOpacityMicromapDataUpdateEXT = VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_DATA_UPDATE_BIT_EXT,
#endif // VK_EXT_opacity_micromap
#if VK_KHR_ray_tracing_position_fetch
  bAllowDataAccess = VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DATA_ACCESS_BIT_KHR,
#endif // VK_KHR_ray_tracing_position_fetch
};

enum class AccelerationStructureCreateFlagBitsKHR : uint32_t {
  bDeviceAddressCaptureReplay = VK_ACCELERATION_STRUCTURE_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR,
#if VK_EXT_descriptor_buffer
  bDescriptorBufferCaptureReplayEXT = VK_ACCELERATION_STRUCTURE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT,
#endif // VK_EXT_descriptor_buffer
#if VK_NV_ray_tracing_motion_blur
  bMotionNV = VK_ACCELERATION_STRUCTURE_CREATE_MOTION_BIT_NV,
#endif // VK_NV_ray_tracing_motion_blur
};

enum class CopyAccelerationStructureModeKHR : int32_t {
  eClone = VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR,
  eCompact = VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR,
#if VK_KHR_acceleration_structure
  eSerialize = VK_COPY_ACCELERATION_STRUCTURE_MODE_SERIALIZE_KHR,
  eDeserialize = VK_COPY_ACCELERATION_STRUCTURE_MODE_DESERIALIZE_KHR,
#endif // VK_KHR_acceleration_structure
};

enum class BuildAccelerationStructureModeKHR : int32_t {
  eBuild = VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR,
  eUpdate = VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR,
};

enum class AccelerationStructureTypeKHR : int32_t {
  eTopLevel = VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR,
  eBottomLevel = VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR,
  eGeneric = VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR,
};

enum class GeometryTypeKHR : int32_t {
  eTriangles = VK_GEOMETRY_TYPE_TRIANGLES_KHR,
  eAabbs = VK_GEOMETRY_TYPE_AABBS_KHR,
  eInstances = VK_GEOMETRY_TYPE_INSTANCES_KHR,
#if VK_NV_ray_tracing_linear_swept_spheres
  eSpheresNV = VK_GEOMETRY_TYPE_SPHERES_NV,
  eLinearSweptSpheresNV = VK_GEOMETRY_TYPE_LINEAR_SWEPT_SPHERES_NV,
#endif // VK_NV_ray_tracing_linear_swept_spheres
};

enum class AccelerationStructureBuildTypeKHR : int32_t {
  eHost = VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_KHR,
  eDevice = VK_ACCELERATION_STRUCTURE_BUILD_TYPE_DEVICE_KHR,
  eHostOrDevice = VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_OR_DEVICE_KHR,
};
#endif // VK_KHR_acceleration_structure

#if VK_KHR_ray_tracing_pipeline
enum class RayTracingShaderGroupTypeKHR : int32_t {
  eGeneral = VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR,
  eTrianglesHitGroup = VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR,
  eProceduralHitGroup = VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR,
};
#endif // VK_KHR_ray_tracing_pipeline

#if VK_KHR_acceleration_structure
enum class AccelerationStructureCompatibilityKHR : int32_t {
  eCompatible = VK_ACCELERATION_STRUCTURE_COMPATIBILITY_COMPATIBLE_KHR,
  eIncompatible = VK_ACCELERATION_STRUCTURE_COMPATIBILITY_INCOMPATIBLE_KHR,
};
#endif // VK_KHR_acceleration_structure

#if VK_KHR_ray_tracing_pipeline
enum class ShaderGroupShaderKHR : int32_t {
  eGeneral = VK_SHADER_GROUP_SHADER_GENERAL_KHR,
  eClosestHit = VK_SHADER_GROUP_SHADER_CLOSEST_HIT_KHR,
  eAnyHit = VK_SHADER_GROUP_SHADER_ANY_HIT_KHR,
  eIntersection = VK_SHADER_GROUP_SHADER_INTERSECTION_KHR,
};
#endif // VK_KHR_ray_tracing_pipeline

#if VK_AMD_memory_overallocation_behavior
enum class MemoryOverallocationBehaviorAMD : int32_t {
  eDefault = VK_MEMORY_OVERALLOCATION_BEHAVIOR_DEFAULT_AMD,
  eAllowed = VK_MEMORY_OVERALLOCATION_BEHAVIOR_ALLOWED_AMD,
  eDisallowed = VK_MEMORY_OVERALLOCATION_BEHAVIOR_DISALLOWED_AMD,
};
#endif // VK_AMD_memory_overallocation_behavior

#if VK_VERSION_1_0
enum class FramebufferCreateFlagBits : uint32_t {
#if VK_VERSION_1_2
  bImageless = VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT,
#endif // VK_VERSION_1_2
#if VK_KHR_imageless_framebuffer
  bImagelessKHR = VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT_KHR,
#endif // VK_KHR_imageless_framebuffer
};

enum class QueryPoolCreateFlagBits : uint32_t {
#if VK_KHR_maintenance9
  bResetKHR = VK_QUERY_POOL_CREATE_RESET_BIT_KHR,
#endif // VK_KHR_maintenance9
};
#endif // VK_VERSION_1_0

#if VK_NV_device_diagnostics_config
enum class DeviceDiagnosticsConfigFlagBitsNV : uint32_t {
  bEnableShaderDebugInfo = VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_DEBUG_INFO_BIT_NV,
  bEnableResourceTracking = VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_RESOURCE_TRACKING_BIT_NV,
  bEnableAutomaticCheckpoints = VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_AUTOMATIC_CHECKPOINTS_BIT_NV,
  bEnableShaderErrorReporting = VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_ERROR_REPORTING_BIT_NV,
};
#endif // VK_NV_device_diagnostics_config

#if VK_VERSION_1_3
enum class PipelineCreationFeedbackFlagBits : uint32_t {
  bValid = VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT,
  bApplicationPipelineCacheHit = VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT,
  bBasePipelineAcceleration = VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT,
#if VK_EXT_pipeline_creation_feedback
  bValidEXT = VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT_EXT,
  bApplicationPipelineCacheHitEXT = VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT_EXT,
  bBasePipelineAccelerationEXT = VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT_EXT,
#endif // VK_EXT_pipeline_creation_feedback
};
#endif // VK_VERSION_1_3

#if VK_EXT_full_screen_exclusive
enum class FullScreenExclusiveEXT : int32_t {
  eDefault = VK_FULL_SCREEN_EXCLUSIVE_DEFAULT_EXT,
  eAllowed = VK_FULL_SCREEN_EXCLUSIVE_ALLOWED_EXT,
  eDisallowed = VK_FULL_SCREEN_EXCLUSIVE_DISALLOWED_EXT,
  eApplicationControlled = VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT,
};
#endif // VK_EXT_full_screen_exclusive

#if VK_KHR_performance_query
enum class PerformanceCounterScopeKHR : int32_t {
  eCommandBuffer = VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_BUFFER_KHR,
  eRenderPass = VK_PERFORMANCE_COUNTER_SCOPE_RENDER_PASS_KHR,
  eCommand = VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_KHR,
};
#endif // VK_KHR_performance_query

#if VK_NV_memory_decompression
enum class MemoryDecompressionMethodFlagBitsNV : uint64_t {
  bGdeflate10 = VK_MEMORY_DECOMPRESSION_METHOD_GDEFLATE_1_0_BIT_NV,
};
#endif // VK_NV_memory_decompression

#if VK_KHR_performance_query
enum class PerformanceCounterUnitKHR : int32_t {
  eGeneric = VK_PERFORMANCE_COUNTER_UNIT_GENERIC_KHR,
  ePercentage = VK_PERFORMANCE_COUNTER_UNIT_PERCENTAGE_KHR,
  eNanoseconds = VK_PERFORMANCE_COUNTER_UNIT_NANOSECONDS_KHR,
  eBytes = VK_PERFORMANCE_COUNTER_UNIT_BYTES_KHR,
  eBytesPerSecond = VK_PERFORMANCE_COUNTER_UNIT_BYTES_PER_SECOND_KHR,
  eKelvin = VK_PERFORMANCE_COUNTER_UNIT_KELVIN_KHR,
  eWatts = VK_PERFORMANCE_COUNTER_UNIT_WATTS_KHR,
  eVolts = VK_PERFORMANCE_COUNTER_UNIT_VOLTS_KHR,
  eAmps = VK_PERFORMANCE_COUNTER_UNIT_AMPS_KHR,
  eHertz = VK_PERFORMANCE_COUNTER_UNIT_HERTZ_KHR,
  eCycles = VK_PERFORMANCE_COUNTER_UNIT_CYCLES_KHR,
};

enum class PerformanceCounterStorageKHR : int32_t {
  eInt32 = VK_PERFORMANCE_COUNTER_STORAGE_INT32_KHR,
  eInt64 = VK_PERFORMANCE_COUNTER_STORAGE_INT64_KHR,
  eUint32 = VK_PERFORMANCE_COUNTER_STORAGE_UINT32_KHR,
  eUint64 = VK_PERFORMANCE_COUNTER_STORAGE_UINT64_KHR,
  eFloat32 = VK_PERFORMANCE_COUNTER_STORAGE_FLOAT32_KHR,
  eFloat64 = VK_PERFORMANCE_COUNTER_STORAGE_FLOAT64_KHR,
};

enum class PerformanceCounterDescriptionFlagBitsKHR : uint32_t {
  bPerformanceImpacting = VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_BIT_KHR,
  bConcurrentlyImpacted = VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_BIT_KHR,
};

enum class AcquireProfilingLockFlagBitsKHR : uint32_t {
};
#endif // VK_KHR_performance_query

#if VK_AMD_shader_core_properties2
enum class ShaderCorePropertiesFlagBitsAMD : uint32_t {
};
#endif // VK_AMD_shader_core_properties2

#if VK_INTEL_performance_query
enum class PerformanceConfigurationTypeINTEL : int32_t {
  eCommandQueueMetricsDiscoveryActivated = VK_PERFORMANCE_CONFIGURATION_TYPE_COMMAND_QUEUE_METRICS_DISCOVERY_ACTIVATED_INTEL,
};

enum class QueryPoolSamplingModeINTEL : int32_t {
  eManual = VK_QUERY_POOL_SAMPLING_MODE_MANUAL_INTEL,
};

enum class PerformanceOverrideTypeINTEL : int32_t {
  eNullHardware = VK_PERFORMANCE_OVERRIDE_TYPE_NULL_HARDWARE_INTEL,
  eFlushGpuCaches = VK_PERFORMANCE_OVERRIDE_TYPE_FLUSH_GPU_CACHES_INTEL,
};

enum class PerformanceParameterTypeINTEL : int32_t {
  eHwCountersSupported = VK_PERFORMANCE_PARAMETER_TYPE_HW_COUNTERS_SUPPORTED_INTEL,
  eStreamMarkerValidBits = VK_PERFORMANCE_PARAMETER_TYPE_STREAM_MARKER_VALID_BITS_INTEL,
};

enum class PerformanceValueTypeINTEL : int32_t {
  eUint32 = VK_PERFORMANCE_VALUE_TYPE_UINT32_INTEL,
  eUint64 = VK_PERFORMANCE_VALUE_TYPE_UINT64_INTEL,
  eFloat = VK_PERFORMANCE_VALUE_TYPE_FLOAT_INTEL,
  eBool = VK_PERFORMANCE_VALUE_TYPE_BOOL_INTEL,
  eString = VK_PERFORMANCE_VALUE_TYPE_STRING_INTEL,
};
#endif // VK_INTEL_performance_query

#if VK_VERSION_1_2
enum class ShaderFloatControlsIndependence : int32_t {
  e32BitOnly = VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY,
  eAll = VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL,
  eNone = VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE,
#if VK_KHR_shader_float_controls
  e32BitOnlyKHR = VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY_KHR,
  eAllKHR = VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL_KHR,
  eNoneKHR = VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE_KHR,
#endif // VK_KHR_shader_float_controls
};
#endif // VK_VERSION_1_2

#if VK_KHR_pipeline_executable_properties
enum class PipelineExecutableStatisticFormatKHR : int32_t {
  eBool32 = VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR,
  eInt64 = VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR,
  eUint64 = VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR,
  eFloat64 = VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR,
};
#endif // VK_KHR_pipeline_executable_properties

#if VK_VERSION_1_4
enum class LineRasterizationMode : int32_t {
  eDefault = VK_LINE_RASTERIZATION_MODE_DEFAULT,
  eRectangular = VK_LINE_RASTERIZATION_MODE_RECTANGULAR,
  eBresenham = VK_LINE_RASTERIZATION_MODE_BRESENHAM,
  eRectangularSmooth = VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH,
#if VK_EXT_line_rasterization
  eDefaultEXT = VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT,
  eRectangularEXT = VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT,
  eBresenhamEXT = VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT,
  eRectangularSmoothEXT = VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT,
#endif // VK_EXT_line_rasterization
#if VK_KHR_line_rasterization
  eDefaultKHR = VK_LINE_RASTERIZATION_MODE_DEFAULT_KHR,
  eRectangularKHR = VK_LINE_RASTERIZATION_MODE_RECTANGULAR_KHR,
  eBresenhamKHR = VK_LINE_RASTERIZATION_MODE_BRESENHAM_KHR,
  eRectangularSmoothKHR = VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_KHR,
#endif // VK_KHR_line_rasterization
};
#endif // VK_VERSION_1_4

#if VK_AMD_pipeline_compiler_control
enum class PipelineCompilerControlFlagBitsAMD : uint32_t {
};
#endif // VK_AMD_pipeline_compiler_control

#if VK_VERSION_1_3
enum class ToolPurposeFlagBits : uint32_t {
  bValidation = VK_TOOL_PURPOSE_VALIDATION_BIT,
  bProfiling = VK_TOOL_PURPOSE_PROFILING_BIT,
  bTracing = VK_TOOL_PURPOSE_TRACING_BIT,
  bAdditionalFeatures = VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT,
  bModifyingFeatures = VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT,
#if VK_EXT_tooling_info
  bValidationEXT = VK_TOOL_PURPOSE_VALIDATION_BIT_EXT,
  bProfilingEXT = VK_TOOL_PURPOSE_PROFILING_BIT_EXT,
  bTracingEXT = VK_TOOL_PURPOSE_TRACING_BIT_EXT,
  bAdditionalFeaturesEXT = VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT_EXT,
  bModifyingFeaturesEXT = VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT_EXT,
  bDebugMarkersEXT = VK_TOOL_PURPOSE_DEBUG_MARKERS_BIT_EXT,
  bDebugReportingEXT = VK_TOOL_PURPOSE_DEBUG_REPORTING_BIT_EXT,
#endif // VK_EXT_tooling_info
};
#endif // VK_VERSION_1_3

#if VK_KHR_fragment_shading_rate
enum class FragmentShadingRateCombinerOpKHR : int32_t {
  eKeep = VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR,
  eReplace = VK_FRAGMENT_SHADING_RATE_COMBINER_OP_REPLACE_KHR,
  eMin = VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MIN_KHR,
  eMax = VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MAX_KHR,
  eMul = VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MUL_KHR,
};
#endif // VK_KHR_fragment_shading_rate

#if VK_NV_fragment_shading_rate_enums
enum class FragmentShadingRateNV : int32_t {
  e1InvocationPerPixel = VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_PIXEL_NV,
  e1InvocationPer1X2Pixels = VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_1X2_PIXELS_NV,
  e1InvocationPer2X1Pixels = VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X1_PIXELS_NV,
  e1InvocationPer2X2Pixels = VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X2_PIXELS_NV,
  e1InvocationPer2X4Pixels = VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X4_PIXELS_NV,
  e1InvocationPer4X2Pixels = VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X2_PIXELS_NV,
  e1InvocationPer4X4Pixels = VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X4_PIXELS_NV,
  e2InvocationsPerPixel = VK_FRAGMENT_SHADING_RATE_2_INVOCATIONS_PER_PIXEL_NV,
  e4InvocationsPerPixel = VK_FRAGMENT_SHADING_RATE_4_INVOCATIONS_PER_PIXEL_NV,
  e8InvocationsPerPixel = VK_FRAGMENT_SHADING_RATE_8_INVOCATIONS_PER_PIXEL_NV,
  e16InvocationsPerPixel = VK_FRAGMENT_SHADING_RATE_16_INVOCATIONS_PER_PIXEL_NV,
  eNoInvocations = VK_FRAGMENT_SHADING_RATE_NO_INVOCATIONS_NV,
};

enum class FragmentShadingRateTypeNV : int32_t {
  eFragmentSize = VK_FRAGMENT_SHADING_RATE_TYPE_FRAGMENT_SIZE_NV,
  eEnums = VK_FRAGMENT_SHADING_RATE_TYPE_ENUMS_NV,
};
#endif // VK_NV_fragment_shading_rate_enums

#if VK_EXT_subpass_merge_feedback
enum class SubpassMergeStatusEXT : int32_t {
  eMerged = VK_SUBPASS_MERGE_STATUS_MERGED_EXT,
  eDisallowed = VK_SUBPASS_MERGE_STATUS_DISALLOWED_EXT,
  eNotMergedSideEffects = VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SIDE_EFFECTS_EXT,
  eNotMergedSamplesMismatch = VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SAMPLES_MISMATCH_EXT,
  eNotMergedViewsMismatch = VK_SUBPASS_MERGE_STATUS_NOT_MERGED_VIEWS_MISMATCH_EXT,
  eNotMergedAliasing = VK_SUBPASS_MERGE_STATUS_NOT_MERGED_ALIASING_EXT,
  eNotMergedDependencies = VK_SUBPASS_MERGE_STATUS_NOT_MERGED_DEPENDENCIES_EXT,
  eNotMergedIncompatibleInputAttachment = VK_SUBPASS_MERGE_STATUS_NOT_MERGED_INCOMPATIBLE_INPUT_ATTACHMENT_EXT,
  eNotMergedTooManyAttachments = VK_SUBPASS_MERGE_STATUS_NOT_MERGED_TOO_MANY_ATTACHMENTS_EXT,
  eNotMergedInsufficientStorage = VK_SUBPASS_MERGE_STATUS_NOT_MERGED_INSUFFICIENT_STORAGE_EXT,
  eNotMergedDepthStencilCount = VK_SUBPASS_MERGE_STATUS_NOT_MERGED_DEPTH_STENCIL_COUNT_EXT,
  eNotMergedResolveAttachmentReuse = VK_SUBPASS_MERGE_STATUS_NOT_MERGED_RESOLVE_ATTACHMENT_REUSE_EXT,
  eNotMergedSingleSubpass = VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SINGLE_SUBPASS_EXT,
  eNotMergedUnspecified = VK_SUBPASS_MERGE_STATUS_NOT_MERGED_UNSPECIFIED_EXT,
};
#endif // VK_EXT_subpass_merge_feedback

#if VK_VERSION_1_3
enum class AccessFlagBits2 : uint64_t {
  eNone = VK_ACCESS_2_NONE,
  bIndirectCommandRead = VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT,
  bIndexRead = VK_ACCESS_2_INDEX_READ_BIT,
  bVertexAttributeRead = VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT,
  bUniformRead = VK_ACCESS_2_UNIFORM_READ_BIT,
  bInputAttachmentRead = VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT,
  bShaderRead = VK_ACCESS_2_SHADER_READ_BIT,
  bShaderWrite = VK_ACCESS_2_SHADER_WRITE_BIT,
  bColorAttachmentRead = VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT,
  bColorAttachmentWrite = VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT,
  bDepthStencilAttachmentRead = VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT,
  bDepthStencilAttachmentWrite = VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT,
  bTransferRead = VK_ACCESS_2_TRANSFER_READ_BIT,
  bTransferWrite = VK_ACCESS_2_TRANSFER_WRITE_BIT,
  bHostRead = VK_ACCESS_2_HOST_READ_BIT,
  bHostWrite = VK_ACCESS_2_HOST_WRITE_BIT,
  bMemoryRead = VK_ACCESS_2_MEMORY_READ_BIT,
  bMemoryWrite = VK_ACCESS_2_MEMORY_WRITE_BIT,
  bShaderSampledRead = VK_ACCESS_2_SHADER_SAMPLED_READ_BIT,
  bShaderStorageRead = VK_ACCESS_2_SHADER_STORAGE_READ_BIT,
  bShaderStorageWrite = VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT,
#if VK_KHR_video_decode_queue
  bVideoDecodeReadKHR = VK_ACCESS_2_VIDEO_DECODE_READ_BIT_KHR,
  bVideoDecodeWriteKHR = VK_ACCESS_2_VIDEO_DECODE_WRITE_BIT_KHR,
#endif // VK_KHR_video_decode_queue
#if VK_KHR_video_encode_queue
  bVideoEncodeReadKHR = VK_ACCESS_2_VIDEO_ENCODE_READ_BIT_KHR,
  bVideoEncodeWriteKHR = VK_ACCESS_2_VIDEO_ENCODE_WRITE_BIT_KHR,
#endif // VK_KHR_video_encode_queue
#if VK_QCOM_tile_shading
  bShaderTileAttachmentReadQCOM = VK_ACCESS_2_SHADER_TILE_ATTACHMENT_READ_BIT_QCOM,
  bShaderTileAttachmentWriteQCOM = VK_ACCESS_2_SHADER_TILE_ATTACHMENT_WRITE_BIT_QCOM,
#endif // VK_QCOM_tile_shading
#if VK_KHR_synchronization2
  eNoneKHR = VK_ACCESS_2_NONE_KHR,
  bIndirectCommandReadKHR = VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT_KHR,
  bIndexReadKHR = VK_ACCESS_2_INDEX_READ_BIT_KHR,
  bVertexAttributeReadKHR = VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT_KHR,
  bUniformReadKHR = VK_ACCESS_2_UNIFORM_READ_BIT_KHR,
  bInputAttachmentReadKHR = VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT_KHR,
  bShaderReadKHR = VK_ACCESS_2_SHADER_READ_BIT_KHR,
  bShaderWriteKHR = VK_ACCESS_2_SHADER_WRITE_BIT_KHR,
  bColorAttachmentReadKHR = VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT_KHR,
  bColorAttachmentWriteKHR = VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT_KHR,
  bDepthStencilAttachmentReadKHR = VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT_KHR,
  bDepthStencilAttachmentWriteKHR = VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT_KHR,
  bTransferReadKHR = VK_ACCESS_2_TRANSFER_READ_BIT_KHR,
  bTransferWriteKHR = VK_ACCESS_2_TRANSFER_WRITE_BIT_KHR,
  bHostReadKHR = VK_ACCESS_2_HOST_READ_BIT_KHR,
  bHostWriteKHR = VK_ACCESS_2_HOST_WRITE_BIT_KHR,
  bMemoryReadKHR = VK_ACCESS_2_MEMORY_READ_BIT_KHR,
  bMemoryWriteKHR = VK_ACCESS_2_MEMORY_WRITE_BIT_KHR,
  bShaderSampledReadKHR = VK_ACCESS_2_SHADER_SAMPLED_READ_BIT_KHR,
  bShaderStorageReadKHR = VK_ACCESS_2_SHADER_STORAGE_READ_BIT_KHR,
  bShaderStorageWriteKHR = VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT_KHR,
  bTransformFeedbackWriteEXT = VK_ACCESS_2_TRANSFORM_FEEDBACK_WRITE_BIT_EXT,
  bTransformFeedbackCounterReadEXT = VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT,
  bTransformFeedbackCounterWriteEXT = VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT,
  // read access flag for reading conditional rendering predicate
  bConditionalRenderingReadEXT = VK_ACCESS_2_CONDITIONAL_RENDERING_READ_BIT_EXT,
  bCommandPreprocessReadNV = VK_ACCESS_2_COMMAND_PREPROCESS_READ_BIT_NV,
  bCommandPreprocessWriteNV = VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_NV,
  bFragmentShadingRateAttachmentReadKHR = VK_ACCESS_2_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR,
  bShadingRateImageReadNV = VK_ACCESS_2_SHADING_RATE_IMAGE_READ_BIT_NV,
  bAccelerationStructureReadKHR = VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR,
  bAccelerationStructureWriteKHR = VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_KHR,
  bFragmentDensityMapReadEXT = VK_ACCESS_2_FRAGMENT_DENSITY_MAP_READ_BIT_EXT,
  bColorAttachmentReadNoncoherentEXT = VK_ACCESS_2_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT,
#endif // VK_KHR_synchronization2
#if VK_EXT_descriptor_buffer
  bDescriptorBufferReadEXT = VK_ACCESS_2_DESCRIPTOR_BUFFER_READ_BIT_EXT,
#endif // VK_EXT_descriptor_buffer
#if VK_HUAWEI_invocation_mask
  bInvocationMaskReadHUAWEI = VK_ACCESS_2_INVOCATION_MASK_READ_BIT_HUAWEI,
#endif // VK_HUAWEI_invocation_mask
#if VK_EXT_opacity_micromap
  bMicromapReadEXT = VK_ACCESS_2_MICROMAP_READ_BIT_EXT,
  bMicromapWriteEXT = VK_ACCESS_2_MICROMAP_WRITE_BIT_EXT,
#endif // VK_EXT_opacity_micromap
#if VK_NV_optical_flow
  bOpticalFlowReadNV = VK_ACCESS_2_OPTICAL_FLOW_READ_BIT_NV,
  bOpticalFlowWriteNV = VK_ACCESS_2_OPTICAL_FLOW_WRITE_BIT_NV,
#endif // VK_NV_optical_flow
#if VK_ARM_data_graph
  bDataGraphReadARM = VK_ACCESS_2_DATA_GRAPH_READ_BIT_ARM,
  bDataGraphWriteARM = VK_ACCESS_2_DATA_GRAPH_WRITE_BIT_ARM,
#endif // VK_ARM_data_graph
};

enum class PipelineStageFlagBits2 : uint64_t {
  eNone = VK_PIPELINE_STAGE_2_NONE,
  bTopOfPipe = VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT,
  bDrawIndirect = VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT,
  bVertexInput = VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT,
  bVertexShader = VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT,
  bTessellationControlShader = VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT,
  bTessellationEvaluationShader = VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT,
  bGeometryShader = VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT,
  bFragmentShader = VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT,
  bEarlyFragmentTests = VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT,
  bLateFragmentTests = VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT,
  bColorAttachmentOutput = VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT,
  bComputeShader = VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT,
  bAllTransfer = VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT,
  bTransfer = VK_PIPELINE_STAGE_2_TRANSFER_BIT,
  bBottomOfPipe = VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT,
  bHost = VK_PIPELINE_STAGE_2_HOST_BIT,
  bAllGraphics = VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT,
  bAllCommands = VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT,
  bCopy = VK_PIPELINE_STAGE_2_COPY_BIT,
  bResolve = VK_PIPELINE_STAGE_2_RESOLVE_BIT,
  bBlit = VK_PIPELINE_STAGE_2_BLIT_BIT,
  bClear = VK_PIPELINE_STAGE_2_CLEAR_BIT,
  bIndexInput = VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT,
  bVertexAttributeInput = VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT,
  bPreRasterizationShaders = VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT,
#if VK_KHR_video_decode_queue
  bVideoDecodeKHR = VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR,
#endif // VK_KHR_video_decode_queue
#if VK_KHR_video_encode_queue
  bVideoEncodeKHR = VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR,
#endif // VK_KHR_video_encode_queue
#if VK_KHR_synchronization2
  eNoneKHR = VK_PIPELINE_STAGE_2_NONE_KHR,
  bTopOfPipeKHR = VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT_KHR,
  bDrawIndirectKHR = VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT_KHR,
  bVertexInputKHR = VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT_KHR,
  bVertexShaderKHR = VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT_KHR,
  bTessellationControlShaderKHR = VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT_KHR,
  bTessellationEvaluationShaderKHR = VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT_KHR,
  bGeometryShaderKHR = VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT_KHR,
  bFragmentShaderKHR = VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT_KHR,
  bEarlyFragmentTestsKHR = VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT_KHR,
  bLateFragmentTestsKHR = VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT_KHR,
  bColorAttachmentOutputKHR = VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT_KHR,
  bComputeShaderKHR = VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT_KHR,
  bAllTransferKHR = VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT_KHR,
  bTransferKHR = VK_PIPELINE_STAGE_2_TRANSFER_BIT_KHR,
  bBottomOfPipeKHR = VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT_KHR,
  bHostKHR = VK_PIPELINE_STAGE_2_HOST_BIT_KHR,
  bAllGraphicsKHR = VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT_KHR,
  bAllCommandsKHR = VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT_KHR,
  bCopyKHR = VK_PIPELINE_STAGE_2_COPY_BIT_KHR,
  bResolveKHR = VK_PIPELINE_STAGE_2_RESOLVE_BIT_KHR,
  bBlitKHR = VK_PIPELINE_STAGE_2_BLIT_BIT_KHR,
  bClearKHR = VK_PIPELINE_STAGE_2_CLEAR_BIT_KHR,
  bIndexInputKHR = VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT_KHR,
  bVertexAttributeInputKHR = VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT_KHR,
  bPreRasterizationShadersKHR = VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT_KHR,
  bTransformFeedbackEXT = VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT,
  // A pipeline stage for conditional rendering predicate fetch
  bConditionalRenderingEXT = VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT,
  bCommandPreprocessNV = VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV,
  bFragmentShadingRateAttachmentKHR = VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR,
  bShadingRateImageNV = VK_PIPELINE_STAGE_2_SHADING_RATE_IMAGE_BIT_NV,
  bAccelerationStructureBuildKHR = VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR,
  bRayTracingShaderKHR = VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR,
  bFragmentDensityProcessEXT = VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT,
  bTaskShaderNV = VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_NV,
  bMeshShaderNV = VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_NV,
#endif // VK_KHR_synchronization2
#if VK_HUAWEI_subpass_shading
  bSubpassShaderHUAWEI = VK_PIPELINE_STAGE_2_SUBPASS_SHADER_BIT_HUAWEI,
#endif // VK_HUAWEI_subpass_shading
#if VK_HUAWEI_invocation_mask
  bInvocationMaskHUAWEI = VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI,
#endif // VK_HUAWEI_invocation_mask
#if VK_KHR_ray_tracing_maintenance1
  bAccelerationStructureCopyKHR = VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR,
#endif // VK_KHR_ray_tracing_maintenance1
#if VK_EXT_opacity_micromap
  bMicromapBuildEXT = VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT,
#endif // VK_EXT_opacity_micromap
#if VK_HUAWEI_cluster_culling_shader
  bClusterCullingShaderHUAWEI = VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI,
#endif // VK_HUAWEI_cluster_culling_shader
#if VK_NV_optical_flow
  bOpticalFlowNV = VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV,
#endif // VK_NV_optical_flow
#if VK_NV_cooperative_vector
  bConvertCooperativeVectorMatrixNV = VK_PIPELINE_STAGE_2_CONVERT_COOPERATIVE_VECTOR_MATRIX_BIT_NV,
#endif // VK_NV_cooperative_vector
#if VK_ARM_data_graph
  bDataGraphARM = VK_PIPELINE_STAGE_2_DATA_GRAPH_BIT_ARM,
#endif // VK_ARM_data_graph
};

enum class SubmitFlagBits : uint32_t {
  bProtected = VK_SUBMIT_PROTECTED_BIT,
#if VK_KHR_synchronization2
  bProtectedKHR = VK_SUBMIT_PROTECTED_BIT_KHR,
#endif // VK_KHR_synchronization2
};
#endif // VK_VERSION_1_3

#if VK_VERSION_1_0
enum class EventCreateFlagBits : uint32_t {
#if VK_VERSION_1_3
  bDeviceOnly = VK_EVENT_CREATE_DEVICE_ONLY_BIT,
#endif // VK_VERSION_1_3
#if VK_KHR_synchronization2
  bDeviceOnlyKHR = VK_EVENT_CREATE_DEVICE_ONLY_BIT_KHR,
#endif // VK_KHR_synchronization2
};
#endif // VK_VERSION_1_0

#if VK_EXT_graphics_pipeline_library
enum class PipelineLayoutCreateFlagBits : uint32_t {
#if VK_EXT_graphics_pipeline_library
  bIndependentSetsEXT = VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT,
#endif // VK_EXT_graphics_pipeline_library
};
#endif // VK_EXT_graphics_pipeline_library

#if VK_EXT_provoking_vertex
enum class ProvokingVertexModeEXT : int32_t {
  eFirstVertex = VK_PROVOKING_VERTEX_MODE_FIRST_VERTEX_EXT,
  eLastVertex = VK_PROVOKING_VERTEX_MODE_LAST_VERTEX_EXT,
};
#endif // VK_EXT_provoking_vertex

#if VK_NV_ray_tracing_motion_blur
enum class AccelerationStructureMotionInstanceTypeNV : int32_t {
  eStatic = VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_STATIC_NV,
  eMatrixMotion = VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_MATRIX_MOTION_NV,
  eSrtMotion = VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_SRT_MOTION_NV,
};
#endif // VK_NV_ray_tracing_motion_blur

#if VK_EXT_rasterization_order_attachment_access
enum class PipelineColorBlendStateCreateFlagBits : uint32_t {
#if VK_ARM_rasterization_order_attachment_access
  bRasterizationOrderAttachmentAccessARM = VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_ARM,
#endif // VK_ARM_rasterization_order_attachment_access
#if VK_EXT_rasterization_order_attachment_access
  bRasterizationOrderAttachmentAccessEXT = VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_EXT,
#endif // VK_EXT_rasterization_order_attachment_access
};

enum class PipelineDepthStencilStateCreateFlagBits : uint32_t {
#if VK_ARM_rasterization_order_attachment_access
  bRasterizationOrderAttachmentDepthAccessARM = VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_ARM,
  bRasterizationOrderAttachmentStencilAccessARM = VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_ARM,
#endif // VK_ARM_rasterization_order_attachment_access
#if VK_EXT_rasterization_order_attachment_access
  bRasterizationOrderAttachmentDepthAccessEXT = VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT,
  bRasterizationOrderAttachmentStencilAccessEXT = VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT,
#endif // VK_EXT_rasterization_order_attachment_access
};
#endif // VK_EXT_rasterization_order_attachment_access

#if VK_EXT_graphics_pipeline_library
enum class GraphicsPipelineLibraryFlagBitsEXT : uint32_t {
  bVertexInputInterface = VK_GRAPHICS_PIPELINE_LIBRARY_VERTEX_INPUT_INTERFACE_BIT_EXT,
  bPreRasterizationShaders = VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT,
  bFragmentShader = VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT,
  bFragmentOutputInterface = VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT,
};
#endif // VK_EXT_graphics_pipeline_library

#if VK_EXT_device_address_binding_report
enum class DeviceAddressBindingFlagBitsEXT : uint32_t {
  bInternalObject = VK_DEVICE_ADDRESS_BINDING_INTERNAL_OBJECT_BIT_EXT,
};

enum class DeviceAddressBindingTypeEXT : int32_t {
  eBind = VK_DEVICE_ADDRESS_BINDING_TYPE_BIND_EXT,
  eUnbind = VK_DEVICE_ADDRESS_BINDING_TYPE_UNBIND_EXT,
};
#endif // VK_EXT_device_address_binding_report

#if VK_EXT_frame_boundary
enum class FrameBoundaryFlagBitsEXT : uint32_t {
  bFrameEnd = VK_FRAME_BOUNDARY_FRAME_END_BIT_EXT,
};
#endif // VK_EXT_frame_boundary

#if VK_KHR_surface_maintenance1
enum class PresentScalingFlagBitsKHR : uint32_t {
  bOneToOne = VK_PRESENT_SCALING_ONE_TO_ONE_BIT_KHR,
  bOneToOneEXT = VK_PRESENT_SCALING_ONE_TO_ONE_BIT_EXT,
  bAspectRatioStretch = VK_PRESENT_SCALING_ASPECT_RATIO_STRETCH_BIT_KHR,
  bAspectRatioStretchEXT = VK_PRESENT_SCALING_ASPECT_RATIO_STRETCH_BIT_EXT,
  bStretch = VK_PRESENT_SCALING_STRETCH_BIT_KHR,
  bStretchEXT = VK_PRESENT_SCALING_STRETCH_BIT_EXT,
};

enum class PresentGravityFlagBitsKHR : uint32_t {
  bMin = VK_PRESENT_GRAVITY_MIN_BIT_KHR,
  bMinEXT = VK_PRESENT_GRAVITY_MIN_BIT_EXT,
  bMax = VK_PRESENT_GRAVITY_MAX_BIT_KHR,
  bMaxEXT = VK_PRESENT_GRAVITY_MAX_BIT_EXT,
  bCentered = VK_PRESENT_GRAVITY_CENTERED_BIT_KHR,
  bCenteredEXT = VK_PRESENT_GRAVITY_CENTERED_BIT_EXT,
};
#endif // VK_KHR_surface_maintenance1

#if VK_ARM_scheduling_controls
enum class PhysicalDeviceSchedulingControlsFlagBitsARM : uint64_t {
  eShaderCoreCount = VK_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_SHADER_CORE_COUNT_ARM,
};
#endif // VK_ARM_scheduling_controls

#if VK_KHR_video_queue
enum class VideoCodecOperationFlagBitsKHR : uint32_t {
  eNone = VK_VIDEO_CODEC_OPERATION_NONE_KHR,
#if VK_KHR_video_encode_h264
  bEncodeH264 = VK_VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_KHR,
#endif // VK_KHR_video_encode_h264
#if VK_KHR_video_encode_h265
  bEncodeH265 = VK_VIDEO_CODEC_OPERATION_ENCODE_H265_BIT_KHR,
#endif // VK_KHR_video_encode_h265
#if VK_KHR_video_decode_h264
  bDecodeH264 = VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR,
#endif // VK_KHR_video_decode_h264
#if VK_KHR_video_decode_h265
  bDecodeH265 = VK_VIDEO_CODEC_OPERATION_DECODE_H265_BIT_KHR,
#endif // VK_KHR_video_decode_h265
#if VK_KHR_video_decode_av1
  bDecodeAv1 = VK_VIDEO_CODEC_OPERATION_DECODE_AV1_BIT_KHR,
#endif // VK_KHR_video_decode_av1
#if VK_KHR_video_encode_av1
  bEncodeAv1 = VK_VIDEO_CODEC_OPERATION_ENCODE_AV1_BIT_KHR,
#endif // VK_KHR_video_encode_av1
#if VK_KHR_video_decode_vp9
  bDecodeVp9 = VK_VIDEO_CODEC_OPERATION_DECODE_VP9_BIT_KHR,
#endif // VK_KHR_video_decode_vp9
};

// Vulkan video chroma subsampling definitions
enum class VideoChromaSubsamplingFlagBitsKHR : uint32_t {
  eInvalid = VK_VIDEO_CHROMA_SUBSAMPLING_INVALID_KHR,
  bMonochrome = VK_VIDEO_CHROMA_SUBSAMPLING_MONOCHROME_BIT_KHR,
  b420 = VK_VIDEO_CHROMA_SUBSAMPLING_420_BIT_KHR,
  b422 = VK_VIDEO_CHROMA_SUBSAMPLING_422_BIT_KHR,
  b444 = VK_VIDEO_CHROMA_SUBSAMPLING_444_BIT_KHR,
};

// Vulkan video component bit depth definitions
enum class VideoComponentBitDepthFlagBitsKHR : uint32_t {
  eInvalid = VK_VIDEO_COMPONENT_BIT_DEPTH_INVALID_KHR,
  b8 = VK_VIDEO_COMPONENT_BIT_DEPTH_8_BIT_KHR,
  b10 = VK_VIDEO_COMPONENT_BIT_DEPTH_10_BIT_KHR,
  b12 = VK_VIDEO_COMPONENT_BIT_DEPTH_12_BIT_KHR,
};

enum class VideoCapabilityFlagBitsKHR : uint32_t {
  bProtectedContent = VK_VIDEO_CAPABILITY_PROTECTED_CONTENT_BIT_KHR,
  bSeparateReferenceImages = VK_VIDEO_CAPABILITY_SEPARATE_REFERENCE_IMAGES_BIT_KHR,
};

enum class VideoSessionCreateFlagBitsKHR : uint32_t {
  bProtectedContent = VK_VIDEO_SESSION_CREATE_PROTECTED_CONTENT_BIT_KHR,
#if VK_KHR_video_encode_queue
  bAllowEncodeParameterOptimizations = VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_PARAMETER_OPTIMIZATIONS_BIT_KHR,
#endif // VK_KHR_video_encode_queue
#if VK_KHR_video_maintenance1
  bInlineQueries = VK_VIDEO_SESSION_CREATE_INLINE_QUERIES_BIT_KHR,
#endif // VK_KHR_video_maintenance1
#if VK_KHR_video_encode_quantization_map
  bAllowEncodeQuantizationDeltaMap = VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_QUANTIZATION_DELTA_MAP_BIT_KHR,
  bAllowEncodeEmphasisMap = VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_EMPHASIS_MAP_BIT_KHR,
#endif // VK_KHR_video_encode_quantization_map
#if VK_KHR_video_maintenance2
  bInlineSessionParameters = VK_VIDEO_SESSION_CREATE_INLINE_SESSION_PARAMETERS_BIT_KHR,
#endif // VK_KHR_video_maintenance2
};
#endif // VK_KHR_video_queue

#if VK_KHR_video_encode_quantization_map
enum class VideoSessionParametersCreateFlagBitsKHR : uint32_t {
#if VK_KHR_video_encode_quantization_map
  bQuantizationMapCompatible = VK_VIDEO_SESSION_PARAMETERS_CREATE_QUANTIZATION_MAP_COMPATIBLE_BIT_KHR,
#endif // VK_KHR_video_encode_quantization_map
};
#endif // VK_KHR_video_encode_quantization_map

#if VK_KHR_video_decode_h264
enum class VideoDecodeH264PictureLayoutFlagBitsKHR : uint32_t {
};
#endif // VK_KHR_video_decode_h264

#if VK_KHR_video_queue
enum class VideoCodingControlFlagBitsKHR : uint32_t {
  bReset = VK_VIDEO_CODING_CONTROL_RESET_BIT_KHR,
#if VK_KHR_video_encode_queue
  bEncodeRateControl = VK_VIDEO_CODING_CONTROL_ENCODE_RATE_CONTROL_BIT_KHR,
  bEncodeQualityLevel = VK_VIDEO_CODING_CONTROL_ENCODE_QUALITY_LEVEL_BIT_KHR,
#endif // VK_KHR_video_encode_queue
};

enum class QueryResultStatusKHR : int32_t {
  eError = VK_QUERY_RESULT_STATUS_ERROR_KHR,
  eNotReady = VK_QUERY_RESULT_STATUS_NOT_READY_KHR,
  eComplete = VK_QUERY_RESULT_STATUS_COMPLETE_KHR,
#if VK_KHR_video_encode_queue
  eInsufficientBitstreamBufferRange = VK_QUERY_RESULT_STATUS_INSUFFICIENT_BITSTREAM_BUFFER_RANGE_KHR,
#endif // VK_KHR_video_encode_queue
};
#endif // VK_KHR_video_queue

#if VK_KHR_video_decode_queue
enum class VideoDecodeUsageFlagBitsKHR : uint32_t {
  eDefault = VK_VIDEO_DECODE_USAGE_DEFAULT_KHR,
  bTranscoding = VK_VIDEO_DECODE_USAGE_TRANSCODING_BIT_KHR,
  bOffline = VK_VIDEO_DECODE_USAGE_OFFLINE_BIT_KHR,
  bStreaming = VK_VIDEO_DECODE_USAGE_STREAMING_BIT_KHR,
};

enum class VideoDecodeCapabilityFlagBitsKHR : uint32_t {
  bDpbAndOutputCoincide = VK_VIDEO_DECODE_CAPABILITY_DPB_AND_OUTPUT_COINCIDE_BIT_KHR,
  bDpbAndOutputDistinct = VK_VIDEO_DECODE_CAPABILITY_DPB_AND_OUTPUT_DISTINCT_BIT_KHR,
};
#endif // VK_KHR_video_decode_queue

#if VK_KHR_video_encode_quantization_map
enum class VideoEncodeFlagBitsKHR : uint32_t {
#if VK_KHR_video_encode_intra_refresh
  bIntraRefresh = VK_VIDEO_ENCODE_INTRA_REFRESH_BIT_KHR,
#endif // VK_KHR_video_encode_intra_refresh
#if VK_KHR_video_encode_quantization_map
  bWithQuantizationDeltaMap = VK_VIDEO_ENCODE_WITH_QUANTIZATION_DELTA_MAP_BIT_KHR,
  bWithEmphasisMap = VK_VIDEO_ENCODE_WITH_EMPHASIS_MAP_BIT_KHR,
#endif // VK_KHR_video_encode_quantization_map
};
#endif // VK_KHR_video_encode_quantization_map

#if VK_KHR_video_encode_queue
enum class VideoEncodeUsageFlagBitsKHR : uint32_t {
  eDefault = VK_VIDEO_ENCODE_USAGE_DEFAULT_KHR,
  bTranscoding = VK_VIDEO_ENCODE_USAGE_TRANSCODING_BIT_KHR,
  bStreaming = VK_VIDEO_ENCODE_USAGE_STREAMING_BIT_KHR,
  bRecording = VK_VIDEO_ENCODE_USAGE_RECORDING_BIT_KHR,
  bConferencing = VK_VIDEO_ENCODE_USAGE_CONFERENCING_BIT_KHR,
};

enum class VideoEncodeContentFlagBitsKHR : uint32_t {
  eDefault = VK_VIDEO_ENCODE_CONTENT_DEFAULT_KHR,
  bCamera = VK_VIDEO_ENCODE_CONTENT_CAMERA_BIT_KHR,
  bDesktop = VK_VIDEO_ENCODE_CONTENT_DESKTOP_BIT_KHR,
  bRendered = VK_VIDEO_ENCODE_CONTENT_RENDERED_BIT_KHR,
};

enum class VideoEncodeTuningModeKHR : int32_t {
  eDefault = VK_VIDEO_ENCODE_TUNING_MODE_DEFAULT_KHR,
  eHighQuality = VK_VIDEO_ENCODE_TUNING_MODE_HIGH_QUALITY_KHR,
  eLowLatency = VK_VIDEO_ENCODE_TUNING_MODE_LOW_LATENCY_KHR,
  eUltraLowLatency = VK_VIDEO_ENCODE_TUNING_MODE_ULTRA_LOW_LATENCY_KHR,
  eLossless = VK_VIDEO_ENCODE_TUNING_MODE_LOSSLESS_KHR,
};

enum class VideoEncodeCapabilityFlagBitsKHR : uint32_t {
  bPrecedingExternallyEncodedBytes = VK_VIDEO_ENCODE_CAPABILITY_PRECEDING_EXTERNALLY_ENCODED_BYTES_BIT_KHR,
  bInsufficientBitstreamBufferRangeDetection = VK_VIDEO_ENCODE_CAPABILITY_INSUFFICIENT_BITSTREAM_BUFFER_RANGE_DETECTION_BIT_KHR,
#if VK_KHR_video_encode_quantization_map
  bQuantizationDeltaMap = VK_VIDEO_ENCODE_CAPABILITY_QUANTIZATION_DELTA_MAP_BIT_KHR,
  bEmphasisMap = VK_VIDEO_ENCODE_CAPABILITY_EMPHASIS_MAP_BIT_KHR,
#endif // VK_KHR_video_encode_quantization_map
};

enum class VideoEncodeFeedbackFlagBitsKHR : uint32_t {
  bBitstreamBufferOffset = VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_BUFFER_OFFSET_BIT_KHR,
  bBitstreamBytesWritten = VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_BYTES_WRITTEN_BIT_KHR,
  bBitstreamHasOverrides = VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_HAS_OVERRIDES_BIT_KHR,
};

enum class VideoEncodeRateControlModeFlagBitsKHR : uint32_t {
  eDefault = VK_VIDEO_ENCODE_RATE_CONTROL_MODE_DEFAULT_KHR,
  bDisabled = VK_VIDEO_ENCODE_RATE_CONTROL_MODE_DISABLED_BIT_KHR,
  bCbr = VK_VIDEO_ENCODE_RATE_CONTROL_MODE_CBR_BIT_KHR,
  bVbr = VK_VIDEO_ENCODE_RATE_CONTROL_MODE_VBR_BIT_KHR,
};
#endif // VK_KHR_video_encode_queue

#if VK_KHR_video_encode_intra_refresh
enum class VideoEncodeIntraRefreshModeFlagBitsKHR : uint32_t {
  eNone = VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_NONE_KHR,
  bPerPicturePartition = VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_PER_PICTURE_PARTITION_BIT_KHR,
  bBlockBased = VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_BLOCK_BASED_BIT_KHR,
  bBlockRowBased = VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_BLOCK_ROW_BASED_BIT_KHR,
  bBlockColumnBased = VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_BLOCK_COLUMN_BASED_BIT_KHR,
};
#endif // VK_KHR_video_encode_intra_refresh

#if VK_KHR_video_encode_h264
enum class VideoEncodeH264CapabilityFlagBitsKHR : uint32_t {
};

enum class VideoEncodeH264StdFlagBitsKHR : uint32_t {
};

enum class VideoEncodeH264RateControlFlagBitsKHR : uint32_t {
};
#endif // VK_KHR_video_encode_h264

#if VK_VERSION_1_4
enum class HostImageCopyFlagBits : uint32_t {
  bMemcpy = VK_HOST_IMAGE_COPY_MEMCPY_BIT,
#if VK_EXT_host_image_copy
  bMemcpyEXT = VK_HOST_IMAGE_COPY_MEMCPY_BIT_EXT,
#endif // VK_EXT_host_image_copy
};
#endif // VK_VERSION_1_4

#if VK_NV_partitioned_acceleration_structure
enum class PartitionedAccelerationStructureOpTypeNV : int32_t {
  eWriteInstance = VK_PARTITIONED_ACCELERATION_STRUCTURE_OP_TYPE_WRITE_INSTANCE_NV,
  eUpdateInstance = VK_PARTITIONED_ACCELERATION_STRUCTURE_OP_TYPE_UPDATE_INSTANCE_NV,
  eWritePartitionTranslation = VK_PARTITIONED_ACCELERATION_STRUCTURE_OP_TYPE_WRITE_PARTITION_TRANSLATION_NV,
};

enum class PartitionedAccelerationStructureInstanceFlagBitsNV : uint32_t {
  bFlagTriangleFacingCullDisable = VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_TRIANGLE_FACING_CULL_DISABLE_BIT_NV,
  bFlagTriangleFlipFacing = VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_TRIANGLE_FLIP_FACING_BIT_NV,
  bFlagForceOpaque = VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_FORCE_OPAQUE_BIT_NV,
  bFlagForceNoOpaque = VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_FORCE_NO_OPAQUE_BIT_NV,
  eFlagEnableExplicitBoundingBox = VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_ENABLE_EXPLICIT_BOUNDING_BOX_NV,
};
#endif // VK_NV_partitioned_acceleration_structure

#if VK_FUCHSIA_buffer_collection
enum class ImageConstraintsInfoFlagBitsFUCHSIA : uint32_t {
  eCpuReadRarely = VK_IMAGE_CONSTRAINTS_INFO_CPU_READ_RARELY_FUCHSIA,
  eCpuReadOften = VK_IMAGE_CONSTRAINTS_INFO_CPU_READ_OFTEN_FUCHSIA,
  eCpuWriteRarely = VK_IMAGE_CONSTRAINTS_INFO_CPU_WRITE_RARELY_FUCHSIA,
  eCpuWriteOften = VK_IMAGE_CONSTRAINTS_INFO_CPU_WRITE_OFTEN_FUCHSIA,
  eProtectedOptional = VK_IMAGE_CONSTRAINTS_INFO_PROTECTED_OPTIONAL_FUCHSIA,
};
#endif // VK_FUCHSIA_buffer_collection

#if VK_VERSION_1_3
enum class FormatFeatureFlagBits2 : uint64_t {
  bSampledImage = VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT,
  bStorageImage = VK_FORMAT_FEATURE_2_STORAGE_IMAGE_BIT,
  bStorageImageAtomic = VK_FORMAT_FEATURE_2_STORAGE_IMAGE_ATOMIC_BIT,
  bUniformTexelBuffer = VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT,
  bStorageTexelBuffer = VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_BIT,
  bStorageTexelBufferAtomic = VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_ATOMIC_BIT,
  bVertexBuffer = VK_FORMAT_FEATURE_2_VERTEX_BUFFER_BIT,
  bColorAttachment = VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT,
  bColorAttachmentBlend = VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT,
  bDepthStencilAttachment = VK_FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT,
  bBlitSrc = VK_FORMAT_FEATURE_2_BLIT_SRC_BIT,
  bBlitDst = VK_FORMAT_FEATURE_2_BLIT_DST_BIT,
  bSampledImageFilterLinear = VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT,
  bTransferSrc = VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT,
  bTransferDst = VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT,
  bSampledImageFilterMinmax = VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT,
  bMidpointChromaSamples = VK_FORMAT_FEATURE_2_MIDPOINT_CHROMA_SAMPLES_BIT,
  bSampledImageYcbcrConversionLinearFilter = VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT,
  bSampledImageYcbcrConversionSeparateReconstructionFilter = VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT,
  bSampledImageYcbcrConversionChromaReconstructionExplicit = VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT,
  bSampledImageYcbcrConversionChromaReconstructionExplicitForceable = VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT,
  bDisjoint = VK_FORMAT_FEATURE_2_DISJOINT_BIT,
  bCositedChromaSamples = VK_FORMAT_FEATURE_2_COSITED_CHROMA_SAMPLES_BIT,
  bStorageReadWithoutFormat = VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT,
  bStorageWriteWithoutFormat = VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT,
  bSampledImageDepthComparison = VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT,
#if VK_VERSION_1_3
  // This is an interaction with EXT_filter_cubic, though not tagged that way
  bSampledImageFilterCubic = VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_CUBIC_BIT,
#endif // VK_VERSION_1_3
#if VK_VERSION_1_4
  bHostImageTransfer = VK_FORMAT_FEATURE_2_HOST_IMAGE_TRANSFER_BIT,
#endif // VK_VERSION_1_4
#if VK_EXT_host_image_copy
  // Host image copies are supported
  bHostImageTransferEXT = VK_FORMAT_FEATURE_2_HOST_IMAGE_TRANSFER_BIT_EXT,
#endif // VK_EXT_host_image_copy
#if VK_KHR_format_feature_flags2
  bSampledImageKHR = VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT_KHR,
  bStorageImageKHR = VK_FORMAT_FEATURE_2_STORAGE_IMAGE_BIT_KHR,
  bStorageImageAtomicKHR = VK_FORMAT_FEATURE_2_STORAGE_IMAGE_ATOMIC_BIT_KHR,
  bUniformTexelBufferKHR = VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT_KHR,
  bStorageTexelBufferKHR = VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_BIT_KHR,
  bStorageTexelBufferAtomicKHR = VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_ATOMIC_BIT_KHR,
  bVertexBufferKHR = VK_FORMAT_FEATURE_2_VERTEX_BUFFER_BIT_KHR,
  bColorAttachmentKHR = VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT_KHR,
  bColorAttachmentBlendKHR = VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT_KHR,
  bDepthStencilAttachmentKHR = VK_FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT_KHR,
  bBlitSrcKHR = VK_FORMAT_FEATURE_2_BLIT_SRC_BIT_KHR,
  bBlitDstKHR = VK_FORMAT_FEATURE_2_BLIT_DST_BIT_KHR,
  bSampledImageFilterLinearKHR = VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT_KHR,
  bTransferSrcKHR = VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT_KHR,
  bTransferDstKHR = VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT_KHR,
  bMidpointChromaSamplesKHR = VK_FORMAT_FEATURE_2_MIDPOINT_CHROMA_SAMPLES_BIT_KHR,
  bSampledImageYcbcrConversionLinearFilterKHR = VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR,
  bSampledImageYcbcrConversionSeparateReconstructionFilterKHR = VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR,
  bSampledImageYcbcrConversionChromaReconstructionExplicitKHR = VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR,
  bSampledImageYcbcrConversionChromaReconstructionExplicitForceableKHR = VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR,
  bDisjointKHR = VK_FORMAT_FEATURE_2_DISJOINT_BIT_KHR,
  bCositedChromaSamplesKHR = VK_FORMAT_FEATURE_2_COSITED_CHROMA_SAMPLES_BIT_KHR,
  bStorageReadWithoutFormatKHR = VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT_KHR,
  bStorageWriteWithoutFormatKHR = VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT_KHR,
  bSampledImageDepthComparisonKHR = VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT_KHR,
  bSampledImageFilterMinmaxKHR = VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT_KHR,
  bSampledImageFilterCubicEXT = VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT,
#endif // VK_KHR_format_feature_flags2
#if VK_NV_ray_tracing_linear_swept_spheres
  bAccelerationStructureRadiusBufferNV = VK_FORMAT_FEATURE_2_ACCELERATION_STRUCTURE_RADIUS_BUFFER_BIT_NV,
#endif // VK_NV_ray_tracing_linear_swept_spheres
#if VK_NV_linear_color_attachment
  // Format support linear image as render target, it cannot be mixed with non linear attachment
  bLinearColorAttachmentNV = VK_FORMAT_FEATURE_2_LINEAR_COLOR_ATTACHMENT_BIT_NV,
#endif // VK_NV_linear_color_attachment
#if VK_QCOM_image_processing
  bWeightImageQCOM = VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM,
  bWeightSampledImageQCOM = VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM,
  bBlockMatchingQCOM = VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM,
  bBoxFilterSampledQCOM = VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM,
#endif // VK_QCOM_image_processing
#if VK_ARM_tensors
  bTensorShaderARM = VK_FORMAT_FEATURE_2_TENSOR_SHADER_BIT_ARM,
  bTensorImageAliasingARM = VK_FORMAT_FEATURE_2_TENSOR_IMAGE_ALIASING_BIT_ARM,
#endif // VK_ARM_tensors
#if VK_NV_optical_flow
  bOpticalFlowImageNV = VK_FORMAT_FEATURE_2_OPTICAL_FLOW_IMAGE_BIT_NV,
  bOpticalFlowVectorNV = VK_FORMAT_FEATURE_2_OPTICAL_FLOW_VECTOR_BIT_NV,
  bOpticalFlowCostNV = VK_FORMAT_FEATURE_2_OPTICAL_FLOW_COST_BIT_NV,
#endif // VK_NV_optical_flow
#if VK_ARM_data_graph
  bTensorDataGraphARM = VK_FORMAT_FEATURE_2_TENSOR_DATA_GRAPH_BIT_ARM,
#endif // VK_ARM_data_graph
#if VK_KHR_video_encode_quantization_map
  bVideoEncodeQuantizationDeltaMapKHR = VK_FORMAT_FEATURE_2_VIDEO_ENCODE_QUANTIZATION_DELTA_MAP_BIT_KHR,
  bVideoEncodeEmphasisMapKHR = VK_FORMAT_FEATURE_2_VIDEO_ENCODE_EMPHASIS_MAP_BIT_KHR,
#endif // VK_KHR_video_encode_quantization_map
};

enum class RenderingFlagBits : uint32_t {
  bContentsSecondaryCommandBuffers = VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT,
  bSuspending = VK_RENDERING_SUSPENDING_BIT,
  bResuming = VK_RENDERING_RESUMING_BIT,
#if VK_KHR_dynamic_rendering
  bContentsSecondaryCommandBuffersKHR = VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT_KHR,
  bSuspendingKHR = VK_RENDERING_SUSPENDING_BIT_KHR,
  bResumingKHR = VK_RENDERING_RESUMING_BIT_KHR,
#endif // VK_KHR_dynamic_rendering
#if VK_EXT_nested_command_buffer
  bContentsInlineEXT = VK_RENDERING_CONTENTS_INLINE_BIT_EXT,
#endif // VK_EXT_nested_command_buffer
#if VK_KHR_maintenance7
  // Promoted from extension 452
  bContentsInlineKHR = VK_RENDERING_CONTENTS_INLINE_BIT_KHR,
#endif // VK_KHR_maintenance7
#if VK_VALVE_fragment_density_map_layered
  bPerLayerFragmentDensityVALVE = VK_RENDERING_PER_LAYER_FRAGMENT_DENSITY_BIT_VALVE,
#endif // VK_VALVE_fragment_density_map_layered
};
#endif // VK_VERSION_1_3

#if VK_KHR_video_encode_h265
enum class VideoEncodeH265CapabilityFlagBitsKHR : uint32_t {
};

enum class VideoEncodeH265StdFlagBitsKHR : uint32_t {
};

enum class VideoEncodeH265RateControlFlagBitsKHR : uint32_t {
};

enum class VideoEncodeH265CtbSizeFlagBitsKHR : uint32_t {
};

enum class VideoEncodeH265TransformBlockSizeFlagBitsKHR : uint32_t {
};
#endif // VK_KHR_video_encode_h265

#if VK_KHR_video_encode_av1
enum class VideoEncodeAV1CapabilityFlagBitsKHR : uint32_t {
};

enum class VideoEncodeAV1StdFlagBitsKHR : uint32_t {
};

enum class VideoEncodeAV1RateControlFlagBitsKHR : uint32_t {
};

enum class VideoEncodeAV1SuperblockSizeFlagBitsKHR : uint32_t {
};

enum class VideoEncodeAV1PredictionModeKHR : int32_t {
};

enum class VideoEncodeAV1RateControlGroupKHR : int32_t {
};
#endif // VK_KHR_video_encode_av1

#if VK_EXT_metal_objects
enum class ExportMetalObjectTypeFlagBitsEXT : uint32_t {
  bMetalDevice = VK_EXPORT_METAL_OBJECT_TYPE_METAL_DEVICE_BIT_EXT,
  bMetalCommandQueue = VK_EXPORT_METAL_OBJECT_TYPE_METAL_COMMAND_QUEUE_BIT_EXT,
  bMetalBuffer = VK_EXPORT_METAL_OBJECT_TYPE_METAL_BUFFER_BIT_EXT,
  bMetalTexture = VK_EXPORT_METAL_OBJECT_TYPE_METAL_TEXTURE_BIT_EXT,
  bMetalIosurface = VK_EXPORT_METAL_OBJECT_TYPE_METAL_IOSURFACE_BIT_EXT,
  bMetalSharedEvent = VK_EXPORT_METAL_OBJECT_TYPE_METAL_SHARED_EVENT_BIT_EXT,
};
#endif // VK_EXT_metal_objects

#if VK_VERSION_1_0
enum class InstanceCreateFlagBits : uint32_t {
#if VK_KHR_portability_enumeration
  bEnumeratePortabilityKHR = VK_INSTANCE_CREATE_ENUMERATE_PORTABILITY_BIT_KHR,
#endif // VK_KHR_portability_enumeration
};
#endif // VK_VERSION_1_0

#if VK_EXT_image_compression_control
enum class ImageCompressionFlagBitsEXT : uint32_t {
  eDefault = VK_IMAGE_COMPRESSION_DEFAULT_EXT,
  eFixedRateDefault = VK_IMAGE_COMPRESSION_FIXED_RATE_DEFAULT_EXT,
  eFixedRateExplicit = VK_IMAGE_COMPRESSION_FIXED_RATE_EXPLICIT_EXT,
  eDisabled = VK_IMAGE_COMPRESSION_DISABLED_EXT,
};

enum class ImageCompressionFixedRateFlagBitsEXT : uint32_t {
  eNone = VK_IMAGE_COMPRESSION_FIXED_RATE_NONE_EXT,
  b1Bpc = VK_IMAGE_COMPRESSION_FIXED_RATE_1BPC_BIT_EXT,
  b2Bpc = VK_IMAGE_COMPRESSION_FIXED_RATE_2BPC_BIT_EXT,
  b3Bpc = VK_IMAGE_COMPRESSION_FIXED_RATE_3BPC_BIT_EXT,
  b4Bpc = VK_IMAGE_COMPRESSION_FIXED_RATE_4BPC_BIT_EXT,
  b5Bpc = VK_IMAGE_COMPRESSION_FIXED_RATE_5BPC_BIT_EXT,
  b6Bpc = VK_IMAGE_COMPRESSION_FIXED_RATE_6BPC_BIT_EXT,
  b7Bpc = VK_IMAGE_COMPRESSION_FIXED_RATE_7BPC_BIT_EXT,
  b8Bpc = VK_IMAGE_COMPRESSION_FIXED_RATE_8BPC_BIT_EXT,
  b9Bpc = VK_IMAGE_COMPRESSION_FIXED_RATE_9BPC_BIT_EXT,
  b10Bpc = VK_IMAGE_COMPRESSION_FIXED_RATE_10BPC_BIT_EXT,
  b11Bpc = VK_IMAGE_COMPRESSION_FIXED_RATE_11BPC_BIT_EXT,
  b12Bpc = VK_IMAGE_COMPRESSION_FIXED_RATE_12BPC_BIT_EXT,
  b13Bpc = VK_IMAGE_COMPRESSION_FIXED_RATE_13BPC_BIT_EXT,
  b14Bpc = VK_IMAGE_COMPRESSION_FIXED_RATE_14BPC_BIT_EXT,
  b15Bpc = VK_IMAGE_COMPRESSION_FIXED_RATE_15BPC_BIT_EXT,
  b16Bpc = VK_IMAGE_COMPRESSION_FIXED_RATE_16BPC_BIT_EXT,
  b17Bpc = VK_IMAGE_COMPRESSION_FIXED_RATE_17BPC_BIT_EXT,
  b18Bpc = VK_IMAGE_COMPRESSION_FIXED_RATE_18BPC_BIT_EXT,
  b19Bpc = VK_IMAGE_COMPRESSION_FIXED_RATE_19BPC_BIT_EXT,
  b20Bpc = VK_IMAGE_COMPRESSION_FIXED_RATE_20BPC_BIT_EXT,
  b21Bpc = VK_IMAGE_COMPRESSION_FIXED_RATE_21BPC_BIT_EXT,
  b22Bpc = VK_IMAGE_COMPRESSION_FIXED_RATE_22BPC_BIT_EXT,
  b23Bpc = VK_IMAGE_COMPRESSION_FIXED_RATE_23BPC_BIT_EXT,
  b24Bpc = VK_IMAGE_COMPRESSION_FIXED_RATE_24BPC_BIT_EXT,
};
#endif // VK_EXT_image_compression_control

#if VK_VERSION_1_4
enum class PipelineRobustnessBufferBehavior : int32_t {
  eDeviceDefault = VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT,
  eDisabled = VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DISABLED,
  eRobustBufferAccess = VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS,
  eRobustBufferAccess2 = VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2,
#if VK_EXT_pipeline_robustness
  eDeviceDefaultEXT = VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT_EXT,
  eDisabledEXT = VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DISABLED_EXT,
  eRobustBufferAccessEXT = VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT,
  eRobustBufferAccess2EXT = VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT,
#endif // VK_EXT_pipeline_robustness
};

enum class PipelineRobustnessImageBehavior : int32_t {
  eDeviceDefault = VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT,
  eDisabled = VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DISABLED,
  eRobustImageAccess = VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS,
  eRobustImageAccess2 = VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_2,
#if VK_EXT_pipeline_robustness
  eDeviceDefaultEXT = VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT_EXT,
  eDisabledEXT = VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DISABLED_EXT,
  eRobustImageAccessEXT = VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_EXT,
  eRobustImageAccess2EXT = VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_2_EXT,
#endif // VK_EXT_pipeline_robustness
};
#endif // VK_VERSION_1_4

#if VK_NV_optical_flow
enum class OpticalFlowGridSizeFlagBitsNV : uint32_t {
  eUnknown = VK_OPTICAL_FLOW_GRID_SIZE_UNKNOWN_NV,
  b1X1 = VK_OPTICAL_FLOW_GRID_SIZE_1X1_BIT_NV,
  b2X2 = VK_OPTICAL_FLOW_GRID_SIZE_2X2_BIT_NV,
  b4X4 = VK_OPTICAL_FLOW_GRID_SIZE_4X4_BIT_NV,
  b8X8 = VK_OPTICAL_FLOW_GRID_SIZE_8X8_BIT_NV,
};

enum class OpticalFlowUsageFlagBitsNV : uint32_t {
  eUnknown = VK_OPTICAL_FLOW_USAGE_UNKNOWN_NV,
  bInput = VK_OPTICAL_FLOW_USAGE_INPUT_BIT_NV,
  bOutput = VK_OPTICAL_FLOW_USAGE_OUTPUT_BIT_NV,
  bHint = VK_OPTICAL_FLOW_USAGE_HINT_BIT_NV,
  bCost = VK_OPTICAL_FLOW_USAGE_COST_BIT_NV,
  bGlobalFlow = VK_OPTICAL_FLOW_USAGE_GLOBAL_FLOW_BIT_NV,
};

enum class OpticalFlowPerformanceLevelNV : int32_t {
  eUnknown = VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_UNKNOWN_NV,
  eSlow = VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_SLOW_NV,
  eMedium = VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_MEDIUM_NV,
  eFast = VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_FAST_NV,
};

enum class OpticalFlowSessionBindingPointNV : int32_t {
  eUnknown = VK_OPTICAL_FLOW_SESSION_BINDING_POINT_UNKNOWN_NV,
  eInput = VK_OPTICAL_FLOW_SESSION_BINDING_POINT_INPUT_NV,
  eReference = VK_OPTICAL_FLOW_SESSION_BINDING_POINT_REFERENCE_NV,
  eHint = VK_OPTICAL_FLOW_SESSION_BINDING_POINT_HINT_NV,
  eFlowVector = VK_OPTICAL_FLOW_SESSION_BINDING_POINT_FLOW_VECTOR_NV,
  eBackwardFlowVector = VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_FLOW_VECTOR_NV,
  eCost = VK_OPTICAL_FLOW_SESSION_BINDING_POINT_COST_NV,
  eBackwardCost = VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_COST_NV,
  eGlobalFlow = VK_OPTICAL_FLOW_SESSION_BINDING_POINT_GLOBAL_FLOW_NV,
};

enum class OpticalFlowSessionCreateFlagBitsNV : uint32_t {
  bEnableHint = VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_HINT_BIT_NV,
  bEnableCost = VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_COST_BIT_NV,
  bEnableGlobalFlow = VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_GLOBAL_FLOW_BIT_NV,
  bAllowRegions = VK_OPTICAL_FLOW_SESSION_CREATE_ALLOW_REGIONS_BIT_NV,
  bBothDirections = VK_OPTICAL_FLOW_SESSION_CREATE_BOTH_DIRECTIONS_BIT_NV,
};

enum class OpticalFlowExecuteFlagBitsNV : uint32_t {
  bDisableTemporalHints = VK_OPTICAL_FLOW_EXECUTE_DISABLE_TEMPORAL_HINTS_BIT_NV,
};
#endif // VK_NV_optical_flow

#if VK_EXT_opacity_micromap
enum class MicromapTypeEXT : int32_t {
  eOpacityMicromap = VK_MICROMAP_TYPE_OPACITY_MICROMAP_EXT,
};

enum class BuildMicromapFlagBitsEXT : uint32_t {
  bPreferFastTrace = VK_BUILD_MICROMAP_PREFER_FAST_TRACE_BIT_EXT,
  bPreferFastBuild = VK_BUILD_MICROMAP_PREFER_FAST_BUILD_BIT_EXT,
  bAllowCompaction = VK_BUILD_MICROMAP_ALLOW_COMPACTION_BIT_EXT,
};

enum class MicromapCreateFlagBitsEXT : uint32_t {
  bDeviceAddressCaptureReplay = VK_MICROMAP_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT,
};

enum class CopyMicromapModeEXT : int32_t {
  eClone = VK_COPY_MICROMAP_MODE_CLONE_EXT,
  eSerialize = VK_COPY_MICROMAP_MODE_SERIALIZE_EXT,
  eDeserialize = VK_COPY_MICROMAP_MODE_DESERIALIZE_EXT,
  eCompact = VK_COPY_MICROMAP_MODE_COMPACT_EXT,
};

enum class BuildMicromapModeEXT : int32_t {
  eBuild = VK_BUILD_MICROMAP_MODE_BUILD_EXT,
};

enum class OpacityMicromapFormatEXT : int32_t {
  e2State = VK_OPACITY_MICROMAP_FORMAT_2_STATE_EXT,
  e4State = VK_OPACITY_MICROMAP_FORMAT_4_STATE_EXT,
};

enum class OpacityMicromapSpecialIndexEXT : int32_t {
  eFullyTransparent = VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_TRANSPARENT_EXT,
  eFullyOpaque = VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_OPAQUE_EXT,
  eFullyUnknownTransparent = VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_UNKNOWN_TRANSPARENT_EXT,
  eFullyUnknownOpaque = VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_UNKNOWN_OPAQUE_EXT,
#if VK_NV_cluster_acceleration_structure
  eClusterGeometryDisableOpacityMicromapNV = VK_OPACITY_MICROMAP_SPECIAL_INDEX_CLUSTER_GEOMETRY_DISABLE_OPACITY_MICROMAP_NV,
#endif // VK_NV_cluster_acceleration_structure
};
#endif // VK_EXT_opacity_micromap

#if VK_EXT_depth_bias_control
enum class DepthBiasRepresentationEXT : int32_t {
  eLeastRepresentableValueFormat = VK_DEPTH_BIAS_REPRESENTATION_LEAST_REPRESENTABLE_VALUE_FORMAT_EXT,
  eLeastRepresentableValueForceUnorm = VK_DEPTH_BIAS_REPRESENTATION_LEAST_REPRESENTABLE_VALUE_FORCE_UNORM_EXT,
  eFloat = VK_DEPTH_BIAS_REPRESENTATION_FLOAT_EXT,
};
#endif // VK_EXT_depth_bias_control

#if VK_EXT_device_fault
enum class DeviceFaultAddressTypeEXT : int32_t {
  // Currently unused
  eNone = VK_DEVICE_FAULT_ADDRESS_TYPE_NONE_EXT,
  eReadInvalid = VK_DEVICE_FAULT_ADDRESS_TYPE_READ_INVALID_EXT,
  eWriteInvalid = VK_DEVICE_FAULT_ADDRESS_TYPE_WRITE_INVALID_EXT,
  eExecuteInvalid = VK_DEVICE_FAULT_ADDRESS_TYPE_EXECUTE_INVALID_EXT,
  eInstructionPointerUnknown = VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_UNKNOWN_EXT,
  eInstructionPointerInvalid = VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_INVALID_EXT,
  eInstructionPointerFault = VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_FAULT_EXT,
};

enum class DeviceFaultVendorBinaryHeaderVersionEXT : int32_t {
  eOne = VK_DEVICE_FAULT_VENDOR_BINARY_HEADER_VERSION_ONE_EXT,
};
#endif // VK_EXT_device_fault

#if VK_EXT_device_generated_commands
enum class IndirectCommandsLayoutUsageFlagBitsEXT : uint32_t {
  bExplicitPreprocess = VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_EXT,
  bUnorderedSequences = VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_EXT,
};

enum class IndirectExecutionSetInfoTypeEXT : int32_t {
  ePipelines = VK_INDIRECT_EXECUTION_SET_INFO_TYPE_PIPELINES_EXT,
  eShaderObjects = VK_INDIRECT_EXECUTION_SET_INFO_TYPE_SHADER_OBJECTS_EXT,
};

enum class IndirectCommandsInputModeFlagBitsEXT : uint32_t {
  eVulkanIndexBuffer = VK_INDIRECT_COMMANDS_INPUT_MODE_VULKAN_INDEX_BUFFER_EXT,
  eDxgiIndexBuffer = VK_INDIRECT_COMMANDS_INPUT_MODE_DXGI_INDEX_BUFFER_EXT,
};

enum class IndirectCommandsTokenTypeEXT : int32_t {
  eExecutionSet = VK_INDIRECT_COMMANDS_TOKEN_TYPE_EXECUTION_SET_EXT,
  ePushConstant = VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_EXT,
  eSequenceIndex = VK_INDIRECT_COMMANDS_TOKEN_TYPE_SEQUENCE_INDEX_EXT,
  eIndexBuffer = VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_EXT,
  eVertexBuffer = VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_EXT,
  eDrawIndexed = VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_EXT,
  eDraw = VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_EXT,
  eDrawIndexedCount = VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_COUNT_EXT,
  eDrawCount = VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_COUNT_EXT,
  eDispatch = VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_EXT,
};
#endif // VK_EXT_device_generated_commands

#if VK_EXT_shader_object
enum class ShaderCreateFlagBitsEXT : uint32_t {
  bLinkStage = VK_SHADER_CREATE_LINK_STAGE_BIT_EXT,
#if VK_EXT_shader_object
  bAllowVaryingSubgroupSize = VK_SHADER_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT,
  bRequireFullSubgroups = VK_SHADER_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT,
  bNoTaskShader = VK_SHADER_CREATE_NO_TASK_SHADER_BIT_EXT,
  bDispatchBase = VK_SHADER_CREATE_DISPATCH_BASE_BIT_EXT,
  bFragmentShadingRateAttachment = VK_SHADER_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_EXT,
  bFragmentDensityMapAttachment = VK_SHADER_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT,
#endif // VK_EXT_shader_object
#if VK_EXT_device_generated_commands
  bIndirectBindable = VK_SHADER_CREATE_INDIRECT_BINDABLE_BIT_EXT,
#endif // VK_EXT_device_generated_commands
};

enum class ShaderCodeTypeEXT : int32_t {
  eBinary = VK_SHADER_CODE_TYPE_BINARY_EXT,
  eSpirv = VK_SHADER_CODE_TYPE_SPIRV_EXT,
};
#endif // VK_EXT_shader_object

#if VK_KHR_cooperative_matrix
enum class ScopeKHR : int32_t {
  eDevice = VK_SCOPE_DEVICE_KHR,
  eWorkgroup = VK_SCOPE_WORKGROUP_KHR,
  eSubgroup = VK_SCOPE_SUBGROUP_KHR,
  eQueueFamily = VK_SCOPE_QUEUE_FAMILY_KHR,
#if VK_NV_cooperative_matrix
  eDeviceNV = VK_SCOPE_DEVICE_NV,
  eWorkgroupNV = VK_SCOPE_WORKGROUP_NV,
  eSubgroupNV = VK_SCOPE_SUBGROUP_NV,
  eQueueFamilyNV = VK_SCOPE_QUEUE_FAMILY_NV,
#endif // VK_NV_cooperative_matrix
};
#endif // VK_KHR_cooperative_matrix

#if VK_NV_cooperative_vector
enum class ComponentTypeKHR : int32_t {
  eFloat16 = VK_COMPONENT_TYPE_FLOAT16_KHR,
  eFloat32 = VK_COMPONENT_TYPE_FLOAT32_KHR,
  eFloat64 = VK_COMPONENT_TYPE_FLOAT64_KHR,
  eSint8 = VK_COMPONENT_TYPE_SINT8_KHR,
  eSint16 = VK_COMPONENT_TYPE_SINT16_KHR,
  eSint32 = VK_COMPONENT_TYPE_SINT32_KHR,
  eSint64 = VK_COMPONENT_TYPE_SINT64_KHR,
  eUint8 = VK_COMPONENT_TYPE_UINT8_KHR,
  eUint16 = VK_COMPONENT_TYPE_UINT16_KHR,
  eUint32 = VK_COMPONENT_TYPE_UINT32_KHR,
  eUint64 = VK_COMPONENT_TYPE_UINT64_KHR,
#if VK_NV_cooperative_matrix
  eFloat16NV = VK_COMPONENT_TYPE_FLOAT16_NV,
  eFloat32NV = VK_COMPONENT_TYPE_FLOAT32_NV,
  eFloat64NV = VK_COMPONENT_TYPE_FLOAT64_NV,
  eSint8NV = VK_COMPONENT_TYPE_SINT8_NV,
  eSint16NV = VK_COMPONENT_TYPE_SINT16_NV,
  eSint32NV = VK_COMPONENT_TYPE_SINT32_NV,
  eSint64NV = VK_COMPONENT_TYPE_SINT64_NV,
  eUint8NV = VK_COMPONENT_TYPE_UINT8_NV,
  eUint16NV = VK_COMPONENT_TYPE_UINT16_NV,
  eUint32NV = VK_COMPONENT_TYPE_UINT32_NV,
  eUint64NV = VK_COMPONENT_TYPE_UINT64_NV,
#endif // VK_NV_cooperative_matrix
#if VK_NV_cooperative_vector
  eSint8PackedNV = VK_COMPONENT_TYPE_SINT8_PACKED_NV,
  eUint8PackedNV = VK_COMPONENT_TYPE_UINT8_PACKED_NV,
  eFloatE4M3NV = VK_COMPONENT_TYPE_FLOAT_E4M3_NV,
  eFloatE5M2NV = VK_COMPONENT_TYPE_FLOAT_E5M2_NV,
#endif // VK_NV_cooperative_vector
#if VK_EXT_shader_float8
  eFloat8E4M3EXT = VK_COMPONENT_TYPE_FLOAT8_E4M3_EXT,
  eFloat8E5M2EXT = VK_COMPONENT_TYPE_FLOAT8_E5M2_EXT,
#endif // VK_EXT_shader_float8
};
#endif // VK_NV_cooperative_vector

#if VK_QCOM_filter_cubic_weights
enum class CubicFilterWeightsQCOM : int32_t {
  eCatmullRom = VK_CUBIC_FILTER_WEIGHTS_CATMULL_ROM_QCOM,
  eZeroTangentCardinal = VK_CUBIC_FILTER_WEIGHTS_ZERO_TANGENT_CARDINAL_QCOM,
  eBSpline = VK_CUBIC_FILTER_WEIGHTS_B_SPLINE_QCOM,
  eMitchellNetravali = VK_CUBIC_FILTER_WEIGHTS_MITCHELL_NETRAVALI_QCOM,
};
#endif // VK_QCOM_filter_cubic_weights

#if VK_QCOM_image_processing2
enum class BlockMatchWindowCompareModeQCOM : int32_t {
  eMin = VK_BLOCK_MATCH_WINDOW_COMPARE_MODE_MIN_QCOM,
  eMax = VK_BLOCK_MATCH_WINDOW_COMPARE_MODE_MAX_QCOM,
};
#endif // VK_QCOM_image_processing2

#if VK_KHR_maintenance7
enum class PhysicalDeviceLayeredApiKHR : int32_t {
  eVulkan = VK_PHYSICAL_DEVICE_LAYERED_API_VULKAN_KHR,
  eD3D12 = VK_PHYSICAL_DEVICE_LAYERED_API_D3D12_KHR,
  eMetal = VK_PHYSICAL_DEVICE_LAYERED_API_METAL_KHR,
  eOpengl = VK_PHYSICAL_DEVICE_LAYERED_API_OPENGL_KHR,
  eOpengles = VK_PHYSICAL_DEVICE_LAYERED_API_OPENGLES_KHR,
};
#endif // VK_KHR_maintenance7

#if VK_MSFT_layered_driver
enum class LayeredDriverUnderlyingApiMSFT : int32_t {
  eNone = VK_LAYERED_DRIVER_UNDERLYING_API_NONE_MSFT,
  eD3D12 = VK_LAYERED_DRIVER_UNDERLYING_API_D3D12_MSFT,
};
#endif // VK_MSFT_layered_driver

#if VK_NV_low_latency2
enum class LatencyMarkerNV : int32_t {
  eSimulationStart = VK_LATENCY_MARKER_SIMULATION_START_NV,
  eSimulationEnd = VK_LATENCY_MARKER_SIMULATION_END_NV,
  eRendersubmitStart = VK_LATENCY_MARKER_RENDERSUBMIT_START_NV,
  eRendersubmitEnd = VK_LATENCY_MARKER_RENDERSUBMIT_END_NV,
  ePresentStart = VK_LATENCY_MARKER_PRESENT_START_NV,
  ePresentEnd = VK_LATENCY_MARKER_PRESENT_END_NV,
  eInputSample = VK_LATENCY_MARKER_INPUT_SAMPLE_NV,
  eTriggerFlash = VK_LATENCY_MARKER_TRIGGER_FLASH_NV,
  eOutOfBandRendersubmitStart = VK_LATENCY_MARKER_OUT_OF_BAND_RENDERSUBMIT_START_NV,
  eOutOfBandRendersubmitEnd = VK_LATENCY_MARKER_OUT_OF_BAND_RENDERSUBMIT_END_NV,
  eOutOfBandPresentStart = VK_LATENCY_MARKER_OUT_OF_BAND_PRESENT_START_NV,
  eOutOfBandPresentEnd = VK_LATENCY_MARKER_OUT_OF_BAND_PRESENT_END_NV,
};

enum class OutOfBandQueueTypeNV : int32_t {
  eRender = VK_OUT_OF_BAND_QUEUE_TYPE_RENDER_NV,
  ePresent = VK_OUT_OF_BAND_QUEUE_TYPE_PRESENT_NV,
};
#endif // VK_NV_low_latency2

#if VK_VERSION_1_4
enum class MemoryUnmapFlagBits : uint32_t {
#if VK_EXT_map_memory_placed
  bReserveEXT = VK_MEMORY_UNMAP_RESERVE_BIT_EXT,
#endif // VK_EXT_map_memory_placed
};
#endif // VK_VERSION_1_4

#if VK_EXT_depth_clamp_control
enum class DepthClampModeEXT : int32_t {
  eViewportRange = VK_DEPTH_CLAMP_MODE_VIEWPORT_RANGE_EXT,
  eUserDefinedRange = VK_DEPTH_CLAMP_MODE_USER_DEFINED_RANGE_EXT,
};
#endif // VK_EXT_depth_clamp_control

#if VK_KHR_maintenance8
enum class AccessFlagBits3KHR : uint64_t {
  eNone = VK_ACCESS_3_NONE_KHR,
};
#endif // VK_KHR_maintenance8

#if VK_QCOM_tile_shading
enum class TileShadingRenderPassFlagBitsQCOM : uint32_t {
  bEnable = VK_TILE_SHADING_RENDER_PASS_ENABLE_BIT_QCOM,
  bPerTileExecution = VK_TILE_SHADING_RENDER_PASS_PER_TILE_EXECUTION_BIT_QCOM,
};
#endif // VK_QCOM_tile_shading

#if VK_NV_cooperative_vector
enum class CooperativeVectorMatrixLayoutNV : int32_t {
  eRowMajor = VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_ROW_MAJOR_NV,
  eColumnMajor = VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_COLUMN_MAJOR_NV,
  eInferencingOptimal = VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_INFERENCING_OPTIMAL_NV,
  eTrainingOptimal = VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_TRAINING_OPTIMAL_NV,
};
#endif // VK_NV_cooperative_vector

#if VK_ARM_tensors
enum class TensorCreateFlagBitsARM : uint64_t {
  bMutableFormat = VK_TENSOR_CREATE_MUTABLE_FORMAT_BIT_ARM,
  bProtected = VK_TENSOR_CREATE_PROTECTED_BIT_ARM,
#if VK_ARM_tensors
  bDescriptorBufferCaptureReplay = VK_TENSOR_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_ARM,
#endif // VK_ARM_tensors
};

enum class TensorUsageFlagBitsARM : uint64_t {
  // Tensor written/read through shader descriptor
  bShader = VK_TENSOR_USAGE_SHADER_BIT_ARM,
  // Tensor can be src of a transfer operation
  bTransferSrc = VK_TENSOR_USAGE_TRANSFER_SRC_BIT_ARM,
  // Tensor can be dst of a transfer operation
  bTransferDst = VK_TENSOR_USAGE_TRANSFER_DST_BIT_ARM,
  // Tensor can be aliased with an image
  bImageAliasing = VK_TENSOR_USAGE_IMAGE_ALIASING_BIT_ARM,
#if VK_ARM_data_graph
  bDataGraph = VK_TENSOR_USAGE_DATA_GRAPH_BIT_ARM,
#endif // VK_ARM_data_graph
};

enum class TensorTilingARM : int32_t {
  eOptimal = VK_TENSOR_TILING_OPTIMAL_ARM,
  eLinear = VK_TENSOR_TILING_LINEAR_ARM,
};

enum class TensorViewCreateFlagBitsARM : uint64_t {
#if VK_ARM_tensors
  bDescriptorBufferCaptureReplay = VK_TENSOR_VIEW_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_ARM,
#endif // VK_ARM_tensors
};
#endif // VK_ARM_tensors

#if VK_KHR_maintenance9
enum class DefaultVertexAttributeValueKHR : int32_t {
  eZeroZeroZeroZero = VK_DEFAULT_VERTEX_ATTRIBUTE_VALUE_ZERO_ZERO_ZERO_ZERO_KHR,
  eZeroZeroZeroOne = VK_DEFAULT_VERTEX_ATTRIBUTE_VALUE_ZERO_ZERO_ZERO_ONE_KHR,
};
#endif // VK_KHR_maintenance9

#if VK_ARM_data_graph
enum class DataGraphPipelineSessionCreateFlagBitsARM : uint64_t {
  bProtected = VK_DATA_GRAPH_PIPELINE_SESSION_CREATE_PROTECTED_BIT_ARM,
};

enum class DataGraphPipelineSessionBindPointARM : int32_t {
  eTransient = VK_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_TRANSIENT_ARM,
};

enum class DataGraphPipelineSessionBindPointTypeARM : int32_t {
  eMemory = VK_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_TYPE_MEMORY_ARM,
};

enum class DataGraphPipelinePropertyARM : int32_t {
  eCreationLog = VK_DATA_GRAPH_PIPELINE_PROPERTY_CREATION_LOG_ARM,
  eIdentifier = VK_DATA_GRAPH_PIPELINE_PROPERTY_IDENTIFIER_ARM,
};

enum class DataGraphPipelineDispatchFlagBitsARM : uint64_t {
};

enum class PhysicalDeviceDataGraphProcessingEngineTypeARM : int32_t {
  eDefault = VK_PHYSICAL_DEVICE_DATA_GRAPH_PROCESSING_ENGINE_TYPE_DEFAULT_ARM,
};

enum class PhysicalDeviceDataGraphOperationTypeARM : int32_t {
  eSpirvExtendedInstructionSet = VK_PHYSICAL_DEVICE_DATA_GRAPH_OPERATION_TYPE_SPIRV_EXTENDED_INSTRUCTION_SET_ARM,
};
#endif // VK_ARM_data_graph

#if VK_VERSION_1_0
struct PhysicalDeviceFeatures : VkPhysicalDeviceFeatures {
  PhysicalDeviceFeatures() noexcept : VkPhysicalDeviceFeatures{} {}

  // out of bounds buffer accesses are well defined
  void setRobustBufferAccess(Bool32 value) { this->robustBufferAccess = value; }
  Bool32 getRobustBufferAccess() const { return this->robustBufferAccess; }
  // full 32-bit range of indices for indexed draw calls
  void setFullDrawIndexUint32(Bool32 value) { this->fullDrawIndexUint32 = value; }
  Bool32 getFullDrawIndexUint32() const { return this->fullDrawIndexUint32; }
  // image views which are arrays of cube maps
  void setImageCubeArray(Bool32 value) { this->imageCubeArray = value; }
  Bool32 getImageCubeArray() const { return this->imageCubeArray; }
  // blending operations are controlled per-attachment
  void setIndependentBlend(Bool32 value) { this->independentBlend = value; }
  Bool32 getIndependentBlend() const { return this->independentBlend; }
  // geometry stage
  void setGeometryShader(Bool32 value) { this->geometryShader = value; }
  Bool32 getGeometryShader() const { return this->geometryShader; }
  // tessellation control and evaluation stage
  void setTessellationShader(Bool32 value) { this->tessellationShader = value; }
  Bool32 getTessellationShader() const { return this->tessellationShader; }
  // per-sample shading and interpolation
  void setSampleRateShading(Bool32 value) { this->sampleRateShading = value; }
  Bool32 getSampleRateShading() const { return this->sampleRateShading; }
  // blend operations which take two sources
  void setDualSrcBlend(Bool32 value) { this->dualSrcBlend = value; }
  Bool32 getDualSrcBlend() const { return this->dualSrcBlend; }
  // logic operations
  void setLogicOp(Bool32 value) { this->logicOp = value; }
  Bool32 getLogicOp() const { return this->logicOp; }
  // multi draw indirect
  void setMultiDrawIndirect(Bool32 value) { this->multiDrawIndirect = value; }
  Bool32 getMultiDrawIndirect() const { return this->multiDrawIndirect; }
  // indirect drawing can use non-zero firstInstance
  void setDrawIndirectFirstInstance(Bool32 value) { this->drawIndirectFirstInstance = value; }
  Bool32 getDrawIndirectFirstInstance() const { return this->drawIndirectFirstInstance; }
  // depth clamping
  void setDepthClamp(Bool32 value) { this->depthClamp = value; }
  Bool32 getDepthClamp() const { return this->depthClamp; }
  // depth bias clamping
  void setDepthBiasClamp(Bool32 value) { this->depthBiasClamp = value; }
  Bool32 getDepthBiasClamp() const { return this->depthBiasClamp; }
  // point and wireframe fill modes
  void setFillModeNonSolid(Bool32 value) { this->fillModeNonSolid = value; }
  Bool32 getFillModeNonSolid() const { return this->fillModeNonSolid; }
  // depth bounds test
  void setDepthBounds(Bool32 value) { this->depthBounds = value; }
  Bool32 getDepthBounds() const { return this->depthBounds; }
  // lines with width greater than 1
  void setWideLines(Bool32 value) { this->wideLines = value; }
  Bool32 getWideLines() const { return this->wideLines; }
  // points with size greater than 1
  void setLargePoints(Bool32 value) { this->largePoints = value; }
  Bool32 getLargePoints() const { return this->largePoints; }
  // the fragment alpha component can be forced to maximum representable alpha value
  void setAlphaToOne(Bool32 value) { this->alphaToOne = value; }
  Bool32 getAlphaToOne() const { return this->alphaToOne; }
  // viewport arrays
  void setMultiViewport(Bool32 value) { this->multiViewport = value; }
  Bool32 getMultiViewport() const { return this->multiViewport; }
  // anisotropic sampler filtering
  void setSamplerAnisotropy(Bool32 value) { this->samplerAnisotropy = value; }
  Bool32 getSamplerAnisotropy() const { return this->samplerAnisotropy; }
  // ETC texture compression formats
  void setTextureCompressionETC2(Bool32 value) { this->textureCompressionETC2 = value; }
  Bool32 getTextureCompressionETC2() const { return this->textureCompressionETC2; }
  // ASTC LDR texture compression formats
  void setTextureCompressionASTC_LDR(Bool32 value) { this->textureCompressionASTC_LDR = value; }
  Bool32 getTextureCompressionASTC_LDR() const { return this->textureCompressionASTC_LDR; }
  // BC1-7 texture compressed formats
  void setTextureCompressionBC(Bool32 value) { this->textureCompressionBC = value; }
  Bool32 getTextureCompressionBC() const { return this->textureCompressionBC; }
  // precise occlusion queries returning actual sample counts
  void setOcclusionQueryPrecise(Bool32 value) { this->occlusionQueryPrecise = value; }
  Bool32 getOcclusionQueryPrecise() const { return this->occlusionQueryPrecise; }
  // pipeline statistics query
  void setPipelineStatisticsQuery(Bool32 value) { this->pipelineStatisticsQuery = value; }
  Bool32 getPipelineStatisticsQuery() const { return this->pipelineStatisticsQuery; }
  // stores and atomic ops on storage buffers and images are supported in vertex, tessellation, and geometry stages
  void setVertexPipelineStoresAndAtomics(Bool32 value) { this->vertexPipelineStoresAndAtomics = value; }
  Bool32 getVertexPipelineStoresAndAtomics() const { return this->vertexPipelineStoresAndAtomics; }
  // stores and atomic ops on storage buffers and images are supported in the fragment stage
  void setFragmentStoresAndAtomics(Bool32 value) { this->fragmentStoresAndAtomics = value; }
  Bool32 getFragmentStoresAndAtomics() const { return this->fragmentStoresAndAtomics; }
  // tessellation and geometry stages can export point size
  void setShaderTessellationAndGeometryPointSize(Bool32 value) { this->shaderTessellationAndGeometryPointSize = value; }
  Bool32 getShaderTessellationAndGeometryPointSize() const { return this->shaderTessellationAndGeometryPointSize; }
  // image gather with runtime values and independent offsets
  void setShaderImageGatherExtended(Bool32 value) { this->shaderImageGatherExtended = value; }
  Bool32 getShaderImageGatherExtended() const { return this->shaderImageGatherExtended; }
  // the extended set of formats can be used for storage images
  void setShaderStorageImageExtendedFormats(Bool32 value) { this->shaderStorageImageExtendedFormats = value; }
  Bool32 getShaderStorageImageExtendedFormats() const { return this->shaderStorageImageExtendedFormats; }
  // multisample images can be used for storage images
  void setShaderStorageImageMultisample(Bool32 value) { this->shaderStorageImageMultisample = value; }
  Bool32 getShaderStorageImageMultisample() const { return this->shaderStorageImageMultisample; }
  // read from storage image does not require format qualifier
  void setShaderStorageImageReadWithoutFormat(Bool32 value) { this->shaderStorageImageReadWithoutFormat = value; }
  Bool32 getShaderStorageImageReadWithoutFormat() const { return this->shaderStorageImageReadWithoutFormat; }
  // write to storage image does not require format qualifier
  void setShaderStorageImageWriteWithoutFormat(Bool32 value) { this->shaderStorageImageWriteWithoutFormat = value; }
  Bool32 getShaderStorageImageWriteWithoutFormat() const { return this->shaderStorageImageWriteWithoutFormat; }
  // arrays of uniform buffers can be accessed with dynamically uniform indices
  void setShaderUniformBufferArrayDynamicIndexing(Bool32 value) { this->shaderUniformBufferArrayDynamicIndexing = value; }
  Bool32 getShaderUniformBufferArrayDynamicIndexing() const { return this->shaderUniformBufferArrayDynamicIndexing; }
  // arrays of sampled images can be accessed with dynamically uniform indices
  void setShaderSampledImageArrayDynamicIndexing(Bool32 value) { this->shaderSampledImageArrayDynamicIndexing = value; }
  Bool32 getShaderSampledImageArrayDynamicIndexing() const { return this->shaderSampledImageArrayDynamicIndexing; }
  // arrays of storage buffers can be accessed with dynamically uniform indices
  void setShaderStorageBufferArrayDynamicIndexing(Bool32 value) { this->shaderStorageBufferArrayDynamicIndexing = value; }
  Bool32 getShaderStorageBufferArrayDynamicIndexing() const { return this->shaderStorageBufferArrayDynamicIndexing; }
  // arrays of storage images can be accessed with dynamically uniform indices
  void setShaderStorageImageArrayDynamicIndexing(Bool32 value) { this->shaderStorageImageArrayDynamicIndexing = value; }
  Bool32 getShaderStorageImageArrayDynamicIndexing() const { return this->shaderStorageImageArrayDynamicIndexing; }
  // clip distance in shaders
  void setShaderClipDistance(Bool32 value) { this->shaderClipDistance = value; }
  Bool32 getShaderClipDistance() const { return this->shaderClipDistance; }
  // cull distance in shaders
  void setShaderCullDistance(Bool32 value) { this->shaderCullDistance = value; }
  Bool32 getShaderCullDistance() const { return this->shaderCullDistance; }
  // 64-bit floats (doubles) in shaders
  void setShaderFloat64(Bool32 value) { this->shaderFloat64 = value; }
  Bool32 getShaderFloat64() const { return this->shaderFloat64; }
  // 64-bit integers in shaders
  void setShaderInt64(Bool32 value) { this->shaderInt64 = value; }
  Bool32 getShaderInt64() const { return this->shaderInt64; }
  // 16-bit integers in shaders
  void setShaderInt16(Bool32 value) { this->shaderInt16 = value; }
  Bool32 getShaderInt16() const { return this->shaderInt16; }
  // shader can use texture operations that return resource residency information (requires sparseNonResident support)
  void setShaderResourceResidency(Bool32 value) { this->shaderResourceResidency = value; }
  Bool32 getShaderResourceResidency() const { return this->shaderResourceResidency; }
  // shader can use texture operations that specify minimum resource LOD
  void setShaderResourceMinLod(Bool32 value) { this->shaderResourceMinLod = value; }
  Bool32 getShaderResourceMinLod() const { return this->shaderResourceMinLod; }
  // Sparse resources support: Resource memory can be managed at opaque page level rather than object level
  void setSparseBinding(Bool32 value) { this->sparseBinding = value; }
  Bool32 getSparseBinding() const { return this->sparseBinding; }
  // Sparse resources support: GPU can access partially resident buffers 
  void setSparseResidencyBuffer(Bool32 value) { this->sparseResidencyBuffer = value; }
  Bool32 getSparseResidencyBuffer() const { return this->sparseResidencyBuffer; }
  // Sparse resources support: GPU can access partially resident 2D (non-MSAA non-depth/stencil) images 
  void setSparseResidencyImage2D(Bool32 value) { this->sparseResidencyImage2D = value; }
  Bool32 getSparseResidencyImage2D() const { return this->sparseResidencyImage2D; }
  // Sparse resources support: GPU can access partially resident 3D images 
  void setSparseResidencyImage3D(Bool32 value) { this->sparseResidencyImage3D = value; }
  Bool32 getSparseResidencyImage3D() const { return this->sparseResidencyImage3D; }
  // Sparse resources support: GPU can access partially resident MSAA 2D images with 2 samples
  void setSparseResidency2Samples(Bool32 value) { this->sparseResidency2Samples = value; }
  Bool32 getSparseResidency2Samples() const { return this->sparseResidency2Samples; }
  // Sparse resources support: GPU can access partially resident MSAA 2D images with 4 samples
  void setSparseResidency4Samples(Bool32 value) { this->sparseResidency4Samples = value; }
  Bool32 getSparseResidency4Samples() const { return this->sparseResidency4Samples; }
  // Sparse resources support: GPU can access partially resident MSAA 2D images with 8 samples
  void setSparseResidency8Samples(Bool32 value) { this->sparseResidency8Samples = value; }
  Bool32 getSparseResidency8Samples() const { return this->sparseResidency8Samples; }
  // Sparse resources support: GPU can access partially resident MSAA 2D images with 16 samples
  void setSparseResidency16Samples(Bool32 value) { this->sparseResidency16Samples = value; }
  Bool32 getSparseResidency16Samples() const { return this->sparseResidency16Samples; }
  // Sparse resources support: GPU can correctly access data aliased into multiple locations (opt-in)
  void setSparseResidencyAliased(Bool32 value) { this->sparseResidencyAliased = value; }
  Bool32 getSparseResidencyAliased() const { return this->sparseResidencyAliased; }
  // multisample rate must be the same for all pipelines in a subpass
  void setVariableMultisampleRate(Bool32 value) { this->variableMultisampleRate = value; }
  Bool32 getVariableMultisampleRate() const { return this->variableMultisampleRate; }
  // Queries may be inherited from primary to secondary command buffers
  void setInheritedQueries(Bool32 value) { this->inheritedQueries = value; }
  Bool32 getInheritedQueries() const { return this->inheritedQueries; }
};

struct PhysicalDeviceSparseProperties : VkPhysicalDeviceSparseProperties {
  PhysicalDeviceSparseProperties() noexcept : VkPhysicalDeviceSparseProperties{} {}

  // Sparse resources support: GPU will access all 2D (single sample) sparse resources using the standard sparse image block shapes (based on pixel format)
  Bool32 getResidencyStandard2DBlockShape() const { return this->residencyStandard2DBlockShape; }
  // Sparse resources support: GPU will access all 2D (multisample) sparse resources using the standard sparse image block shapes (based on pixel format)
  Bool32 getResidencyStandard2DMultisampleBlockShape() const { return this->residencyStandard2DMultisampleBlockShape; }
  // Sparse resources support: GPU will access all 3D sparse resources using the standard sparse image block shapes (based on pixel format)
  Bool32 getResidencyStandard3DBlockShape() const { return this->residencyStandard3DBlockShape; }
  // Sparse resources support: Images with mip level dimensions that are NOT a multiple of the sparse image block dimensions will be placed in the mip tail
  Bool32 getResidencyAlignedMipSize() const { return this->residencyAlignedMipSize; }
  // Sparse resources support: GPU can consistently access non-resident regions of a resource, all reads return as if data is 0, writes are discarded
  Bool32 getResidencyNonResidentStrict() const { return this->residencyNonResidentStrict; }
};

struct MemoryRequirements : VkMemoryRequirements {
  MemoryRequirements() noexcept : VkMemoryRequirements{} {}

  // Specified in bytes
  DeviceSize getSize() const { return this->size; }
  // Specified in bytes
  DeviceSize getAlignment() const { return this->alignment; }
  // Bitmask of the allowed memory type indices into memoryTypes[] for this object
  uint32_t getMemoryTypeBits() const { return this->memoryTypeBits; }
};

struct SubresourceLayout : VkSubresourceLayout {
  SubresourceLayout() noexcept : VkSubresourceLayout{} {}
  SubresourceLayout(DeviceSize offset, DeviceSize size, DeviceSize rowPitch, DeviceSize arrayPitch, DeviceSize depthPitch) noexcept : VkSubresourceLayout{.offset = offset, .size = size, .rowPitch = rowPitch, .arrayPitch = arrayPitch, .depthPitch = depthPitch} {}

  // Specified in bytes
  void setOffset(DeviceSize value) { this->offset = value; }
  DeviceSize getOffset() const { return this->offset; }
  // Specified in bytes
  void setSize(DeviceSize value) { this->size = value; }
  DeviceSize getSize() const { return this->size; }
  // Specified in bytes
  void setRowPitch(DeviceSize value) { this->rowPitch = value; }
  DeviceSize getRowPitch() const { return this->rowPitch; }
  // Specified in bytes
  void setArrayPitch(DeviceSize value) { this->arrayPitch = value; }
  DeviceSize getArrayPitch() const { return this->arrayPitch; }
  // Specified in bytes
  void setDepthPitch(DeviceSize value) { this->depthPitch = value; }
  DeviceSize getDepthPitch() const { return this->depthPitch; }
};

struct BufferCopy : VkBufferCopy {
  BufferCopy() noexcept : VkBufferCopy{} {}
  BufferCopy(DeviceSize srcOffset, DeviceSize dstOffset, DeviceSize size) noexcept : VkBufferCopy{.srcOffset = srcOffset, .dstOffset = dstOffset, .size = size} {}

  // Specified in bytes
  void setSrcOffset(DeviceSize value) { this->srcOffset = value; }
  DeviceSize getSrcOffset() const { return this->srcOffset; }
  // Specified in bytes
  void setDstOffset(DeviceSize value) { this->dstOffset = value; }
  DeviceSize getDstOffset() const { return this->dstOffset; }
  // Specified in bytes
  void setSize(DeviceSize value) { this->size = value; }
  DeviceSize getSize() const { return this->size; }
};
#endif // VK_VERSION_1_0

#if VK_NV_cluster_acceleration_structure
struct StridedDeviceAddressNV : VkStridedDeviceAddressNV {
  StridedDeviceAddressNV() noexcept : VkStridedDeviceAddressNV{} {}
  StridedDeviceAddressNV(DeviceAddress startAddress, DeviceSize strideInBytes) noexcept : VkStridedDeviceAddressNV{.startAddress = startAddress, .strideInBytes = strideInBytes} {}

  void setStartAddress(DeviceAddress value) { this->startAddress = value; }
  DeviceAddress getStartAddress() const { return this->startAddress; }
  // Specified in bytes
  void setStrideInBytes(DeviceSize value) { this->strideInBytes = value; }
  DeviceSize getStrideInBytes() const { return this->strideInBytes; }
};

struct ClusterAccelerationStructureMoveObjectsInfoNV : VkClusterAccelerationStructureMoveObjectsInfoNV {
  ClusterAccelerationStructureMoveObjectsInfoNV() noexcept : VkClusterAccelerationStructureMoveObjectsInfoNV{} {}
  ClusterAccelerationStructureMoveObjectsInfoNV(DeviceAddress srcAccelerationStructure) noexcept : VkClusterAccelerationStructureMoveObjectsInfoNV{.srcAccelerationStructure = srcAccelerationStructure} {}

  void setSrcAccelerationStructure(DeviceAddress value) { this->srcAccelerationStructure = value; }
  DeviceAddress getSrcAccelerationStructure() const { return this->srcAccelerationStructure; }
};

struct ClusterAccelerationStructureBuildClustersBottomLevelInfoNV : VkClusterAccelerationStructureBuildClustersBottomLevelInfoNV {
  ClusterAccelerationStructureBuildClustersBottomLevelInfoNV() noexcept : VkClusterAccelerationStructureBuildClustersBottomLevelInfoNV{} {}
  ClusterAccelerationStructureBuildClustersBottomLevelInfoNV(uint32_t clusterReferencesCount, uint32_t clusterReferencesStride, DeviceAddress clusterReferences) noexcept : VkClusterAccelerationStructureBuildClustersBottomLevelInfoNV{.clusterReferencesCount = clusterReferencesCount, .clusterReferencesStride = clusterReferencesStride, .clusterReferences = clusterReferences} {}

  void setClusterReferencesCount(uint32_t value) { this->clusterReferencesCount = value; }
  uint32_t getClusterReferencesCount() const { return this->clusterReferencesCount; }
  void setClusterReferencesStride(uint32_t value) { this->clusterReferencesStride = value; }
  uint32_t getClusterReferencesStride() const { return this->clusterReferencesStride; }
  void setClusterReferences(DeviceAddress value) { this->clusterReferences = value; }
  DeviceAddress getClusterReferences() const { return this->clusterReferences; }
};

struct ClusterAccelerationStructureGetTemplateIndicesInfoNV : VkClusterAccelerationStructureGetTemplateIndicesInfoNV {
  ClusterAccelerationStructureGetTemplateIndicesInfoNV() noexcept : VkClusterAccelerationStructureGetTemplateIndicesInfoNV{} {}
  ClusterAccelerationStructureGetTemplateIndicesInfoNV(DeviceAddress clusterTemplateAddress) noexcept : VkClusterAccelerationStructureGetTemplateIndicesInfoNV{.clusterTemplateAddress = clusterTemplateAddress} {}

  void setClusterTemplateAddress(DeviceAddress value) { this->clusterTemplateAddress = value; }
  DeviceAddress getClusterTemplateAddress() const { return this->clusterTemplateAddress; }
};
#endif // VK_NV_cluster_acceleration_structure

#if VK_NV_device_generated_commands
struct BindVertexBufferIndirectCommandNV : VkBindVertexBufferIndirectCommandNV {
  BindVertexBufferIndirectCommandNV() noexcept : VkBindVertexBufferIndirectCommandNV{} {}
  BindVertexBufferIndirectCommandNV(DeviceAddress bufferAddress, uint32_t size, uint32_t stride) noexcept : VkBindVertexBufferIndirectCommandNV{.bufferAddress = bufferAddress, .size = size, .stride = stride} {}

  void setBufferAddress(DeviceAddress value) { this->bufferAddress = value; }
  DeviceAddress getBufferAddress() const { return this->bufferAddress; }
  void setSize(uint32_t value) { this->size = value; }
  uint32_t getSize() const { return this->size; }
  void setStride(uint32_t value) { this->stride = value; }
  uint32_t getStride() const { return this->stride; }
};
#endif // VK_NV_device_generated_commands

#if VK_NV_device_generated_commands_compute
struct BindPipelineIndirectCommandNV : VkBindPipelineIndirectCommandNV {
  BindPipelineIndirectCommandNV() noexcept : VkBindPipelineIndirectCommandNV{} {}
  BindPipelineIndirectCommandNV(DeviceAddress pipelineAddress) noexcept : VkBindPipelineIndirectCommandNV{.pipelineAddress = pipelineAddress} {}

  void setPipelineAddress(DeviceAddress value) { this->pipelineAddress = value; }
  DeviceAddress getPipelineAddress() const { return this->pipelineAddress; }
};
#endif // VK_NV_device_generated_commands_compute

#if VK_KHR_ray_tracing_pipeline
struct StridedDeviceAddressRegionKHR : VkStridedDeviceAddressRegionKHR {
  StridedDeviceAddressRegionKHR() noexcept : VkStridedDeviceAddressRegionKHR{} {}

  void setStride(DeviceSize value) { this->stride = value; }
  DeviceSize getStride() const { return this->stride; }
  void setSize(DeviceSize value) { this->size = value; }
  DeviceSize getSize() const { return this->size; }

  void setDeviceAddress(DeviceAddress value) { this->deviceAddress = value; }
  DeviceAddress getDeviceAddress() const { return this->deviceAddress; }
};
#endif // VK_KHR_ray_tracing_pipeline

#if VK_KHR_ray_tracing_maintenance1
struct TraceRaysIndirectCommand2KHR : VkTraceRaysIndirectCommand2KHR {
  TraceRaysIndirectCommand2KHR() noexcept : VkTraceRaysIndirectCommand2KHR{} {}
  TraceRaysIndirectCommand2KHR(DeviceAddress raygenShaderRecordAddress, DeviceSize raygenShaderRecordSize, DeviceAddress missShaderBindingTableAddress, DeviceSize missShaderBindingTableSize, DeviceSize missShaderBindingTableStride, DeviceAddress hitShaderBindingTableAddress, DeviceSize hitShaderBindingTableSize, DeviceSize hitShaderBindingTableStride, DeviceAddress callableShaderBindingTableAddress, DeviceSize callableShaderBindingTableSize, DeviceSize callableShaderBindingTableStride, uint32_t width, uint32_t height, uint32_t depth) noexcept : VkTraceRaysIndirectCommand2KHR{.raygenShaderRecordAddress = raygenShaderRecordAddress, .raygenShaderRecordSize = raygenShaderRecordSize, .missShaderBindingTableAddress = missShaderBindingTableAddress, .missShaderBindingTableSize = missShaderBindingTableSize, .missShaderBindingTableStride = missShaderBindingTableStride, .hitShaderBindingTableAddress = hitShaderBindingTableAddress, .hitShaderBindingTableSize = hitShaderBindingTableSize, .hitShaderBindingTableStride = hitShaderBindingTableStride, .callableShaderBindingTableAddress = callableShaderBindingTableAddress, .callableShaderBindingTableSize = callableShaderBindingTableSize, .callableShaderBindingTableStride = callableShaderBindingTableStride, .width = width, .height = height, .depth = depth} {}

  void setRaygenShaderRecordAddress(DeviceAddress value) { this->raygenShaderRecordAddress = value; }
  DeviceAddress getRaygenShaderRecordAddress() const { return this->raygenShaderRecordAddress; }
  void setRaygenShaderRecordSize(DeviceSize value) { this->raygenShaderRecordSize = value; }
  DeviceSize getRaygenShaderRecordSize() const { return this->raygenShaderRecordSize; }
  void setMissShaderBindingTableAddress(DeviceAddress value) { this->missShaderBindingTableAddress = value; }
  DeviceAddress getMissShaderBindingTableAddress() const { return this->missShaderBindingTableAddress; }
  void setMissShaderBindingTableSize(DeviceSize value) { this->missShaderBindingTableSize = value; }
  DeviceSize getMissShaderBindingTableSize() const { return this->missShaderBindingTableSize; }
  void setMissShaderBindingTableStride(DeviceSize value) { this->missShaderBindingTableStride = value; }
  DeviceSize getMissShaderBindingTableStride() const { return this->missShaderBindingTableStride; }
  void setHitShaderBindingTableAddress(DeviceAddress value) { this->hitShaderBindingTableAddress = value; }
  DeviceAddress getHitShaderBindingTableAddress() const { return this->hitShaderBindingTableAddress; }
  void setHitShaderBindingTableSize(DeviceSize value) { this->hitShaderBindingTableSize = value; }
  DeviceSize getHitShaderBindingTableSize() const { return this->hitShaderBindingTableSize; }
  void setHitShaderBindingTableStride(DeviceSize value) { this->hitShaderBindingTableStride = value; }
  DeviceSize getHitShaderBindingTableStride() const { return this->hitShaderBindingTableStride; }
  void setCallableShaderBindingTableAddress(DeviceAddress value) { this->callableShaderBindingTableAddress = value; }
  DeviceAddress getCallableShaderBindingTableAddress() const { return this->callableShaderBindingTableAddress; }
  void setCallableShaderBindingTableSize(DeviceSize value) { this->callableShaderBindingTableSize = value; }
  DeviceSize getCallableShaderBindingTableSize() const { return this->callableShaderBindingTableSize; }
  void setCallableShaderBindingTableStride(DeviceSize value) { this->callableShaderBindingTableStride = value; }
  DeviceSize getCallableShaderBindingTableStride() const { return this->callableShaderBindingTableStride; }
  void setWidth(uint32_t value) { this->width = value; }
  uint32_t getWidth() const { return this->width; }
  void setHeight(uint32_t value) { this->height = value; }
  uint32_t getHeight() const { return this->height; }
  void setDepth(uint32_t value) { this->depth = value; }
  uint32_t getDepth() const { return this->depth; }
};
#endif // VK_KHR_ray_tracing_maintenance1

#if VK_NV_partitioned_acceleration_structure
struct PartitionedAccelerationStructureUpdateInstanceDataNV : VkPartitionedAccelerationStructureUpdateInstanceDataNV {
  PartitionedAccelerationStructureUpdateInstanceDataNV() noexcept : VkPartitionedAccelerationStructureUpdateInstanceDataNV{} {}
  PartitionedAccelerationStructureUpdateInstanceDataNV(uint32_t instanceIndex, uint32_t instanceContributionToHitGroupIndex, DeviceAddress accelerationStructure) noexcept : VkPartitionedAccelerationStructureUpdateInstanceDataNV{.instanceIndex = instanceIndex, .instanceContributionToHitGroupIndex = instanceContributionToHitGroupIndex, .accelerationStructure = accelerationStructure} {}

  void setInstanceIndex(uint32_t value) { this->instanceIndex = value; }
  uint32_t getInstanceIndex() const { return this->instanceIndex; }
  void setInstanceContributionToHitGroupIndex(uint32_t value) { this->instanceContributionToHitGroupIndex = value; }
  uint32_t getInstanceContributionToHitGroupIndex() const { return this->instanceContributionToHitGroupIndex; }
  void setAccelerationStructure(DeviceAddress value) { this->accelerationStructure = value; }
  DeviceAddress getAccelerationStructure() const { return this->accelerationStructure; }
};
#endif // VK_NV_partitioned_acceleration_structure

#if VK_EXT_device_generated_commands
struct DrawIndirectCountIndirectCommandEXT : VkDrawIndirectCountIndirectCommandEXT {
  DrawIndirectCountIndirectCommandEXT() noexcept : VkDrawIndirectCountIndirectCommandEXT{} {}
  DrawIndirectCountIndirectCommandEXT(DeviceAddress bufferAddress, uint32_t stride, uint32_t commandCount) noexcept : VkDrawIndirectCountIndirectCommandEXT{.bufferAddress = bufferAddress, .stride = stride, .commandCount = commandCount} {}

  void setBufferAddress(DeviceAddress value) { this->bufferAddress = value; }
  DeviceAddress getBufferAddress() const { return this->bufferAddress; }
  void setStride(uint32_t value) { this->stride = value; }
  uint32_t getStride() const { return this->stride; }
  void setCommandCount(uint32_t value) { this->commandCount = value; }
  uint32_t getCommandCount() const { return this->commandCount; }
};

struct BindVertexBufferIndirectCommandEXT : VkBindVertexBufferIndirectCommandEXT {
  BindVertexBufferIndirectCommandEXT() noexcept : VkBindVertexBufferIndirectCommandEXT{} {}
  BindVertexBufferIndirectCommandEXT(DeviceAddress bufferAddress, uint32_t size, uint32_t stride) noexcept : VkBindVertexBufferIndirectCommandEXT{.bufferAddress = bufferAddress, .size = size, .stride = stride} {}

  void setBufferAddress(DeviceAddress value) { this->bufferAddress = value; }
  DeviceAddress getBufferAddress() const { return this->bufferAddress; }
  void setSize(uint32_t value) { this->size = value; }
  uint32_t getSize() const { return this->size; }
  void setStride(uint32_t value) { this->stride = value; }
  uint32_t getStride() const { return this->stride; }
};
#endif // VK_EXT_device_generated_commands

#if VK_NV_copy_memory_indirect
struct CopyMemoryIndirectCommandNV : VkCopyMemoryIndirectCommandNV {
  CopyMemoryIndirectCommandNV() noexcept : VkCopyMemoryIndirectCommandNV{} {}
  CopyMemoryIndirectCommandNV(DeviceAddress srcAddress, DeviceAddress dstAddress, DeviceSize size) noexcept : VkCopyMemoryIndirectCommandNV{.srcAddress = srcAddress, .dstAddress = dstAddress, .size = size} {}

  void setSrcAddress(DeviceAddress value) { this->srcAddress = value; }
  DeviceAddress getSrcAddress() const { return this->srcAddress; }
  void setDstAddress(DeviceAddress value) { this->dstAddress = value; }
  DeviceAddress getDstAddress() const { return this->dstAddress; }
  // Specified in bytes
  void setSize(DeviceSize value) { this->size = value; }
  DeviceSize getSize() const { return this->size; }
};
#endif // VK_NV_copy_memory_indirect

#if VK_EXT_private_data
using PrivateDataSlotCreateFlagsEXT = PrivateDataSlotCreateFlags;
#endif // VK_EXT_private_data
#if VK_KHR_descriptor_update_template
using DescriptorUpdateTemplateCreateFlagsKHR = DescriptorUpdateTemplateCreateFlags;
#endif // VK_KHR_descriptor_update_template
#if VK_KHR_maintenance1
using CommandPoolTrimFlagsKHR = CommandPoolTrimFlags;
#endif // VK_KHR_maintenance1

#if VK_KHR_display
struct DisplayModeParametersKHR : VkDisplayModeParametersKHR {
  DisplayModeParametersKHR() noexcept : VkDisplayModeParametersKHR{} {}
  DisplayModeParametersKHR(const Extent2D& visibleRegion, uint32_t refreshRate) noexcept : VkDisplayModeParametersKHR{.visibleRegion = visibleRegion, .refreshRate = refreshRate} {}

  // Visible scanout region.
  void setVisibleRegion(const Extent2D& value) { this->visibleRegion = value; }
  const Extent2D& getVisibleRegion() const { return static_cast<const Extent2D&>(this->visibleRegion); }
  // Number of times per second the display is updated.
  void setRefreshRate(uint32_t value) { this->refreshRate = value; }
  uint32_t getRefreshRate() const { return this->refreshRate; }
};
#endif // VK_KHR_display

#if VK_KHR_incremental_present
struct RectLayerKHR : VkRectLayerKHR {
  RectLayerKHR() noexcept : VkRectLayerKHR{} {}
  RectLayerKHR(const Offset2D& offset, const Extent2D& extent, uint32_t layer) noexcept : VkRectLayerKHR{.offset = offset, .extent = extent, .layer = layer} {}

  // upper-left corner of a rectangle that has not changed, in pixels of a presentation images
  void setOffset(const Offset2D& value) { this->offset = value; }
  const Offset2D& getOffset() const { return static_cast<const Offset2D&>(this->offset); }
  // Dimensions of a rectangle that has not changed, in pixels of a presentation images
  void setExtent(const Extent2D& value) { this->extent = value; }
  const Extent2D& getExtent() const { return static_cast<const Extent2D&>(this->extent); }
  // Layer of a swapchain's image(s), for stereoscopic-3D images
  void setLayer(uint32_t value) { this->layer = value; }
  uint32_t getLayer() const { return this->layer; }
};
#endif // VK_KHR_incremental_present

#if VK_VERSION_1_0
struct Rect2D : VkRect2D {
  Rect2D() noexcept : VkRect2D{} {}
  Rect2D(const Offset2D& offset, const Extent2D& extent) noexcept : VkRect2D{.offset = offset, .extent = extent} {}

  void setOffset(const Offset2D& value) { this->offset = value; }
  const Offset2D& getOffset() const { return static_cast<const Offset2D&>(this->offset); }
  void setExtent(const Extent2D& value) { this->extent = value; }
  const Extent2D& getExtent() const { return static_cast<const Extent2D&>(this->extent); }
};

struct SpecializationInfo : VkSpecializationInfo {
  SpecializationInfo() noexcept : VkSpecializationInfo{} {}

  // Number of entries in the map
  void setMapEntryCount(uint32_t value) { this->mapEntryCount = value; }
  uint32_t getMapEntryCount() const { return this->mapEntryCount; }
  // Array of map entries
  void setMapEntries(const SpecializationMapEntry* value) { this->pMapEntries = std::bit_cast<const VkSpecializationMapEntry*>(value); }
  const SpecializationMapEntry* getMapEntries() const { return std::bit_cast<const SpecializationMapEntry*>(this->pMapEntries); }
  // Size in bytes of pData
  void setDataSize(size_t value) { this->dataSize = value; }
  size_t getDataSize() const { return this->dataSize; }
  // Pointer to SpecConstant data
  void setData(const void* value) { this->pData = value; }
  const void* getData() const { return this->pData; }
};
#endif // VK_VERSION_1_0

#if VK_KHR_driver_properties
using ConformanceVersionKHR = ConformanceVersion;
#endif // VK_KHR_driver_properties
#if VK_KHR_vertex_attribute_divisor
using VertexInputBindingDivisorDescriptionKHR = VertexInputBindingDivisorDescription;
#endif // VK_KHR_vertex_attribute_divisor
#if VK_EXT_vertex_attribute_divisor
using VertexInputBindingDivisorDescriptionEXT = VertexInputBindingDivisorDescription;
#endif // VK_EXT_vertex_attribute_divisor

#if VK_VERSION_1_0
struct AttachmentReference : VkAttachmentReference {
  AttachmentReference() noexcept : VkAttachmentReference{} {}
  AttachmentReference(uint32_t attachment, ImageLayout layout) noexcept : VkAttachmentReference{.attachment = attachment, .layout = std::bit_cast<VkImageLayout>(layout)} {}

  void setAttachment(uint32_t value) { this->attachment = value; }
  uint32_t getAttachment() const { return this->attachment; }
  void setLayout(ImageLayout value) { this->layout = std::bit_cast<VkImageLayout>(value); }
  ImageLayout getLayout() const { return std::bit_cast<ImageLayout>(this->layout); }
};

struct ComponentMapping : VkComponentMapping {
  ComponentMapping() noexcept : VkComponentMapping{} {}
  ComponentMapping(ComponentSwizzle r, ComponentSwizzle g, ComponentSwizzle b, ComponentSwizzle a) noexcept : VkComponentMapping{.r = std::bit_cast<VkComponentSwizzle>(r), .g = std::bit_cast<VkComponentSwizzle>(g), .b = std::bit_cast<VkComponentSwizzle>(b), .a = std::bit_cast<VkComponentSwizzle>(a)} {}

  void setR(ComponentSwizzle value) { this->r = std::bit_cast<VkComponentSwizzle>(value); }
  ComponentSwizzle getR() const { return std::bit_cast<ComponentSwizzle>(this->r); }
  void setG(ComponentSwizzle value) { this->g = std::bit_cast<VkComponentSwizzle>(value); }
  ComponentSwizzle getG() const { return std::bit_cast<ComponentSwizzle>(this->g); }
  void setB(ComponentSwizzle value) { this->b = std::bit_cast<VkComponentSwizzle>(value); }
  ComponentSwizzle getB() const { return std::bit_cast<ComponentSwizzle>(this->b); }
  void setA(ComponentSwizzle value) { this->a = std::bit_cast<VkComponentSwizzle>(value); }
  ComponentSwizzle getA() const { return std::bit_cast<ComponentSwizzle>(this->a); }
};
#endif // VK_VERSION_1_0

#if VK_VERSION_1_1
struct DescriptorUpdateTemplateEntry : VkDescriptorUpdateTemplateEntry {
  DescriptorUpdateTemplateEntry() noexcept : VkDescriptorUpdateTemplateEntry{} {}
  DescriptorUpdateTemplateEntry(uint32_t dstBinding, uint32_t dstArrayElement, uint32_t descriptorCount, DescriptorType descriptorType, size_t offset, size_t stride) noexcept : VkDescriptorUpdateTemplateEntry{.dstBinding = dstBinding, .dstArrayElement = dstArrayElement, .descriptorCount = descriptorCount, .descriptorType = std::bit_cast<VkDescriptorType>(descriptorType), .offset = offset, .stride = stride} {}

  // Binding within the destination descriptor set to write
  void setDstBinding(uint32_t value) { this->dstBinding = value; }
  uint32_t getDstBinding() const { return this->dstBinding; }
  // Array element within the destination binding to write
  void setDstArrayElement(uint32_t value) { this->dstArrayElement = value; }
  uint32_t getDstArrayElement() const { return this->dstArrayElement; }
  // Number of descriptors to write
  void setDescriptorCount(uint32_t value) { this->descriptorCount = value; }
  uint32_t getDescriptorCount() const { return this->descriptorCount; }
  // Descriptor type to write
  void setDescriptorType(DescriptorType value) { this->descriptorType = std::bit_cast<VkDescriptorType>(value); }
  DescriptorType getDescriptorType() const { return std::bit_cast<DescriptorType>(this->descriptorType); }
  // Offset into pData where the descriptors to update are stored
  void setOffset(size_t value) { this->offset = value; }
  size_t getOffset() const { return this->offset; }
  // Stride between two descriptors in pData when writing more than one descriptor
  void setStride(size_t value) { this->stride = value; }
  size_t getStride() const { return this->stride; }
};
#endif // VK_VERSION_1_1

#if VK_EXT_mutable_descriptor_type
struct MutableDescriptorTypeListEXT : VkMutableDescriptorTypeListEXT {
  MutableDescriptorTypeListEXT() noexcept : VkMutableDescriptorTypeListEXT{} {}

  void setDescriptorTypeCount(uint32_t value) { this->descriptorTypeCount = value; }
  uint32_t getDescriptorTypeCount() const { return this->descriptorTypeCount; }
  void setDescriptorTypes(const DescriptorType* value) { this->pDescriptorTypes = std::bit_cast<const VkDescriptorType*>(value); }
  const DescriptorType* getDescriptorTypes() const { return std::bit_cast<const DescriptorType*>(this->pDescriptorTypes); }
};
#endif // VK_EXT_mutable_descriptor_type

#if VK_VERSION_1_0
struct DescriptorPoolSize : VkDescriptorPoolSize {
  DescriptorPoolSize() noexcept : VkDescriptorPoolSize{} {}
  DescriptorPoolSize(DescriptorType type, uint32_t descriptorCount) noexcept : VkDescriptorPoolSize{.type = std::bit_cast<VkDescriptorType>(type), .descriptorCount = descriptorCount} {}

  void setType(DescriptorType value) { this->type = std::bit_cast<VkDescriptorType>(value); }
  DescriptorType getType() const { return std::bit_cast<DescriptorType>(this->type); }
  void setDescriptorCount(uint32_t value) { this->descriptorCount = value; }
  uint32_t getDescriptorCount() const { return this->descriptorCount; }
};

struct PipelineCacheHeaderVersionOne : VkPipelineCacheHeaderVersionOne {
  PipelineCacheHeaderVersionOne() noexcept : VkPipelineCacheHeaderVersionOne{} {}
  PipelineCacheHeaderVersionOne(uint32_t headerSize, PipelineCacheHeaderVersion headerVersion, uint32_t vendorID, uint32_t deviceID, std::span<const uint8_t, VK_UUID_SIZE> pipelineCacheUUID) noexcept : VkPipelineCacheHeaderVersionOne{.headerSize = headerSize, .headerVersion = std::bit_cast<VkPipelineCacheHeaderVersion>(headerVersion), .vendorID = vendorID, .deviceID = deviceID} { setPipelineCacheUUID(pipelineCacheUUID); }

  void setHeaderSize(uint32_t value) { this->headerSize = value; }
  uint32_t getHeaderSize() const { return this->headerSize; }
  void setHeaderVersion(PipelineCacheHeaderVersion value) { this->headerVersion = std::bit_cast<VkPipelineCacheHeaderVersion>(value); }
  PipelineCacheHeaderVersion getHeaderVersion() const { return std::bit_cast<PipelineCacheHeaderVersion>(this->headerVersion); }
  void setVendorID(uint32_t value) { this->vendorID = value; }
  uint32_t getVendorID() const { return this->vendorID; }
  void setDeviceID(uint32_t value) { this->deviceID = value; }
  uint32_t getDeviceID() const { return this->deviceID; }
  void setPipelineCacheUUID(std::span<const uint8_t, VK_UUID_SIZE> value) { std::memcpy(&this->pipelineCacheUUID, value.data(), value.size_bytes()); }
  std::span<const uint8_t, VK_UUID_SIZE> getPipelineCacheUUID() const { return this->pipelineCacheUUID; }
};

using PipelineCacheCreateFlags = FlagSet<PipelineCacheCreateFlagBits, Flags>;
constexpr PipelineCacheCreateFlags operator|(PipelineCacheCreateFlagBits a, PipelineCacheCreateFlagBits b) noexcept { return PipelineCacheCreateFlags(Flags(a) | Flags(b)); }
#endif // VK_VERSION_1_0

#if VK_NV_device_generated_commands
struct BindIndexBufferIndirectCommandNV : VkBindIndexBufferIndirectCommandNV {
  BindIndexBufferIndirectCommandNV() noexcept : VkBindIndexBufferIndirectCommandNV{} {}
  BindIndexBufferIndirectCommandNV(DeviceAddress bufferAddress, uint32_t size, IndexType indexType) noexcept : VkBindIndexBufferIndirectCommandNV{.bufferAddress = bufferAddress, .size = size, .indexType = std::bit_cast<VkIndexType>(indexType)} {}

  void setBufferAddress(DeviceAddress value) { this->bufferAddress = value; }
  DeviceAddress getBufferAddress() const { return this->bufferAddress; }
  void setSize(uint32_t value) { this->size = value; }
  uint32_t getSize() const { return this->size; }
  void setIndexType(IndexType value) { this->indexType = std::bit_cast<VkIndexType>(value); }
  IndexType getIndexType() const { return std::bit_cast<IndexType>(this->indexType); }
};
#endif // VK_NV_device_generated_commands

#if VK_EXT_device_generated_commands
struct BindIndexBufferIndirectCommandEXT : VkBindIndexBufferIndirectCommandEXT {
  BindIndexBufferIndirectCommandEXT() noexcept : VkBindIndexBufferIndirectCommandEXT{} {}
  BindIndexBufferIndirectCommandEXT(DeviceAddress bufferAddress, uint32_t size, IndexType indexType) noexcept : VkBindIndexBufferIndirectCommandEXT{.bufferAddress = bufferAddress, .size = size, .indexType = std::bit_cast<VkIndexType>(indexType)} {}

  void setBufferAddress(DeviceAddress value) { this->bufferAddress = value; }
  DeviceAddress getBufferAddress() const { return this->bufferAddress; }
  void setSize(uint32_t value) { this->size = value; }
  uint32_t getSize() const { return this->size; }
  void setIndexType(IndexType value) { this->indexType = std::bit_cast<VkIndexType>(value); }
  IndexType getIndexType() const { return std::bit_cast<IndexType>(this->indexType); }
};
#endif // VK_EXT_device_generated_commands

#if VK_EXT_extended_dynamic_state3
struct ColorBlendEquationEXT : VkColorBlendEquationEXT {
  ColorBlendEquationEXT() noexcept : VkColorBlendEquationEXT{} {}
  ColorBlendEquationEXT(BlendFactor srcColorBlendFactor, BlendFactor dstColorBlendFactor, BlendOp colorBlendOp, BlendFactor srcAlphaBlendFactor, BlendFactor dstAlphaBlendFactor, BlendOp alphaBlendOp) noexcept : VkColorBlendEquationEXT{.srcColorBlendFactor = std::bit_cast<VkBlendFactor>(srcColorBlendFactor), .dstColorBlendFactor = std::bit_cast<VkBlendFactor>(dstColorBlendFactor), .colorBlendOp = std::bit_cast<VkBlendOp>(colorBlendOp), .srcAlphaBlendFactor = std::bit_cast<VkBlendFactor>(srcAlphaBlendFactor), .dstAlphaBlendFactor = std::bit_cast<VkBlendFactor>(dstAlphaBlendFactor), .alphaBlendOp = std::bit_cast<VkBlendOp>(alphaBlendOp)} {}

  void setSrcColorBlendFactor(BlendFactor value) { this->srcColorBlendFactor = std::bit_cast<VkBlendFactor>(value); }
  BlendFactor getSrcColorBlendFactor() const { return std::bit_cast<BlendFactor>(this->srcColorBlendFactor); }
  void setDstColorBlendFactor(BlendFactor value) { this->dstColorBlendFactor = std::bit_cast<VkBlendFactor>(value); }
  BlendFactor getDstColorBlendFactor() const { return std::bit_cast<BlendFactor>(this->dstColorBlendFactor); }
  void setColorBlendOp(BlendOp value) { this->colorBlendOp = std::bit_cast<VkBlendOp>(value); }
  BlendOp getColorBlendOp() const { return std::bit_cast<BlendOp>(this->colorBlendOp); }
  void setSrcAlphaBlendFactor(BlendFactor value) { this->srcAlphaBlendFactor = std::bit_cast<VkBlendFactor>(value); }
  BlendFactor getSrcAlphaBlendFactor() const { return std::bit_cast<BlendFactor>(this->srcAlphaBlendFactor); }
  void setDstAlphaBlendFactor(BlendFactor value) { this->dstAlphaBlendFactor = std::bit_cast<VkBlendFactor>(value); }
  BlendFactor getDstAlphaBlendFactor() const { return std::bit_cast<BlendFactor>(this->dstAlphaBlendFactor); }
  void setAlphaBlendOp(BlendOp value) { this->alphaBlendOp = std::bit_cast<VkBlendOp>(value); }
  BlendOp getAlphaBlendOp() const { return std::bit_cast<BlendOp>(this->alphaBlendOp); }
};
#endif // VK_EXT_extended_dynamic_state3

#if VK_VERSION_1_0
struct StencilOpState : VkStencilOpState {
  StencilOpState() noexcept : VkStencilOpState{} {}
  StencilOpState(StencilOp failOp, StencilOp passOp, StencilOp depthFailOp, CompareOp compareOp, uint32_t compareMask, uint32_t writeMask, uint32_t reference) noexcept : VkStencilOpState{.failOp = std::bit_cast<VkStencilOp>(failOp), .passOp = std::bit_cast<VkStencilOp>(passOp), .depthFailOp = std::bit_cast<VkStencilOp>(depthFailOp), .compareOp = std::bit_cast<VkCompareOp>(compareOp), .compareMask = compareMask, .writeMask = writeMask, .reference = reference} {}

  void setFailOp(StencilOp value) { this->failOp = std::bit_cast<VkStencilOp>(value); }
  StencilOp getFailOp() const { return std::bit_cast<StencilOp>(this->failOp); }
  void setPassOp(StencilOp value) { this->passOp = std::bit_cast<VkStencilOp>(value); }
  StencilOp getPassOp() const { return std::bit_cast<StencilOp>(this->passOp); }
  void setDepthFailOp(StencilOp value) { this->depthFailOp = std::bit_cast<VkStencilOp>(value); }
  StencilOp getDepthFailOp() const { return std::bit_cast<StencilOp>(this->depthFailOp); }
  void setCompareOp(CompareOp value) { this->compareOp = std::bit_cast<VkCompareOp>(value); }
  CompareOp getCompareOp() const { return std::bit_cast<CompareOp>(this->compareOp); }
  void setCompareMask(uint32_t value) { this->compareMask = value; }
  uint32_t getCompareMask() const { return this->compareMask; }
  void setWriteMask(uint32_t value) { this->writeMask = value; }
  uint32_t getWriteMask() const { return this->writeMask; }
  void setReference(uint32_t value) { this->reference = value; }
  uint32_t getReference() const { return this->reference; }
};

struct VertexInputBindingDescription : VkVertexInputBindingDescription {
  VertexInputBindingDescription() noexcept : VkVertexInputBindingDescription{} {}
  VertexInputBindingDescription(uint32_t binding, uint32_t stride, VertexInputRate inputRate) noexcept : VkVertexInputBindingDescription{.binding = binding, .stride = stride, .inputRate = std::bit_cast<VkVertexInputRate>(inputRate)} {}

  // Vertex buffer binding id
  void setBinding(uint32_t value) { this->binding = value; }
  uint32_t getBinding() const { return this->binding; }
  // Distance between vertices in bytes (0 = no advancement)
  void setStride(uint32_t value) { this->stride = value; }
  uint32_t getStride() const { return this->stride; }
  // The rate at which the vertex data is consumed
  void setInputRate(VertexInputRate value) { this->inputRate = std::bit_cast<VkVertexInputRate>(value); }
  VertexInputRate getInputRate() const { return std::bit_cast<VertexInputRate>(this->inputRate); }
};

struct VertexInputAttributeDescription : VkVertexInputAttributeDescription {
  VertexInputAttributeDescription() noexcept : VkVertexInputAttributeDescription{} {}
  VertexInputAttributeDescription(uint32_t location, uint32_t binding, Format format, uint32_t offset) noexcept : VkVertexInputAttributeDescription{.location = location, .binding = binding, .format = std::bit_cast<VkFormat>(format), .offset = offset} {}

  // location of the shader vertex attrib
  void setLocation(uint32_t value) { this->location = value; }
  uint32_t getLocation() const { return this->location; }
  // Vertex buffer binding id
  void setBinding(uint32_t value) { this->binding = value; }
  uint32_t getBinding() const { return this->binding; }
  // format of source data
  void setFormat(Format value) { this->format = std::bit_cast<VkFormat>(value); }
  Format getFormat() const { return std::bit_cast<Format>(this->format); }
  // Offset of first element in bytes from base of vertex
  void setOffset(uint32_t value) { this->offset = value; }
  uint32_t getOffset() const { return this->offset; }
};
#endif // VK_VERSION_1_0

#if VK_KHR_android_surface
struct AndroidSurfaceCreateInfoKHR : VkAndroidSurfaceCreateInfoKHR {
  AndroidSurfaceCreateInfoKHR() noexcept : VkAndroidSurfaceCreateInfoKHR{.sType = VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR} {}

  void setwindow(struct ANativeWindow* value) { this->window = value; }
  struct ANativeWindow* getwindow() const { return this->window; }

  void setFlags(AndroidSurfaceCreateFlagsKHR value) { this->flags = std::bit_cast<VkAndroidSurfaceCreateFlagsKHR>(value); }
  AndroidSurfaceCreateFlagsKHR getFlags() const { return std::bit_cast<AndroidSurfaceCreateFlagsKHR>(this->flags); }
};
#endif // VK_KHR_android_surface

#if VK_NN_vi_surface
struct ViSurfaceCreateInfoNN : VkViSurfaceCreateInfoNN {
  ViSurfaceCreateInfoNN() noexcept : VkViSurfaceCreateInfoNN{.sType = VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN} {}

  void setwindow(void* value) { this->window = value; }
  void* getwindow() const { return this->window; }

  void setFlags(ViSurfaceCreateFlagsNN value) { this->flags = std::bit_cast<VkViSurfaceCreateFlagsNN>(value); }
  ViSurfaceCreateFlagsNN getFlags() const { return std::bit_cast<ViSurfaceCreateFlagsNN>(this->flags); }
};
#endif // VK_NN_vi_surface

#if VK_KHR_wayland_surface
struct WaylandSurfaceCreateInfoKHR : VkWaylandSurfaceCreateInfoKHR {
  WaylandSurfaceCreateInfoKHR() noexcept : VkWaylandSurfaceCreateInfoKHR{.sType = VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR} {}

  void setdisplay(struct wl_display* value) { this->display = value; }
  struct wl_display* getdisplay() const { return this->display; }
  void setsurface(struct wl_surface* value) { this->surface = value; }
  struct wl_surface* getsurface() const { return this->surface; }

  void setFlags(WaylandSurfaceCreateFlagsKHR value) { this->flags = std::bit_cast<VkWaylandSurfaceCreateFlagsKHR>(value); }
  WaylandSurfaceCreateFlagsKHR getFlags() const { return std::bit_cast<WaylandSurfaceCreateFlagsKHR>(this->flags); }
};
#endif // VK_KHR_wayland_surface

#if VK_KHR_win32_surface
struct Win32SurfaceCreateInfoKHR : VkWin32SurfaceCreateInfoKHR {
  Win32SurfaceCreateInfoKHR() noexcept : VkWin32SurfaceCreateInfoKHR{.sType = VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR} {}

  void setHinstance(HINSTANCE value) { this->hinstance = value; }
  HINSTANCE getHinstance() const { return this->hinstance; }
  void setHwnd(HWND value) { this->hwnd = value; }
  HWND getHwnd() const { return this->hwnd; }

  void setFlags(Win32SurfaceCreateFlagsKHR value) { this->flags = std::bit_cast<VkWin32SurfaceCreateFlagsKHR>(value); }
  Win32SurfaceCreateFlagsKHR getFlags() const { return std::bit_cast<Win32SurfaceCreateFlagsKHR>(this->flags); }
};
#endif // VK_KHR_win32_surface

#if VK_KHR_xlib_surface
struct XlibSurfaceCreateInfoKHR : VkXlibSurfaceCreateInfoKHR {
  XlibSurfaceCreateInfoKHR() noexcept : VkXlibSurfaceCreateInfoKHR{.sType = VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR} {}

  void setdpy(Display* value) { this->dpy = value; }
  Display* getdpy() const { return this->dpy; }
  void setWindow(Window value) { this->window = value; }
  Window getWindow() const { return this->window; }

  void setFlags(XlibSurfaceCreateFlagsKHR value) { this->flags = std::bit_cast<VkXlibSurfaceCreateFlagsKHR>(value); }
  XlibSurfaceCreateFlagsKHR getFlags() const { return std::bit_cast<XlibSurfaceCreateFlagsKHR>(this->flags); }
};
#endif // VK_KHR_xlib_surface

#if VK_KHR_xcb_surface
struct XcbSurfaceCreateInfoKHR : VkXcbSurfaceCreateInfoKHR {
  XcbSurfaceCreateInfoKHR() noexcept : VkXcbSurfaceCreateInfoKHR{.sType = VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR} {}

  void setconnection(xcb_connection_t* value) { this->connection = value; }
  xcb_connection_t* getconnection() const { return this->connection; }
  void setWindow(xcb_window_t value) { this->window = value; }
  xcb_window_t getWindow() const { return this->window; }

  void setFlags(XcbSurfaceCreateFlagsKHR value) { this->flags = std::bit_cast<VkXcbSurfaceCreateFlagsKHR>(value); }
  XcbSurfaceCreateFlagsKHR getFlags() const { return std::bit_cast<XcbSurfaceCreateFlagsKHR>(this->flags); }
};
#endif // VK_KHR_xcb_surface

#if VK_EXT_directfb_surface
struct DirectFBSurfaceCreateInfoEXT : VkDirectFBSurfaceCreateInfoEXT {
  DirectFBSurfaceCreateInfoEXT() noexcept : VkDirectFBSurfaceCreateInfoEXT{.sType = VK_STRUCTURE_TYPE_DIRECTFB_SURFACE_CREATE_INFO_EXT} {}

  void setdfb(IDirectFB* value) { this->dfb = value; }
  IDirectFB* getdfb() const { return this->dfb; }
  void setsurface(IDirectFBSurface* value) { this->surface = value; }
  IDirectFBSurface* getsurface() const { return this->surface; }

  void setFlags(DirectFBSurfaceCreateFlagsEXT value) { this->flags = std::bit_cast<VkDirectFBSurfaceCreateFlagsEXT>(value); }
  DirectFBSurfaceCreateFlagsEXT getFlags() const { return std::bit_cast<DirectFBSurfaceCreateFlagsEXT>(this->flags); }
};
#endif // VK_EXT_directfb_surface

#if VK_FUCHSIA_imagepipe_surface
struct ImagePipeSurfaceCreateInfoFUCHSIA : VkImagePipeSurfaceCreateInfoFUCHSIA {
  ImagePipeSurfaceCreateInfoFUCHSIA() noexcept : VkImagePipeSurfaceCreateInfoFUCHSIA{.sType = VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA} {}

  void setImagePipeHandle(zx_handle_t value) { this->imagePipeHandle = value; }
  zx_handle_t getImagePipeHandle() const { return this->imagePipeHandle; }

  void setFlags(ImagePipeSurfaceCreateFlagsFUCHSIA value) { this->flags = std::bit_cast<VkImagePipeSurfaceCreateFlagsFUCHSIA>(value); }
  ImagePipeSurfaceCreateFlagsFUCHSIA getFlags() const { return std::bit_cast<ImagePipeSurfaceCreateFlagsFUCHSIA>(this->flags); }
};
#endif // VK_FUCHSIA_imagepipe_surface

#if VK_GGP_stream_descriptor_surface
struct StreamDescriptorSurfaceCreateInfoGGP : VkStreamDescriptorSurfaceCreateInfoGGP {
  StreamDescriptorSurfaceCreateInfoGGP() noexcept : VkStreamDescriptorSurfaceCreateInfoGGP{.sType = VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP} {}

  void setStreamDescriptor(GgpStreamDescriptor value) { this->streamDescriptor = value; }
  GgpStreamDescriptor getStreamDescriptor() const { return this->streamDescriptor; }

  void setFlags(StreamDescriptorSurfaceCreateFlagsGGP value) { this->flags = std::bit_cast<VkStreamDescriptorSurfaceCreateFlagsGGP>(value); }
  StreamDescriptorSurfaceCreateFlagsGGP getFlags() const { return std::bit_cast<StreamDescriptorSurfaceCreateFlagsGGP>(this->flags); }
};
#endif // VK_GGP_stream_descriptor_surface

#if VK_QNX_screen_surface
struct ScreenSurfaceCreateInfoQNX : VkScreenSurfaceCreateInfoQNX {
  ScreenSurfaceCreateInfoQNX() noexcept : VkScreenSurfaceCreateInfoQNX{.sType = VK_STRUCTURE_TYPE_SCREEN_SURFACE_CREATE_INFO_QNX} {}

  void setcontext(struct _screen_context* value) { this->context = value; }
  struct _screen_context* getcontext() const { return this->context; }
  void setwindow(struct _screen_window* value) { this->window = value; }
  struct _screen_window* getwindow() const { return this->window; }

  void setFlags(ScreenSurfaceCreateFlagsQNX value) { this->flags = std::bit_cast<VkScreenSurfaceCreateFlagsQNX>(value); }
  ScreenSurfaceCreateFlagsQNX getFlags() const { return std::bit_cast<ScreenSurfaceCreateFlagsQNX>(this->flags); }
};
#endif // VK_QNX_screen_surface

#if VK_EXT_debug_marker
struct DebugMarkerMarkerInfoEXT : VkDebugMarkerMarkerInfoEXT {
  DebugMarkerMarkerInfoEXT() noexcept : VkDebugMarkerMarkerInfoEXT{.sType = VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT} {}

  // Name of the debug marker
  void setMarkerName(const char* value) { this->pMarkerName = value; }
  const char* getMarkerName() const { return this->pMarkerName; }
  // Optional color for debug marker
  void setColor(std::span<const float, 4> value) { std::memcpy(&this->color, value.data(), value.size_bytes()); }
  std::span<const float, 4> getColor() const { return this->color; }
};
#endif // VK_EXT_debug_marker

#if VK_VERSION_1_3
struct PrivateDataSlotCreateInfo : VkPrivateDataSlotCreateInfo {
  PrivateDataSlotCreateInfo() noexcept : VkPrivateDataSlotCreateInfo{.sType = VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO} {}

  void setFlags(PrivateDataSlotCreateFlags value) { this->flags = std::bit_cast<VkPrivateDataSlotCreateFlags>(value); }
  PrivateDataSlotCreateFlags getFlags() const { return std::bit_cast<PrivateDataSlotCreateFlags>(this->flags); }
};
#endif // VK_VERSION_1_3

#if VK_NV_cluster_acceleration_structure
struct ClusterAccelerationStructureClustersBottomLevelInputNV : VkClusterAccelerationStructureClustersBottomLevelInputNV {
  ClusterAccelerationStructureClustersBottomLevelInputNV() noexcept : VkClusterAccelerationStructureClustersBottomLevelInputNV{.sType = VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_CLUSTERS_BOTTOM_LEVEL_INPUT_NV} {}

  void setMaxTotalClusterCount(uint32_t value) { this->maxTotalClusterCount = value; }
  uint32_t getMaxTotalClusterCount() const { return this->maxTotalClusterCount; }
  void setMaxClusterCountPerAccelerationStructure(uint32_t value) { this->maxClusterCountPerAccelerationStructure = value; }
  uint32_t getMaxClusterCountPerAccelerationStructure() const { return this->maxClusterCountPerAccelerationStructure; }
};

struct ClusterAccelerationStructureTriangleClusterInputNV : VkClusterAccelerationStructureTriangleClusterInputNV {
  ClusterAccelerationStructureTriangleClusterInputNV() noexcept : VkClusterAccelerationStructureTriangleClusterInputNV{.sType = VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_TRIANGLE_CLUSTER_INPUT_NV} {}

  void setVertexFormat(Format value) { this->vertexFormat = std::bit_cast<VkFormat>(value); }
  Format getVertexFormat() const { return std::bit_cast<Format>(this->vertexFormat); }
  void setMaxGeometryIndexValue(uint32_t value) { this->maxGeometryIndexValue = value; }
  uint32_t getMaxGeometryIndexValue() const { return this->maxGeometryIndexValue; }
  void setMaxClusterUniqueGeometryCount(uint32_t value) { this->maxClusterUniqueGeometryCount = value; }
  uint32_t getMaxClusterUniqueGeometryCount() const { return this->maxClusterUniqueGeometryCount; }
  void setMaxClusterTriangleCount(uint32_t value) { this->maxClusterTriangleCount = value; }
  uint32_t getMaxClusterTriangleCount() const { return this->maxClusterTriangleCount; }
  void setMaxClusterVertexCount(uint32_t value) { this->maxClusterVertexCount = value; }
  uint32_t getMaxClusterVertexCount() const { return this->maxClusterVertexCount; }
  void setMaxTotalTriangleCount(uint32_t value) { this->maxTotalTriangleCount = value; }
  uint32_t getMaxTotalTriangleCount() const { return this->maxTotalTriangleCount; }
  void setMaxTotalVertexCount(uint32_t value) { this->maxTotalVertexCount = value; }
  uint32_t getMaxTotalVertexCount() const { return this->maxTotalVertexCount; }
  void setMinPositionTruncateBitCount(uint32_t value) { this->minPositionTruncateBitCount = value; }
  uint32_t getMinPositionTruncateBitCount() const { return this->minPositionTruncateBitCount; }
};
#endif // VK_NV_cluster_acceleration_structure

#if VK_KHR_pipeline_binary
struct PipelineBinaryKeyKHR : VkPipelineBinaryKeyKHR {
  PipelineBinaryKeyKHR() noexcept : VkPipelineBinaryKeyKHR{.sType = VK_STRUCTURE_TYPE_PIPELINE_BINARY_KEY_KHR} {}

  void setKeySize(uint32_t value) { this->keySize = value; }
  uint32_t getKeySize() const { return this->keySize; }
  void setKey(std::span<const uint8_t, VK_MAX_PIPELINE_BINARY_KEY_SIZE_KHR> value) { std::memcpy(&this->key, value.data(), value.size_bytes()); }
  std::span<const uint8_t, VK_MAX_PIPELINE_BINARY_KEY_SIZE_KHR> getKey() const { return this->key; }
};
#endif // VK_KHR_pipeline_binary

#if VK_FUCHSIA_external_memory
struct MemoryZirconHandlePropertiesFUCHSIA : VkMemoryZirconHandlePropertiesFUCHSIA {
  MemoryZirconHandlePropertiesFUCHSIA() noexcept : VkMemoryZirconHandlePropertiesFUCHSIA{.sType = VK_STRUCTURE_TYPE_MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA} {}

  uint32_t getMemoryTypeBits() const { return this->memoryTypeBits; }
};
#endif // VK_FUCHSIA_external_memory

#if VK_KHR_external_memory_win32
struct MemoryWin32HandlePropertiesKHR : VkMemoryWin32HandlePropertiesKHR {
  MemoryWin32HandlePropertiesKHR() noexcept : VkMemoryWin32HandlePropertiesKHR{.sType = VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR} {}

  uint32_t getMemoryTypeBits() const { return this->memoryTypeBits; }
};
#endif // VK_KHR_external_memory_win32

#if VK_KHR_external_memory_fd
struct MemoryFdPropertiesKHR : VkMemoryFdPropertiesKHR {
  MemoryFdPropertiesKHR() noexcept : VkMemoryFdPropertiesKHR{.sType = VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR} {}

  uint32_t getMemoryTypeBits() const { return this->memoryTypeBits; }
};
#endif // VK_KHR_external_memory_fd

#if VK_EXT_external_memory_metal
struct MemoryMetalHandlePropertiesEXT : VkMemoryMetalHandlePropertiesEXT {
  MemoryMetalHandlePropertiesEXT() noexcept : VkMemoryMetalHandlePropertiesEXT{.sType = VK_STRUCTURE_TYPE_MEMORY_METAL_HANDLE_PROPERTIES_EXT} {}

  uint32_t getMemoryTypeBits() const { return this->memoryTypeBits; }
};
#endif // VK_EXT_external_memory_metal

#if VK_KHR_present_wait2
struct PresentWait2InfoKHR : VkPresentWait2InfoKHR {
  PresentWait2InfoKHR() noexcept : VkPresentWait2InfoKHR{.sType = VK_STRUCTURE_TYPE_PRESENT_WAIT_2_INFO_KHR} {}

  void setPresentId(uint64_t value) { this->presentId = value; }
  uint64_t getPresentId() const { return this->presentId; }
  void setTimeout(uint64_t value) { this->timeout = value; }
  uint64_t getTimeout() const { return this->timeout; }
};
#endif // VK_KHR_present_wait2

#if VK_EXT_hdr_metadata
struct HdrMetadataEXT : VkHdrMetadataEXT {
  HdrMetadataEXT() noexcept : VkHdrMetadataEXT{.sType = VK_STRUCTURE_TYPE_HDR_METADATA_EXT} {}

  // Display primary's Red
  void setDisplayPrimaryRed(const XYColorEXT& value) { this->displayPrimaryRed = value; }
  const XYColorEXT& getDisplayPrimaryRed() const { return static_cast<const XYColorEXT&>(this->displayPrimaryRed); }
  // Display primary's Green
  void setDisplayPrimaryGreen(const XYColorEXT& value) { this->displayPrimaryGreen = value; }
  const XYColorEXT& getDisplayPrimaryGreen() const { return static_cast<const XYColorEXT&>(this->displayPrimaryGreen); }
  // Display primary's Blue
  void setDisplayPrimaryBlue(const XYColorEXT& value) { this->displayPrimaryBlue = value; }
  const XYColorEXT& getDisplayPrimaryBlue() const { return static_cast<const XYColorEXT&>(this->displayPrimaryBlue); }
  // Display primary's Blue
  void setWhitePoint(const XYColorEXT& value) { this->whitePoint = value; }
  const XYColorEXT& getWhitePoint() const { return static_cast<const XYColorEXT&>(this->whitePoint); }
  // Display maximum luminance
  void setMaxLuminance(float value) { this->maxLuminance = value; }
  float getMaxLuminance() const { return this->maxLuminance; }
  // Display minimum luminance
  void setMinLuminance(float value) { this->minLuminance = value; }
  float getMinLuminance() const { return this->minLuminance; }
  // Content maximum luminance
  void setMaxContentLightLevel(float value) { this->maxContentLightLevel = value; }
  float getMaxContentLightLevel() const { return this->maxContentLightLevel; }
  void setMaxFrameAverageLightLevel(float value) { this->maxFrameAverageLightLevel = value; }
  float getMaxFrameAverageLightLevel() const { return this->maxFrameAverageLightLevel; }

#if VK_HUAWEI_hdr_vivid
  void attach(struct HdrVividDynamicMetadataHUAWEI&);
#endif // VK_HUAWEI_hdr_vivid
};
#endif // VK_EXT_hdr_metadata

#if VK_EXT_metal_surface
struct MetalSurfaceCreateInfoEXT : VkMetalSurfaceCreateInfoEXT {
  MetalSurfaceCreateInfoEXT() noexcept : VkMetalSurfaceCreateInfoEXT{.sType = VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT} {}

  void setLayer(const CAMetalLayer* value) { this->pLayer = value; }
  const CAMetalLayer* getLayer() const { return this->pLayer; }

  void setFlags(MetalSurfaceCreateFlagsEXT value) { this->flags = std::bit_cast<VkMetalSurfaceCreateFlagsEXT>(value); }
  MetalSurfaceCreateFlagsEXT getFlags() const { return std::bit_cast<MetalSurfaceCreateFlagsEXT>(this->flags); }
};
#endif // VK_EXT_metal_surface

#if VK_EXT_sample_locations
struct MultisamplePropertiesEXT : VkMultisamplePropertiesEXT {
  MultisamplePropertiesEXT() noexcept : VkMultisamplePropertiesEXT{.sType = VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT} {}

  const Extent2D& getMaxSampleLocationGridSize() const { return static_cast<const Extent2D&>(this->maxSampleLocationGridSize); }
};
#endif // VK_EXT_sample_locations

#if VK_EXT_validation_cache
struct ValidationCacheCreateInfoEXT : VkValidationCacheCreateInfoEXT {
  ValidationCacheCreateInfoEXT() noexcept : VkValidationCacheCreateInfoEXT{.sType = VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT} {}

  void setFlags(ValidationCacheCreateFlagsEXT value) { this->flags = std::bit_cast<VkValidationCacheCreateFlagsEXT>(value); }
  ValidationCacheCreateFlagsEXT getFlags() const { return std::bit_cast<ValidationCacheCreateFlagsEXT>(this->flags); }
  void setInitialDataSize(size_t value) { this->initialDataSize = value; }
  size_t getInitialDataSize() const { return this->initialDataSize; }
  void setInitialData(const void* value) { this->pInitialData = value; }
  const void* getInitialData() const { return this->pInitialData; }
};
#endif // VK_EXT_validation_cache

#if VK_VERSION_1_4
struct RenderingAreaInfo : VkRenderingAreaInfo {
  RenderingAreaInfo() noexcept : VkRenderingAreaInfo{.sType = VK_STRUCTURE_TYPE_RENDERING_AREA_INFO} {}

  void setViewMask(uint32_t value) { this->viewMask = value; }
  uint32_t getViewMask() const { return this->viewMask; }
  void setDepthAttachmentFormat(Format value) { this->depthAttachmentFormat = std::bit_cast<VkFormat>(value); }
  Format getDepthAttachmentFormat() const { return std::bit_cast<Format>(this->depthAttachmentFormat); }
  void setStencilAttachmentFormat(Format value) { this->stencilAttachmentFormat = std::bit_cast<VkFormat>(value); }
  Format getStencilAttachmentFormat() const { return std::bit_cast<Format>(this->stencilAttachmentFormat); }

  void setColorAttachmentCount(uint32_t value) { this->colorAttachmentCount = value; }
  uint32_t getColorAttachmentCount() const { return this->colorAttachmentCount; }
  void setColorAttachmentFormats(const Format* value) { this->pColorAttachmentFormats = std::bit_cast<const VkFormat*>(value); }
  const Format* getColorAttachmentFormats() const { return std::bit_cast<const Format*>(this->pColorAttachmentFormats); }
};
#endif // VK_VERSION_1_4

#if VK_VERSION_1_1
struct DescriptorSetLayoutSupport : VkDescriptorSetLayoutSupport {
  DescriptorSetLayoutSupport() noexcept : VkDescriptorSetLayoutSupport{.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT} {}

  Bool32 getSupported() const { return this->supported; }

#if VK_VERSION_1_2
  void attach(struct DescriptorSetVariableDescriptorCountLayoutSupport&);
#endif // VK_VERSION_1_2
};
#endif // VK_VERSION_1_1

#if VK_EXT_debug_utils
struct DebugUtilsLabelEXT : VkDebugUtilsLabelEXT {
  DebugUtilsLabelEXT() noexcept : VkDebugUtilsLabelEXT{.sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT} {}

  void setLabelName(const char* value) { this->pLabelName = value; }
  const char* getLabelName() const { return this->pLabelName; }
  void setColor(std::span<const float, 4> value) { std::memcpy(&this->color, value.data(), value.size_bytes()); }
  std::span<const float, 4> getColor() const { return this->color; }
};
#endif // VK_EXT_debug_utils

#if VK_EXT_external_memory_host
struct MemoryHostPointerPropertiesEXT : VkMemoryHostPointerPropertiesEXT {
  MemoryHostPointerPropertiesEXT() noexcept : VkMemoryHostPointerPropertiesEXT{.sType = VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT} {}

  uint32_t getMemoryTypeBits() const { return this->memoryTypeBits; }
};
#endif // VK_EXT_external_memory_host

#if VK_VERSION_1_2
struct SubpassEndInfo : VkSubpassEndInfo {
  SubpassEndInfo() noexcept : VkSubpassEndInfo{.sType = VK_STRUCTURE_TYPE_SUBPASS_END_INFO} {}

#if VK_EXT_fragment_density_map_offset
  void attach(struct RenderPassFragmentDensityMapOffsetEndInfoEXT&);
#endif // VK_EXT_fragment_density_map_offset
};
#endif // VK_VERSION_1_2

#if VK_ANDROID_external_memory_android_hardware_buffer
struct AndroidHardwareBufferPropertiesANDROID : VkAndroidHardwareBufferPropertiesANDROID {
  AndroidHardwareBufferPropertiesANDROID() noexcept : VkAndroidHardwareBufferPropertiesANDROID{.sType = VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID} {}

  DeviceSize getAllocationSize() const { return this->allocationSize; }
  uint32_t getMemoryTypeBits() const { return this->memoryTypeBits; }

  void attach(struct AndroidHardwareBufferFormatPropertiesANDROID&);
#if VK_ANDROID_external_format_resolve
  void attach(struct AndroidHardwareBufferFormatResolvePropertiesANDROID&);
#endif // VK_ANDROID_external_format_resolve
};
#endif // VK_ANDROID_external_memory_android_hardware_buffer

#if VK_EXT_image_drm_format_modifier
struct ImageDrmFormatModifierPropertiesEXT : VkImageDrmFormatModifierPropertiesEXT {
  ImageDrmFormatModifierPropertiesEXT() noexcept : VkImageDrmFormatModifierPropertiesEXT{.sType = VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT} {}

  uint64_t getDrmFormatModifier() const { return this->drmFormatModifier; }
};
#endif // VK_EXT_image_drm_format_modifier

#if VK_NVX_image_view_handle
struct ImageViewAddressPropertiesNVX : VkImageViewAddressPropertiesNVX {
  ImageViewAddressPropertiesNVX() noexcept : VkImageViewAddressPropertiesNVX{.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX} {}

  DeviceAddress getDeviceAddress() const { return this->deviceAddress; }
  DeviceSize getSize() const { return this->size; }
};
#endif // VK_NVX_image_view_handle

#if VK_EXT_headless_surface
struct HeadlessSurfaceCreateInfoEXT : VkHeadlessSurfaceCreateInfoEXT {
  HeadlessSurfaceCreateInfoEXT() noexcept : VkHeadlessSurfaceCreateInfoEXT{.sType = VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT} {}

  void setFlags(HeadlessSurfaceCreateFlagsEXT value) { this->flags = std::bit_cast<VkHeadlessSurfaceCreateFlagsEXT>(value); }
  HeadlessSurfaceCreateFlagsEXT getFlags() const { return std::bit_cast<HeadlessSurfaceCreateFlagsEXT>(this->flags); }
};
#endif // VK_EXT_headless_surface

#if VK_INTEL_performance_query
struct InitializePerformanceApiInfoINTEL : VkInitializePerformanceApiInfoINTEL {
  InitializePerformanceApiInfoINTEL() noexcept : VkInitializePerformanceApiInfoINTEL{.sType = VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL} {}

  void setUserData(void* value) { this->pUserData = value; }
  void* getUserData() const { return this->pUserData; }
};

struct PerformanceMarkerInfoINTEL : VkPerformanceMarkerInfoINTEL {
  PerformanceMarkerInfoINTEL() noexcept : VkPerformanceMarkerInfoINTEL{.sType = VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL} {}

  void setMarker(uint64_t value) { this->marker = value; }
  uint64_t getMarker() const { return this->marker; }
};

struct PerformanceStreamMarkerInfoINTEL : VkPerformanceStreamMarkerInfoINTEL {
  PerformanceStreamMarkerInfoINTEL() noexcept : VkPerformanceStreamMarkerInfoINTEL{.sType = VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL} {}

  void setMarker(uint32_t value) { this->marker = value; }
  uint32_t getMarker() const { return this->marker; }
};
#endif // VK_INTEL_performance_query

#if VK_KHR_pipeline_executable_properties
struct PipelineExecutableInternalRepresentationKHR : VkPipelineExecutableInternalRepresentationKHR {
  PipelineExecutableInternalRepresentationKHR() noexcept : VkPipelineExecutableInternalRepresentationKHR{.sType = VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR} {}

  std::string_view getName() const { return this->name; }
  std::string_view getDescription() const { return this->description; }
  Bool32 getIsText() const { return this->isText; }
  size_t getDataSize() const { return this->dataSize; }

  void* getData() const { return this->pData; }
};
#endif // VK_KHR_pipeline_executable_properties

#if VK_KHR_acceleration_structure
struct AccelerationStructureGeometryTrianglesDataKHR : VkAccelerationStructureGeometryTrianglesDataKHR {
  AccelerationStructureGeometryTrianglesDataKHR() noexcept : VkAccelerationStructureGeometryTrianglesDataKHR{.sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR} {}

  void setVertexFormat(Format value) { this->vertexFormat = std::bit_cast<VkFormat>(value); }
  Format getVertexFormat() const { return std::bit_cast<Format>(this->vertexFormat); }
  void setVertexData(DeviceOrHostAddressConstKHR value) { this->vertexData = value; }
  DeviceOrHostAddressConstKHR getVertexData() const { return this->vertexData; }
  void setVertexStride(DeviceSize value) { this->vertexStride = value; }
  DeviceSize getVertexStride() const { return this->vertexStride; }
  void setMaxVertex(uint32_t value) { this->maxVertex = value; }
  uint32_t getMaxVertex() const { return this->maxVertex; }
  void setIndexType(IndexType value) { this->indexType = std::bit_cast<VkIndexType>(value); }
  IndexType getIndexType() const { return std::bit_cast<IndexType>(this->indexType); }
  void setIndexData(DeviceOrHostAddressConstKHR value) { this->indexData = value; }
  DeviceOrHostAddressConstKHR getIndexData() const { return this->indexData; }
  void setTransformData(DeviceOrHostAddressConstKHR value) { this->transformData = value; }
  DeviceOrHostAddressConstKHR getTransformData() const { return this->transformData; }

#if VK_NV_ray_tracing_motion_blur
  void attach(struct AccelerationStructureGeometryMotionTrianglesDataNV&);
#endif // VK_NV_ray_tracing_motion_blur
#if VK_EXT_opacity_micromap
  void attach(struct AccelerationStructureTrianglesOpacityMicromapEXT&);
#endif // VK_EXT_opacity_micromap
};

struct AccelerationStructureGeometryAabbsDataKHR : VkAccelerationStructureGeometryAabbsDataKHR {
  AccelerationStructureGeometryAabbsDataKHR() noexcept : VkAccelerationStructureGeometryAabbsDataKHR{.sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR} {}

  void setData(DeviceOrHostAddressConstKHR value) { this->data = value; }
  DeviceOrHostAddressConstKHR getData() const { return this->data; }
  void setStride(DeviceSize value) { this->stride = value; }
  DeviceSize getStride() const { return this->stride; }
};

struct AccelerationStructureGeometryInstancesDataKHR : VkAccelerationStructureGeometryInstancesDataKHR {
  AccelerationStructureGeometryInstancesDataKHR() noexcept : VkAccelerationStructureGeometryInstancesDataKHR{.sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR} {}

  void setData(DeviceOrHostAddressConstKHR value) { this->data = value; }
  DeviceOrHostAddressConstKHR getData() const { return this->data; }

  void setArrayOfPointers(Bool32 value) { this->arrayOfPointers = value; }
  Bool32 getArrayOfPointers() const { return this->arrayOfPointers; }
};

struct AccelerationStructureVersionInfoKHR : VkAccelerationStructureVersionInfoKHR {
  AccelerationStructureVersionInfoKHR() noexcept : VkAccelerationStructureVersionInfoKHR{.sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR} {}

  void setVersionData(const uint8_t* value) { this->pVersionData = value; }
  const uint8_t* getVersionData() const { return this->pVersionData; }
};
#endif // VK_KHR_acceleration_structure

#if VK_KHR_ray_tracing_pipeline
struct RayTracingPipelineInterfaceCreateInfoKHR : VkRayTracingPipelineInterfaceCreateInfoKHR {
  RayTracingPipelineInterfaceCreateInfoKHR() noexcept : VkRayTracingPipelineInterfaceCreateInfoKHR{.sType = VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR} {}

  void setMaxPipelineRayPayloadSize(uint32_t value) { this->maxPipelineRayPayloadSize = value; }
  uint32_t getMaxPipelineRayPayloadSize() const { return this->maxPipelineRayPayloadSize; }
  void setMaxPipelineRayHitAttributeSize(uint32_t value) { this->maxPipelineRayHitAttributeSize = value; }
  uint32_t getMaxPipelineRayHitAttributeSize() const { return this->maxPipelineRayHitAttributeSize; }
};
#endif // VK_KHR_ray_tracing_pipeline

#if VK_VERSION_1_3
struct BufferCopy2 : VkBufferCopy2 {
  BufferCopy2() noexcept : VkBufferCopy2{.sType = VK_STRUCTURE_TYPE_BUFFER_COPY_2} {}

  // Specified in bytes
  void setSrcOffset(DeviceSize value) { this->srcOffset = value; }
  DeviceSize getSrcOffset() const { return this->srcOffset; }
  // Specified in bytes
  void setDstOffset(DeviceSize value) { this->dstOffset = value; }
  DeviceSize getDstOffset() const { return this->dstOffset; }
  // Specified in bytes
  void setSize(DeviceSize value) { this->size = value; }
  DeviceSize getSize() const { return this->size; }
};
#endif // VK_VERSION_1_3

#if VK_KHR_acceleration_structure
struct AccelerationStructureBuildSizesInfoKHR : VkAccelerationStructureBuildSizesInfoKHR {
  AccelerationStructureBuildSizesInfoKHR() noexcept : VkAccelerationStructureBuildSizesInfoKHR{.sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR} {}

  DeviceSize getAccelerationStructureSize() const { return this->accelerationStructureSize; }
  DeviceSize getUpdateScratchSize() const { return this->updateScratchSize; }
  DeviceSize getBuildScratchSize() const { return this->buildScratchSize; }
};
#endif // VK_KHR_acceleration_structure

#if VK_VERSION_1_0
struct SemaphoreCreateInfo : VkSemaphoreCreateInfo {
  SemaphoreCreateInfo() noexcept : VkSemaphoreCreateInfo{.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO} {}

  // Semaphore creation flags
  void setFlags(SemaphoreCreateFlags value) { this->flags = std::bit_cast<VkSemaphoreCreateFlags>(value); }
  SemaphoreCreateFlags getFlags() const { return std::bit_cast<SemaphoreCreateFlags>(this->flags); }

#if VK_VERSION_1_1
  void attach(struct ExportSemaphoreCreateInfo&);
#endif // VK_VERSION_1_1
#if VK_KHR_external_semaphore_win32
  void attach(struct ExportSemaphoreWin32HandleInfoKHR&);
#endif // VK_KHR_external_semaphore_win32
#if VK_VERSION_1_2
  void attach(struct SemaphoreTypeCreateInfo&);
#endif // VK_VERSION_1_2
#if VK_EXT_metal_objects
  void attach(struct ExportMetalObjectCreateInfoEXT&);
  void attach(struct ImportMetalSharedEventInfoEXT&);
#endif // VK_EXT_metal_objects
#if VK_NV_low_latency
  void attach(struct QueryLowLatencySupportNV&);
#endif // VK_NV_low_latency
};
#endif // VK_VERSION_1_0

#if VK_KHR_pipeline_binary
struct PipelineCreateInfoKHR : VkPipelineCreateInfoKHR {
  PipelineCreateInfoKHR() noexcept : VkPipelineCreateInfoKHR{.sType = VK_STRUCTURE_TYPE_PIPELINE_CREATE_INFO_KHR} {}
};
#endif // VK_KHR_pipeline_binary

#if VK_EXT_vertex_input_dynamic_state
struct VertexInputBindingDescription2EXT : VkVertexInputBindingDescription2EXT {
  VertexInputBindingDescription2EXT() noexcept : VkVertexInputBindingDescription2EXT{.sType = VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT} {}

  void setBinding(uint32_t value) { this->binding = value; }
  uint32_t getBinding() const { return this->binding; }
  void setStride(uint32_t value) { this->stride = value; }
  uint32_t getStride() const { return this->stride; }
  void setInputRate(VertexInputRate value) { this->inputRate = std::bit_cast<VkVertexInputRate>(value); }
  VertexInputRate getInputRate() const { return std::bit_cast<VertexInputRate>(this->inputRate); }
  void setDivisor(uint32_t value) { this->divisor = value; }
  uint32_t getDivisor() const { return this->divisor; }
};

struct VertexInputAttributeDescription2EXT : VkVertexInputAttributeDescription2EXT {
  VertexInputAttributeDescription2EXT() noexcept : VkVertexInputAttributeDescription2EXT{.sType = VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT} {}

  // location of the shader vertex attrib
  void setLocation(uint32_t value) { this->location = value; }
  uint32_t getLocation() const { return this->location; }
  // Vertex buffer binding id
  void setBinding(uint32_t value) { this->binding = value; }
  uint32_t getBinding() const { return this->binding; }
  // format of source data
  void setFormat(Format value) { this->format = std::bit_cast<VkFormat>(value); }
  Format getFormat() const { return std::bit_cast<Format>(this->format); }
  // Offset of first element in bytes from base of vertex
  void setOffset(uint32_t value) { this->offset = value; }
  uint32_t getOffset() const { return this->offset; }
};
#endif // VK_EXT_vertex_input_dynamic_state

#if VK_KHR_video_queue
struct VideoSessionParametersUpdateInfoKHR : VkVideoSessionParametersUpdateInfoKHR {
  VideoSessionParametersUpdateInfoKHR() noexcept : VkVideoSessionParametersUpdateInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR} {}

  void setUpdateSequenceCount(uint32_t value) { this->updateSequenceCount = value; }
  uint32_t getUpdateSequenceCount() const { return this->updateSequenceCount; }

#if VK_KHR_video_decode_h264
  void attach(struct VideoDecodeH264SessionParametersAddInfoKHR&);
#endif // VK_KHR_video_decode_h264
#if VK_KHR_video_decode_h265
  void attach(struct VideoDecodeH265SessionParametersAddInfoKHR&);
#endif // VK_KHR_video_decode_h265
#if VK_KHR_video_encode_h264
  void attach(struct VideoEncodeH264SessionParametersAddInfoKHR&);
#endif // VK_KHR_video_encode_h264
#if VK_KHR_video_encode_h265
  void attach(struct VideoEncodeH265SessionParametersAddInfoKHR&);
#endif // VK_KHR_video_encode_h265
};
#endif // VK_KHR_video_queue

#if VK_KHR_video_encode_queue
struct VideoEncodeSessionParametersFeedbackInfoKHR : VkVideoEncodeSessionParametersFeedbackInfoKHR {
  VideoEncodeSessionParametersFeedbackInfoKHR() noexcept : VkVideoEncodeSessionParametersFeedbackInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_FEEDBACK_INFO_KHR} {}

  Bool32 getHasOverrides() const { return this->hasOverrides; }

  void attach(struct VideoEncodeH264SessionParametersFeedbackInfoKHR&);
  void attach(struct VideoEncodeH265SessionParametersFeedbackInfoKHR&);
};
#endif // VK_KHR_video_encode_queue

#if VK_KHR_video_queue
struct VideoEndCodingInfoKHR : VkVideoEndCodingInfoKHR {
  VideoEndCodingInfoKHR() noexcept : VkVideoEndCodingInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR} {}

  void setFlags(VideoEndCodingFlagsKHR value) { this->flags = std::bit_cast<VkVideoEndCodingFlagsKHR>(value); }
  VideoEndCodingFlagsKHR getFlags() const { return std::bit_cast<VideoEndCodingFlagsKHR>(this->flags); }
};
#endif // VK_KHR_video_queue

#if VK_KHR_video_encode_queue
struct VideoEncodeRateControlLayerInfoKHR : VkVideoEncodeRateControlLayerInfoKHR {
  VideoEncodeRateControlLayerInfoKHR() noexcept : VkVideoEncodeRateControlLayerInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR} {}

  void setAverageBitrate(uint64_t value) { this->averageBitrate = value; }
  uint64_t getAverageBitrate() const { return this->averageBitrate; }
  void setMaxBitrate(uint64_t value) { this->maxBitrate = value; }
  uint64_t getMaxBitrate() const { return this->maxBitrate; }
  void setFrameRateNumerator(uint32_t value) { this->frameRateNumerator = value; }
  uint32_t getFrameRateNumerator() const { return this->frameRateNumerator; }
  void setFrameRateDenominator(uint32_t value) { this->frameRateDenominator = value; }
  uint32_t getFrameRateDenominator() const { return this->frameRateDenominator; }

  void attach(struct VideoEncodeH264RateControlLayerInfoKHR&);
  void attach(struct VideoEncodeH265RateControlLayerInfoKHR&);
#if VK_KHR_video_encode_av1
  void attach(struct VideoEncodeAV1RateControlLayerInfoKHR&);
#endif // VK_KHR_video_encode_av1
};
#endif // VK_KHR_video_encode_queue

#if VK_KHR_video_encode_h264
struct VideoEncodeH264NaluSliceInfoKHR : VkVideoEncodeH264NaluSliceInfoKHR {
  VideoEncodeH264NaluSliceInfoKHR() noexcept : VkVideoEncodeH264NaluSliceInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_NALU_SLICE_INFO_KHR} {}

  void setConstantQp(int32_t value) { this->constantQp = value; }
  int32_t getConstantQp() const { return this->constantQp; }
  void setStdSliceHeader(const StdVideoEncodeH264SliceHeader* value) { this->pStdSliceHeader = value; }
  const StdVideoEncodeH264SliceHeader* getStdSliceHeader() const { return this->pStdSliceHeader; }
};
#endif // VK_KHR_video_encode_h264

#if VK_KHR_video_encode_h265
struct VideoEncodeH265NaluSliceSegmentInfoKHR : VkVideoEncodeH265NaluSliceSegmentInfoKHR {
  VideoEncodeH265NaluSliceSegmentInfoKHR() noexcept : VkVideoEncodeH265NaluSliceSegmentInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_NALU_SLICE_SEGMENT_INFO_KHR} {}

  void setConstantQp(int32_t value) { this->constantQp = value; }
  int32_t getConstantQp() const { return this->constantQp; }
  void setStdSliceSegmentHeader(const StdVideoEncodeH265SliceSegmentHeader* value) { this->pStdSliceSegmentHeader = value; }
  const StdVideoEncodeH265SliceSegmentHeader* getStdSliceSegmentHeader() const { return this->pStdSliceSegmentHeader; }
};
#endif // VK_KHR_video_encode_h265

#if VK_NVX_binary_import
struct CuModuleCreateInfoNVX : VkCuModuleCreateInfoNVX {
  CuModuleCreateInfoNVX() noexcept : VkCuModuleCreateInfoNVX{.sType = VK_STRUCTURE_TYPE_CU_MODULE_CREATE_INFO_NVX} {}

  void setDataSize(size_t value) { this->dataSize = value; }
  size_t getDataSize() const { return this->dataSize; }
  void setData(const void* value) { this->pData = value; }
  const void* getData() const { return this->pData; }

  void attach(struct CuModuleTexturingModeCreateInfoNVX&);
};
#endif // VK_NVX_binary_import

#if VK_EXT_descriptor_buffer
struct DescriptorAddressInfoEXT : VkDescriptorAddressInfoEXT {
  DescriptorAddressInfoEXT() noexcept : VkDescriptorAddressInfoEXT{.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_ADDRESS_INFO_EXT} {}

  void setAddress(DeviceAddress value) { this->address = value; }
  DeviceAddress getAddress() const { return this->address; }
  void setRange(DeviceSize value) { this->range = value; }
  DeviceSize getRange() const { return this->range; }
  void setFormat(Format value) { this->format = std::bit_cast<VkFormat>(value); }
  Format getFormat() const { return std::bit_cast<Format>(this->format); }
};

struct DescriptorGetInfoEXT : VkDescriptorGetInfoEXT {
  DescriptorGetInfoEXT() noexcept : VkDescriptorGetInfoEXT{.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_GET_INFO_EXT} {}

  void setType(DescriptorType value) { this->type = std::bit_cast<VkDescriptorType>(value); }
  DescriptorType getType() const { return std::bit_cast<DescriptorType>(this->type); }
  void setData(DescriptorDataEXT value) { this->data = value; }
  DescriptorDataEXT getData() const { return this->data; }

#if VK_ARM_tensors
  void attach(struct DescriptorGetTensorInfoARM&);
#endif // VK_ARM_tensors
};
#endif // VK_EXT_descriptor_buffer

#if VK_FUCHSIA_buffer_collection
struct BufferCollectionCreateInfoFUCHSIA : VkBufferCollectionCreateInfoFUCHSIA {
  BufferCollectionCreateInfoFUCHSIA() noexcept : VkBufferCollectionCreateInfoFUCHSIA{.sType = VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CREATE_INFO_FUCHSIA} {}

  void setCollectionToken(zx_handle_t value) { this->collectionToken = value; }
  zx_handle_t getCollectionToken() const { return this->collectionToken; }
};

struct SysmemColorSpaceFUCHSIA : VkSysmemColorSpaceFUCHSIA {
  SysmemColorSpaceFUCHSIA() noexcept : VkSysmemColorSpaceFUCHSIA{.sType = VK_STRUCTURE_TYPE_SYSMEM_COLOR_SPACE_FUCHSIA} {}

  void setColorSpace(uint32_t value) { this->colorSpace = value; }
  uint32_t getColorSpace() const { return this->colorSpace; }
};

struct BufferCollectionConstraintsInfoFUCHSIA : VkBufferCollectionConstraintsInfoFUCHSIA {
  BufferCollectionConstraintsInfoFUCHSIA() noexcept : VkBufferCollectionConstraintsInfoFUCHSIA{.sType = VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CONSTRAINTS_INFO_FUCHSIA} {}

  void setMinBufferCount(uint32_t value) { this->minBufferCount = value; }
  uint32_t getMinBufferCount() const { return this->minBufferCount; }
  void setMaxBufferCount(uint32_t value) { this->maxBufferCount = value; }
  uint32_t getMaxBufferCount() const { return this->maxBufferCount; }
  void setMinBufferCountForCamping(uint32_t value) { this->minBufferCountForCamping = value; }
  uint32_t getMinBufferCountForCamping() const { return this->minBufferCountForCamping; }
  void setMinBufferCountForDedicatedSlack(uint32_t value) { this->minBufferCountForDedicatedSlack = value; }
  uint32_t getMinBufferCountForDedicatedSlack() const { return this->minBufferCountForDedicatedSlack; }
  void setMinBufferCountForSharedSlack(uint32_t value) { this->minBufferCountForSharedSlack = value; }
  uint32_t getMinBufferCountForSharedSlack() const { return this->minBufferCountForSharedSlack; }
};
#endif // VK_FUCHSIA_buffer_collection

#if VK_EXT_fragment_density_map_offset
struct RenderingEndInfoEXT : VkRenderingEndInfoEXT {
  RenderingEndInfoEXT() noexcept : VkRenderingEndInfoEXT{.sType = VK_STRUCTURE_TYPE_RENDERING_END_INFO_EXT} {}

  void attach(struct RenderPassFragmentDensityMapOffsetEndInfoEXT&);
};
#endif // VK_EXT_fragment_density_map_offset

#if VK_VALVE_descriptor_set_host_mapping
struct DescriptorSetLayoutHostMappingInfoVALVE : VkDescriptorSetLayoutHostMappingInfoVALVE {
  DescriptorSetLayoutHostMappingInfoVALVE() noexcept : VkDescriptorSetLayoutHostMappingInfoVALVE{.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE} {}

  void setDescriptorOffset(size_t value) { this->descriptorOffset = value; }
  size_t getDescriptorOffset() const { return this->descriptorOffset; }
  void setDescriptorSize(uint32_t value) { this->descriptorSize = value; }
  uint32_t getDescriptorSize() const { return this->descriptorSize; }
};
#endif // VK_VALVE_descriptor_set_host_mapping

#if VK_EXT_shader_module_identifier
struct ShaderModuleIdentifierEXT : VkShaderModuleIdentifierEXT {
  ShaderModuleIdentifierEXT() noexcept : VkShaderModuleIdentifierEXT{.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_IDENTIFIER_EXT} {}

  uint32_t getIdentifierSize() const { return this->identifierSize; }
  std::span<const uint8_t, VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT> getIdentifier() const { return this->identifier; }
};
#endif // VK_EXT_shader_module_identifier

#if VK_EXT_opacity_micromap
struct MicromapVersionInfoEXT : VkMicromapVersionInfoEXT {
  MicromapVersionInfoEXT() noexcept : VkMicromapVersionInfoEXT{.sType = VK_STRUCTURE_TYPE_MICROMAP_VERSION_INFO_EXT} {}

  void setVersionData(const uint8_t* value) { this->pVersionData = value; }
  const uint8_t* getVersionData() const { return this->pVersionData; }
};

struct MicromapBuildSizesInfoEXT : VkMicromapBuildSizesInfoEXT {
  MicromapBuildSizesInfoEXT() noexcept : VkMicromapBuildSizesInfoEXT{.sType = VK_STRUCTURE_TYPE_MICROMAP_BUILD_SIZES_INFO_EXT} {}

  void setMicromapSize(DeviceSize value) { this->micromapSize = value; }
  DeviceSize getMicromapSize() const { return this->micromapSize; }
  void setBuildScratchSize(DeviceSize value) { this->buildScratchSize = value; }
  DeviceSize getBuildScratchSize() const { return this->buildScratchSize; }

  void setDiscardable(Bool32 value) { this->discardable = value; }
  Bool32 getDiscardable() const { return this->discardable; }
};
#endif // VK_EXT_opacity_micromap

#if VK_EXT_pipeline_properties
struct PipelinePropertiesIdentifierEXT : VkPipelinePropertiesIdentifierEXT {
  PipelinePropertiesIdentifierEXT() noexcept : VkPipelinePropertiesIdentifierEXT{.sType = VK_STRUCTURE_TYPE_PIPELINE_PROPERTIES_IDENTIFIER_EXT} {}

  std::span<const uint8_t, VK_UUID_SIZE> getPipelineIdentifier() const { return this->pipelineIdentifier; }
};
#endif // VK_EXT_pipeline_properties

#if VK_EXT_metal_objects
struct ExportMetalObjectsInfoEXT : VkExportMetalObjectsInfoEXT {
  ExportMetalObjectsInfoEXT() noexcept : VkExportMetalObjectsInfoEXT{.sType = VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECTS_INFO_EXT} {}

  void attach(struct ExportMetalDeviceInfoEXT&);
  void attach(struct ExportMetalCommandQueueInfoEXT&);
  void attach(struct ExportMetalBufferInfoEXT&);
  void attach(struct ExportMetalTextureInfoEXT&);
  void attach(struct ExportMetalIOSurfaceInfoEXT&);
  void attach(struct ExportMetalSharedEventInfoEXT&);
};
#endif // VK_EXT_metal_objects

#if VK_QCOM_tile_properties
struct TilePropertiesQCOM : VkTilePropertiesQCOM {
  TilePropertiesQCOM() noexcept : VkTilePropertiesQCOM{.sType = VK_STRUCTURE_TYPE_TILE_PROPERTIES_QCOM} {}

  void setTileSize(const Extent3D& value) { this->tileSize = value; }
  const Extent3D& getTileSize() const { return static_cast<const Extent3D&>(this->tileSize); }
  void setApronSize(const Extent2D& value) { this->apronSize = value; }
  const Extent2D& getApronSize() const { return static_cast<const Extent2D&>(this->apronSize); }
  void setOrigin(const Offset2D& value) { this->origin = value; }
  const Offset2D& getOrigin() const { return static_cast<const Offset2D&>(this->origin); }
};
#endif // VK_QCOM_tile_properties

#if VK_NV_optical_flow
struct OpticalFlowImageFormatPropertiesNV : VkOpticalFlowImageFormatPropertiesNV {
  OpticalFlowImageFormatPropertiesNV() noexcept : VkOpticalFlowImageFormatPropertiesNV{.sType = VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_PROPERTIES_NV} {}

  Format getFormat() const { return std::bit_cast<Format>(this->format); }
};
#endif // VK_NV_optical_flow

#if VK_EXT_device_fault
struct DeviceFaultCountsEXT : VkDeviceFaultCountsEXT {
  DeviceFaultCountsEXT() noexcept : VkDeviceFaultCountsEXT{.sType = VK_STRUCTURE_TYPE_DEVICE_FAULT_COUNTS_EXT} {}

  void setAddressInfoCount(uint32_t value) { this->addressInfoCount = value; }
  uint32_t getAddressInfoCount() const { return this->addressInfoCount; }
  void setVendorInfoCount(uint32_t value) { this->vendorInfoCount = value; }
  uint32_t getVendorInfoCount() const { return this->vendorInfoCount; }
  // Specified in bytes
  void setVendorBinarySize(DeviceSize value) { this->vendorBinarySize = value; }
  DeviceSize getVendorBinarySize() const { return this->vendorBinarySize; }
};
#endif // VK_EXT_device_fault

#if VK_EXT_depth_bias_control
struct DepthBiasInfoEXT : VkDepthBiasInfoEXT {
  DepthBiasInfoEXT() noexcept : VkDepthBiasInfoEXT{.sType = VK_STRUCTURE_TYPE_DEPTH_BIAS_INFO_EXT} {}

  void setDepthBiasConstantFactor(float value) { this->depthBiasConstantFactor = value; }
  float getDepthBiasConstantFactor() const { return this->depthBiasConstantFactor; }
  void setDepthBiasClamp(float value) { this->depthBiasClamp = value; }
  float getDepthBiasClamp() const { return this->depthBiasClamp; }
  void setDepthBiasSlopeFactor(float value) { this->depthBiasSlopeFactor = value; }
  float getDepthBiasSlopeFactor() const { return this->depthBiasSlopeFactor; }

  void attach(struct DepthBiasRepresentationInfoEXT&);
};
#endif // VK_EXT_depth_bias_control

#if VK_LUNARG_direct_driver_loading
struct DirectDriverLoadingInfoLUNARG : VkDirectDriverLoadingInfoLUNARG {
  DirectDriverLoadingInfoLUNARG() noexcept : VkDirectDriverLoadingInfoLUNARG{.sType = VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_INFO_LUNARG} {}

  void setFlags(DirectDriverLoadingFlagsLUNARG value) { this->flags = std::bit_cast<VkDirectDriverLoadingFlagsLUNARG>(value); }
  DirectDriverLoadingFlagsLUNARG getFlags() const { return std::bit_cast<DirectDriverLoadingFlagsLUNARG>(this->flags); }
  void setPfnGetInstanceProcAddr(PFN_vkGetInstanceProcAddrLUNARG value) { this->pfnGetInstanceProcAddr = value; }
  PFN_vkGetInstanceProcAddrLUNARG getPfnGetInstanceProcAddr() const { return this->pfnGetInstanceProcAddr; }
};
#endif // VK_LUNARG_direct_driver_loading

#if VK_QNX_external_memory_screen_buffer
struct ScreenBufferPropertiesQNX : VkScreenBufferPropertiesQNX {
  ScreenBufferPropertiesQNX() noexcept : VkScreenBufferPropertiesQNX{.sType = VK_STRUCTURE_TYPE_SCREEN_BUFFER_PROPERTIES_QNX} {}

  DeviceSize getAllocationSize() const { return this->allocationSize; }
  uint32_t getMemoryTypeBits() const { return this->memoryTypeBits; }

  void attach(struct ScreenBufferFormatPropertiesQNX&);
};
#endif // VK_QNX_external_memory_screen_buffer

#if VK_NV_low_latency2
struct LatencySleepModeInfoNV : VkLatencySleepModeInfoNV {
  LatencySleepModeInfoNV() noexcept : VkLatencySleepModeInfoNV{.sType = VK_STRUCTURE_TYPE_LATENCY_SLEEP_MODE_INFO_NV} {}

  void setMinimumIntervalUs(uint32_t value) { this->minimumIntervalUs = value; }
  uint32_t getMinimumIntervalUs() const { return this->minimumIntervalUs; }

  void setLowLatencyMode(Bool32 value) { this->lowLatencyMode = value; }
  Bool32 getLowLatencyMode() const { return this->lowLatencyMode; }
  void setLowLatencyBoost(Bool32 value) { this->lowLatencyBoost = value; }
  Bool32 getLowLatencyBoost() const { return this->lowLatencyBoost; }
};

struct LatencyTimingsFrameReportNV : VkLatencyTimingsFrameReportNV {
  LatencyTimingsFrameReportNV() noexcept : VkLatencyTimingsFrameReportNV{.sType = VK_STRUCTURE_TYPE_LATENCY_TIMINGS_FRAME_REPORT_NV} {}

  uint64_t getPresentID() const { return this->presentID; }
  uint64_t getInputSampleTimeUs() const { return this->inputSampleTimeUs; }
  uint64_t getSimStartTimeUs() const { return this->simStartTimeUs; }
  uint64_t getSimEndTimeUs() const { return this->simEndTimeUs; }
  uint64_t getRenderSubmitStartTimeUs() const { return this->renderSubmitStartTimeUs; }
  uint64_t getRenderSubmitEndTimeUs() const { return this->renderSubmitEndTimeUs; }
  uint64_t getPresentStartTimeUs() const { return this->presentStartTimeUs; }
  uint64_t getPresentEndTimeUs() const { return this->presentEndTimeUs; }
  uint64_t getDriverStartTimeUs() const { return this->driverStartTimeUs; }
  uint64_t getDriverEndTimeUs() const { return this->driverEndTimeUs; }
  uint64_t getOsRenderQueueStartTimeUs() const { return this->osRenderQueueStartTimeUs; }
  uint64_t getOsRenderQueueEndTimeUs() const { return this->osRenderQueueEndTimeUs; }
  uint64_t getGpuRenderStartTimeUs() const { return this->gpuRenderStartTimeUs; }
  uint64_t getGpuRenderEndTimeUs() const { return this->gpuRenderEndTimeUs; }
};
#endif // VK_NV_low_latency2

#if VK_QCOM_tile_shading
struct PerTileBeginInfoQCOM : VkPerTileBeginInfoQCOM {
  PerTileBeginInfoQCOM() noexcept : VkPerTileBeginInfoQCOM{.sType = VK_STRUCTURE_TYPE_PER_TILE_BEGIN_INFO_QCOM} {}
};

struct PerTileEndInfoQCOM : VkPerTileEndInfoQCOM {
  PerTileEndInfoQCOM() noexcept : VkPerTileEndInfoQCOM{.sType = VK_STRUCTURE_TYPE_PER_TILE_END_INFO_QCOM} {}
};

struct DispatchTileInfoQCOM : VkDispatchTileInfoQCOM {
  DispatchTileInfoQCOM() noexcept : VkDispatchTileInfoQCOM{.sType = VK_STRUCTURE_TYPE_DISPATCH_TILE_INFO_QCOM} {}
};
#endif // VK_QCOM_tile_shading

#if VK_NV_external_compute_queue
struct ExternalComputeQueueDataParamsNV : VkExternalComputeQueueDataParamsNV {
  ExternalComputeQueueDataParamsNV() noexcept : VkExternalComputeQueueDataParamsNV{.sType = VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_DATA_PARAMS_NV} {}

  void setDeviceIndex(uint32_t value) { this->deviceIndex = value; }
  uint32_t getDeviceIndex() const { return this->deviceIndex; }
};
#endif // VK_NV_external_compute_queue

#if VK_ARM_tensors
struct TensorCopyARM : VkTensorCopyARM {
  TensorCopyARM() noexcept : VkTensorCopyARM{.sType = VK_STRUCTURE_TYPE_TENSOR_COPY_ARM} {}

  void setDimensionCount(uint32_t value) { this->dimensionCount = value; }
  uint32_t getDimensionCount() const { return this->dimensionCount; }

  void setSrcOffset(const uint64_t* value) { this->pSrcOffset = value; }
  const uint64_t* getSrcOffset() const { return this->pSrcOffset; }
  void setDstOffset(const uint64_t* value) { this->pDstOffset = value; }
  const uint64_t* getDstOffset() const { return this->pDstOffset; }
  void setExtent(const uint64_t* value) { this->pExtent = value; }
  const uint64_t* getExtent() const { return this->pExtent; }
};
#endif // VK_ARM_tensors

#if VK_OHOS_surface
struct OHSurfaceCreateInfoOHOS : VkOHSurfaceCreateInfoOHOS {
  OHSurfaceCreateInfoOHOS() noexcept : VkOHSurfaceCreateInfoOHOS{.sType = VK_STRUCTURE_TYPE_OH_SURFACE_CREATE_INFO_OHOS} {}

  void setwindow(OHNativeWindow* value) { this->window = value; }
  OHNativeWindow* getwindow() const { return this->window; }

  void setFlags(SurfaceCreateFlagsOHOS value) { this->flags = std::bit_cast<VkSurfaceCreateFlagsOHOS>(value); }
  SurfaceCreateFlagsOHOS getFlags() const { return std::bit_cast<SurfaceCreateFlagsOHOS>(this->flags); }
};
#endif // VK_OHOS_surface

#if VK_ARM_data_graph
struct DataGraphPipelineConstantARM : VkDataGraphPipelineConstantARM {
  DataGraphPipelineConstantARM() noexcept : VkDataGraphPipelineConstantARM{.sType = VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CONSTANT_ARM} {}

  void setId(uint32_t value) { this->id = value; }
  uint32_t getId() const { return this->id; }
  void setConstantData(const void* value) { this->pConstantData = value; }
  const void* getConstantData() const { return this->pConstantData; }

  void attach(struct TensorDescriptionARM&);
  void attach(struct DataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM&);
};

struct DataGraphPipelineResourceInfoARM : VkDataGraphPipelineResourceInfoARM {
  DataGraphPipelineResourceInfoARM() noexcept : VkDataGraphPipelineResourceInfoARM{.sType = VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_RESOURCE_INFO_ARM} {}

  void setDescriptorSet(uint32_t value) { this->descriptorSet = value; }
  uint32_t getDescriptorSet() const { return this->descriptorSet; }
  void setBinding(uint32_t value) { this->binding = value; }
  uint32_t getBinding() const { return this->binding; }

  void setArrayElement(uint32_t value) { this->arrayElement = value; }
  uint32_t getArrayElement() const { return this->arrayElement; }

  void attach(struct TensorDescriptionARM&);
};
#endif // VK_ARM_data_graph

#if VK_VERSION_1_0
struct ApplicationInfo : VkApplicationInfo {
  ApplicationInfo() noexcept : VkApplicationInfo{.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO} {}

  void setApplicationVersion(uint32_t value) { this->applicationVersion = value; }
  uint32_t getApplicationVersion() const { return this->applicationVersion; }
  void setEngineVersion(uint32_t value) { this->engineVersion = value; }
  uint32_t getEngineVersion() const { return this->engineVersion; }
  void setApiVersion(uint32_t value) { this->apiVersion = value; }
  uint32_t getApiVersion() const { return this->apiVersion; }

  void setApplicationName(const char* value) { this->pApplicationName = value; }
  const char* getApplicationName() const { return this->pApplicationName; }
  void setEngineName(const char* value) { this->pEngineName = value; }
  const char* getEngineName() const { return this->pEngineName; }

};

struct MemoryAllocateInfo : VkMemoryAllocateInfo {
  MemoryAllocateInfo() noexcept : VkMemoryAllocateInfo{.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO} {}

  // Size of memory allocation
  void setAllocationSize(DeviceSize value) { this->allocationSize = value; }
  DeviceSize getAllocationSize() const { return this->allocationSize; }
  // Index of the of the memory type to allocate from
  void setMemoryTypeIndex(uint32_t value) { this->memoryTypeIndex = value; }
  uint32_t getMemoryTypeIndex() const { return this->memoryTypeIndex; }

#if VK_VERSION_1_1
  void attach(struct ExportMemoryAllocateInfo&);
#endif // VK_VERSION_1_1
#if VK_KHR_external_memory_win32
  void attach(struct ImportMemoryWin32HandleInfoKHR&);
  void attach(struct ExportMemoryWin32HandleInfoKHR&);
#endif // VK_KHR_external_memory_win32
#if VK_FUCHSIA_external_memory
  void attach(struct ImportMemoryZirconHandleInfoFUCHSIA&);
#endif // VK_FUCHSIA_external_memory
#if VK_KHR_external_memory_fd
  void attach(struct ImportMemoryFdInfoKHR&);
#endif // VK_KHR_external_memory_fd
#if VK_EXT_external_memory_metal
  void attach(struct ImportMemoryMetalHandleInfoEXT&);
#endif // VK_EXT_external_memory_metal
#if VK_VERSION_1_1
  void attach(struct MemoryAllocateFlagsInfo&);
  void attach(struct MemoryDedicatedAllocateInfo&);
#endif // VK_VERSION_1_1
#if VK_EXT_external_memory_host
  void attach(struct ImportMemoryHostPointerInfoEXT&);
#endif // VK_EXT_external_memory_host
#if VK_ANDROID_external_memory_android_hardware_buffer
  void attach(struct ImportAndroidHardwareBufferInfoANDROID&);
#endif // VK_ANDROID_external_memory_android_hardware_buffer
#if VK_EXT_memory_priority
  void attach(struct MemoryPriorityAllocateInfoEXT&);
#endif // VK_EXT_memory_priority
#if VK_VERSION_1_2
  void attach(struct MemoryOpaqueCaptureAddressAllocateInfo&);
#endif // VK_VERSION_1_2
#if VK_FUCHSIA_buffer_collection
  void attach(struct ImportMemoryBufferCollectionFUCHSIA&);
#endif // VK_FUCHSIA_buffer_collection
#if VK_EXT_metal_objects
  void attach(struct ExportMetalObjectCreateInfoEXT&);
  void attach(struct ImportMetalBufferInfoEXT&);
#endif // VK_EXT_metal_objects
#if VK_QNX_external_memory_screen_buffer
  void attach(struct ImportScreenBufferInfoQNX&);
#endif // VK_QNX_external_memory_screen_buffer
#if VK_ARM_tensors
  void attach(struct MemoryDedicatedAllocateInfoTensorARM&);
#endif // VK_ARM_tensors
};

struct PipelineInputAssemblyStateCreateInfo : VkPipelineInputAssemblyStateCreateInfo {
  PipelineInputAssemblyStateCreateInfo() noexcept : VkPipelineInputAssemblyStateCreateInfo{.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO} {}

  void setTopology(PrimitiveTopology value) { this->topology = std::bit_cast<VkPrimitiveTopology>(value); }
  PrimitiveTopology getTopology() const { return std::bit_cast<PrimitiveTopology>(this->topology); }

  void setFlags(PipelineInputAssemblyStateCreateFlags value) { this->flags = std::bit_cast<VkPipelineInputAssemblyStateCreateFlags>(value); }
  PipelineInputAssemblyStateCreateFlags getFlags() const { return std::bit_cast<PipelineInputAssemblyStateCreateFlags>(this->flags); }
  void setPrimitiveRestartEnable(Bool32 value) { this->primitiveRestartEnable = value; }
  Bool32 getPrimitiveRestartEnable() const { return this->primitiveRestartEnable; }
};

struct PipelineTessellationStateCreateInfo : VkPipelineTessellationStateCreateInfo {
  PipelineTessellationStateCreateInfo() noexcept : VkPipelineTessellationStateCreateInfo{.sType = VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO} {}

  void setPatchControlPoints(uint32_t value) { this->patchControlPoints = value; }
  uint32_t getPatchControlPoints() const { return this->patchControlPoints; }

  void setFlags(PipelineTessellationStateCreateFlags value) { this->flags = std::bit_cast<VkPipelineTessellationStateCreateFlags>(value); }
  PipelineTessellationStateCreateFlags getFlags() const { return std::bit_cast<PipelineTessellationStateCreateFlags>(this->flags); }

#if VK_VERSION_1_1
  void attach(struct PipelineTessellationDomainOriginStateCreateInfo&);
#endif // VK_VERSION_1_1
};
#endif // VK_VERSION_1_0

#if VK_VERSION_1_2
struct SubpassBeginInfo : VkSubpassBeginInfo {
  SubpassBeginInfo() noexcept : VkSubpassBeginInfo{.sType = VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO} {}

  void setContents(SubpassContents value) { this->contents = std::bit_cast<VkSubpassContents>(value); }
  SubpassContents getContents() const { return std::bit_cast<SubpassContents>(this->contents); }
};
#endif // VK_VERSION_1_2

#if VK_VERSION_1_0
struct PipelineDynamicStateCreateInfo : VkPipelineDynamicStateCreateInfo {
  PipelineDynamicStateCreateInfo() noexcept : VkPipelineDynamicStateCreateInfo{.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO} {}

  void setFlags(PipelineDynamicStateCreateFlags value) { this->flags = std::bit_cast<VkPipelineDynamicStateCreateFlags>(value); }
  PipelineDynamicStateCreateFlags getFlags() const { return std::bit_cast<PipelineDynamicStateCreateFlags>(this->flags); }
  void setDynamicStateCount(uint32_t value) { this->dynamicStateCount = value; }
  uint32_t getDynamicStateCount() const { return this->dynamicStateCount; }
  void setDynamicStates(const DynamicState* value) { this->pDynamicStates = std::bit_cast<const VkDynamicState*>(value); }
  const DynamicState* getDynamicStates() const { return std::bit_cast<const DynamicState*>(this->pDynamicStates); }
};
#endif // VK_VERSION_1_0

#if VK_KHR_descriptor_update_template
using DescriptorUpdateTemplateTypeKHR = DescriptorUpdateTemplateType;
#endif // VK_KHR_descriptor_update_template

#if VK_EXT_debug_utils
struct DebugUtilsObjectTagInfoEXT : VkDebugUtilsObjectTagInfoEXT {
  DebugUtilsObjectTagInfoEXT() noexcept : VkDebugUtilsObjectTagInfoEXT{.sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT} {}

  void setObject(Object value) { this->objectType = std::bit_cast<VkObjectType>(value.type); this->objectHandle = value.handle; }
  Object getObject() const { return {std::bit_cast<ObjectType>(this->objectType), this->objectHandle}; }
  void setTagName(uint64_t value) { this->tagName = value; }
  uint64_t getTagName() const { return this->tagName; }
  void setTagSize(size_t value) { this->tagSize = value; }
  size_t getTagSize() const { return this->tagSize; }
  void setTag(const void* value) { this->pTag = value; }
  const void* getTag() const { return this->pTag; }
};
#endif // VK_EXT_debug_utils

#if VK_VERSION_1_0
struct DeviceMemory : Handle<VkDeviceMemory, ObjectType::eDeviceMemory> {};
struct CommandPool : Handle<VkCommandPool, ObjectType::eCommandPool> {};
struct Buffer : Handle<VkBuffer, ObjectType::eBuffer> {};
struct BufferView : Handle<VkBufferView, ObjectType::eBufferView> {};
struct Image : Handle<VkImage, ObjectType::eImage> {};
struct ImageView : Handle<VkImageView, ObjectType::eImageView> {};
struct ShaderModule : Handle<VkShaderModule, ObjectType::eShaderModule> {};
struct Pipeline : Handle<VkPipeline, ObjectType::ePipeline> {};
struct PipelineLayout : Handle<VkPipelineLayout, ObjectType::ePipelineLayout> {};
struct Sampler : Handle<VkSampler, ObjectType::eSampler> {};
struct DescriptorSet : Handle<VkDescriptorSet, ObjectType::eDescriptorSet> {};
struct DescriptorSetLayout : Handle<VkDescriptorSetLayout, ObjectType::eDescriptorSetLayout> {};
struct DescriptorPool : Handle<VkDescriptorPool, ObjectType::eDescriptorPool> {};
struct Fence : Handle<VkFence, ObjectType::eFence> {};
struct Semaphore : Handle<VkSemaphore, ObjectType::eSemaphore> {};
struct Event : Handle<VkEvent, ObjectType::eEvent> {};
struct QueryPool : Handle<VkQueryPool, ObjectType::eQueryPool> {};
struct Framebuffer : Handle<VkFramebuffer, ObjectType::eFramebuffer> {};
struct RenderPass : Handle<VkRenderPass, ObjectType::eRenderPass> {};
struct PipelineCache : Handle<VkPipelineCache, ObjectType::ePipelineCache> {};
#endif // VK_VERSION_1_0
#if VK_KHR_pipeline_binary
struct PipelineBinaryKHR : Handle<VkPipelineBinaryKHR, ObjectType::ePipelineBinaryKHR> {};
#endif // VK_KHR_pipeline_binary
#if VK_NV_device_generated_commands
struct IndirectCommandsLayoutNV : Handle<VkIndirectCommandsLayoutNV, ObjectType::eIndirectCommandsLayoutNV> {};
#endif // VK_NV_device_generated_commands
#if VK_EXT_device_generated_commands
struct IndirectCommandsLayoutEXT : Handle<VkIndirectCommandsLayoutEXT, ObjectType::eIndirectCommandsLayoutEXT> {};
struct IndirectExecutionSetEXT : Handle<VkIndirectExecutionSetEXT, ObjectType::eIndirectExecutionSetEXT> {};
#endif // VK_EXT_device_generated_commands
#if VK_VERSION_1_1
struct DescriptorUpdateTemplate : Handle<VkDescriptorUpdateTemplate, ObjectType::eDescriptorUpdateTemplate> {};
struct SamplerYcbcrConversion : Handle<VkSamplerYcbcrConversion, ObjectType::eSamplerYcbcrConversion> {};
#endif // VK_VERSION_1_1
#if VK_EXT_validation_cache
struct ValidationCacheEXT : Handle<VkValidationCacheEXT, ObjectType::eValidationCacheEXT> {};
#endif // VK_EXT_validation_cache
#if VK_KHR_acceleration_structure
struct AccelerationStructureKHR : Handle<VkAccelerationStructureKHR, ObjectType::eAccelerationStructureKHR> {};
#endif // VK_KHR_acceleration_structure
#if VK_INTEL_performance_query
struct PerformanceConfigurationINTEL : Handle<VkPerformanceConfigurationINTEL, ObjectType::ePerformanceConfigurationINTEL> {};
#endif // VK_INTEL_performance_query
#if VK_FUCHSIA_buffer_collection
struct BufferCollectionFUCHSIA : Handle<VkBufferCollectionFUCHSIA, ObjectType::eBufferCollectionFUCHSIA> {};
#endif // VK_FUCHSIA_buffer_collection
#if VK_KHR_deferred_host_operations
struct DeferredOperationKHR : Handle<VkDeferredOperationKHR, ObjectType::eDeferredOperationKHR> {};
#endif // VK_KHR_deferred_host_operations
#if VK_VERSION_1_3
struct PrivateDataSlot : Handle<VkPrivateDataSlot, ObjectType::ePrivateDataSlot> {};
#endif // VK_VERSION_1_3
#if VK_NVX_binary_import
struct CuModuleNVX : Handle<VkCuModuleNVX, ObjectType::eCuModuleNVX> {};
struct CuFunctionNVX : Handle<VkCuFunctionNVX, ObjectType::eCuFunctionNVX> {};
#endif // VK_NVX_binary_import
#if VK_NV_optical_flow
struct OpticalFlowSessionNV : Handle<VkOpticalFlowSessionNV, ObjectType::eOpticalFlowSessionNV> {};
#endif // VK_NV_optical_flow
#if VK_EXT_opacity_micromap
struct MicromapEXT : Handle<VkMicromapEXT, ObjectType::eMicromapEXT> {};
#endif // VK_EXT_opacity_micromap
#if VK_EXT_shader_object
struct ShaderEXT : Handle<VkShaderEXT, ObjectType::eShaderEXT> {};
#endif // VK_EXT_shader_object
#if VK_ARM_tensors
struct TensorARM : Handle<VkTensorARM, ObjectType::eTensorARM> {};
struct TensorViewARM : Handle<VkTensorViewARM, ObjectType::eTensorViewARM> {};
#endif // VK_ARM_tensors
#if VK_ARM_data_graph
struct DataGraphPipelineSessionARM : Handle<VkDataGraphPipelineSessionARM, ObjectType::eDataGraphPipelineSessionARM> {};
#endif // VK_ARM_data_graph
#if VK_KHR_display
struct DisplayKHR : Handle<VkDisplayKHR, ObjectType::eDisplayKHR> {};
struct DisplayModeKHR : Handle<VkDisplayModeKHR, ObjectType::eDisplayModeKHR> {};
#endif // VK_KHR_display
#if VK_KHR_surface
struct SurfaceKHR : Handle<VkSurfaceKHR, ObjectType::eSurfaceKHR> {};
#endif // VK_KHR_surface
#if VK_KHR_swapchain
struct SwapchainKHR : Handle<VkSwapchainKHR, ObjectType::eSwapchainKHR> {};
#endif // VK_KHR_swapchain
#if VK_EXT_debug_utils
struct DebugUtilsMessengerEXT : Handle<VkDebugUtilsMessengerEXT, ObjectType::eDebugUtilsMessengerEXT> {};
#endif // VK_EXT_debug_utils
#if VK_KHR_video_queue
struct VideoSessionKHR : Handle<VkVideoSessionKHR, ObjectType::eVideoSessionKHR> {};
struct VideoSessionParametersKHR : Handle<VkVideoSessionParametersKHR, ObjectType::eVideoSessionParametersKHR> {};
#endif // VK_KHR_video_queue

#if VK_AMD_anti_lag
struct AntiLagPresentationInfoAMD : VkAntiLagPresentationInfoAMD {
  AntiLagPresentationInfoAMD() noexcept : VkAntiLagPresentationInfoAMD{.sType = VK_STRUCTURE_TYPE_ANTI_LAG_PRESENTATION_INFO_AMD} {}

  void setStage(AntiLagStageAMD value) { this->stage = std::bit_cast<VkAntiLagStageAMD>(value); }
  AntiLagStageAMD getStage() const { return std::bit_cast<AntiLagStageAMD>(this->stage); }
  void setFrameIndex(uint64_t value) { this->frameIndex = value; }
  uint64_t getFrameIndex() const { return this->frameIndex; }
};
#endif // VK_AMD_anti_lag

#if VK_VERSION_1_0
using QueueFlags = FlagSet<QueueFlagBits, Flags>;
constexpr QueueFlags operator|(QueueFlagBits a, QueueFlagBits b) noexcept { return QueueFlags(Flags(a) | Flags(b)); }

using CullModeFlags = FlagSet<CullModeFlagBits, Flags>;
constexpr CullModeFlags operator|(CullModeFlagBits a, CullModeFlagBits b) noexcept { return CullModeFlags(Flags(a) | Flags(b)); }

using RenderPassCreateFlags = FlagSet<RenderPassCreateFlagBits, Flags>;
constexpr RenderPassCreateFlags operator|(RenderPassCreateFlagBits a, RenderPassCreateFlagBits b) noexcept { return RenderPassCreateFlags(Flags(a) | Flags(b)); }

using DeviceQueueCreateFlags = FlagSet<DeviceQueueCreateFlagBits, Flags>;
constexpr DeviceQueueCreateFlags operator|(DeviceQueueCreateFlagBits a, DeviceQueueCreateFlagBits b) noexcept { return DeviceQueueCreateFlags(Flags(a) | Flags(b)); }

using MemoryPropertyFlags = FlagSet<MemoryPropertyFlagBits, Flags>;
constexpr MemoryPropertyFlags operator|(MemoryPropertyFlagBits a, MemoryPropertyFlagBits b) noexcept { return MemoryPropertyFlags(Flags(a) | Flags(b)); }

using MemoryHeapFlags = FlagSet<MemoryHeapFlagBits, Flags>;
constexpr MemoryHeapFlags operator|(MemoryHeapFlagBits a, MemoryHeapFlagBits b) noexcept { return MemoryHeapFlags(Flags(a) | Flags(b)); }

using AccessFlags = FlagSet<AccessFlagBits, Flags>;
constexpr AccessFlags operator|(AccessFlagBits a, AccessFlagBits b) noexcept { return AccessFlags(Flags(a) | Flags(b)); }

using BufferUsageFlags = FlagSet<BufferUsageFlagBits, Flags>;
constexpr BufferUsageFlags operator|(BufferUsageFlagBits a, BufferUsageFlagBits b) noexcept { return BufferUsageFlags(Flags(a) | Flags(b)); }
#endif // VK_VERSION_1_0

#if VK_VERSION_1_4
using BufferUsageFlags2 = FlagSet<BufferUsageFlagBits2, Flags64>;
constexpr BufferUsageFlags2 operator|(BufferUsageFlagBits2 a, BufferUsageFlagBits2 b) noexcept { return BufferUsageFlags2(Flags64(a) | Flags64(b)); }
#endif // VK_VERSION_1_4

#if VK_KHR_maintenance5
using BufferUsageFlagBits2KHR = BufferUsageFlagBits2;
#endif // VK_KHR_maintenance5

#if VK_VERSION_1_0
using BufferCreateFlags = FlagSet<BufferCreateFlagBits, Flags>;
constexpr BufferCreateFlags operator|(BufferCreateFlagBits a, BufferCreateFlagBits b) noexcept { return BufferCreateFlags(Flags(a) | Flags(b)); }

using ShaderStageFlags = FlagSet<ShaderStageFlagBits, Flags>;
constexpr ShaderStageFlags operator|(ShaderStageFlagBits a, ShaderStageFlagBits b) noexcept { return ShaderStageFlags(Flags(a) | Flags(b)); }

using ImageUsageFlags = FlagSet<ImageUsageFlagBits, Flags>;
constexpr ImageUsageFlags operator|(ImageUsageFlagBits a, ImageUsageFlagBits b) noexcept { return ImageUsageFlags(Flags(a) | Flags(b)); }

using ImageCreateFlags = FlagSet<ImageCreateFlagBits, Flags>;
constexpr ImageCreateFlags operator|(ImageCreateFlagBits a, ImageCreateFlagBits b) noexcept { return ImageCreateFlags(Flags(a) | Flags(b)); }

using ImageViewCreateFlags = FlagSet<ImageViewCreateFlagBits, Flags>;
constexpr ImageViewCreateFlags operator|(ImageViewCreateFlagBits a, ImageViewCreateFlagBits b) noexcept { return ImageViewCreateFlags(Flags(a) | Flags(b)); }

using SamplerCreateFlags = FlagSet<SamplerCreateFlagBits, Flags>;
constexpr SamplerCreateFlags operator|(SamplerCreateFlagBits a, SamplerCreateFlagBits b) noexcept { return SamplerCreateFlags(Flags(a) | Flags(b)); }

using PipelineCreateFlags = FlagSet<PipelineCreateFlagBits, Flags>;
constexpr PipelineCreateFlags operator|(PipelineCreateFlagBits a, PipelineCreateFlagBits b) noexcept { return PipelineCreateFlags(Flags(a) | Flags(b)); }
#endif // VK_VERSION_1_0

#if VK_VERSION_1_4
using PipelineCreateFlags2 = FlagSet<PipelineCreateFlagBits2, Flags64>;
constexpr PipelineCreateFlags2 operator|(PipelineCreateFlagBits2 a, PipelineCreateFlagBits2 b) noexcept { return PipelineCreateFlags2(Flags64(a) | Flags64(b)); }
#endif // VK_VERSION_1_4

#if VK_KHR_maintenance5
using PipelineCreateFlagBits2KHR = PipelineCreateFlagBits2;
#endif // VK_KHR_maintenance5

#if VK_VERSION_1_0
using PipelineShaderStageCreateFlags = FlagSet<PipelineShaderStageCreateFlagBits, Flags>;
constexpr PipelineShaderStageCreateFlags operator|(PipelineShaderStageCreateFlagBits a, PipelineShaderStageCreateFlagBits b) noexcept { return PipelineShaderStageCreateFlags(Flags(a) | Flags(b)); }

using ColorComponentFlags = FlagSet<ColorComponentFlagBits, Flags>;
constexpr ColorComponentFlags operator|(ColorComponentFlagBits a, ColorComponentFlagBits b) noexcept { return ColorComponentFlags(Flags(a) | Flags(b)); }

using FenceCreateFlags = FlagSet<FenceCreateFlagBits, Flags>;
constexpr FenceCreateFlags operator|(FenceCreateFlagBits a, FenceCreateFlagBits b) noexcept { return FenceCreateFlags(Flags(a) | Flags(b)); }

using FormatFeatureFlags = FlagSet<FormatFeatureFlagBits, Flags>;
constexpr FormatFeatureFlags operator|(FormatFeatureFlagBits a, FormatFeatureFlagBits b) noexcept { return FormatFeatureFlags(Flags(a) | Flags(b)); }

using QueryControlFlags = FlagSet<QueryControlFlagBits, Flags>;
constexpr QueryControlFlags operator|(QueryControlFlagBits a, QueryControlFlagBits b) noexcept { return QueryControlFlags(Flags(a) | Flags(b)); }

using QueryResultFlags = FlagSet<QueryResultFlagBits, Flags>;
constexpr QueryResultFlags operator|(QueryResultFlagBits a, QueryResultFlagBits b) noexcept { return QueryResultFlags(Flags(a) | Flags(b)); }

using CommandBufferUsageFlags = FlagSet<CommandBufferUsageFlagBits, Flags>;
constexpr CommandBufferUsageFlags operator|(CommandBufferUsageFlagBits a, CommandBufferUsageFlagBits b) noexcept { return CommandBufferUsageFlags(Flags(a) | Flags(b)); }

using QueryPipelineStatisticFlags = FlagSet<QueryPipelineStatisticFlagBits, Flags>;
constexpr QueryPipelineStatisticFlags operator|(QueryPipelineStatisticFlagBits a, QueryPipelineStatisticFlagBits b) noexcept { return QueryPipelineStatisticFlags(Flags(a) | Flags(b)); }

using MemoryMapFlags = FlagSet<MemoryMapFlagBits, Flags>;
constexpr MemoryMapFlags operator|(MemoryMapFlagBits a, MemoryMapFlagBits b) noexcept { return MemoryMapFlags(Flags(a) | Flags(b)); }

using ImageAspectFlags = FlagSet<ImageAspectFlagBits, Flags>;
constexpr ImageAspectFlags operator|(ImageAspectFlagBits a, ImageAspectFlagBits b) noexcept { return ImageAspectFlags(Flags(a) | Flags(b)); }

using SparseImageFormatFlags = FlagSet<SparseImageFormatFlagBits, Flags>;
constexpr SparseImageFormatFlags operator|(SparseImageFormatFlagBits a, SparseImageFormatFlagBits b) noexcept { return SparseImageFormatFlags(Flags(a) | Flags(b)); }

using SparseMemoryBindFlags = FlagSet<SparseMemoryBindFlagBits, Flags>;
constexpr SparseMemoryBindFlags operator|(SparseMemoryBindFlagBits a, SparseMemoryBindFlagBits b) noexcept { return SparseMemoryBindFlags(Flags(a) | Flags(b)); }
#endif // VK_VERSION_1_0

#if VK_NV_device_diagnostic_checkpoints
struct CheckpointDataNV : VkCheckpointDataNV {
  CheckpointDataNV() noexcept : VkCheckpointDataNV{.sType = VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV} {}

  PipelineStageFlagBits getStage() const { return std::bit_cast<PipelineStageFlagBits>(this->stage); }
  void* getCheckpointMarker() const { return this->pCheckpointMarker; }
};
#endif // VK_NV_device_diagnostic_checkpoints

#if VK_VERSION_1_0
using PipelineStageFlags = FlagSet<PipelineStageFlagBits, Flags>;
constexpr PipelineStageFlags operator|(PipelineStageFlagBits a, PipelineStageFlagBits b) noexcept { return PipelineStageFlags(Flags(a) | Flags(b)); }

using CommandPoolCreateFlags = FlagSet<CommandPoolCreateFlagBits, Flags>;
constexpr CommandPoolCreateFlags operator|(CommandPoolCreateFlagBits a, CommandPoolCreateFlagBits b) noexcept { return CommandPoolCreateFlags(Flags(a) | Flags(b)); }

using CommandPoolResetFlags = FlagSet<CommandPoolResetFlagBits, Flags>;
constexpr CommandPoolResetFlags operator|(CommandPoolResetFlagBits a, CommandPoolResetFlagBits b) noexcept { return CommandPoolResetFlags(Flags(a) | Flags(b)); }

using CommandBufferResetFlags = FlagSet<CommandBufferResetFlagBits, Flags>;
constexpr CommandBufferResetFlags operator|(CommandBufferResetFlagBits a, CommandBufferResetFlagBits b) noexcept { return CommandBufferResetFlags(Flags(a) | Flags(b)); }

using SampleCountFlags = FlagSet<SampleCountFlagBits, Flags>;
constexpr SampleCountFlags operator|(SampleCountFlagBits a, SampleCountFlagBits b) noexcept { return SampleCountFlags(Flags(a) | Flags(b)); }

struct PipelineMultisampleStateCreateInfo : VkPipelineMultisampleStateCreateInfo {
  PipelineMultisampleStateCreateInfo() noexcept : VkPipelineMultisampleStateCreateInfo{.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO} {}

  // Number of samples used for rasterization
  void setRasterizationSamples(SampleCountFlagBits value) { this->rasterizationSamples = std::bit_cast<VkSampleCountFlagBits>(value); }
  SampleCountFlagBits getRasterizationSamples() const { return std::bit_cast<SampleCountFlagBits>(this->rasterizationSamples); }
  // optional (GL45)
  void setMinSampleShading(float value) { this->minSampleShading = value; }
  float getMinSampleShading() const { return this->minSampleShading; }

  void setFlags(PipelineMultisampleStateCreateFlags value) { this->flags = std::bit_cast<VkPipelineMultisampleStateCreateFlags>(value); }
  PipelineMultisampleStateCreateFlags getFlags() const { return std::bit_cast<PipelineMultisampleStateCreateFlags>(this->flags); }
  // optional (GL45)
  void setSampleShadingEnable(Bool32 value) { this->sampleShadingEnable = value; }
  Bool32 getSampleShadingEnable() const { return this->sampleShadingEnable; }
  // Array of sampleMask words
  void setSampleMask(const SampleMask* value) { this->pSampleMask = value; }
  const SampleMask* getSampleMask() const { return this->pSampleMask; }
  void setAlphaToCoverageEnable(Bool32 value) { this->alphaToCoverageEnable = value; }
  Bool32 getAlphaToCoverageEnable() const { return this->alphaToCoverageEnable; }
  void setAlphaToOneEnable(Bool32 value) { this->alphaToOneEnable = value; }
  Bool32 getAlphaToOneEnable() const { return this->alphaToOneEnable; }

#if VK_NV_fragment_coverage_to_color
  void attach(struct PipelineCoverageToColorStateCreateInfoNV&);
#endif // VK_NV_fragment_coverage_to_color
#if VK_EXT_sample_locations
  void attach(struct PipelineSampleLocationsStateCreateInfoEXT&);
#endif // VK_EXT_sample_locations
#if VK_NV_framebuffer_mixed_samples
  void attach(struct PipelineCoverageModulationStateCreateInfoNV&);
#endif // VK_NV_framebuffer_mixed_samples
#if VK_NV_coverage_reduction_mode
  void attach(struct PipelineCoverageReductionStateCreateInfoNV&);
#endif // VK_NV_coverage_reduction_mode
};

using AttachmentDescriptionFlags = FlagSet<AttachmentDescriptionFlagBits, Flags>;
constexpr AttachmentDescriptionFlags operator|(AttachmentDescriptionFlagBits a, AttachmentDescriptionFlagBits b) noexcept { return AttachmentDescriptionFlags(Flags(a) | Flags(b)); }

using StencilFaceFlags = FlagSet<StencilFaceFlagBits, Flags>;
constexpr StencilFaceFlags operator|(StencilFaceFlagBits a, StencilFaceFlagBits b) noexcept { return StencilFaceFlags(Flags(a) | Flags(b)); }

using DescriptorPoolCreateFlags = FlagSet<DescriptorPoolCreateFlagBits, Flags>;
constexpr DescriptorPoolCreateFlags operator|(DescriptorPoolCreateFlagBits a, DescriptorPoolCreateFlagBits b) noexcept { return DescriptorPoolCreateFlags(Flags(a) | Flags(b)); }

using DependencyFlags = FlagSet<DependencyFlagBits, Flags>;
constexpr DependencyFlags operator|(DependencyFlagBits a, DependencyFlagBits b) noexcept { return DependencyFlags(Flags(a) | Flags(b)); }
#endif // VK_VERSION_1_0

#if VK_KHR_timeline_semaphore
using SemaphoreTypeKHR = SemaphoreType;
#endif // VK_KHR_timeline_semaphore

#if VK_VERSION_1_2
using SemaphoreWaitFlags = FlagSet<SemaphoreWaitFlagBits, Flags>;
constexpr SemaphoreWaitFlags operator|(SemaphoreWaitFlagBits a, SemaphoreWaitFlagBits b) noexcept { return SemaphoreWaitFlags(Flags(a) | Flags(b)); }
#endif // VK_VERSION_1_2

#if VK_KHR_timeline_semaphore
using SemaphoreWaitFlagBitsKHR = SemaphoreWaitFlagBits;
#endif // VK_KHR_timeline_semaphore

#if VK_KHR_surface
struct SurfaceFormatKHR : VkSurfaceFormatKHR {
  SurfaceFormatKHR() noexcept : VkSurfaceFormatKHR{} {}

  // Supported pair of rendering format
  Format getFormat() const { return std::bit_cast<Format>(this->format); }
  // and color space for the surface
  ColorSpaceKHR getColorSpace() const { return std::bit_cast<ColorSpaceKHR>(this->colorSpace); }
};
#endif // VK_KHR_surface

#if VK_KHR_display
using DisplayPlaneAlphaFlagsKHR = FlagSet<DisplayPlaneAlphaFlagBitsKHR, Flags>;
constexpr DisplayPlaneAlphaFlagsKHR operator|(DisplayPlaneAlphaFlagBitsKHR a, DisplayPlaneAlphaFlagBitsKHR b) noexcept { return DisplayPlaneAlphaFlagsKHR(Flags(a) | Flags(b)); }
#endif // VK_KHR_display

#if VK_KHR_surface
using CompositeAlphaFlagsKHR = FlagSet<CompositeAlphaFlagBitsKHR, Flags>;
constexpr CompositeAlphaFlagsKHR operator|(CompositeAlphaFlagBitsKHR a, CompositeAlphaFlagBitsKHR b) noexcept { return CompositeAlphaFlagsKHR(Flags(a) | Flags(b)); }
#endif // VK_KHR_surface

#if VK_KHR_display
using SurfaceTransformFlagsKHR = FlagSet<SurfaceTransformFlagBitsKHR, Flags>;
constexpr SurfaceTransformFlagsKHR operator|(SurfaceTransformFlagBitsKHR a, SurfaceTransformFlagBitsKHR b) noexcept { return SurfaceTransformFlagsKHR(Flags(a) | Flags(b)); }
#endif // VK_KHR_display

#if VK_KHR_calibrated_timestamps
struct CalibratedTimestampInfoKHR : VkCalibratedTimestampInfoKHR {
  CalibratedTimestampInfoKHR() noexcept : VkCalibratedTimestampInfoKHR{.sType = VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_KHR} {}

  void setTimeDomain(TimeDomainKHR value) { this->timeDomain = std::bit_cast<VkTimeDomainKHR>(value); }
  TimeDomainKHR getTimeDomain() const { return std::bit_cast<TimeDomainKHR>(this->timeDomain); }
};
#endif // VK_KHR_calibrated_timestamps

#if VK_EXT_calibrated_timestamps
using TimeDomainEXT = TimeDomainKHR;
#endif // VK_EXT_calibrated_timestamps

#if VK_EXT_debug_marker
struct DebugMarkerObjectNameInfoEXT : VkDebugMarkerObjectNameInfoEXT {
  DebugMarkerObjectNameInfoEXT() noexcept : VkDebugMarkerObjectNameInfoEXT{.sType = VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT} {}

  // The type of the object
  void setObjectType(DebugReportObjectTypeEXT value) { this->objectType = std::bit_cast<VkDebugReportObjectTypeEXT>(value); }
  DebugReportObjectTypeEXT getObjectType() const { return std::bit_cast<DebugReportObjectTypeEXT>(this->objectType); }
  // The handle of the object, cast to uint64_t
  void setObject(uint64_t value) { this->object = value; }
  uint64_t getObject() const { return this->object; }
  // Name to apply to the object
  void setObjectName(const char* value) { this->pObjectName = value; }
  const char* getObjectName() const { return this->pObjectName; }
};

struct DebugMarkerObjectTagInfoEXT : VkDebugMarkerObjectTagInfoEXT {
  DebugMarkerObjectTagInfoEXT() noexcept : VkDebugMarkerObjectTagInfoEXT{.sType = VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT} {}

  // The type of the object
  void setObjectType(DebugReportObjectTypeEXT value) { this->objectType = std::bit_cast<VkDebugReportObjectTypeEXT>(value); }
  DebugReportObjectTypeEXT getObjectType() const { return std::bit_cast<DebugReportObjectTypeEXT>(this->objectType); }
  // The handle of the object, cast to uint64_t
  void setObject(uint64_t value) { this->object = value; }
  uint64_t getObject() const { return this->object; }
  // The name of the tag to set on the object
  void setTagName(uint64_t value) { this->tagName = value; }
  uint64_t getTagName() const { return this->tagName; }
  // The length in bytes of the tag data
  void setTagSize(size_t value) { this->tagSize = value; }
  size_t getTagSize() const { return this->tagSize; }
  // Tag data to attach to the object
  void setTag(const void* value) { this->pTag = value; }
  const void* getTag() const { return this->pTag; }
};
#endif // VK_EXT_debug_marker

#if VK_EXT_device_memory_report
struct DeviceMemoryReportCallbackDataEXT : VkDeviceMemoryReportCallbackDataEXT {
  DeviceMemoryReportCallbackDataEXT() noexcept : VkDeviceMemoryReportCallbackDataEXT{.sType = VK_STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT} {}

  DeviceMemoryReportFlagsEXT getFlags() const { return std::bit_cast<DeviceMemoryReportFlagsEXT>(this->flags); }
  DeviceMemoryReportEventTypeEXT getType() const { return std::bit_cast<DeviceMemoryReportEventTypeEXT>(this->type); }
  uint64_t getMemoryObjectId() const { return this->memoryObjectId; }
  DeviceSize getSize() const { return this->size; }
  Object getObject() const { return {std::bit_cast<ObjectType>(this->objectType), this->objectHandle}; }
  uint32_t getHeapIndex() const { return this->heapIndex; }
};
#endif // VK_EXT_device_memory_report

#if VK_NV_cluster_acceleration_structure
using ClusterAccelerationStructureIndexFormatFlagsNV = FlagSet<ClusterAccelerationStructureIndexFormatFlagBitsNV, Flags>;
constexpr ClusterAccelerationStructureIndexFormatFlagsNV operator|(ClusterAccelerationStructureIndexFormatFlagBitsNV a, ClusterAccelerationStructureIndexFormatFlagBitsNV b) noexcept { return ClusterAccelerationStructureIndexFormatFlagsNV(Flags(a) | Flags(b)); }

struct ClusterAccelerationStructureMoveObjectsInputNV : VkClusterAccelerationStructureMoveObjectsInputNV {
  ClusterAccelerationStructureMoveObjectsInputNV() noexcept : VkClusterAccelerationStructureMoveObjectsInputNV{.sType = VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_MOVE_OBJECTS_INPUT_NV} {}

  void setType(ClusterAccelerationStructureTypeNV value) { this->type = std::bit_cast<VkClusterAccelerationStructureTypeNV>(value); }
  ClusterAccelerationStructureTypeNV getType() const { return std::bit_cast<ClusterAccelerationStructureTypeNV>(this->type); }
  void setMaxMovedBytes(DeviceSize value) { this->maxMovedBytes = value; }
  DeviceSize getMaxMovedBytes() const { return this->maxMovedBytes; }

  void setNoMoveOverlap(Bool32 value) { this->noMoveOverlap = value; }
  Bool32 getNoMoveOverlap() const { return this->noMoveOverlap; }
};

using ClusterAccelerationStructureClusterFlagsNV = FlagSet<ClusterAccelerationStructureClusterFlagBitsNV, Flags>;
constexpr ClusterAccelerationStructureClusterFlagsNV operator|(ClusterAccelerationStructureClusterFlagBitsNV a, ClusterAccelerationStructureClusterFlagBitsNV b) noexcept { return ClusterAccelerationStructureClusterFlagsNV(Flags(a) | Flags(b)); }

using ClusterAccelerationStructureGeometryFlagsNV = FlagSet<ClusterAccelerationStructureGeometryFlagBitsNV, Flags>;
constexpr ClusterAccelerationStructureGeometryFlagsNV operator|(ClusterAccelerationStructureGeometryFlagBitsNV a, ClusterAccelerationStructureGeometryFlagBitsNV b) noexcept { return ClusterAccelerationStructureGeometryFlagsNV(Flags(a) | Flags(b)); }

using ClusterAccelerationStructureAddressResolutionFlagsNV = FlagSet<ClusterAccelerationStructureAddressResolutionFlagBitsNV, Flags>;
constexpr ClusterAccelerationStructureAddressResolutionFlagsNV operator|(ClusterAccelerationStructureAddressResolutionFlagBitsNV a, ClusterAccelerationStructureAddressResolutionFlagBitsNV b) noexcept { return ClusterAccelerationStructureAddressResolutionFlagsNV(Flags(a) | Flags(b)); }
#endif // VK_NV_cluster_acceleration_structure

#if VK_EXT_layer_settings
struct LayerSettingEXT : VkLayerSettingEXT {
  LayerSettingEXT() noexcept : VkLayerSettingEXT{} {}

  void setLayerName(const char* value) { this->pLayerName = value; }
  const char* getLayerName() const { return this->pLayerName; }
  void setSettingName(const char* value) { this->pSettingName = value; }
  const char* getSettingName() const { return this->pSettingName; }
  // The type of the object
  void setType(LayerSettingTypeEXT value) { this->type = std::bit_cast<VkLayerSettingTypeEXT>(value); }
  LayerSettingTypeEXT getType() const { return std::bit_cast<LayerSettingTypeEXT>(this->type); }

  // Number of values of the setting
  void setValueCount(uint32_t value) { this->valueCount = value; }
  uint32_t getValueCount() const { return this->valueCount; }
  // Values to pass for a setting
  void setValues(const void* value) { this->pValues = value; }
  const void* getValues() const { return this->pValues; }
};
#endif // VK_EXT_layer_settings

#if VK_VERSION_1_1
using SubgroupFeatureFlags = FlagSet<SubgroupFeatureFlagBits, Flags>;
constexpr SubgroupFeatureFlags operator|(SubgroupFeatureFlagBits a, SubgroupFeatureFlagBits b) noexcept { return SubgroupFeatureFlags(Flags(a) | Flags(b)); }
#endif // VK_VERSION_1_1

#if VK_NV_device_generated_commands
using IndirectCommandsLayoutUsageFlagsNV = FlagSet<IndirectCommandsLayoutUsageFlagBitsNV, Flags>;
constexpr IndirectCommandsLayoutUsageFlagsNV operator|(IndirectCommandsLayoutUsageFlagBitsNV a, IndirectCommandsLayoutUsageFlagBitsNV b) noexcept { return IndirectCommandsLayoutUsageFlagsNV(Flags(a) | Flags(b)); }

using IndirectStateFlagsNV = FlagSet<IndirectStateFlagBitsNV, Flags>;
constexpr IndirectStateFlagsNV operator|(IndirectStateFlagBitsNV a, IndirectStateFlagBitsNV b) noexcept { return IndirectStateFlagsNV(Flags(a) | Flags(b)); }
#endif // VK_NV_device_generated_commands

#if VK_VERSION_1_0
using DescriptorSetLayoutCreateFlags = FlagSet<DescriptorSetLayoutCreateFlagBits, Flags>;
constexpr DescriptorSetLayoutCreateFlags operator|(DescriptorSetLayoutCreateFlagBits a, DescriptorSetLayoutCreateFlagBits b) noexcept { return DescriptorSetLayoutCreateFlags(Flags(a) | Flags(b)); }
#endif // VK_VERSION_1_0

#if VK_VERSION_1_1
using ExternalMemoryHandleTypeFlags = FlagSet<ExternalMemoryHandleTypeFlagBits, Flags>;
constexpr ExternalMemoryHandleTypeFlags operator|(ExternalMemoryHandleTypeFlagBits a, ExternalMemoryHandleTypeFlagBits b) noexcept { return ExternalMemoryHandleTypeFlags(Flags(a) | Flags(b)); }
#endif // VK_VERSION_1_1

#if VK_KHR_external_memory_capabilities
using ExternalMemoryHandleTypeFlagBitsKHR = ExternalMemoryHandleTypeFlagBits;
#endif // VK_KHR_external_memory_capabilities

#if VK_VERSION_1_1
using ExternalMemoryFeatureFlags = FlagSet<ExternalMemoryFeatureFlagBits, Flags>;
constexpr ExternalMemoryFeatureFlags operator|(ExternalMemoryFeatureFlagBits a, ExternalMemoryFeatureFlagBits b) noexcept { return ExternalMemoryFeatureFlags(Flags(a) | Flags(b)); }
#endif // VK_VERSION_1_1

#if VK_KHR_external_memory_capabilities
using ExternalMemoryFeatureFlagBitsKHR = ExternalMemoryFeatureFlagBits;
#endif // VK_KHR_external_memory_capabilities

#if VK_VERSION_1_1
using ExternalSemaphoreHandleTypeFlags = FlagSet<ExternalSemaphoreHandleTypeFlagBits, Flags>;
constexpr ExternalSemaphoreHandleTypeFlags operator|(ExternalSemaphoreHandleTypeFlagBits a, ExternalSemaphoreHandleTypeFlagBits b) noexcept { return ExternalSemaphoreHandleTypeFlags(Flags(a) | Flags(b)); }

struct PhysicalDeviceExternalSemaphoreInfo : VkPhysicalDeviceExternalSemaphoreInfo {
  PhysicalDeviceExternalSemaphoreInfo() noexcept : VkPhysicalDeviceExternalSemaphoreInfo{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO} {}

  void setHandleType(ExternalSemaphoreHandleTypeFlagBits value) { this->handleType = std::bit_cast<VkExternalSemaphoreHandleTypeFlagBits>(value); }
  ExternalSemaphoreHandleTypeFlagBits getHandleType() const { return std::bit_cast<ExternalSemaphoreHandleTypeFlagBits>(this->handleType); }

#if VK_VERSION_1_2
  void attach(struct SemaphoreTypeCreateInfo&);
#endif // VK_VERSION_1_2
};
#endif // VK_VERSION_1_1

#if VK_KHR_external_semaphore_capabilities
using ExternalSemaphoreHandleTypeFlagBitsKHR = ExternalSemaphoreHandleTypeFlagBits;
#endif // VK_KHR_external_semaphore_capabilities

#if VK_VERSION_1_1
using ExternalSemaphoreFeatureFlags = FlagSet<ExternalSemaphoreFeatureFlagBits, Flags>;
constexpr ExternalSemaphoreFeatureFlags operator|(ExternalSemaphoreFeatureFlagBits a, ExternalSemaphoreFeatureFlagBits b) noexcept { return ExternalSemaphoreFeatureFlags(Flags(a) | Flags(b)); }
#endif // VK_VERSION_1_1

#if VK_KHR_external_semaphore_capabilities
using ExternalSemaphoreFeatureFlagBitsKHR = ExternalSemaphoreFeatureFlagBits;
#endif // VK_KHR_external_semaphore_capabilities

#if VK_VERSION_1_1
using SemaphoreImportFlags = FlagSet<SemaphoreImportFlagBits, Flags>;
constexpr SemaphoreImportFlags operator|(SemaphoreImportFlagBits a, SemaphoreImportFlagBits b) noexcept { return SemaphoreImportFlags(Flags(a) | Flags(b)); }
#endif // VK_VERSION_1_1

#if VK_KHR_external_semaphore
using SemaphoreImportFlagBitsKHR = SemaphoreImportFlagBits;
#endif // VK_KHR_external_semaphore

#if VK_VERSION_1_1
struct PhysicalDeviceExternalFenceInfo : VkPhysicalDeviceExternalFenceInfo {
  PhysicalDeviceExternalFenceInfo() noexcept : VkPhysicalDeviceExternalFenceInfo{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO} {}

  void setHandleType(ExternalFenceHandleTypeFlagBits value) { this->handleType = std::bit_cast<VkExternalFenceHandleTypeFlagBits>(value); }
  ExternalFenceHandleTypeFlagBits getHandleType() const { return std::bit_cast<ExternalFenceHandleTypeFlagBits>(this->handleType); }
};

using ExternalFenceHandleTypeFlags = FlagSet<ExternalFenceHandleTypeFlagBits, Flags>;
constexpr ExternalFenceHandleTypeFlags operator|(ExternalFenceHandleTypeFlagBits a, ExternalFenceHandleTypeFlagBits b) noexcept { return ExternalFenceHandleTypeFlags(Flags(a) | Flags(b)); }
#endif // VK_VERSION_1_1

#if VK_KHR_external_fence_capabilities
using ExternalFenceHandleTypeFlagBitsKHR = ExternalFenceHandleTypeFlagBits;
#endif // VK_KHR_external_fence_capabilities

#if VK_VERSION_1_1
using ExternalFenceFeatureFlags = FlagSet<ExternalFenceFeatureFlagBits, Flags>;
constexpr ExternalFenceFeatureFlags operator|(ExternalFenceFeatureFlagBits a, ExternalFenceFeatureFlagBits b) noexcept { return ExternalFenceFeatureFlags(Flags(a) | Flags(b)); }
#endif // VK_VERSION_1_1

#if VK_KHR_external_fence_capabilities
using ExternalFenceFeatureFlagBitsKHR = ExternalFenceFeatureFlagBits;
#endif // VK_KHR_external_fence_capabilities

#if VK_VERSION_1_1
using FenceImportFlags = FlagSet<FenceImportFlagBits, Flags>;
constexpr FenceImportFlags operator|(FenceImportFlagBits a, FenceImportFlagBits b) noexcept { return FenceImportFlags(Flags(a) | Flags(b)); }
#endif // VK_VERSION_1_1

#if VK_KHR_external_fence
using FenceImportFlagBitsKHR = FenceImportFlagBits;
#endif // VK_KHR_external_fence

#if VK_EXT_display_surface_counter
using SurfaceCounterFlagsEXT = FlagSet<SurfaceCounterFlagBitsEXT, Flags>;
constexpr SurfaceCounterFlagsEXT operator|(SurfaceCounterFlagBitsEXT a, SurfaceCounterFlagBitsEXT b) noexcept { return SurfaceCounterFlagsEXT(Flags(a) | Flags(b)); }
#endif // VK_EXT_display_surface_counter

#if VK_EXT_display_control
struct DisplayPowerInfoEXT : VkDisplayPowerInfoEXT {
  DisplayPowerInfoEXT() noexcept : VkDisplayPowerInfoEXT{.sType = VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT} {}

  void setPowerState(DisplayPowerStateEXT value) { this->powerState = std::bit_cast<VkDisplayPowerStateEXT>(value); }
  DisplayPowerStateEXT getPowerState() const { return std::bit_cast<DisplayPowerStateEXT>(this->powerState); }
};

struct DeviceEventInfoEXT : VkDeviceEventInfoEXT {
  DeviceEventInfoEXT() noexcept : VkDeviceEventInfoEXT{.sType = VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT} {}

  void setDeviceEvent(DeviceEventTypeEXT value) { this->deviceEvent = std::bit_cast<VkDeviceEventTypeEXT>(value); }
  DeviceEventTypeEXT getDeviceEvent() const { return std::bit_cast<DeviceEventTypeEXT>(this->deviceEvent); }
};

struct DisplayEventInfoEXT : VkDisplayEventInfoEXT {
  DisplayEventInfoEXT() noexcept : VkDisplayEventInfoEXT{.sType = VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT} {}

  void setDisplayEvent(DisplayEventTypeEXT value) { this->displayEvent = std::bit_cast<VkDisplayEventTypeEXT>(value); }
  DisplayEventTypeEXT getDisplayEvent() const { return std::bit_cast<DisplayEventTypeEXT>(this->displayEvent); }
};
#endif // VK_EXT_display_control

#if VK_VERSION_1_1
using PeerMemoryFeatureFlags = FlagSet<PeerMemoryFeatureFlagBits, Flags>;
constexpr PeerMemoryFeatureFlags operator|(PeerMemoryFeatureFlagBits a, PeerMemoryFeatureFlagBits b) noexcept { return PeerMemoryFeatureFlags(Flags(a) | Flags(b)); }
#endif // VK_VERSION_1_1

#if VK_KHR_device_group
using PeerMemoryFeatureFlagBitsKHR = PeerMemoryFeatureFlagBits;
#endif // VK_KHR_device_group

#if VK_VERSION_1_1
using MemoryAllocateFlags = FlagSet<MemoryAllocateFlagBits, Flags>;
constexpr MemoryAllocateFlags operator|(MemoryAllocateFlagBits a, MemoryAllocateFlagBits b) noexcept { return MemoryAllocateFlags(Flags(a) | Flags(b)); }
#endif // VK_VERSION_1_1

#if VK_KHR_device_group
using MemoryAllocateFlagBitsKHR = MemoryAllocateFlagBits;
#endif // VK_KHR_device_group

#if VK_KHR_swapchain
using DeviceGroupPresentModeFlagsKHR = FlagSet<DeviceGroupPresentModeFlagBitsKHR, Flags>;
constexpr DeviceGroupPresentModeFlagsKHR operator|(DeviceGroupPresentModeFlagBitsKHR a, DeviceGroupPresentModeFlagBitsKHR b) noexcept { return DeviceGroupPresentModeFlagsKHR(Flags(a) | Flags(b)); }

using SwapchainCreateFlagsKHR = FlagSet<SwapchainCreateFlagBitsKHR, Flags>;
constexpr SwapchainCreateFlagsKHR operator|(SwapchainCreateFlagBitsKHR a, SwapchainCreateFlagBitsKHR b) noexcept { return SwapchainCreateFlagsKHR(Flags(a) | Flags(b)); }
#endif // VK_KHR_swapchain

#if VK_NV_viewport_swizzle
struct ViewportSwizzleNV : VkViewportSwizzleNV {
  ViewportSwizzleNV() noexcept : VkViewportSwizzleNV{} {}
  ViewportSwizzleNV(ViewportCoordinateSwizzleNV x, ViewportCoordinateSwizzleNV y, ViewportCoordinateSwizzleNV z, ViewportCoordinateSwizzleNV w) noexcept : VkViewportSwizzleNV{.x = std::bit_cast<VkViewportCoordinateSwizzleNV>(x), .y = std::bit_cast<VkViewportCoordinateSwizzleNV>(y), .z = std::bit_cast<VkViewportCoordinateSwizzleNV>(z), .w = std::bit_cast<VkViewportCoordinateSwizzleNV>(w)} {}

  void setX(ViewportCoordinateSwizzleNV value) { this->x = std::bit_cast<VkViewportCoordinateSwizzleNV>(value); }
  ViewportCoordinateSwizzleNV getX() const { return std::bit_cast<ViewportCoordinateSwizzleNV>(this->x); }
  void setY(ViewportCoordinateSwizzleNV value) { this->y = std::bit_cast<VkViewportCoordinateSwizzleNV>(value); }
  ViewportCoordinateSwizzleNV getY() const { return std::bit_cast<ViewportCoordinateSwizzleNV>(this->y); }
  void setZ(ViewportCoordinateSwizzleNV value) { this->z = std::bit_cast<VkViewportCoordinateSwizzleNV>(value); }
  ViewportCoordinateSwizzleNV getZ() const { return std::bit_cast<ViewportCoordinateSwizzleNV>(this->z); }
  void setW(ViewportCoordinateSwizzleNV value) { this->w = std::bit_cast<VkViewportCoordinateSwizzleNV>(value); }
  ViewportCoordinateSwizzleNV getW() const { return std::bit_cast<ViewportCoordinateSwizzleNV>(this->w); }
};
#endif // VK_NV_viewport_swizzle

#if VK_VERSION_1_0
using SubpassDescriptionFlags = FlagSet<SubpassDescriptionFlagBits, Flags>;
constexpr SubpassDescriptionFlags operator|(SubpassDescriptionFlagBits a, SubpassDescriptionFlagBits b) noexcept { return SubpassDescriptionFlags(Flags(a) | Flags(b)); }
#endif // VK_VERSION_1_0

#if VK_KHR_maintenance2
using PointClippingBehaviorKHR = PointClippingBehavior;
#endif // VK_KHR_maintenance2
#if VK_EXT_sampler_filter_minmax
using SamplerReductionModeEXT = SamplerReductionMode;
#endif // VK_EXT_sampler_filter_minmax
#if VK_KHR_maintenance2
using TessellationDomainOriginKHR = TessellationDomainOrigin;
#endif // VK_KHR_maintenance2
#if VK_KHR_sampler_ycbcr_conversion
using SamplerYcbcrModelConversionKHR = SamplerYcbcrModelConversion;
using SamplerYcbcrRangeKHR = SamplerYcbcrRange;
using ChromaLocationKHR = ChromaLocation;
#endif // VK_KHR_sampler_ycbcr_conversion

#if VK_EXT_extended_dynamic_state3
struct ColorBlendAdvancedEXT : VkColorBlendAdvancedEXT {
  ColorBlendAdvancedEXT() noexcept : VkColorBlendAdvancedEXT{} {}

  void setAdvancedBlendOp(BlendOp value) { this->advancedBlendOp = std::bit_cast<VkBlendOp>(value); }
  BlendOp getAdvancedBlendOp() const { return std::bit_cast<BlendOp>(this->advancedBlendOp); }
  void setBlendOverlap(BlendOverlapEXT value) { this->blendOverlap = std::bit_cast<VkBlendOverlapEXT>(value); }
  BlendOverlapEXT getBlendOverlap() const { return std::bit_cast<BlendOverlapEXT>(this->blendOverlap); }

  void setSrcPremultiplied(Bool32 value) { this->srcPremultiplied = value; }
  Bool32 getSrcPremultiplied() const { return this->srcPremultiplied; }
  void setDstPremultiplied(Bool32 value) { this->dstPremultiplied = value; }
  Bool32 getDstPremultiplied() const { return this->dstPremultiplied; }
  void setClampResults(Bool32 value) { this->clampResults = value; }
  Bool32 getClampResults() const { return this->clampResults; }
};
#endif // VK_EXT_extended_dynamic_state3

#if VK_KHR_global_priority
using QueueGlobalPriorityKHR = QueueGlobalPriority;
#endif // VK_KHR_global_priority
#if VK_EXT_global_priority
using QueueGlobalPriorityEXT = QueueGlobalPriority;
#endif // VK_EXT_global_priority

#if VK_EXT_debug_utils
using DebugUtilsMessageSeverityFlagsEXT = FlagSet<DebugUtilsMessageSeverityFlagBitsEXT, Flags>;
constexpr DebugUtilsMessageSeverityFlagsEXT operator|(DebugUtilsMessageSeverityFlagBitsEXT a, DebugUtilsMessageSeverityFlagBitsEXT b) noexcept { return DebugUtilsMessageSeverityFlagsEXT(Flags(a) | Flags(b)); }

using DebugUtilsMessageTypeFlagsEXT = FlagSet<DebugUtilsMessageTypeFlagBitsEXT, Flags>;
constexpr DebugUtilsMessageTypeFlagsEXT operator|(DebugUtilsMessageTypeFlagBitsEXT a, DebugUtilsMessageTypeFlagBitsEXT b) noexcept { return DebugUtilsMessageTypeFlagsEXT(Flags(a) | Flags(b)); }
#endif // VK_EXT_debug_utils

#if VK_VERSION_1_2
using DescriptorBindingFlags = FlagSet<DescriptorBindingFlagBits, Flags>;
constexpr DescriptorBindingFlags operator|(DescriptorBindingFlagBits a, DescriptorBindingFlagBits b) noexcept { return DescriptorBindingFlags(Flags(a) | Flags(b)); }
#endif // VK_VERSION_1_2

#if VK_EXT_descriptor_indexing
using DescriptorBindingFlagBitsEXT = DescriptorBindingFlagBits;
#endif // VK_EXT_descriptor_indexing
#if VK_KHR_driver_properties
using DriverIdKHR = DriverId;
#endif // VK_KHR_driver_properties

#if VK_EXT_conditional_rendering
using ConditionalRenderingFlagsEXT = FlagSet<ConditionalRenderingFlagBitsEXT, Flags>;
constexpr ConditionalRenderingFlagsEXT operator|(ConditionalRenderingFlagBitsEXT a, ConditionalRenderingFlagBitsEXT b) noexcept { return ConditionalRenderingFlagsEXT(Flags(a) | Flags(b)); }
#endif // VK_EXT_conditional_rendering

#if VK_VERSION_1_2
using ResolveModeFlags = FlagSet<ResolveModeFlagBits, Flags>;
constexpr ResolveModeFlags operator|(ResolveModeFlagBits a, ResolveModeFlagBits b) noexcept { return ResolveModeFlags(Flags(a) | Flags(b)); }
#endif // VK_VERSION_1_2

#if VK_KHR_depth_stencil_resolve
using ResolveModeFlagBitsKHR = ResolveModeFlagBits;
#endif // VK_KHR_depth_stencil_resolve

#if VK_NV_shading_rate_image
struct ShadingRatePaletteNV : VkShadingRatePaletteNV {
  ShadingRatePaletteNV() noexcept : VkShadingRatePaletteNV{} {}
  ShadingRatePaletteNV(uint32_t shadingRatePaletteEntryCount, const ShadingRatePaletteEntryNV* pShadingRatePaletteEntries) noexcept : VkShadingRatePaletteNV{.shadingRatePaletteEntryCount = shadingRatePaletteEntryCount, .pShadingRatePaletteEntries = std::bit_cast<const VkShadingRatePaletteEntryNV*>(pShadingRatePaletteEntries)} {}

  void setShadingRatePaletteEntryCount(uint32_t value) { this->shadingRatePaletteEntryCount = value; }
  uint32_t getShadingRatePaletteEntryCount() const { return this->shadingRatePaletteEntryCount; }
  void setShadingRatePaletteEntries(const ShadingRatePaletteEntryNV* value) { this->pShadingRatePaletteEntries = std::bit_cast<const VkShadingRatePaletteEntryNV*>(value); }
  const ShadingRatePaletteEntryNV* getShadingRatePaletteEntries() const { return std::bit_cast<const ShadingRatePaletteEntryNV*>(this->pShadingRatePaletteEntries); }
};

struct CoarseSampleOrderCustomNV : VkCoarseSampleOrderCustomNV {
  CoarseSampleOrderCustomNV() noexcept : VkCoarseSampleOrderCustomNV{} {}
  CoarseSampleOrderCustomNV(ShadingRatePaletteEntryNV shadingRate, uint32_t sampleCount, uint32_t sampleLocationCount, const CoarseSampleLocationNV* pSampleLocations) noexcept : VkCoarseSampleOrderCustomNV{.shadingRate = std::bit_cast<VkShadingRatePaletteEntryNV>(shadingRate), .sampleCount = sampleCount, .sampleLocationCount = sampleLocationCount, .pSampleLocations = std::bit_cast<const VkCoarseSampleLocationNV*>(pSampleLocations)} {}

  void setShadingRate(ShadingRatePaletteEntryNV value) { this->shadingRate = std::bit_cast<VkShadingRatePaletteEntryNV>(value); }
  ShadingRatePaletteEntryNV getShadingRate() const { return std::bit_cast<ShadingRatePaletteEntryNV>(this->shadingRate); }
  void setSampleCount(uint32_t value) { this->sampleCount = value; }
  uint32_t getSampleCount() const { return this->sampleCount; }
  void setSampleLocationCount(uint32_t value) { this->sampleLocationCount = value; }
  uint32_t getSampleLocationCount() const { return this->sampleLocationCount; }
  void setSampleLocations(const CoarseSampleLocationNV* value) { this->pSampleLocations = std::bit_cast<const VkCoarseSampleLocationNV*>(value); }
  const CoarseSampleLocationNV* getSampleLocations() const { return std::bit_cast<const CoarseSampleLocationNV*>(this->pSampleLocations); }
};
#endif // VK_NV_shading_rate_image

#if VK_KHR_acceleration_structure
using GeometryInstanceFlagsKHR = FlagSet<GeometryInstanceFlagBitsKHR, Flags>;
constexpr GeometryInstanceFlagsKHR operator|(GeometryInstanceFlagBitsKHR a, GeometryInstanceFlagBitsKHR b) noexcept { return GeometryInstanceFlagsKHR(Flags(a) | Flags(b)); }

using GeometryFlagsKHR = FlagSet<GeometryFlagBitsKHR, Flags>;
constexpr GeometryFlagsKHR operator|(GeometryFlagBitsKHR a, GeometryFlagBitsKHR b) noexcept { return GeometryFlagsKHR(Flags(a) | Flags(b)); }

using BuildAccelerationStructureFlagsKHR = FlagSet<BuildAccelerationStructureFlagBitsKHR, Flags>;
constexpr BuildAccelerationStructureFlagsKHR operator|(BuildAccelerationStructureFlagBitsKHR a, BuildAccelerationStructureFlagBitsKHR b) noexcept { return BuildAccelerationStructureFlagsKHR(Flags(a) | Flags(b)); }

using AccelerationStructureCreateFlagsKHR = FlagSet<AccelerationStructureCreateFlagBitsKHR, Flags>;
constexpr AccelerationStructureCreateFlagsKHR operator|(AccelerationStructureCreateFlagBitsKHR a, AccelerationStructureCreateFlagBitsKHR b) noexcept { return AccelerationStructureCreateFlagsKHR(Flags(a) | Flags(b)); }
#endif // VK_KHR_acceleration_structure

#if VK_KHR_ray_tracing_pipeline
struct RayTracingShaderGroupCreateInfoKHR : VkRayTracingShaderGroupCreateInfoKHR {
  RayTracingShaderGroupCreateInfoKHR() noexcept : VkRayTracingShaderGroupCreateInfoKHR{.sType = VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR} {}

  void setType(RayTracingShaderGroupTypeKHR value) { this->type = std::bit_cast<VkRayTracingShaderGroupTypeKHR>(value); }
  RayTracingShaderGroupTypeKHR getType() const { return std::bit_cast<RayTracingShaderGroupTypeKHR>(this->type); }
  void setGeneralShader(uint32_t value) { this->generalShader = value; }
  uint32_t getGeneralShader() const { return this->generalShader; }
  void setClosestHitShader(uint32_t value) { this->closestHitShader = value; }
  uint32_t getClosestHitShader() const { return this->closestHitShader; }
  void setAnyHitShader(uint32_t value) { this->anyHitShader = value; }
  uint32_t getAnyHitShader() const { return this->anyHitShader; }
  void setIntersectionShader(uint32_t value) { this->intersectionShader = value; }
  uint32_t getIntersectionShader() const { return this->intersectionShader; }

  void setShaderGroupCaptureReplayHandle(const void* value) { this->pShaderGroupCaptureReplayHandle = value; }
  const void* getShaderGroupCaptureReplayHandle() const { return this->pShaderGroupCaptureReplayHandle; }
};
#endif // VK_KHR_ray_tracing_pipeline

#if VK_VERSION_1_0
using FramebufferCreateFlags = FlagSet<FramebufferCreateFlagBits, Flags>;
constexpr FramebufferCreateFlags operator|(FramebufferCreateFlagBits a, FramebufferCreateFlagBits b) noexcept { return FramebufferCreateFlags(Flags(a) | Flags(b)); }

using QueryPoolCreateFlags = FlagSet<QueryPoolCreateFlagBits, Flags>;
constexpr QueryPoolCreateFlags operator|(QueryPoolCreateFlagBits a, QueryPoolCreateFlagBits b) noexcept { return QueryPoolCreateFlags(Flags(a) | Flags(b)); }
#endif // VK_VERSION_1_0

#if VK_NV_device_diagnostics_config
using DeviceDiagnosticsConfigFlagsNV = FlagSet<DeviceDiagnosticsConfigFlagBitsNV, Flags>;
constexpr DeviceDiagnosticsConfigFlagsNV operator|(DeviceDiagnosticsConfigFlagBitsNV a, DeviceDiagnosticsConfigFlagBitsNV b) noexcept { return DeviceDiagnosticsConfigFlagsNV(Flags(a) | Flags(b)); }
#endif // VK_NV_device_diagnostics_config

#if VK_VERSION_1_3
using PipelineCreationFeedbackFlags = FlagSet<PipelineCreationFeedbackFlagBits, Flags>;
constexpr PipelineCreationFeedbackFlags operator|(PipelineCreationFeedbackFlagBits a, PipelineCreationFeedbackFlagBits b) noexcept { return PipelineCreationFeedbackFlags(Flags(a) | Flags(b)); }
#endif // VK_VERSION_1_3

#if VK_EXT_pipeline_creation_feedback
using PipelineCreationFeedbackFlagBitsEXT = PipelineCreationFeedbackFlagBits;
#endif // VK_EXT_pipeline_creation_feedback

#if VK_NV_memory_decompression
using MemoryDecompressionMethodFlagsNV = FlagSet<MemoryDecompressionMethodFlagBitsNV, Flags64>;
constexpr MemoryDecompressionMethodFlagsNV operator|(MemoryDecompressionMethodFlagBitsNV a, MemoryDecompressionMethodFlagBitsNV b) noexcept { return MemoryDecompressionMethodFlagsNV(Flags64(a) | Flags64(b)); }
#endif // VK_NV_memory_decompression

#if VK_KHR_performance_query
struct PerformanceCounterKHR : VkPerformanceCounterKHR {
  PerformanceCounterKHR() noexcept : VkPerformanceCounterKHR{.sType = VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR} {}

  PerformanceCounterUnitKHR getUnit() const { return std::bit_cast<PerformanceCounterUnitKHR>(this->unit); }
  PerformanceCounterScopeKHR getScope() const { return std::bit_cast<PerformanceCounterScopeKHR>(this->scope); }
  PerformanceCounterStorageKHR getStorage() const { return std::bit_cast<PerformanceCounterStorageKHR>(this->storage); }
  std::span<const uint8_t, VK_UUID_SIZE> getUuid() const { return this->uuid; }
};

using PerformanceCounterDescriptionFlagsKHR = FlagSet<PerformanceCounterDescriptionFlagBitsKHR, Flags>;
constexpr PerformanceCounterDescriptionFlagsKHR operator|(PerformanceCounterDescriptionFlagBitsKHR a, PerformanceCounterDescriptionFlagBitsKHR b) noexcept { return PerformanceCounterDescriptionFlagsKHR(Flags(a) | Flags(b)); }

using AcquireProfilingLockFlagsKHR = FlagSet<AcquireProfilingLockFlagBitsKHR, Flags>;
constexpr AcquireProfilingLockFlagsKHR operator|(AcquireProfilingLockFlagBitsKHR a, AcquireProfilingLockFlagBitsKHR b) noexcept { return AcquireProfilingLockFlagsKHR(Flags(a) | Flags(b)); }
#endif // VK_KHR_performance_query

#if VK_AMD_shader_core_properties2
using ShaderCorePropertiesFlagsAMD = FlagSet<ShaderCorePropertiesFlagBitsAMD, Flags>;
constexpr ShaderCorePropertiesFlagsAMD operator|(ShaderCorePropertiesFlagBitsAMD a, ShaderCorePropertiesFlagBitsAMD b) noexcept { return ShaderCorePropertiesFlagsAMD(Flags(a) | Flags(b)); }
#endif // VK_AMD_shader_core_properties2

#if VK_INTEL_performance_query
struct PerformanceConfigurationAcquireInfoINTEL : VkPerformanceConfigurationAcquireInfoINTEL {
  PerformanceConfigurationAcquireInfoINTEL() noexcept : VkPerformanceConfigurationAcquireInfoINTEL{.sType = VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL} {}

  void setType(PerformanceConfigurationTypeINTEL value) { this->type = std::bit_cast<VkPerformanceConfigurationTypeINTEL>(value); }
  PerformanceConfigurationTypeINTEL getType() const { return std::bit_cast<PerformanceConfigurationTypeINTEL>(this->type); }
};

struct PerformanceOverrideInfoINTEL : VkPerformanceOverrideInfoINTEL {
  PerformanceOverrideInfoINTEL() noexcept : VkPerformanceOverrideInfoINTEL{.sType = VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL} {}

  void setType(PerformanceOverrideTypeINTEL value) { this->type = std::bit_cast<VkPerformanceOverrideTypeINTEL>(value); }
  PerformanceOverrideTypeINTEL getType() const { return std::bit_cast<PerformanceOverrideTypeINTEL>(this->type); }
  void setParameter(uint64_t value) { this->parameter = value; }
  uint64_t getParameter() const { return this->parameter; }

  void setEnable(Bool32 value) { this->enable = value; }
  Bool32 getEnable() const { return this->enable; }
};

struct PerformanceValueINTEL : VkPerformanceValueINTEL {
  PerformanceValueINTEL() noexcept : VkPerformanceValueINTEL{} {}

  PerformanceValueTypeINTEL getType() const { return std::bit_cast<PerformanceValueTypeINTEL>(this->type); }
  PerformanceValueDataINTEL getData() const { return this->data; }
};
#endif // VK_INTEL_performance_query

#if VK_KHR_shader_float_controls
using ShaderFloatControlsIndependenceKHR = ShaderFloatControlsIndependence;
#endif // VK_KHR_shader_float_controls

#if VK_KHR_pipeline_executable_properties
struct PipelineExecutableStatisticKHR : VkPipelineExecutableStatisticKHR {
  PipelineExecutableStatisticKHR() noexcept : VkPipelineExecutableStatisticKHR{.sType = VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR} {}

  std::string_view getName() const { return this->name; }
  std::string_view getDescription() const { return this->description; }
  PipelineExecutableStatisticFormatKHR getFormat() const { return std::bit_cast<PipelineExecutableStatisticFormatKHR>(this->format); }
  PipelineExecutableStatisticValueKHR getValue() const { return this->value; }
};
#endif // VK_KHR_pipeline_executable_properties

#if VK_KHR_line_rasterization
using LineRasterizationModeKHR = LineRasterizationMode;
#endif // VK_KHR_line_rasterization
#if VK_EXT_line_rasterization
using LineRasterizationModeEXT = LineRasterizationMode;
#endif // VK_EXT_line_rasterization

#if VK_AMD_pipeline_compiler_control
using PipelineCompilerControlFlagsAMD = FlagSet<PipelineCompilerControlFlagBitsAMD, Flags>;
constexpr PipelineCompilerControlFlagsAMD operator|(PipelineCompilerControlFlagBitsAMD a, PipelineCompilerControlFlagBitsAMD b) noexcept { return PipelineCompilerControlFlagsAMD(Flags(a) | Flags(b)); }
#endif // VK_AMD_pipeline_compiler_control

#if VK_VERSION_1_3
using ToolPurposeFlags = FlagSet<ToolPurposeFlagBits, Flags>;
constexpr ToolPurposeFlags operator|(ToolPurposeFlagBits a, ToolPurposeFlagBits b) noexcept { return ToolPurposeFlags(Flags(a) | Flags(b)); }
#endif // VK_VERSION_1_3

#if VK_EXT_tooling_info
using ToolPurposeFlagBitsEXT = ToolPurposeFlagBits;
#endif // VK_EXT_tooling_info

#if VK_EXT_subpass_merge_feedback
struct RenderPassSubpassFeedbackInfoEXT : VkRenderPassSubpassFeedbackInfoEXT {
  RenderPassSubpassFeedbackInfoEXT() noexcept : VkRenderPassSubpassFeedbackInfoEXT{} {}

  SubpassMergeStatusEXT getSubpassMergeStatus() const { return std::bit_cast<SubpassMergeStatusEXT>(this->subpassMergeStatus); }
  std::string_view getDescription() const { return this->description; }
  uint32_t getPostMergeIndex() const { return this->postMergeIndex; }
};
#endif // VK_EXT_subpass_merge_feedback

#if VK_VERSION_1_3
using AccessFlags2 = FlagSet<AccessFlagBits2, Flags64>;
constexpr AccessFlags2 operator|(AccessFlagBits2 a, AccessFlagBits2 b) noexcept { return AccessFlags2(Flags64(a) | Flags64(b)); }
#endif // VK_VERSION_1_3

#if VK_KHR_synchronization2
using AccessFlagBits2KHR = AccessFlagBits2;
#endif // VK_KHR_synchronization2

#if VK_VERSION_1_3
using PipelineStageFlags2 = FlagSet<PipelineStageFlagBits2, Flags64>;
constexpr PipelineStageFlags2 operator|(PipelineStageFlagBits2 a, PipelineStageFlagBits2 b) noexcept { return PipelineStageFlags2(Flags64(a) | Flags64(b)); }
#endif // VK_VERSION_1_3

#if VK_KHR_synchronization2
using PipelineStageFlagBits2KHR = PipelineStageFlagBits2;
#endif // VK_KHR_synchronization2

#if VK_VERSION_1_3
using SubmitFlags = FlagSet<SubmitFlagBits, Flags>;
constexpr SubmitFlags operator|(SubmitFlagBits a, SubmitFlagBits b) noexcept { return SubmitFlags(Flags(a) | Flags(b)); }
#endif // VK_VERSION_1_3

#if VK_KHR_synchronization2
using SubmitFlagBitsKHR = SubmitFlagBits;
#endif // VK_KHR_synchronization2

#if VK_VERSION_1_0
using EventCreateFlags = FlagSet<EventCreateFlagBits, Flags>;
constexpr EventCreateFlags operator|(EventCreateFlagBits a, EventCreateFlagBits b) noexcept { return EventCreateFlags(Flags(a) | Flags(b)); }

using PipelineLayoutCreateFlags = FlagSet<PipelineLayoutCreateFlagBits, Flags>;
constexpr PipelineLayoutCreateFlags operator|(PipelineLayoutCreateFlagBits a, PipelineLayoutCreateFlagBits b) noexcept { return PipelineLayoutCreateFlags(Flags(a) | Flags(b)); }
#endif // VK_VERSION_1_0

#if VK_NV_ray_tracing_motion_blur
struct AccelerationStructureMotionInstanceNV : VkAccelerationStructureMotionInstanceNV {
  AccelerationStructureMotionInstanceNV() noexcept : VkAccelerationStructureMotionInstanceNV{} {}

  void setType(AccelerationStructureMotionInstanceTypeNV value) { this->type = std::bit_cast<VkAccelerationStructureMotionInstanceTypeNV>(value); }
  AccelerationStructureMotionInstanceTypeNV getType() const { return std::bit_cast<AccelerationStructureMotionInstanceTypeNV>(this->type); }
  void setData(AccelerationStructureMotionInstanceDataNV value) { this->data = value; }
  AccelerationStructureMotionInstanceDataNV getData() const { return this->data; }

  void setFlags(AccelerationStructureMotionInstanceFlagsNV value) { this->flags = std::bit_cast<VkAccelerationStructureMotionInstanceFlagsNV>(value); }
  AccelerationStructureMotionInstanceFlagsNV getFlags() const { return std::bit_cast<AccelerationStructureMotionInstanceFlagsNV>(this->flags); }
};
#endif // VK_NV_ray_tracing_motion_blur

#if VK_VERSION_1_0
using PipelineColorBlendStateCreateFlags = FlagSet<PipelineColorBlendStateCreateFlagBits, Flags>;
constexpr PipelineColorBlendStateCreateFlags operator|(PipelineColorBlendStateCreateFlagBits a, PipelineColorBlendStateCreateFlagBits b) noexcept { return PipelineColorBlendStateCreateFlags(Flags(a) | Flags(b)); }

using PipelineDepthStencilStateCreateFlags = FlagSet<PipelineDepthStencilStateCreateFlagBits, Flags>;
constexpr PipelineDepthStencilStateCreateFlags operator|(PipelineDepthStencilStateCreateFlagBits a, PipelineDepthStencilStateCreateFlagBits b) noexcept { return PipelineDepthStencilStateCreateFlags(Flags(a) | Flags(b)); }
#endif // VK_VERSION_1_0

#if VK_EXT_graphics_pipeline_library
using GraphicsPipelineLibraryFlagsEXT = FlagSet<GraphicsPipelineLibraryFlagBitsEXT, Flags>;
constexpr GraphicsPipelineLibraryFlagsEXT operator|(GraphicsPipelineLibraryFlagBitsEXT a, GraphicsPipelineLibraryFlagBitsEXT b) noexcept { return GraphicsPipelineLibraryFlagsEXT(Flags(a) | Flags(b)); }
#endif // VK_EXT_graphics_pipeline_library

#if VK_EXT_device_address_binding_report
using DeviceAddressBindingFlagsEXT = FlagSet<DeviceAddressBindingFlagBitsEXT, Flags>;
constexpr DeviceAddressBindingFlagsEXT operator|(DeviceAddressBindingFlagBitsEXT a, DeviceAddressBindingFlagBitsEXT b) noexcept { return DeviceAddressBindingFlagsEXT(Flags(a) | Flags(b)); }
#endif // VK_EXT_device_address_binding_report

#if VK_EXT_frame_boundary
using FrameBoundaryFlagsEXT = FlagSet<FrameBoundaryFlagBitsEXT, Flags>;
constexpr FrameBoundaryFlagsEXT operator|(FrameBoundaryFlagBitsEXT a, FrameBoundaryFlagBitsEXT b) noexcept { return FrameBoundaryFlagsEXT(Flags(a) | Flags(b)); }
#endif // VK_EXT_frame_boundary

#if VK_KHR_surface_maintenance1
using PresentScalingFlagsKHR = FlagSet<PresentScalingFlagBitsKHR, Flags>;
constexpr PresentScalingFlagsKHR operator|(PresentScalingFlagBitsKHR a, PresentScalingFlagBitsKHR b) noexcept { return PresentScalingFlagsKHR(Flags(a) | Flags(b)); }
#endif // VK_KHR_surface_maintenance1

#if VK_EXT_surface_maintenance1
using PresentScalingFlagBitsEXT = PresentScalingFlagBitsKHR;
#endif // VK_EXT_surface_maintenance1

#if VK_KHR_surface_maintenance1
using PresentGravityFlagsKHR = FlagSet<PresentGravityFlagBitsKHR, Flags>;
constexpr PresentGravityFlagsKHR operator|(PresentGravityFlagBitsKHR a, PresentGravityFlagBitsKHR b) noexcept { return PresentGravityFlagsKHR(Flags(a) | Flags(b)); }
#endif // VK_KHR_surface_maintenance1

#if VK_EXT_surface_maintenance1
using PresentGravityFlagBitsEXT = PresentGravityFlagBitsKHR;
#endif // VK_EXT_surface_maintenance1

#if VK_ARM_scheduling_controls
using PhysicalDeviceSchedulingControlsFlagsARM = FlagSet<PhysicalDeviceSchedulingControlsFlagBitsARM, Flags64>;
constexpr PhysicalDeviceSchedulingControlsFlagsARM operator|(PhysicalDeviceSchedulingControlsFlagBitsARM a, PhysicalDeviceSchedulingControlsFlagBitsARM b) noexcept { return PhysicalDeviceSchedulingControlsFlagsARM(Flags64(a) | Flags64(b)); }
#endif // VK_ARM_scheduling_controls

#if VK_KHR_video_queue
using VideoCodecOperationFlagsKHR = FlagSet<VideoCodecOperationFlagBitsKHR, Flags>;
constexpr VideoCodecOperationFlagsKHR operator|(VideoCodecOperationFlagBitsKHR a, VideoCodecOperationFlagBitsKHR b) noexcept { return VideoCodecOperationFlagsKHR(Flags(a) | Flags(b)); }

using VideoChromaSubsamplingFlagsKHR = FlagSet<VideoChromaSubsamplingFlagBitsKHR, Flags>;
constexpr VideoChromaSubsamplingFlagsKHR operator|(VideoChromaSubsamplingFlagBitsKHR a, VideoChromaSubsamplingFlagBitsKHR b) noexcept { return VideoChromaSubsamplingFlagsKHR(Flags(a) | Flags(b)); }

using VideoComponentBitDepthFlagsKHR = FlagSet<VideoComponentBitDepthFlagBitsKHR, Flags>;
constexpr VideoComponentBitDepthFlagsKHR operator|(VideoComponentBitDepthFlagBitsKHR a, VideoComponentBitDepthFlagBitsKHR b) noexcept { return VideoComponentBitDepthFlagsKHR(Flags(a) | Flags(b)); }

using VideoCapabilityFlagsKHR = FlagSet<VideoCapabilityFlagBitsKHR, Flags>;
constexpr VideoCapabilityFlagsKHR operator|(VideoCapabilityFlagBitsKHR a, VideoCapabilityFlagBitsKHR b) noexcept { return VideoCapabilityFlagsKHR(Flags(a) | Flags(b)); }

using VideoSessionCreateFlagsKHR = FlagSet<VideoSessionCreateFlagBitsKHR, Flags>;
constexpr VideoSessionCreateFlagsKHR operator|(VideoSessionCreateFlagBitsKHR a, VideoSessionCreateFlagBitsKHR b) noexcept { return VideoSessionCreateFlagsKHR(Flags(a) | Flags(b)); }

using VideoSessionParametersCreateFlagsKHR = FlagSet<VideoSessionParametersCreateFlagBitsKHR, Flags>;
constexpr VideoSessionParametersCreateFlagsKHR operator|(VideoSessionParametersCreateFlagBitsKHR a, VideoSessionParametersCreateFlagBitsKHR b) noexcept { return VideoSessionParametersCreateFlagsKHR(Flags(a) | Flags(b)); }
#endif // VK_KHR_video_queue

#if VK_KHR_video_decode_h264
using VideoDecodeH264PictureLayoutFlagsKHR = FlagSet<VideoDecodeH264PictureLayoutFlagBitsKHR, Flags>;
constexpr VideoDecodeH264PictureLayoutFlagsKHR operator|(VideoDecodeH264PictureLayoutFlagBitsKHR a, VideoDecodeH264PictureLayoutFlagBitsKHR b) noexcept { return VideoDecodeH264PictureLayoutFlagsKHR(Flags(a) | Flags(b)); }
#endif // VK_KHR_video_decode_h264

#if VK_KHR_video_queue
using VideoCodingControlFlagsKHR = FlagSet<VideoCodingControlFlagBitsKHR, Flags>;
constexpr VideoCodingControlFlagsKHR operator|(VideoCodingControlFlagBitsKHR a, VideoCodingControlFlagBitsKHR b) noexcept { return VideoCodingControlFlagsKHR(Flags(a) | Flags(b)); }
#endif // VK_KHR_video_queue

#if VK_KHR_video_decode_queue
using VideoDecodeUsageFlagsKHR = FlagSet<VideoDecodeUsageFlagBitsKHR, Flags>;
constexpr VideoDecodeUsageFlagsKHR operator|(VideoDecodeUsageFlagBitsKHR a, VideoDecodeUsageFlagBitsKHR b) noexcept { return VideoDecodeUsageFlagsKHR(Flags(a) | Flags(b)); }

using VideoDecodeCapabilityFlagsKHR = FlagSet<VideoDecodeCapabilityFlagBitsKHR, Flags>;
constexpr VideoDecodeCapabilityFlagsKHR operator|(VideoDecodeCapabilityFlagBitsKHR a, VideoDecodeCapabilityFlagBitsKHR b) noexcept { return VideoDecodeCapabilityFlagsKHR(Flags(a) | Flags(b)); }
#endif // VK_KHR_video_decode_queue

#if VK_KHR_video_encode_queue
using VideoEncodeFlagsKHR = FlagSet<VideoEncodeFlagBitsKHR, Flags>;
constexpr VideoEncodeFlagsKHR operator|(VideoEncodeFlagBitsKHR a, VideoEncodeFlagBitsKHR b) noexcept { return VideoEncodeFlagsKHR(Flags(a) | Flags(b)); }

using VideoEncodeUsageFlagsKHR = FlagSet<VideoEncodeUsageFlagBitsKHR, Flags>;
constexpr VideoEncodeUsageFlagsKHR operator|(VideoEncodeUsageFlagBitsKHR a, VideoEncodeUsageFlagBitsKHR b) noexcept { return VideoEncodeUsageFlagsKHR(Flags(a) | Flags(b)); }

using VideoEncodeContentFlagsKHR = FlagSet<VideoEncodeContentFlagBitsKHR, Flags>;
constexpr VideoEncodeContentFlagsKHR operator|(VideoEncodeContentFlagBitsKHR a, VideoEncodeContentFlagBitsKHR b) noexcept { return VideoEncodeContentFlagsKHR(Flags(a) | Flags(b)); }

using VideoEncodeCapabilityFlagsKHR = FlagSet<VideoEncodeCapabilityFlagBitsKHR, Flags>;
constexpr VideoEncodeCapabilityFlagsKHR operator|(VideoEncodeCapabilityFlagBitsKHR a, VideoEncodeCapabilityFlagBitsKHR b) noexcept { return VideoEncodeCapabilityFlagsKHR(Flags(a) | Flags(b)); }

using VideoEncodeFeedbackFlagsKHR = FlagSet<VideoEncodeFeedbackFlagBitsKHR, Flags>;
constexpr VideoEncodeFeedbackFlagsKHR operator|(VideoEncodeFeedbackFlagBitsKHR a, VideoEncodeFeedbackFlagBitsKHR b) noexcept { return VideoEncodeFeedbackFlagsKHR(Flags(a) | Flags(b)); }

struct VideoEncodeQualityLevelPropertiesKHR : VkVideoEncodeQualityLevelPropertiesKHR {
  VideoEncodeQualityLevelPropertiesKHR() noexcept : VkVideoEncodeQualityLevelPropertiesKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_PROPERTIES_KHR} {}

  VideoEncodeRateControlModeFlagBitsKHR getPreferredRateControlMode() const { return std::bit_cast<VideoEncodeRateControlModeFlagBitsKHR>(this->preferredRateControlMode); }
  uint32_t getPreferredRateControlLayerCount() const { return this->preferredRateControlLayerCount; }

  void attach(struct VideoEncodeH264QualityLevelPropertiesKHR&);
  void attach(struct VideoEncodeH265QualityLevelPropertiesKHR&);
#if VK_KHR_video_encode_av1
  void attach(struct VideoEncodeAV1QualityLevelPropertiesKHR&);
#endif // VK_KHR_video_encode_av1
};

using VideoEncodeRateControlModeFlagsKHR = FlagSet<VideoEncodeRateControlModeFlagBitsKHR, Flags>;
constexpr VideoEncodeRateControlModeFlagsKHR operator|(VideoEncodeRateControlModeFlagBitsKHR a, VideoEncodeRateControlModeFlagBitsKHR b) noexcept { return VideoEncodeRateControlModeFlagsKHR(Flags(a) | Flags(b)); }
#endif // VK_KHR_video_encode_queue

#if VK_KHR_video_encode_intra_refresh
using VideoEncodeIntraRefreshModeFlagsKHR = FlagSet<VideoEncodeIntraRefreshModeFlagBitsKHR, Flags>;
constexpr VideoEncodeIntraRefreshModeFlagsKHR operator|(VideoEncodeIntraRefreshModeFlagBitsKHR a, VideoEncodeIntraRefreshModeFlagBitsKHR b) noexcept { return VideoEncodeIntraRefreshModeFlagsKHR(Flags(a) | Flags(b)); }
#endif // VK_KHR_video_encode_intra_refresh

#if VK_KHR_video_encode_h264
using VideoEncodeH264CapabilityFlagsKHR = FlagSet<VideoEncodeH264CapabilityFlagBitsKHR, Flags>;
constexpr VideoEncodeH264CapabilityFlagsKHR operator|(VideoEncodeH264CapabilityFlagBitsKHR a, VideoEncodeH264CapabilityFlagBitsKHR b) noexcept { return VideoEncodeH264CapabilityFlagsKHR(Flags(a) | Flags(b)); }

using VideoEncodeH264StdFlagsKHR = FlagSet<VideoEncodeH264StdFlagBitsKHR, Flags>;
constexpr VideoEncodeH264StdFlagsKHR operator|(VideoEncodeH264StdFlagBitsKHR a, VideoEncodeH264StdFlagBitsKHR b) noexcept { return VideoEncodeH264StdFlagsKHR(Flags(a) | Flags(b)); }

using VideoEncodeH264RateControlFlagsKHR = FlagSet<VideoEncodeH264RateControlFlagBitsKHR, Flags>;
constexpr VideoEncodeH264RateControlFlagsKHR operator|(VideoEncodeH264RateControlFlagBitsKHR a, VideoEncodeH264RateControlFlagBitsKHR b) noexcept { return VideoEncodeH264RateControlFlagsKHR(Flags(a) | Flags(b)); }
#endif // VK_KHR_video_encode_h264

#if VK_VERSION_1_4
using HostImageCopyFlags = FlagSet<HostImageCopyFlagBits, Flags>;
constexpr HostImageCopyFlags operator|(HostImageCopyFlagBits a, HostImageCopyFlagBits b) noexcept { return HostImageCopyFlags(Flags(a) | Flags(b)); }
#endif // VK_VERSION_1_4

#if VK_EXT_host_image_copy
using HostImageCopyFlagBitsEXT = HostImageCopyFlagBits;
#endif // VK_EXT_host_image_copy

#if VK_NV_partitioned_acceleration_structure
using PartitionedAccelerationStructureInstanceFlagsNV = FlagSet<PartitionedAccelerationStructureInstanceFlagBitsNV, Flags>;
constexpr PartitionedAccelerationStructureInstanceFlagsNV operator|(PartitionedAccelerationStructureInstanceFlagBitsNV a, PartitionedAccelerationStructureInstanceFlagBitsNV b) noexcept { return PartitionedAccelerationStructureInstanceFlagsNV(Flags(a) | Flags(b)); }
#endif // VK_NV_partitioned_acceleration_structure

#if VK_FUCHSIA_buffer_collection
using ImageConstraintsInfoFlagsFUCHSIA = FlagSet<ImageConstraintsInfoFlagBitsFUCHSIA, Flags>;
constexpr ImageConstraintsInfoFlagsFUCHSIA operator|(ImageConstraintsInfoFlagBitsFUCHSIA a, ImageConstraintsInfoFlagBitsFUCHSIA b) noexcept { return ImageConstraintsInfoFlagsFUCHSIA(Flags(a) | Flags(b)); }
#endif // VK_FUCHSIA_buffer_collection

#if VK_VERSION_1_3
using FormatFeatureFlags2 = FlagSet<FormatFeatureFlagBits2, Flags64>;
constexpr FormatFeatureFlags2 operator|(FormatFeatureFlagBits2 a, FormatFeatureFlagBits2 b) noexcept { return FormatFeatureFlags2(Flags64(a) | Flags64(b)); }
#endif // VK_VERSION_1_3

#if VK_KHR_format_feature_flags2
using FormatFeatureFlagBits2KHR = FormatFeatureFlagBits2;
#endif // VK_KHR_format_feature_flags2

#if VK_VERSION_1_3
using RenderingFlags = FlagSet<RenderingFlagBits, Flags>;
constexpr RenderingFlags operator|(RenderingFlagBits a, RenderingFlagBits b) noexcept { return RenderingFlags(Flags(a) | Flags(b)); }
#endif // VK_VERSION_1_3

#if VK_KHR_dynamic_rendering
using RenderingFlagBitsKHR = RenderingFlagBits;
#endif // VK_KHR_dynamic_rendering

#if VK_KHR_video_encode_h265
using VideoEncodeH265CapabilityFlagsKHR = FlagSet<VideoEncodeH265CapabilityFlagBitsKHR, Flags>;
constexpr VideoEncodeH265CapabilityFlagsKHR operator|(VideoEncodeH265CapabilityFlagBitsKHR a, VideoEncodeH265CapabilityFlagBitsKHR b) noexcept { return VideoEncodeH265CapabilityFlagsKHR(Flags(a) | Flags(b)); }

using VideoEncodeH265StdFlagsKHR = FlagSet<VideoEncodeH265StdFlagBitsKHR, Flags>;
constexpr VideoEncodeH265StdFlagsKHR operator|(VideoEncodeH265StdFlagBitsKHR a, VideoEncodeH265StdFlagBitsKHR b) noexcept { return VideoEncodeH265StdFlagsKHR(Flags(a) | Flags(b)); }

using VideoEncodeH265RateControlFlagsKHR = FlagSet<VideoEncodeH265RateControlFlagBitsKHR, Flags>;
constexpr VideoEncodeH265RateControlFlagsKHR operator|(VideoEncodeH265RateControlFlagBitsKHR a, VideoEncodeH265RateControlFlagBitsKHR b) noexcept { return VideoEncodeH265RateControlFlagsKHR(Flags(a) | Flags(b)); }

using VideoEncodeH265CtbSizeFlagsKHR = FlagSet<VideoEncodeH265CtbSizeFlagBitsKHR, Flags>;
constexpr VideoEncodeH265CtbSizeFlagsKHR operator|(VideoEncodeH265CtbSizeFlagBitsKHR a, VideoEncodeH265CtbSizeFlagBitsKHR b) noexcept { return VideoEncodeH265CtbSizeFlagsKHR(Flags(a) | Flags(b)); }

using VideoEncodeH265TransformBlockSizeFlagsKHR = FlagSet<VideoEncodeH265TransformBlockSizeFlagBitsKHR, Flags>;
constexpr VideoEncodeH265TransformBlockSizeFlagsKHR operator|(VideoEncodeH265TransformBlockSizeFlagBitsKHR a, VideoEncodeH265TransformBlockSizeFlagBitsKHR b) noexcept { return VideoEncodeH265TransformBlockSizeFlagsKHR(Flags(a) | Flags(b)); }
#endif // VK_KHR_video_encode_h265

#if VK_KHR_video_encode_av1
using VideoEncodeAV1CapabilityFlagsKHR = FlagSet<VideoEncodeAV1CapabilityFlagBitsKHR, Flags>;
constexpr VideoEncodeAV1CapabilityFlagsKHR operator|(VideoEncodeAV1CapabilityFlagBitsKHR a, VideoEncodeAV1CapabilityFlagBitsKHR b) noexcept { return VideoEncodeAV1CapabilityFlagsKHR(Flags(a) | Flags(b)); }

using VideoEncodeAV1StdFlagsKHR = FlagSet<VideoEncodeAV1StdFlagBitsKHR, Flags>;
constexpr VideoEncodeAV1StdFlagsKHR operator|(VideoEncodeAV1StdFlagBitsKHR a, VideoEncodeAV1StdFlagBitsKHR b) noexcept { return VideoEncodeAV1StdFlagsKHR(Flags(a) | Flags(b)); }

using VideoEncodeAV1RateControlFlagsKHR = FlagSet<VideoEncodeAV1RateControlFlagBitsKHR, Flags>;
constexpr VideoEncodeAV1RateControlFlagsKHR operator|(VideoEncodeAV1RateControlFlagBitsKHR a, VideoEncodeAV1RateControlFlagBitsKHR b) noexcept { return VideoEncodeAV1RateControlFlagsKHR(Flags(a) | Flags(b)); }

using VideoEncodeAV1SuperblockSizeFlagsKHR = FlagSet<VideoEncodeAV1SuperblockSizeFlagBitsKHR, Flags>;
constexpr VideoEncodeAV1SuperblockSizeFlagsKHR operator|(VideoEncodeAV1SuperblockSizeFlagBitsKHR a, VideoEncodeAV1SuperblockSizeFlagBitsKHR b) noexcept { return VideoEncodeAV1SuperblockSizeFlagsKHR(Flags(a) | Flags(b)); }
#endif // VK_KHR_video_encode_av1

#if VK_EXT_metal_objects
using ExportMetalObjectTypeFlagsEXT = FlagSet<ExportMetalObjectTypeFlagBitsEXT, Flags>;
constexpr ExportMetalObjectTypeFlagsEXT operator|(ExportMetalObjectTypeFlagBitsEXT a, ExportMetalObjectTypeFlagBitsEXT b) noexcept { return ExportMetalObjectTypeFlagsEXT(Flags(a) | Flags(b)); }
#endif // VK_EXT_metal_objects

#if VK_VERSION_1_0
using InstanceCreateFlags = FlagSet<InstanceCreateFlagBits, Flags>;
constexpr InstanceCreateFlags operator|(InstanceCreateFlagBits a, InstanceCreateFlagBits b) noexcept { return InstanceCreateFlags(Flags(a) | Flags(b)); }
#endif // VK_VERSION_1_0

#if VK_EXT_image_compression_control
using ImageCompressionFlagsEXT = FlagSet<ImageCompressionFlagBitsEXT, Flags>;
constexpr ImageCompressionFlagsEXT operator|(ImageCompressionFlagBitsEXT a, ImageCompressionFlagBitsEXT b) noexcept { return ImageCompressionFlagsEXT(Flags(a) | Flags(b)); }

using ImageCompressionFixedRateFlagsEXT = FlagSet<ImageCompressionFixedRateFlagBitsEXT, Flags>;
constexpr ImageCompressionFixedRateFlagsEXT operator|(ImageCompressionFixedRateFlagBitsEXT a, ImageCompressionFixedRateFlagBitsEXT b) noexcept { return ImageCompressionFixedRateFlagsEXT(Flags(a) | Flags(b)); }
#endif // VK_EXT_image_compression_control

#if VK_EXT_pipeline_robustness
using PipelineRobustnessBufferBehaviorEXT = PipelineRobustnessBufferBehavior;
using PipelineRobustnessImageBehaviorEXT = PipelineRobustnessImageBehavior;
#endif // VK_EXT_pipeline_robustness

#if VK_NV_optical_flow
using OpticalFlowGridSizeFlagsNV = FlagSet<OpticalFlowGridSizeFlagBitsNV, Flags>;
constexpr OpticalFlowGridSizeFlagsNV operator|(OpticalFlowGridSizeFlagBitsNV a, OpticalFlowGridSizeFlagBitsNV b) noexcept { return OpticalFlowGridSizeFlagsNV(Flags(a) | Flags(b)); }

using OpticalFlowUsageFlagsNV = FlagSet<OpticalFlowUsageFlagBitsNV, Flags>;
constexpr OpticalFlowUsageFlagsNV operator|(OpticalFlowUsageFlagBitsNV a, OpticalFlowUsageFlagBitsNV b) noexcept { return OpticalFlowUsageFlagsNV(Flags(a) | Flags(b)); }

using OpticalFlowSessionCreateFlagsNV = FlagSet<OpticalFlowSessionCreateFlagBitsNV, Flags>;
constexpr OpticalFlowSessionCreateFlagsNV operator|(OpticalFlowSessionCreateFlagBitsNV a, OpticalFlowSessionCreateFlagBitsNV b) noexcept { return OpticalFlowSessionCreateFlagsNV(Flags(a) | Flags(b)); }

using OpticalFlowExecuteFlagsNV = FlagSet<OpticalFlowExecuteFlagBitsNV, Flags>;
constexpr OpticalFlowExecuteFlagsNV operator|(OpticalFlowExecuteFlagBitsNV a, OpticalFlowExecuteFlagBitsNV b) noexcept { return OpticalFlowExecuteFlagsNV(Flags(a) | Flags(b)); }
#endif // VK_NV_optical_flow

#if VK_EXT_opacity_micromap
using BuildMicromapFlagsEXT = FlagSet<BuildMicromapFlagBitsEXT, Flags>;
constexpr BuildMicromapFlagsEXT operator|(BuildMicromapFlagBitsEXT a, BuildMicromapFlagBitsEXT b) noexcept { return BuildMicromapFlagsEXT(Flags(a) | Flags(b)); }

using MicromapCreateFlagsEXT = FlagSet<MicromapCreateFlagBitsEXT, Flags>;
constexpr MicromapCreateFlagsEXT operator|(MicromapCreateFlagBitsEXT a, MicromapCreateFlagBitsEXT b) noexcept { return MicromapCreateFlagsEXT(Flags(a) | Flags(b)); }
#endif // VK_EXT_opacity_micromap

#if VK_EXT_device_fault
struct DeviceFaultAddressInfoEXT : VkDeviceFaultAddressInfoEXT {
  DeviceFaultAddressInfoEXT() noexcept : VkDeviceFaultAddressInfoEXT{} {}
  DeviceFaultAddressInfoEXT(DeviceFaultAddressTypeEXT addressType, DeviceAddress reportedAddress, DeviceSize addressPrecision) noexcept : VkDeviceFaultAddressInfoEXT{.addressType = std::bit_cast<VkDeviceFaultAddressTypeEXT>(addressType), .reportedAddress = reportedAddress, .addressPrecision = addressPrecision} {}

  void setAddressType(DeviceFaultAddressTypeEXT value) { this->addressType = std::bit_cast<VkDeviceFaultAddressTypeEXT>(value); }
  DeviceFaultAddressTypeEXT getAddressType() const { return std::bit_cast<DeviceFaultAddressTypeEXT>(this->addressType); }
  void setReportedAddress(DeviceAddress value) { this->reportedAddress = value; }
  DeviceAddress getReportedAddress() const { return this->reportedAddress; }
  void setAddressPrecision(DeviceSize value) { this->addressPrecision = value; }
  DeviceSize getAddressPrecision() const { return this->addressPrecision; }
};

struct DeviceFaultVendorBinaryHeaderVersionOneEXT : VkDeviceFaultVendorBinaryHeaderVersionOneEXT {
  DeviceFaultVendorBinaryHeaderVersionOneEXT() noexcept : VkDeviceFaultVendorBinaryHeaderVersionOneEXT{} {}
  DeviceFaultVendorBinaryHeaderVersionOneEXT(uint32_t headerSize, DeviceFaultVendorBinaryHeaderVersionEXT headerVersion, uint32_t vendorID, uint32_t deviceID, uint32_t driverVersion, std::span<const uint8_t, VK_UUID_SIZE> pipelineCacheUUID, uint32_t applicationNameOffset, uint32_t applicationVersion, uint32_t engineNameOffset, uint32_t engineVersion, uint32_t apiVersion) noexcept : VkDeviceFaultVendorBinaryHeaderVersionOneEXT{.headerSize = headerSize, .headerVersion = std::bit_cast<VkDeviceFaultVendorBinaryHeaderVersionEXT>(headerVersion), .vendorID = vendorID, .deviceID = deviceID, .driverVersion = driverVersion, .applicationNameOffset = applicationNameOffset, .applicationVersion = applicationVersion, .engineNameOffset = engineNameOffset, .engineVersion = engineVersion, .apiVersion = apiVersion} { setPipelineCacheUUID(pipelineCacheUUID); }

  void setHeaderSize(uint32_t value) { this->headerSize = value; }
  uint32_t getHeaderSize() const { return this->headerSize; }
  void setHeaderVersion(DeviceFaultVendorBinaryHeaderVersionEXT value) { this->headerVersion = std::bit_cast<VkDeviceFaultVendorBinaryHeaderVersionEXT>(value); }
  DeviceFaultVendorBinaryHeaderVersionEXT getHeaderVersion() const { return std::bit_cast<DeviceFaultVendorBinaryHeaderVersionEXT>(this->headerVersion); }
  void setVendorID(uint32_t value) { this->vendorID = value; }
  uint32_t getVendorID() const { return this->vendorID; }
  void setDeviceID(uint32_t value) { this->deviceID = value; }
  uint32_t getDeviceID() const { return this->deviceID; }
  void setDriverVersion(uint32_t value) { this->driverVersion = value; }
  uint32_t getDriverVersion() const { return this->driverVersion; }
  void setPipelineCacheUUID(std::span<const uint8_t, VK_UUID_SIZE> value) { std::memcpy(&this->pipelineCacheUUID, value.data(), value.size_bytes()); }
  std::span<const uint8_t, VK_UUID_SIZE> getPipelineCacheUUID() const { return this->pipelineCacheUUID; }
  void setApplicationNameOffset(uint32_t value) { this->applicationNameOffset = value; }
  uint32_t getApplicationNameOffset() const { return this->applicationNameOffset; }
  void setApplicationVersion(uint32_t value) { this->applicationVersion = value; }
  uint32_t getApplicationVersion() const { return this->applicationVersion; }
  void setEngineNameOffset(uint32_t value) { this->engineNameOffset = value; }
  uint32_t getEngineNameOffset() const { return this->engineNameOffset; }
  void setEngineVersion(uint32_t value) { this->engineVersion = value; }
  uint32_t getEngineVersion() const { return this->engineVersion; }
  void setApiVersion(uint32_t value) { this->apiVersion = value; }
  uint32_t getApiVersion() const { return this->apiVersion; }
};
#endif // VK_EXT_device_fault

#if VK_EXT_device_generated_commands
using IndirectCommandsLayoutUsageFlagsEXT = FlagSet<IndirectCommandsLayoutUsageFlagBitsEXT, Flags>;
constexpr IndirectCommandsLayoutUsageFlagsEXT operator|(IndirectCommandsLayoutUsageFlagBitsEXT a, IndirectCommandsLayoutUsageFlagBitsEXT b) noexcept { return IndirectCommandsLayoutUsageFlagsEXT(Flags(a) | Flags(b)); }

struct IndirectExecutionSetCreateInfoEXT : VkIndirectExecutionSetCreateInfoEXT {
  IndirectExecutionSetCreateInfoEXT() noexcept : VkIndirectExecutionSetCreateInfoEXT{.sType = VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_CREATE_INFO_EXT} {}

  void setType(IndirectExecutionSetInfoTypeEXT value) { this->type = std::bit_cast<VkIndirectExecutionSetInfoTypeEXT>(value); }
  IndirectExecutionSetInfoTypeEXT getType() const { return std::bit_cast<IndirectExecutionSetInfoTypeEXT>(this->type); }
  void setInfo(IndirectExecutionSetInfoEXT value) { this->info = value; }
  IndirectExecutionSetInfoEXT getInfo() const { return this->info; }
};

using IndirectCommandsInputModeFlagsEXT = FlagSet<IndirectCommandsInputModeFlagBitsEXT, Flags>;
constexpr IndirectCommandsInputModeFlagsEXT operator|(IndirectCommandsInputModeFlagBitsEXT a, IndirectCommandsInputModeFlagBitsEXT b) noexcept { return IndirectCommandsInputModeFlagsEXT(Flags(a) | Flags(b)); }

struct IndirectCommandsIndexBufferTokenEXT : VkIndirectCommandsIndexBufferTokenEXT {
  IndirectCommandsIndexBufferTokenEXT() noexcept : VkIndirectCommandsIndexBufferTokenEXT{} {}
  IndirectCommandsIndexBufferTokenEXT(IndirectCommandsInputModeFlagBitsEXT mode) noexcept : VkIndirectCommandsIndexBufferTokenEXT{.mode = std::bit_cast<VkIndirectCommandsInputModeFlagBitsEXT>(mode)} {}

  void setMode(IndirectCommandsInputModeFlagBitsEXT value) { this->mode = std::bit_cast<VkIndirectCommandsInputModeFlagBitsEXT>(value); }
  IndirectCommandsInputModeFlagBitsEXT getMode() const { return std::bit_cast<IndirectCommandsInputModeFlagBitsEXT>(this->mode); }
};

struct IndirectCommandsLayoutTokenEXT : VkIndirectCommandsLayoutTokenEXT {
  IndirectCommandsLayoutTokenEXT() noexcept : VkIndirectCommandsLayoutTokenEXT{.sType = VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_EXT} {}

  void setType(IndirectCommandsTokenTypeEXT value) { this->type = std::bit_cast<VkIndirectCommandsTokenTypeEXT>(value); }
  IndirectCommandsTokenTypeEXT getType() const { return std::bit_cast<IndirectCommandsTokenTypeEXT>(this->type); }
  void setData(IndirectCommandsTokenDataEXT value) { this->data = value; }
  IndirectCommandsTokenDataEXT getData() const { return this->data; }
  void setOffset(uint32_t value) { this->offset = value; }
  uint32_t getOffset() const { return this->offset; }
};
#endif // VK_EXT_device_generated_commands

#if VK_EXT_shader_object
using ShaderCreateFlagsEXT = FlagSet<ShaderCreateFlagBitsEXT, Flags>;
constexpr ShaderCreateFlagsEXT operator|(ShaderCreateFlagBitsEXT a, ShaderCreateFlagBitsEXT b) noexcept { return ShaderCreateFlagsEXT(Flags(a) | Flags(b)); }
#endif // VK_EXT_shader_object

#if VK_NV_cooperative_matrix
using ScopeNV = ScopeKHR;
#endif // VK_NV_cooperative_matrix

#if VK_KHR_cooperative_matrix
struct CooperativeMatrixPropertiesKHR : VkCooperativeMatrixPropertiesKHR {
  CooperativeMatrixPropertiesKHR() noexcept : VkCooperativeMatrixPropertiesKHR{.sType = VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_KHR} {}

  uint32_t getMSize() const { return this->MSize; }
  uint32_t getNSize() const { return this->NSize; }
  uint32_t getKSize() const { return this->KSize; }
  ComponentTypeKHR getAType() const { return std::bit_cast<ComponentTypeKHR>(this->AType); }
  ComponentTypeKHR getBType() const { return std::bit_cast<ComponentTypeKHR>(this->BType); }
  ComponentTypeKHR getCType() const { return std::bit_cast<ComponentTypeKHR>(this->CType); }
  ComponentTypeKHR getResultType() const { return std::bit_cast<ComponentTypeKHR>(this->ResultType); }
  Bool32 getSaturatingAccumulation() const { return this->saturatingAccumulation; }
  ScopeKHR getScope() const { return std::bit_cast<ScopeKHR>(this->scope); }
};
#endif // VK_KHR_cooperative_matrix

#if VK_NV_cooperative_matrix2
struct CooperativeMatrixFlexibleDimensionsPropertiesNV : VkCooperativeMatrixFlexibleDimensionsPropertiesNV {
  CooperativeMatrixFlexibleDimensionsPropertiesNV() noexcept : VkCooperativeMatrixFlexibleDimensionsPropertiesNV{.sType = VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_FLEXIBLE_DIMENSIONS_PROPERTIES_NV} {}

  uint32_t getMGranularity() const { return this->MGranularity; }
  uint32_t getNGranularity() const { return this->NGranularity; }
  uint32_t getKGranularity() const { return this->KGranularity; }
  ComponentTypeKHR getAType() const { return std::bit_cast<ComponentTypeKHR>(this->AType); }
  ComponentTypeKHR getBType() const { return std::bit_cast<ComponentTypeKHR>(this->BType); }
  ComponentTypeKHR getCType() const { return std::bit_cast<ComponentTypeKHR>(this->CType); }
  ComponentTypeKHR getResultType() const { return std::bit_cast<ComponentTypeKHR>(this->ResultType); }
  Bool32 getSaturatingAccumulation() const { return this->saturatingAccumulation; }
  ScopeKHR getScope() const { return std::bit_cast<ScopeKHR>(this->scope); }
  uint32_t getWorkgroupInvocations() const { return this->workgroupInvocations; }
};
#endif // VK_NV_cooperative_matrix2

#if VK_NV_cooperative_vector
struct CooperativeVectorPropertiesNV : VkCooperativeVectorPropertiesNV {
  CooperativeVectorPropertiesNV() noexcept : VkCooperativeVectorPropertiesNV{.sType = VK_STRUCTURE_TYPE_COOPERATIVE_VECTOR_PROPERTIES_NV} {}

  void setInputType(ComponentTypeKHR value) { this->inputType = std::bit_cast<VkComponentTypeKHR>(value); }
  ComponentTypeKHR getInputType() const { return std::bit_cast<ComponentTypeKHR>(this->inputType); }
  void setInputInterpretation(ComponentTypeKHR value) { this->inputInterpretation = std::bit_cast<VkComponentTypeKHR>(value); }
  ComponentTypeKHR getInputInterpretation() const { return std::bit_cast<ComponentTypeKHR>(this->inputInterpretation); }
  void setMatrixInterpretation(ComponentTypeKHR value) { this->matrixInterpretation = std::bit_cast<VkComponentTypeKHR>(value); }
  ComponentTypeKHR getMatrixInterpretation() const { return std::bit_cast<ComponentTypeKHR>(this->matrixInterpretation); }
  void setBiasInterpretation(ComponentTypeKHR value) { this->biasInterpretation = std::bit_cast<VkComponentTypeKHR>(value); }
  ComponentTypeKHR getBiasInterpretation() const { return std::bit_cast<ComponentTypeKHR>(this->biasInterpretation); }
  void setResultType(ComponentTypeKHR value) { this->resultType = std::bit_cast<VkComponentTypeKHR>(value); }
  ComponentTypeKHR getResultType() const { return std::bit_cast<ComponentTypeKHR>(this->resultType); }

  void setTranspose(Bool32 value) { this->transpose = value; }
  Bool32 getTranspose() const { return this->transpose; }
};
#endif // VK_NV_cooperative_vector

#if VK_NV_cooperative_matrix
using ComponentTypeNV = ComponentTypeKHR;
#endif // VK_NV_cooperative_matrix

#if VK_KHR_maintenance7
struct PhysicalDeviceLayeredApiPropertiesKHR : VkPhysicalDeviceLayeredApiPropertiesKHR {
  PhysicalDeviceLayeredApiPropertiesKHR() noexcept : VkPhysicalDeviceLayeredApiPropertiesKHR{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_KHR} {}

  uint32_t getVendorID() const { return this->vendorID; }
  uint32_t getDeviceID() const { return this->deviceID; }
  PhysicalDeviceLayeredApiKHR getLayeredAPI() const { return std::bit_cast<PhysicalDeviceLayeredApiKHR>(this->layeredAPI); }
  std::string_view getDeviceName() const { return this->deviceName; }

  void attach(struct PhysicalDeviceLayeredApiVulkanPropertiesKHR&);
};
#endif // VK_KHR_maintenance7

#if VK_NV_low_latency2
struct SetLatencyMarkerInfoNV : VkSetLatencyMarkerInfoNV {
  SetLatencyMarkerInfoNV() noexcept : VkSetLatencyMarkerInfoNV{.sType = VK_STRUCTURE_TYPE_SET_LATENCY_MARKER_INFO_NV} {}

  void setPresentID(uint64_t value) { this->presentID = value; }
  uint64_t getPresentID() const { return this->presentID; }
  void setMarker(LatencyMarkerNV value) { this->marker = std::bit_cast<VkLatencyMarkerNV>(value); }
  LatencyMarkerNV getMarker() const { return std::bit_cast<LatencyMarkerNV>(this->marker); }
};

struct OutOfBandQueueTypeInfoNV : VkOutOfBandQueueTypeInfoNV {
  OutOfBandQueueTypeInfoNV() noexcept : VkOutOfBandQueueTypeInfoNV{.sType = VK_STRUCTURE_TYPE_OUT_OF_BAND_QUEUE_TYPE_INFO_NV} {}

  void setQueueType(OutOfBandQueueTypeNV value) { this->queueType = std::bit_cast<VkOutOfBandQueueTypeNV>(value); }
  OutOfBandQueueTypeNV getQueueType() const { return std::bit_cast<OutOfBandQueueTypeNV>(this->queueType); }
};
#endif // VK_NV_low_latency2

#if VK_VERSION_1_4
using MemoryUnmapFlags = FlagSet<MemoryUnmapFlagBits, Flags>;
constexpr MemoryUnmapFlags operator|(MemoryUnmapFlagBits a, MemoryUnmapFlagBits b) noexcept { return MemoryUnmapFlags(Flags(a) | Flags(b)); }
#endif // VK_VERSION_1_4

#if VK_KHR_map_memory2
using MemoryUnmapFlagBitsKHR = MemoryUnmapFlagBits;
#endif // VK_KHR_map_memory2

#if VK_KHR_maintenance8
using AccessFlags3KHR = FlagSet<AccessFlagBits3KHR, Flags64>;
constexpr AccessFlags3KHR operator|(AccessFlagBits3KHR a, AccessFlagBits3KHR b) noexcept { return AccessFlags3KHR(Flags64(a) | Flags64(b)); }
#endif // VK_KHR_maintenance8

#if VK_QCOM_tile_shading
using TileShadingRenderPassFlagsQCOM = FlagSet<TileShadingRenderPassFlagBitsQCOM, Flags>;
constexpr TileShadingRenderPassFlagsQCOM operator|(TileShadingRenderPassFlagBitsQCOM a, TileShadingRenderPassFlagBitsQCOM b) noexcept { return TileShadingRenderPassFlagsQCOM(Flags(a) | Flags(b)); }
#endif // VK_QCOM_tile_shading

#if VK_NV_cooperative_vector
struct ConvertCooperativeVectorMatrixInfoNV : VkConvertCooperativeVectorMatrixInfoNV {
  ConvertCooperativeVectorMatrixInfoNV() noexcept : VkConvertCooperativeVectorMatrixInfoNV{.sType = VK_STRUCTURE_TYPE_CONVERT_COOPERATIVE_VECTOR_MATRIX_INFO_NV} {}

  void setSrcSize(size_t value) { this->srcSize = value; }
  size_t getSrcSize() const { return this->srcSize; }
  void setSrcData(DeviceOrHostAddressConstKHR value) { this->srcData = value; }
  DeviceOrHostAddressConstKHR getSrcData() const { return this->srcData; }
  void setDstData(DeviceOrHostAddressKHR value) { this->dstData = value; }
  DeviceOrHostAddressKHR getDstData() const { return this->dstData; }
  void setSrcComponentType(ComponentTypeKHR value) { this->srcComponentType = std::bit_cast<VkComponentTypeKHR>(value); }
  ComponentTypeKHR getSrcComponentType() const { return std::bit_cast<ComponentTypeKHR>(this->srcComponentType); }
  void setDstComponentType(ComponentTypeKHR value) { this->dstComponentType = std::bit_cast<VkComponentTypeKHR>(value); }
  ComponentTypeKHR getDstComponentType() const { return std::bit_cast<ComponentTypeKHR>(this->dstComponentType); }
  void setNumRows(uint32_t value) { this->numRows = value; }
  uint32_t getNumRows() const { return this->numRows; }
  void setNumColumns(uint32_t value) { this->numColumns = value; }
  uint32_t getNumColumns() const { return this->numColumns; }
  void setSrcLayout(CooperativeVectorMatrixLayoutNV value) { this->srcLayout = std::bit_cast<VkCooperativeVectorMatrixLayoutNV>(value); }
  CooperativeVectorMatrixLayoutNV getSrcLayout() const { return std::bit_cast<CooperativeVectorMatrixLayoutNV>(this->srcLayout); }
  void setSrcStride(size_t value) { this->srcStride = value; }
  size_t getSrcStride() const { return this->srcStride; }
  void setDstLayout(CooperativeVectorMatrixLayoutNV value) { this->dstLayout = std::bit_cast<VkCooperativeVectorMatrixLayoutNV>(value); }
  CooperativeVectorMatrixLayoutNV getDstLayout() const { return std::bit_cast<CooperativeVectorMatrixLayoutNV>(this->dstLayout); }
  void setDstStride(size_t value) { this->dstStride = value; }
  size_t getDstStride() const { return this->dstStride; }

  void setDstSize(size_t* value) { this->pDstSize = value; }
  size_t* getDstSize() const { return this->pDstSize; }
};
#endif // VK_NV_cooperative_vector

#if VK_ARM_tensors
using TensorCreateFlagsARM = FlagSet<TensorCreateFlagBitsARM, Flags64>;
constexpr TensorCreateFlagsARM operator|(TensorCreateFlagBitsARM a, TensorCreateFlagBitsARM b) noexcept { return TensorCreateFlagsARM(Flags64(a) | Flags64(b)); }

using TensorUsageFlagsARM = FlagSet<TensorUsageFlagBitsARM, Flags64>;
constexpr TensorUsageFlagsARM operator|(TensorUsageFlagBitsARM a, TensorUsageFlagBitsARM b) noexcept { return TensorUsageFlagsARM(Flags64(a) | Flags64(b)); }

using TensorViewCreateFlagsARM = FlagSet<TensorViewCreateFlagBitsARM, Flags64>;
constexpr TensorViewCreateFlagsARM operator|(TensorViewCreateFlagBitsARM a, TensorViewCreateFlagBitsARM b) noexcept { return TensorViewCreateFlagsARM(Flags64(a) | Flags64(b)); }
#endif // VK_ARM_tensors

#if VK_ARM_data_graph
using DataGraphPipelineSessionCreateFlagsARM = FlagSet<DataGraphPipelineSessionCreateFlagBitsARM, Flags64>;
constexpr DataGraphPipelineSessionCreateFlagsARM operator|(DataGraphPipelineSessionCreateFlagBitsARM a, DataGraphPipelineSessionCreateFlagBitsARM b) noexcept { return DataGraphPipelineSessionCreateFlagsARM(Flags64(a) | Flags64(b)); }

struct DataGraphPipelineSessionBindPointRequirementARM : VkDataGraphPipelineSessionBindPointRequirementARM {
  DataGraphPipelineSessionBindPointRequirementARM() noexcept : VkDataGraphPipelineSessionBindPointRequirementARM{.sType = VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_REQUIREMENT_ARM} {}

  void setBindPoint(DataGraphPipelineSessionBindPointARM value) { this->bindPoint = std::bit_cast<VkDataGraphPipelineSessionBindPointARM>(value); }
  DataGraphPipelineSessionBindPointARM getBindPoint() const { return std::bit_cast<DataGraphPipelineSessionBindPointARM>(this->bindPoint); }
  void setBindPointType(DataGraphPipelineSessionBindPointTypeARM value) { this->bindPointType = std::bit_cast<VkDataGraphPipelineSessionBindPointTypeARM>(value); }
  DataGraphPipelineSessionBindPointTypeARM getBindPointType() const { return std::bit_cast<DataGraphPipelineSessionBindPointTypeARM>(this->bindPointType); }
  void setNumObjects(uint32_t value) { this->numObjects = value; }
  uint32_t getNumObjects() const { return this->numObjects; }
};

struct DataGraphPipelinePropertyQueryResultARM : VkDataGraphPipelinePropertyQueryResultARM {
  DataGraphPipelinePropertyQueryResultARM() noexcept : VkDataGraphPipelinePropertyQueryResultARM{.sType = VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_PROPERTY_QUERY_RESULT_ARM} {}

  void setProperty(DataGraphPipelinePropertyARM value) { this->property = std::bit_cast<VkDataGraphPipelinePropertyARM>(value); }
  DataGraphPipelinePropertyARM getProperty() const { return std::bit_cast<DataGraphPipelinePropertyARM>(this->property); }

  void setIsText(Bool32 value) { this->isText = value; }
  Bool32 getIsText() const { return this->isText; }
  void setDataSize(size_t value) { this->dataSize = value; }
  size_t getDataSize() const { return this->dataSize; }
  void setData(void* value) { this->pData = value; }
  void* getData() const { return this->pData; }
};

using DataGraphPipelineDispatchFlagsARM = FlagSet<DataGraphPipelineDispatchFlagBitsARM, Flags64>;
constexpr DataGraphPipelineDispatchFlagsARM operator|(DataGraphPipelineDispatchFlagBitsARM a, DataGraphPipelineDispatchFlagBitsARM b) noexcept { return DataGraphPipelineDispatchFlagsARM(Flags64(a) | Flags64(b)); }

struct PhysicalDeviceDataGraphProcessingEngineARM : VkPhysicalDeviceDataGraphProcessingEngineARM {
  PhysicalDeviceDataGraphProcessingEngineARM() noexcept : VkPhysicalDeviceDataGraphProcessingEngineARM{} {}

  void setType(PhysicalDeviceDataGraphProcessingEngineTypeARM value) { this->type = std::bit_cast<VkPhysicalDeviceDataGraphProcessingEngineTypeARM>(value); }
  PhysicalDeviceDataGraphProcessingEngineTypeARM getType() const { return std::bit_cast<PhysicalDeviceDataGraphProcessingEngineTypeARM>(this->type); }

  void setIsForeign(Bool32 value) { this->isForeign = value; }
  Bool32 getIsForeign() const { return this->isForeign; }
};

struct PhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM : VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM {
  PhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM() noexcept : VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_QUEUE_FAMILY_DATA_GRAPH_PROCESSING_ENGINE_INFO_ARM} {}

  void setQueueFamilyIndex(uint32_t value) { this->queueFamilyIndex = value; }
  uint32_t getQueueFamilyIndex() const { return this->queueFamilyIndex; }
  void setEngineType(PhysicalDeviceDataGraphProcessingEngineTypeARM value) { this->engineType = std::bit_cast<VkPhysicalDeviceDataGraphProcessingEngineTypeARM>(value); }
  PhysicalDeviceDataGraphProcessingEngineTypeARM getEngineType() const { return std::bit_cast<PhysicalDeviceDataGraphProcessingEngineTypeARM>(this->engineType); }
};

struct PhysicalDeviceDataGraphOperationSupportARM : VkPhysicalDeviceDataGraphOperationSupportARM {
  PhysicalDeviceDataGraphOperationSupportARM() noexcept : VkPhysicalDeviceDataGraphOperationSupportARM{} {}
  PhysicalDeviceDataGraphOperationSupportARM(PhysicalDeviceDataGraphOperationTypeARM operationType, std::string_view name, uint32_t version) noexcept : VkPhysicalDeviceDataGraphOperationSupportARM{.operationType = std::bit_cast<VkPhysicalDeviceDataGraphOperationTypeARM>(operationType), .version = version} { setName(name); }

  void setOperationType(PhysicalDeviceDataGraphOperationTypeARM value) { this->operationType = std::bit_cast<VkPhysicalDeviceDataGraphOperationTypeARM>(value); }
  PhysicalDeviceDataGraphOperationTypeARM getOperationType() const { return std::bit_cast<PhysicalDeviceDataGraphOperationTypeARM>(this->operationType); }
  void setName(std::string_view value) { const auto len = std::max<std::size_t>(VK_MAX_PHYSICAL_DEVICE_DATA_GRAPH_OPERATION_SET_NAME_SIZE_ARM - 1, value.size()); std::memcpy(&this->name, value.data(), len); this->name[len] = '\0'; }
  std::string_view getName() const { return this->name; }
  void setVersion(uint32_t value) { this->version = value; }
  uint32_t getVersion() const { return this->version; }
};
#endif // VK_ARM_data_graph

#if VK_KHR_video_queue
struct VideoSessionMemoryRequirementsKHR : VkVideoSessionMemoryRequirementsKHR {
  VideoSessionMemoryRequirementsKHR() noexcept : VkVideoSessionMemoryRequirementsKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_SESSION_MEMORY_REQUIREMENTS_KHR} {}

  uint32_t getMemoryBindIndex() const { return this->memoryBindIndex; }
  const MemoryRequirements& getMemoryRequirements() const { return static_cast<const MemoryRequirements&>(this->memoryRequirements); }
};
#endif // VK_KHR_video_queue

#if VK_VERSION_1_1
struct MemoryRequirements2 : VkMemoryRequirements2 {
  MemoryRequirements2() noexcept : VkMemoryRequirements2{.sType = VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2} {}

  const MemoryRequirements& getMemoryRequirements() const { return static_cast<const MemoryRequirements&>(this->memoryRequirements); }

  void attach(struct MemoryDedicatedRequirements&);
#if VK_QCOM_tile_memory_heap
  void attach(struct TileMemoryRequirementsQCOM&);
#endif // VK_QCOM_tile_memory_heap
};
#endif // VK_VERSION_1_1

#if VK_VERSION_1_4
struct SubresourceLayout2 : VkSubresourceLayout2 {
  SubresourceLayout2() noexcept : VkSubresourceLayout2{.sType = VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2} {}

  const SubresourceLayout& getSubresourceLayout() const { return static_cast<const SubresourceLayout&>(this->subresourceLayout); }

  void attach(struct SubresourceHostMemcpySize&);
#if VK_EXT_image_compression_control
  void attach(struct ImageCompressionPropertiesEXT&);
#endif // VK_EXT_image_compression_control
};
#endif // VK_VERSION_1_4

#if VK_NV_partitioned_acceleration_structure
struct BuildPartitionedAccelerationStructureIndirectCommandNV : VkBuildPartitionedAccelerationStructureIndirectCommandNV {
  BuildPartitionedAccelerationStructureIndirectCommandNV() noexcept : VkBuildPartitionedAccelerationStructureIndirectCommandNV{} {}
  BuildPartitionedAccelerationStructureIndirectCommandNV(PartitionedAccelerationStructureOpTypeNV opType, uint32_t argCount, const StridedDeviceAddressNV& argData) noexcept : VkBuildPartitionedAccelerationStructureIndirectCommandNV{.opType = std::bit_cast<VkPartitionedAccelerationStructureOpTypeNV>(opType), .argCount = argCount, .argData = argData} {}

  void setOpType(PartitionedAccelerationStructureOpTypeNV value) { this->opType = std::bit_cast<VkPartitionedAccelerationStructureOpTypeNV>(value); }
  PartitionedAccelerationStructureOpTypeNV getOpType() const { return std::bit_cast<PartitionedAccelerationStructureOpTypeNV>(this->opType); }
  void setArgCount(uint32_t value) { this->argCount = value; }
  uint32_t getArgCount() const { return this->argCount; }
  void setArgData(const StridedDeviceAddressNV& value) { this->argData = value; }
  const StridedDeviceAddressNV& getArgData() const { return static_cast<const StridedDeviceAddressNV&>(this->argData); }
};
#endif // VK_NV_partitioned_acceleration_structure

#if VK_NV_cluster_acceleration_structure
struct ClusterAccelerationStructureInstantiateClusterInfoNV : VkClusterAccelerationStructureInstantiateClusterInfoNV {
  ClusterAccelerationStructureInstantiateClusterInfoNV() noexcept : VkClusterAccelerationStructureInstantiateClusterInfoNV{} {}
  ClusterAccelerationStructureInstantiateClusterInfoNV(uint32_t clusterIdOffset, uint32_t geometryIndexOffset, uint32_t reserved, DeviceAddress clusterTemplateAddress, const StridedDeviceAddressNV& vertexBuffer) noexcept : VkClusterAccelerationStructureInstantiateClusterInfoNV{.clusterIdOffset = clusterIdOffset, .geometryIndexOffset = geometryIndexOffset, .reserved = reserved, .clusterTemplateAddress = clusterTemplateAddress, .vertexBuffer = vertexBuffer} {}

  void setClusterIdOffset(uint32_t value) { this->clusterIdOffset = value; }
  uint32_t getClusterIdOffset() const { return this->clusterIdOffset; }
  void setGeometryIndexOffset(uint32_t value) { this->geometryIndexOffset = value; }
  uint32_t getGeometryIndexOffset() const { return this->geometryIndexOffset; }
  void setReserved(uint32_t value) { this->reserved = value; }
  uint32_t getReserved() const { return this->reserved; }
  void setClusterTemplateAddress(DeviceAddress value) { this->clusterTemplateAddress = value; }
  DeviceAddress getClusterTemplateAddress() const { return this->clusterTemplateAddress; }
  void setVertexBuffer(const StridedDeviceAddressNV& value) { this->vertexBuffer = value; }
  const StridedDeviceAddressNV& getVertexBuffer() const { return static_cast<const StridedDeviceAddressNV&>(this->vertexBuffer); }
};
#endif // VK_NV_cluster_acceleration_structure

#if VK_KHR_display
struct DisplayModeCreateInfoKHR : VkDisplayModeCreateInfoKHR {
  DisplayModeCreateInfoKHR() noexcept : VkDisplayModeCreateInfoKHR{.sType = VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR} {}

  // The parameters this mode uses.
  void setParameters(const DisplayModeParametersKHR& value) { this->parameters = value; }
  const DisplayModeParametersKHR& getParameters() const { return static_cast<const DisplayModeParametersKHR&>(this->parameters); }

  void setFlags(DisplayModeCreateFlagsKHR value) { this->flags = std::bit_cast<VkDisplayModeCreateFlagsKHR>(value); }
  DisplayModeCreateFlagsKHR getFlags() const { return std::bit_cast<DisplayModeCreateFlagsKHR>(this->flags); }
};
#endif // VK_KHR_display

#if VK_KHR_incremental_present
struct PresentRegionKHR : VkPresentRegionKHR {
  PresentRegionKHR() noexcept : VkPresentRegionKHR{} {}

  // Number of rectangles in pRectangles
  void setRectangleCount(uint32_t value) { this->rectangleCount = value; }
  uint32_t getRectangleCount() const { return this->rectangleCount; }
  // Array of rectangles that have changed in a swapchain's image(s)
  void setRectangles(const RectLayerKHR* value) { this->pRectangles = std::bit_cast<const VkRectLayerKHR*>(value); }
  const RectLayerKHR* getRectangles() const { return std::bit_cast<const RectLayerKHR*>(this->pRectangles); }
};
#endif // VK_KHR_incremental_present

#if VK_ARM_render_pass_striped
struct RenderPassStripeInfoARM : VkRenderPassStripeInfoARM {
  RenderPassStripeInfoARM() noexcept : VkRenderPassStripeInfoARM{.sType = VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_INFO_ARM} {}

  void setStripeArea(const Rect2D& value) { this->stripeArea = value; }
  const Rect2D& getStripeArea() const { return static_cast<const Rect2D&>(this->stripeArea); }
};
#endif // VK_ARM_render_pass_striped

#if VK_VERSION_1_0
struct ClearRect : VkClearRect {
  ClearRect() noexcept : VkClearRect{} {}
  ClearRect(const Rect2D& rect, uint32_t baseArrayLayer, uint32_t layerCount) noexcept : VkClearRect{.rect = rect, .baseArrayLayer = baseArrayLayer, .layerCount = layerCount} {}

  void setRect(const Rect2D& value) { this->rect = value; }
  const Rect2D& getRect() const { return static_cast<const Rect2D&>(this->rect); }
  void setBaseArrayLayer(uint32_t value) { this->baseArrayLayer = value; }
  uint32_t getBaseArrayLayer() const { return this->baseArrayLayer; }
  void setLayerCount(uint32_t value) { this->layerCount = value; }
  uint32_t getLayerCount() const { return this->layerCount; }
};

struct PipelineViewportStateCreateInfo : VkPipelineViewportStateCreateInfo {
  PipelineViewportStateCreateInfo() noexcept : VkPipelineViewportStateCreateInfo{.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO} {}

  void setFlags(PipelineViewportStateCreateFlags value) { this->flags = std::bit_cast<VkPipelineViewportStateCreateFlags>(value); }
  PipelineViewportStateCreateFlags getFlags() const { return std::bit_cast<PipelineViewportStateCreateFlags>(this->flags); }
  void setViewportCount(uint32_t value) { this->viewportCount = value; }
  uint32_t getViewportCount() const { return this->viewportCount; }
  void setViewports(const Viewport* value) { this->pViewports = std::bit_cast<const VkViewport*>(value); }
  const Viewport* getViewports() const { return std::bit_cast<const Viewport*>(this->pViewports); }
  void setScissorCount(uint32_t value) { this->scissorCount = value; }
  uint32_t getScissorCount() const { return this->scissorCount; }
  void setScissors(const Rect2D* value) { this->pScissors = std::bit_cast<const VkRect2D*>(value); }
  const Rect2D* getScissors() const { return std::bit_cast<const Rect2D*>(this->pScissors); }

#if VK_NV_clip_space_w_scaling
  void attach(struct PipelineViewportWScalingStateCreateInfoNV&);
#endif // VK_NV_clip_space_w_scaling
#if VK_NV_viewport_swizzle
  void attach(struct PipelineViewportSwizzleStateCreateInfoNV&);
#endif // VK_NV_viewport_swizzle
#if VK_NV_scissor_exclusive
  void attach(struct PipelineViewportExclusiveScissorStateCreateInfoNV&);
#endif // VK_NV_scissor_exclusive
#if VK_NV_shading_rate_image
  void attach(struct PipelineViewportShadingRateImageStateCreateInfoNV&);
  void attach(struct PipelineViewportCoarseSampleOrderStateCreateInfoNV&);
#endif // VK_NV_shading_rate_image
#if VK_EXT_depth_clip_control
  void attach(struct PipelineViewportDepthClipControlCreateInfoEXT&);
#endif // VK_EXT_depth_clip_control
#if VK_EXT_depth_clamp_control
  void attach(struct PipelineViewportDepthClampControlCreateInfoEXT&);
#endif // VK_EXT_depth_clamp_control
};
#endif // VK_VERSION_1_0

#if VK_VERSION_1_1
struct SamplerYcbcrConversionCreateInfo : VkSamplerYcbcrConversionCreateInfo {
  SamplerYcbcrConversionCreateInfo() noexcept : VkSamplerYcbcrConversionCreateInfo{.sType = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO} {}

  void setFormat(Format value) { this->format = std::bit_cast<VkFormat>(value); }
  Format getFormat() const { return std::bit_cast<Format>(this->format); }
  void setYcbcrModel(SamplerYcbcrModelConversion value) { this->ycbcrModel = std::bit_cast<VkSamplerYcbcrModelConversion>(value); }
  SamplerYcbcrModelConversion getYcbcrModel() const { return std::bit_cast<SamplerYcbcrModelConversion>(this->ycbcrModel); }
  void setYcbcrRange(SamplerYcbcrRange value) { this->ycbcrRange = std::bit_cast<VkSamplerYcbcrRange>(value); }
  SamplerYcbcrRange getYcbcrRange() const { return std::bit_cast<SamplerYcbcrRange>(this->ycbcrRange); }
  void setComponents(const ComponentMapping& value) { this->components = value; }
  const ComponentMapping& getComponents() const { return static_cast<const ComponentMapping&>(this->components); }
  void setXChromaOffset(ChromaLocation value) { this->xChromaOffset = std::bit_cast<VkChromaLocation>(value); }
  ChromaLocation getXChromaOffset() const { return std::bit_cast<ChromaLocation>(this->xChromaOffset); }
  void setYChromaOffset(ChromaLocation value) { this->yChromaOffset = std::bit_cast<VkChromaLocation>(value); }
  ChromaLocation getYChromaOffset() const { return std::bit_cast<ChromaLocation>(this->yChromaOffset); }
  void setChromaFilter(Filter value) { this->chromaFilter = std::bit_cast<VkFilter>(value); }
  Filter getChromaFilter() const { return std::bit_cast<Filter>(this->chromaFilter); }

  void setForceExplicitReconstruction(Bool32 value) { this->forceExplicitReconstruction = value; }
  Bool32 getForceExplicitReconstruction() const { return this->forceExplicitReconstruction; }

#if VK_ANDROID_external_memory_android_hardware_buffer
  void attach(struct ExternalFormatANDROID&);
#endif // VK_ANDROID_external_memory_android_hardware_buffer
#if VK_QNX_external_memory_screen_buffer
  void attach(struct ExternalFormatQNX&);
#endif // VK_QNX_external_memory_screen_buffer
#if VK_QCOM_ycbcr_degamma
  void attach(struct SamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM&);
#endif // VK_QCOM_ycbcr_degamma
};
#endif // VK_VERSION_1_1

#if VK_KHR_descriptor_update_template
using DescriptorUpdateTemplateEntryKHR = DescriptorUpdateTemplateEntry;
#endif // VK_KHR_descriptor_update_template
#if VK_VALVE_mutable_descriptor_type
using MutableDescriptorTypeListVALVE = MutableDescriptorTypeListEXT;
#endif // VK_VALVE_mutable_descriptor_type

#if VK_VERSION_1_0
struct PipelineCacheCreateInfo : VkPipelineCacheCreateInfo {
  PipelineCacheCreateInfo() noexcept : VkPipelineCacheCreateInfo{.sType = VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO} {}

  void setFlags(PipelineCacheCreateFlags value) { this->flags = std::bit_cast<VkPipelineCacheCreateFlags>(value); }
  PipelineCacheCreateFlags getFlags() const { return std::bit_cast<PipelineCacheCreateFlags>(this->flags); }
  // Size of initial data to populate cache, in bytes
  void setInitialDataSize(size_t value) { this->initialDataSize = value; }
  size_t getInitialDataSize() const { return this->initialDataSize; }
  // Initial data to populate cache
  void setInitialData(const void* value) { this->pInitialData = value; }
  const void* getInitialData() const { return this->pInitialData; }
};

struct PipelineVertexInputStateCreateInfo : VkPipelineVertexInputStateCreateInfo {
  PipelineVertexInputStateCreateInfo() noexcept : VkPipelineVertexInputStateCreateInfo{.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO} {}

  void setFlags(PipelineVertexInputStateCreateFlags value) { this->flags = std::bit_cast<VkPipelineVertexInputStateCreateFlags>(value); }
  PipelineVertexInputStateCreateFlags getFlags() const { return std::bit_cast<PipelineVertexInputStateCreateFlags>(this->flags); }
  // number of bindings
  void setVertexBindingDescriptionCount(uint32_t value) { this->vertexBindingDescriptionCount = value; }
  uint32_t getVertexBindingDescriptionCount() const { return this->vertexBindingDescriptionCount; }
  void setVertexBindingDescriptions(const VertexInputBindingDescription* value) { this->pVertexBindingDescriptions = std::bit_cast<const VkVertexInputBindingDescription*>(value); }
  const VertexInputBindingDescription* getVertexBindingDescriptions() const { return std::bit_cast<const VertexInputBindingDescription*>(this->pVertexBindingDescriptions); }
  // number of attributes
  void setVertexAttributeDescriptionCount(uint32_t value) { this->vertexAttributeDescriptionCount = value; }
  uint32_t getVertexAttributeDescriptionCount() const { return this->vertexAttributeDescriptionCount; }
  void setVertexAttributeDescriptions(const VertexInputAttributeDescription* value) { this->pVertexAttributeDescriptions = std::bit_cast<const VkVertexInputAttributeDescription*>(value); }
  const VertexInputAttributeDescription* getVertexAttributeDescriptions() const { return std::bit_cast<const VertexInputAttributeDescription*>(this->pVertexAttributeDescriptions); }

#if VK_VERSION_1_4
  void attach(struct PipelineVertexInputDivisorStateCreateInfo&);
#endif // VK_VERSION_1_4
};
#endif // VK_VERSION_1_0

#if VK_EXT_private_data
using PrivateDataSlotCreateInfoEXT = PrivateDataSlotCreateInfo;
#endif // VK_EXT_private_data

#if VK_KHR_pipeline_binary
struct PipelineBinaryKeysAndDataKHR : VkPipelineBinaryKeysAndDataKHR {
  PipelineBinaryKeysAndDataKHR() noexcept : VkPipelineBinaryKeysAndDataKHR{} {}
  PipelineBinaryKeysAndDataKHR(uint32_t binaryCount, const PipelineBinaryKeyKHR* pPipelineBinaryKeys, const PipelineBinaryDataKHR* pPipelineBinaryData) noexcept : VkPipelineBinaryKeysAndDataKHR{.binaryCount = binaryCount, .pPipelineBinaryKeys = std::bit_cast<const VkPipelineBinaryKeyKHR*>(pPipelineBinaryKeys), .pPipelineBinaryData = std::bit_cast<const VkPipelineBinaryDataKHR*>(pPipelineBinaryData)} {}

  void setBinaryCount(uint32_t value) { this->binaryCount = value; }
  uint32_t getBinaryCount() const { return this->binaryCount; }
  void setPipelineBinaryKeys(const PipelineBinaryKeyKHR* value) { this->pPipelineBinaryKeys = std::bit_cast<const VkPipelineBinaryKeyKHR*>(value); }
  const PipelineBinaryKeyKHR* getPipelineBinaryKeys() const { return std::bit_cast<const PipelineBinaryKeyKHR*>(this->pPipelineBinaryKeys); }
  void setPipelineBinaryData(const PipelineBinaryDataKHR* value) { this->pPipelineBinaryData = std::bit_cast<const VkPipelineBinaryDataKHR*>(value); }
  const PipelineBinaryDataKHR* getPipelineBinaryData() const { return std::bit_cast<const PipelineBinaryDataKHR*>(this->pPipelineBinaryData); }
};
#endif // VK_KHR_pipeline_binary

#if VK_HUAWEI_hdr_vivid
struct HdrVividDynamicMetadataHUAWEI : VkHdrVividDynamicMetadataHUAWEI {
  HdrVividDynamicMetadataHUAWEI() noexcept : VkHdrVividDynamicMetadataHUAWEI{.sType = VK_STRUCTURE_TYPE_HDR_VIVID_DYNAMIC_METADATA_HUAWEI} {}

  // Specified in bytes
  void setDynamicMetadataSize(size_t value) { this->dynamicMetadataSize = value; }
  size_t getDynamicMetadataSize() const { return this->dynamicMetadataSize; }
  // Binary code of size dynamicMetadataSize
  void setDynamicMetadata(const void* value) { this->pDynamicMetadata = value; }
  const void* getDynamicMetadata() const { return this->pDynamicMetadata; }
};
inline void HdrMetadataEXT::attach(HdrVividDynamicMetadataHUAWEI& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_HUAWEI_hdr_vivid

#if VK_KHR_maintenance5
using RenderingAreaInfoKHR = RenderingAreaInfo;
#endif // VK_KHR_maintenance5
#if VK_KHR_maintenance3
using DescriptorSetLayoutSupportKHR = DescriptorSetLayoutSupport;
#endif // VK_KHR_maintenance3

#if VK_VERSION_1_2
struct DescriptorSetVariableDescriptorCountLayoutSupport : VkDescriptorSetVariableDescriptorCountLayoutSupport {
  DescriptorSetVariableDescriptorCountLayoutSupport() noexcept : VkDescriptorSetVariableDescriptorCountLayoutSupport{.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT} {}

  uint32_t getMaxVariableDescriptorCount() const { return this->maxVariableDescriptorCount; }
};
inline void DescriptorSetLayoutSupport::attach(DescriptorSetVariableDescriptorCountLayoutSupport& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_2

#if VK_KHR_create_renderpass2
using SubpassEndInfoKHR = SubpassEndInfo;
#endif // VK_KHR_create_renderpass2

#if VK_ANDROID_external_format_resolve
struct AndroidHardwareBufferFormatResolvePropertiesANDROID : VkAndroidHardwareBufferFormatResolvePropertiesANDROID {
  AndroidHardwareBufferFormatResolvePropertiesANDROID() noexcept : VkAndroidHardwareBufferFormatResolvePropertiesANDROID{.sType = VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_RESOLVE_PROPERTIES_ANDROID} {}

  Format getColorAttachmentFormat() const { return std::bit_cast<Format>(this->colorAttachmentFormat); }
};
inline void AndroidHardwareBufferPropertiesANDROID::attach(AndroidHardwareBufferFormatResolvePropertiesANDROID& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_ANDROID_external_format_resolve

#if VK_NV_ray_tracing_motion_blur
struct AccelerationStructureGeometryMotionTrianglesDataNV : VkAccelerationStructureGeometryMotionTrianglesDataNV {
  AccelerationStructureGeometryMotionTrianglesDataNV() noexcept : VkAccelerationStructureGeometryMotionTrianglesDataNV{.sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV} {}

  void setVertexData(DeviceOrHostAddressConstKHR value) { this->vertexData = value; }
  DeviceOrHostAddressConstKHR getVertexData() const { return this->vertexData; }
};
inline void AccelerationStructureGeometryTrianglesDataKHR::attach(AccelerationStructureGeometryMotionTrianglesDataNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_ray_tracing_motion_blur

#if VK_KHR_copy_commands2
using BufferCopy2KHR = BufferCopy2;
#endif // VK_KHR_copy_commands2

#if VK_NV_low_latency
struct QueryLowLatencySupportNV : VkQueryLowLatencySupportNV {
  QueryLowLatencySupportNV() noexcept : VkQueryLowLatencySupportNV{.sType = VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV} {}

  void setQueriedLowLatencyData(void* value) { this->pQueriedLowLatencyData = value; }
  void* getQueriedLowLatencyData() const { return this->pQueriedLowLatencyData; }
};
inline void SemaphoreCreateInfo::attach(QueryLowLatencySupportNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_low_latency

#if VK_KHR_external_semaphore_win32
struct ExportSemaphoreWin32HandleInfoKHR : VkExportSemaphoreWin32HandleInfoKHR {
  ExportSemaphoreWin32HandleInfoKHR() noexcept : VkExportSemaphoreWin32HandleInfoKHR{.sType = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR} {}

  void setDwAccess(DWORD value) { this->dwAccess = value; }
  DWORD getDwAccess() const { return this->dwAccess; }
  void setName(LPCWSTR value) { this->name = value; }
  LPCWSTR getName() const { return this->name; }

  void setAttributes(const SECURITY_ATTRIBUTES* value) { this->pAttributes = value; }
  const SECURITY_ATTRIBUTES* getAttributes() const { return this->pAttributes; }
};
inline void SemaphoreCreateInfo::attach(ExportSemaphoreWin32HandleInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_external_semaphore_win32

#if VK_KHR_video_decode_h264
struct VideoDecodeH264SessionParametersAddInfoKHR : VkVideoDecodeH264SessionParametersAddInfoKHR {
  VideoDecodeH264SessionParametersAddInfoKHR() noexcept : VkVideoDecodeH264SessionParametersAddInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR} {}

  void setStdSPSCount(uint32_t value) { this->stdSPSCount = value; }
  uint32_t getStdSPSCount() const { return this->stdSPSCount; }
  void setStdSPSs(const StdVideoH264SequenceParameterSet* value) { this->pStdSPSs = value; }
  const StdVideoH264SequenceParameterSet* getStdSPSs() const { return this->pStdSPSs; }
  void setStdPPSCount(uint32_t value) { this->stdPPSCount = value; }
  uint32_t getStdPPSCount() const { return this->stdPPSCount; }
  // List of Picture Parameters associated with the spsStd, above
  void setStdPPSs(const StdVideoH264PictureParameterSet* value) { this->pStdPPSs = value; }
  const StdVideoH264PictureParameterSet* getStdPPSs() const { return this->pStdPPSs; }
};
inline void VideoSessionParametersUpdateInfoKHR::attach(VideoDecodeH264SessionParametersAddInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_decode_h264

#if VK_KHR_video_decode_h265
struct VideoDecodeH265SessionParametersAddInfoKHR : VkVideoDecodeH265SessionParametersAddInfoKHR {
  VideoDecodeH265SessionParametersAddInfoKHR() noexcept : VkVideoDecodeH265SessionParametersAddInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR} {}

  void setStdVPSCount(uint32_t value) { this->stdVPSCount = value; }
  uint32_t getStdVPSCount() const { return this->stdVPSCount; }
  void setStdVPSs(const StdVideoH265VideoParameterSet* value) { this->pStdVPSs = value; }
  const StdVideoH265VideoParameterSet* getStdVPSs() const { return this->pStdVPSs; }
  void setStdSPSCount(uint32_t value) { this->stdSPSCount = value; }
  uint32_t getStdSPSCount() const { return this->stdSPSCount; }
  void setStdSPSs(const StdVideoH265SequenceParameterSet* value) { this->pStdSPSs = value; }
  const StdVideoH265SequenceParameterSet* getStdSPSs() const { return this->pStdSPSs; }
  void setStdPPSCount(uint32_t value) { this->stdPPSCount = value; }
  uint32_t getStdPPSCount() const { return this->stdPPSCount; }
  // List of Picture Parameters associated with the spsStd, above
  void setStdPPSs(const StdVideoH265PictureParameterSet* value) { this->pStdPPSs = value; }
  const StdVideoH265PictureParameterSet* getStdPPSs() const { return this->pStdPPSs; }
};
inline void VideoSessionParametersUpdateInfoKHR::attach(VideoDecodeH265SessionParametersAddInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_decode_h265

#if VK_KHR_video_encode_h264
struct VideoEncodeH264SessionParametersAddInfoKHR : VkVideoEncodeH264SessionParametersAddInfoKHR {
  VideoEncodeH264SessionParametersAddInfoKHR() noexcept : VkVideoEncodeH264SessionParametersAddInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR} {}

  void setStdSPSCount(uint32_t value) { this->stdSPSCount = value; }
  uint32_t getStdSPSCount() const { return this->stdSPSCount; }
  void setStdSPSs(const StdVideoH264SequenceParameterSet* value) { this->pStdSPSs = value; }
  const StdVideoH264SequenceParameterSet* getStdSPSs() const { return this->pStdSPSs; }
  void setStdPPSCount(uint32_t value) { this->stdPPSCount = value; }
  uint32_t getStdPPSCount() const { return this->stdPPSCount; }
  // List of Picture Parameters associated with the spsStd, above
  void setStdPPSs(const StdVideoH264PictureParameterSet* value) { this->pStdPPSs = value; }
  const StdVideoH264PictureParameterSet* getStdPPSs() const { return this->pStdPPSs; }
};
inline void VideoSessionParametersUpdateInfoKHR::attach(VideoEncodeH264SessionParametersAddInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_encode_h264

#if VK_KHR_video_encode_h265
struct VideoEncodeH265SessionParametersAddInfoKHR : VkVideoEncodeH265SessionParametersAddInfoKHR {
  VideoEncodeH265SessionParametersAddInfoKHR() noexcept : VkVideoEncodeH265SessionParametersAddInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR} {}

  void setStdVPSCount(uint32_t value) { this->stdVPSCount = value; }
  uint32_t getStdVPSCount() const { return this->stdVPSCount; }
  void setStdVPSs(const StdVideoH265VideoParameterSet* value) { this->pStdVPSs = value; }
  const StdVideoH265VideoParameterSet* getStdVPSs() const { return this->pStdVPSs; }
  void setStdSPSCount(uint32_t value) { this->stdSPSCount = value; }
  uint32_t getStdSPSCount() const { return this->stdSPSCount; }
  void setStdSPSs(const StdVideoH265SequenceParameterSet* value) { this->pStdSPSs = value; }
  const StdVideoH265SequenceParameterSet* getStdSPSs() const { return this->pStdSPSs; }
  void setStdPPSCount(uint32_t value) { this->stdPPSCount = value; }
  uint32_t getStdPPSCount() const { return this->stdPPSCount; }
  // List of Picture Parameters associated with the spsStd, above
  void setStdPPSs(const StdVideoH265PictureParameterSet* value) { this->pStdPPSs = value; }
  const StdVideoH265PictureParameterSet* getStdPPSs() const { return this->pStdPPSs; }
};
inline void VideoSessionParametersUpdateInfoKHR::attach(VideoEncodeH265SessionParametersAddInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_encode_h265

#if VK_KHR_video_encode_h264
struct VideoEncodeH264SessionParametersFeedbackInfoKHR : VkVideoEncodeH264SessionParametersFeedbackInfoKHR {
  VideoEncodeH264SessionParametersFeedbackInfoKHR() noexcept : VkVideoEncodeH264SessionParametersFeedbackInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_FEEDBACK_INFO_KHR} {}

  Bool32 getHasStdSPSOverrides() const { return this->hasStdSPSOverrides; }
  Bool32 getHasStdPPSOverrides() const { return this->hasStdPPSOverrides; }
};
#if VK_KHR_video_encode_queue
inline void VideoEncodeSessionParametersFeedbackInfoKHR::attach(VideoEncodeH264SessionParametersFeedbackInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_encode_queue
#endif // VK_KHR_video_encode_h264

#if VK_KHR_video_encode_h265
struct VideoEncodeH265SessionParametersFeedbackInfoKHR : VkVideoEncodeH265SessionParametersFeedbackInfoKHR {
  VideoEncodeH265SessionParametersFeedbackInfoKHR() noexcept : VkVideoEncodeH265SessionParametersFeedbackInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_FEEDBACK_INFO_KHR} {}

  Bool32 getHasStdVPSOverrides() const { return this->hasStdVPSOverrides; }
  Bool32 getHasStdSPSOverrides() const { return this->hasStdSPSOverrides; }
  Bool32 getHasStdPPSOverrides() const { return this->hasStdPPSOverrides; }
};
#if VK_KHR_video_encode_queue
inline void VideoEncodeSessionParametersFeedbackInfoKHR::attach(VideoEncodeH265SessionParametersFeedbackInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_encode_queue
#endif // VK_KHR_video_encode_h265

#if VK_KHR_video_encode_h264
struct VideoEncodeH264RateControlLayerInfoKHR : VkVideoEncodeH264RateControlLayerInfoKHR {
  VideoEncodeH264RateControlLayerInfoKHR() noexcept : VkVideoEncodeH264RateControlLayerInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_LAYER_INFO_KHR} {}

  void setMinQp(const VideoEncodeH264QpKHR& value) { this->minQp = value; }
  const VideoEncodeH264QpKHR& getMinQp() const { return static_cast<const VideoEncodeH264QpKHR&>(this->minQp); }
  void setMaxQp(const VideoEncodeH264QpKHR& value) { this->maxQp = value; }
  const VideoEncodeH264QpKHR& getMaxQp() const { return static_cast<const VideoEncodeH264QpKHR&>(this->maxQp); }
  void setMaxFrameSize(const VideoEncodeH264FrameSizeKHR& value) { this->maxFrameSize = value; }
  const VideoEncodeH264FrameSizeKHR& getMaxFrameSize() const { return static_cast<const VideoEncodeH264FrameSizeKHR&>(this->maxFrameSize); }

  void setUseMinQp(Bool32 value) { this->useMinQp = value; }
  Bool32 getUseMinQp() const { return this->useMinQp; }
  void setUseMaxQp(Bool32 value) { this->useMaxQp = value; }
  Bool32 getUseMaxQp() const { return this->useMaxQp; }
  void setUseMaxFrameSize(Bool32 value) { this->useMaxFrameSize = value; }
  Bool32 getUseMaxFrameSize() const { return this->useMaxFrameSize; }
};
#if VK_KHR_video_encode_queue
inline void VideoEncodeRateControlLayerInfoKHR::attach(VideoEncodeH264RateControlLayerInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_encode_queue
#endif // VK_KHR_video_encode_h264

#if VK_KHR_video_encode_h265
struct VideoEncodeH265RateControlLayerInfoKHR : VkVideoEncodeH265RateControlLayerInfoKHR {
  VideoEncodeH265RateControlLayerInfoKHR() noexcept : VkVideoEncodeH265RateControlLayerInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_LAYER_INFO_KHR} {}

  void setMinQp(const VideoEncodeH265QpKHR& value) { this->minQp = value; }
  const VideoEncodeH265QpKHR& getMinQp() const { return static_cast<const VideoEncodeH265QpKHR&>(this->minQp); }
  void setMaxQp(const VideoEncodeH265QpKHR& value) { this->maxQp = value; }
  const VideoEncodeH265QpKHR& getMaxQp() const { return static_cast<const VideoEncodeH265QpKHR&>(this->maxQp); }
  void setMaxFrameSize(const VideoEncodeH265FrameSizeKHR& value) { this->maxFrameSize = value; }
  const VideoEncodeH265FrameSizeKHR& getMaxFrameSize() const { return static_cast<const VideoEncodeH265FrameSizeKHR&>(this->maxFrameSize); }

  void setUseMinQp(Bool32 value) { this->useMinQp = value; }
  Bool32 getUseMinQp() const { return this->useMinQp; }
  void setUseMaxQp(Bool32 value) { this->useMaxQp = value; }
  Bool32 getUseMaxQp() const { return this->useMaxQp; }
  void setUseMaxFrameSize(Bool32 value) { this->useMaxFrameSize = value; }
  Bool32 getUseMaxFrameSize() const { return this->useMaxFrameSize; }
};
#if VK_KHR_video_encode_queue
inline void VideoEncodeRateControlLayerInfoKHR::attach(VideoEncodeH265RateControlLayerInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_encode_queue
#endif // VK_KHR_video_encode_h265

#if VK_KHR_video_encode_av1
struct VideoEncodeAV1RateControlLayerInfoKHR : VkVideoEncodeAV1RateControlLayerInfoKHR {
  VideoEncodeAV1RateControlLayerInfoKHR() noexcept : VkVideoEncodeAV1RateControlLayerInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_LAYER_INFO_KHR} {}

  void setMinQIndex(const VideoEncodeAV1QIndexKHR& value) { this->minQIndex = value; }
  const VideoEncodeAV1QIndexKHR& getMinQIndex() const { return static_cast<const VideoEncodeAV1QIndexKHR&>(this->minQIndex); }
  void setMaxQIndex(const VideoEncodeAV1QIndexKHR& value) { this->maxQIndex = value; }
  const VideoEncodeAV1QIndexKHR& getMaxQIndex() const { return static_cast<const VideoEncodeAV1QIndexKHR&>(this->maxQIndex); }
  void setMaxFrameSize(const VideoEncodeAV1FrameSizeKHR& value) { this->maxFrameSize = value; }
  const VideoEncodeAV1FrameSizeKHR& getMaxFrameSize() const { return static_cast<const VideoEncodeAV1FrameSizeKHR&>(this->maxFrameSize); }

  void setUseMinQIndex(Bool32 value) { this->useMinQIndex = value; }
  Bool32 getUseMinQIndex() const { return this->useMinQIndex; }
  void setUseMaxQIndex(Bool32 value) { this->useMaxQIndex = value; }
  Bool32 getUseMaxQIndex() const { return this->useMaxQIndex; }
  void setUseMaxFrameSize(Bool32 value) { this->useMaxFrameSize = value; }
  Bool32 getUseMaxFrameSize() const { return this->useMaxFrameSize; }
};
inline void VideoEncodeRateControlLayerInfoKHR::attach(VideoEncodeAV1RateControlLayerInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_encode_av1

#if VK_NVX_binary_import
struct CuModuleTexturingModeCreateInfoNVX : VkCuModuleTexturingModeCreateInfoNVX {
  CuModuleTexturingModeCreateInfoNVX() noexcept : VkCuModuleTexturingModeCreateInfoNVX{.sType = VK_STRUCTURE_TYPE_CU_MODULE_TEXTURING_MODE_CREATE_INFO_NVX} {}

  void setUse64bitTexturing(Bool32 value) { this->use64bitTexturing = value; }
  Bool32 getUse64bitTexturing() const { return this->use64bitTexturing; }
};
inline void CuModuleCreateInfoNVX::attach(CuModuleTexturingModeCreateInfoNVX& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NVX_binary_import

#if VK_EXT_fragment_density_map_offset
struct RenderPassFragmentDensityMapOffsetEndInfoEXT : VkRenderPassFragmentDensityMapOffsetEndInfoEXT {
  RenderPassFragmentDensityMapOffsetEndInfoEXT() noexcept : VkRenderPassFragmentDensityMapOffsetEndInfoEXT{.sType = VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_EXT} {}

  void setFragmentDensityOffsetCount(uint32_t value) { this->fragmentDensityOffsetCount = value; }
  uint32_t getFragmentDensityOffsetCount() const { return this->fragmentDensityOffsetCount; }
  void setFragmentDensityOffsets(const Offset2D* value) { this->pFragmentDensityOffsets = std::bit_cast<const VkOffset2D*>(value); }
  const Offset2D* getFragmentDensityOffsets() const { return std::bit_cast<const Offset2D*>(this->pFragmentDensityOffsets); }
};
inline void SubpassEndInfo::attach(RenderPassFragmentDensityMapOffsetEndInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void RenderingEndInfoEXT::attach(RenderPassFragmentDensityMapOffsetEndInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_fragment_density_map_offset

#if VK_EXT_metal_objects
struct ExportMetalDeviceInfoEXT : VkExportMetalDeviceInfoEXT {
  ExportMetalDeviceInfoEXT() noexcept : VkExportMetalDeviceInfoEXT{.sType = VK_STRUCTURE_TYPE_EXPORT_METAL_DEVICE_INFO_EXT} {}

  void setMtlDevice(MTLDevice_id value) { this->mtlDevice = value; }
  MTLDevice_id getMtlDevice() const { return this->mtlDevice; }
};
inline void ExportMetalObjectsInfoEXT::attach(ExportMetalDeviceInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_metal_objects

#if VK_NV_low_latency2
struct GetLatencyMarkerInfoNV : VkGetLatencyMarkerInfoNV {
  GetLatencyMarkerInfoNV() noexcept : VkGetLatencyMarkerInfoNV{.sType = VK_STRUCTURE_TYPE_GET_LATENCY_MARKER_INFO_NV} {}

  void setTimingCount(uint32_t value) { this->timingCount = value; }
  uint32_t getTimingCount() const { return this->timingCount; }
  void setTimings(LatencyTimingsFrameReportNV* value) { this->pTimings = std::bit_cast<VkLatencyTimingsFrameReportNV*>(value); }
  LatencyTimingsFrameReportNV* getTimings() const { return std::bit_cast<LatencyTimingsFrameReportNV*>(this->pTimings); }
};
#endif // VK_NV_low_latency2

#if VK_NV_external_compute_queue
struct ExternalComputeQueueNV : Handle<VkExternalComputeQueueNV, ObjectType::eExternalComputeQueueNV> {
  void getExternalComputeQueueDataNV(ExternalComputeQueueDataParamsNV* params, void* pData) const { vkGetExternalComputeQueueDataNV(this->handle, std::bit_cast<VkExternalComputeQueueDataParamsNV*>(params), pData); }
};
#endif // VK_NV_external_compute_queue

#if VK_OHOS_surface
using SurfaceCreateInfoOHOS = OHSurfaceCreateInfoOHOS;
#endif // VK_OHOS_surface

#if VK_ARM_data_graph
struct DataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM : VkDataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM {
  DataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM() noexcept : VkDataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM{.sType = VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CONSTANT_TENSOR_SEMI_STRUCTURED_SPARSITY_INFO_ARM} {}

  void setDimension(uint32_t value) { this->dimension = value; }
  uint32_t getDimension() const { return this->dimension; }
  void setZeroCount(uint32_t value) { this->zeroCount = value; }
  uint32_t getZeroCount() const { return this->zeroCount; }
  void setGroupSize(uint32_t value) { this->groupSize = value; }
  uint32_t getGroupSize() const { return this->groupSize; }
};
inline void DataGraphPipelineConstantARM::attach(DataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_ARM_data_graph

#if VK_ANDROID_external_memory_android_hardware_buffer
struct ImportAndroidHardwareBufferInfoANDROID : VkImportAndroidHardwareBufferInfoANDROID {
  ImportAndroidHardwareBufferInfoANDROID() noexcept : VkImportAndroidHardwareBufferInfoANDROID{.sType = VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID} {}

  void setbuffer(struct AHardwareBuffer* value) { this->buffer = value; }
  struct AHardwareBuffer* getbuffer() const { return this->buffer; }
};
inline void MemoryAllocateInfo::attach(ImportAndroidHardwareBufferInfoANDROID& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_ANDROID_external_memory_android_hardware_buffer

#if VK_EXT_memory_priority
struct MemoryPriorityAllocateInfoEXT : VkMemoryPriorityAllocateInfoEXT {
  MemoryPriorityAllocateInfoEXT() noexcept : VkMemoryPriorityAllocateInfoEXT{.sType = VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT} {}

  void setPriority(float value) { this->priority = value; }
  float getPriority() const { return this->priority; }
};
inline void MemoryAllocateInfo::attach(MemoryPriorityAllocateInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_memory_priority

#if VK_VERSION_1_2
struct MemoryOpaqueCaptureAddressAllocateInfo : VkMemoryOpaqueCaptureAddressAllocateInfo {
  MemoryOpaqueCaptureAddressAllocateInfo() noexcept : VkMemoryOpaqueCaptureAddressAllocateInfo{.sType = VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO} {}

  void setOpaqueCaptureAddress(uint64_t value) { this->opaqueCaptureAddress = value; }
  uint64_t getOpaqueCaptureAddress() const { return this->opaqueCaptureAddress; }
};
inline void MemoryAllocateInfo::attach(MemoryOpaqueCaptureAddressAllocateInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_2

#if VK_EXT_external_memory_host
struct ImportMemoryHostPointerInfoEXT : VkImportMemoryHostPointerInfoEXT {
  ImportMemoryHostPointerInfoEXT() noexcept : VkImportMemoryHostPointerInfoEXT{.sType = VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT} {}

  void setHandleType(ExternalMemoryHandleTypeFlagBits value) { this->handleType = std::bit_cast<VkExternalMemoryHandleTypeFlagBits>(value); }
  ExternalMemoryHandleTypeFlagBits getHandleType() const { return std::bit_cast<ExternalMemoryHandleTypeFlagBits>(this->handleType); }
  void setHostPointer(void* value) { this->pHostPointer = value; }
  void* getHostPointer() const { return this->pHostPointer; }
};
inline void MemoryAllocateInfo::attach(ImportMemoryHostPointerInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_external_memory_host

#if VK_EXT_metal_objects
struct ImportMetalBufferInfoEXT : VkImportMetalBufferInfoEXT {
  ImportMetalBufferInfoEXT() noexcept : VkImportMetalBufferInfoEXT{.sType = VK_STRUCTURE_TYPE_IMPORT_METAL_BUFFER_INFO_EXT} {}

  void setMtlBuffer(MTLBuffer_id value) { this->mtlBuffer = value; }
  MTLBuffer_id getMtlBuffer() const { return this->mtlBuffer; }
};
inline void MemoryAllocateInfo::attach(ImportMetalBufferInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_metal_objects

#if VK_QNX_external_memory_screen_buffer
struct ImportScreenBufferInfoQNX : VkImportScreenBufferInfoQNX {
  ImportScreenBufferInfoQNX() noexcept : VkImportScreenBufferInfoQNX{.sType = VK_STRUCTURE_TYPE_IMPORT_SCREEN_BUFFER_INFO_QNX} {}

  void setbuffer(struct _screen_buffer* value) { this->buffer = value; }
  struct _screen_buffer* getbuffer() const { return this->buffer; }
};
inline void MemoryAllocateInfo::attach(ImportScreenBufferInfoQNX& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_QNX_external_memory_screen_buffer

#if VK_KHR_external_memory_win32
struct ImportMemoryWin32HandleInfoKHR : VkImportMemoryWin32HandleInfoKHR {
  ImportMemoryWin32HandleInfoKHR() noexcept : VkImportMemoryWin32HandleInfoKHR{.sType = VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR} {}

  void setHandleType(ExternalMemoryHandleTypeFlagBits value) { this->handleType = std::bit_cast<VkExternalMemoryHandleTypeFlagBits>(value); }
  ExternalMemoryHandleTypeFlagBits getHandleType() const { return std::bit_cast<ExternalMemoryHandleTypeFlagBits>(this->handleType); }
  void setHandle(HANDLE value) { this->handle = value; }
  HANDLE getHandle() const { return this->handle; }
  void setName(LPCWSTR value) { this->name = value; }
  LPCWSTR getName() const { return this->name; }
};
inline void MemoryAllocateInfo::attach(ImportMemoryWin32HandleInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }

struct ExportMemoryWin32HandleInfoKHR : VkExportMemoryWin32HandleInfoKHR {
  ExportMemoryWin32HandleInfoKHR() noexcept : VkExportMemoryWin32HandleInfoKHR{.sType = VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR} {}

  void setDwAccess(DWORD value) { this->dwAccess = value; }
  DWORD getDwAccess() const { return this->dwAccess; }
  void setName(LPCWSTR value) { this->name = value; }
  LPCWSTR getName() const { return this->name; }

  void setAttributes(const SECURITY_ATTRIBUTES* value) { this->pAttributes = value; }
  const SECURITY_ATTRIBUTES* getAttributes() const { return this->pAttributes; }
};
inline void MemoryAllocateInfo::attach(ExportMemoryWin32HandleInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_external_memory_win32

#if VK_FUCHSIA_external_memory
struct ImportMemoryZirconHandleInfoFUCHSIA : VkImportMemoryZirconHandleInfoFUCHSIA {
  ImportMemoryZirconHandleInfoFUCHSIA() noexcept : VkImportMemoryZirconHandleInfoFUCHSIA{.sType = VK_STRUCTURE_TYPE_IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA} {}

  void setHandleType(ExternalMemoryHandleTypeFlagBits value) { this->handleType = std::bit_cast<VkExternalMemoryHandleTypeFlagBits>(value); }
  ExternalMemoryHandleTypeFlagBits getHandleType() const { return std::bit_cast<ExternalMemoryHandleTypeFlagBits>(this->handleType); }
  void setHandle(zx_handle_t value) { this->handle = value; }
  zx_handle_t getHandle() const { return this->handle; }
};
inline void MemoryAllocateInfo::attach(ImportMemoryZirconHandleInfoFUCHSIA& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_FUCHSIA_external_memory

#if VK_KHR_external_memory_fd
struct ImportMemoryFdInfoKHR : VkImportMemoryFdInfoKHR {
  ImportMemoryFdInfoKHR() noexcept : VkImportMemoryFdInfoKHR{.sType = VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR} {}

  void setFd(int value) { this->fd = value; }
  int getFd() const { return this->fd; }

  void setHandleType(ExternalMemoryHandleTypeFlagBits value) { this->handleType = std::bit_cast<VkExternalMemoryHandleTypeFlagBits>(value); }
  ExternalMemoryHandleTypeFlagBits getHandleType() const { return std::bit_cast<ExternalMemoryHandleTypeFlagBits>(this->handleType); }
};
inline void MemoryAllocateInfo::attach(ImportMemoryFdInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_external_memory_fd

#if VK_EXT_external_memory_metal
struct ImportMemoryMetalHandleInfoEXT : VkImportMemoryMetalHandleInfoEXT {
  ImportMemoryMetalHandleInfoEXT() noexcept : VkImportMemoryMetalHandleInfoEXT{.sType = VK_STRUCTURE_TYPE_IMPORT_MEMORY_METAL_HANDLE_INFO_EXT} {}

  void setHandleType(ExternalMemoryHandleTypeFlagBits value) { this->handleType = std::bit_cast<VkExternalMemoryHandleTypeFlagBits>(value); }
  ExternalMemoryHandleTypeFlagBits getHandleType() const { return std::bit_cast<ExternalMemoryHandleTypeFlagBits>(this->handleType); }
  void sethandle(void* value) { this->handle = value; }
  void* gethandle() const { return this->handle; }
};
inline void MemoryAllocateInfo::attach(ImportMemoryMetalHandleInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_external_memory_metal

#if VK_VERSION_1_1
struct PipelineTessellationDomainOriginStateCreateInfo : VkPipelineTessellationDomainOriginStateCreateInfo {
  PipelineTessellationDomainOriginStateCreateInfo() noexcept : VkPipelineTessellationDomainOriginStateCreateInfo{.sType = VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO} {}

  void setDomainOrigin(TessellationDomainOrigin value) { this->domainOrigin = std::bit_cast<VkTessellationDomainOrigin>(value); }
  TessellationDomainOrigin getDomainOrigin() const { return std::bit_cast<TessellationDomainOrigin>(this->domainOrigin); }
};
inline void PipelineTessellationStateCreateInfo::attach(PipelineTessellationDomainOriginStateCreateInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_1

#if VK_KHR_create_renderpass2
using SubpassBeginInfoKHR = SubpassBeginInfo;
#endif // VK_KHR_create_renderpass2

#if VK_VERSION_1_2
struct DeviceMemoryOpaqueCaptureAddressInfo : VkDeviceMemoryOpaqueCaptureAddressInfo {
  DeviceMemoryOpaqueCaptureAddressInfo() noexcept : VkDeviceMemoryOpaqueCaptureAddressInfo{.sType = VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO} {}

  void setMemory(DeviceMemory value) { this->memory = std::bit_cast<VkDeviceMemory>(value); }
  DeviceMemory getMemory() const { return std::bit_cast<DeviceMemory>(this->memory); }
};
#endif // VK_VERSION_1_2

#if VK_KHR_video_queue
struct BindVideoSessionMemoryInfoKHR : VkBindVideoSessionMemoryInfoKHR {
  BindVideoSessionMemoryInfoKHR() noexcept : VkBindVideoSessionMemoryInfoKHR{.sType = VK_STRUCTURE_TYPE_BIND_VIDEO_SESSION_MEMORY_INFO_KHR} {}

  void setMemoryBindIndex(uint32_t value) { this->memoryBindIndex = value; }
  uint32_t getMemoryBindIndex() const { return this->memoryBindIndex; }
  void setMemory(DeviceMemory value) { this->memory = std::bit_cast<VkDeviceMemory>(value); }
  DeviceMemory getMemory() const { return std::bit_cast<DeviceMemory>(this->memory); }
  void setMemoryOffset(DeviceSize value) { this->memoryOffset = value; }
  DeviceSize getMemoryOffset() const { return this->memoryOffset; }
  void setMemorySize(DeviceSize value) { this->memorySize = value; }
  DeviceSize getMemorySize() const { return this->memorySize; }
};
#endif // VK_KHR_video_queue

#if VK_NV_external_memory_rdma
struct MemoryGetRemoteAddressInfoNV : VkMemoryGetRemoteAddressInfoNV {
  MemoryGetRemoteAddressInfoNV() noexcept : VkMemoryGetRemoteAddressInfoNV{.sType = VK_STRUCTURE_TYPE_MEMORY_GET_REMOTE_ADDRESS_INFO_NV} {}

  void setMemory(DeviceMemory value) { this->memory = std::bit_cast<VkDeviceMemory>(value); }
  DeviceMemory getMemory() const { return std::bit_cast<DeviceMemory>(this->memory); }
  void setHandleType(ExternalMemoryHandleTypeFlagBits value) { this->handleType = std::bit_cast<VkExternalMemoryHandleTypeFlagBits>(value); }
  ExternalMemoryHandleTypeFlagBits getHandleType() const { return std::bit_cast<ExternalMemoryHandleTypeFlagBits>(this->handleType); }
};
#endif // VK_NV_external_memory_rdma

#if VK_EXT_metal_objects
struct ExportMetalBufferInfoEXT : VkExportMetalBufferInfoEXT {
  ExportMetalBufferInfoEXT() noexcept : VkExportMetalBufferInfoEXT{.sType = VK_STRUCTURE_TYPE_EXPORT_METAL_BUFFER_INFO_EXT} {}

  void setMemory(DeviceMemory value) { this->memory = std::bit_cast<VkDeviceMemory>(value); }
  DeviceMemory getMemory() const { return std::bit_cast<DeviceMemory>(this->memory); }
  void setMtlBuffer(MTLBuffer_id value) { this->mtlBuffer = value; }
  MTLBuffer_id getMtlBuffer() const { return this->mtlBuffer; }
};
inline void ExportMetalObjectsInfoEXT::attach(ExportMetalBufferInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_metal_objects

#if VK_FUCHSIA_external_memory
struct MemoryGetZirconHandleInfoFUCHSIA : VkMemoryGetZirconHandleInfoFUCHSIA {
  MemoryGetZirconHandleInfoFUCHSIA() noexcept : VkMemoryGetZirconHandleInfoFUCHSIA{.sType = VK_STRUCTURE_TYPE_MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA} {}

  void setMemory(DeviceMemory value) { this->memory = std::bit_cast<VkDeviceMemory>(value); }
  DeviceMemory getMemory() const { return std::bit_cast<DeviceMemory>(this->memory); }
  void setHandleType(ExternalMemoryHandleTypeFlagBits value) { this->handleType = std::bit_cast<VkExternalMemoryHandleTypeFlagBits>(value); }
  ExternalMemoryHandleTypeFlagBits getHandleType() const { return std::bit_cast<ExternalMemoryHandleTypeFlagBits>(this->handleType); }
};
#endif // VK_FUCHSIA_external_memory

#if VK_KHR_external_memory_win32
struct MemoryGetWin32HandleInfoKHR : VkMemoryGetWin32HandleInfoKHR {
  MemoryGetWin32HandleInfoKHR() noexcept : VkMemoryGetWin32HandleInfoKHR{.sType = VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR} {}

  void setMemory(DeviceMemory value) { this->memory = std::bit_cast<VkDeviceMemory>(value); }
  DeviceMemory getMemory() const { return std::bit_cast<DeviceMemory>(this->memory); }
  void setHandleType(ExternalMemoryHandleTypeFlagBits value) { this->handleType = std::bit_cast<VkExternalMemoryHandleTypeFlagBits>(value); }
  ExternalMemoryHandleTypeFlagBits getHandleType() const { return std::bit_cast<ExternalMemoryHandleTypeFlagBits>(this->handleType); }
};
#endif // VK_KHR_external_memory_win32

#if VK_KHR_external_memory_fd
struct MemoryGetFdInfoKHR : VkMemoryGetFdInfoKHR {
  MemoryGetFdInfoKHR() noexcept : VkMemoryGetFdInfoKHR{.sType = VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR} {}

  void setMemory(DeviceMemory value) { this->memory = std::bit_cast<VkDeviceMemory>(value); }
  DeviceMemory getMemory() const { return std::bit_cast<DeviceMemory>(this->memory); }
  void setHandleType(ExternalMemoryHandleTypeFlagBits value) { this->handleType = std::bit_cast<VkExternalMemoryHandleTypeFlagBits>(value); }
  ExternalMemoryHandleTypeFlagBits getHandleType() const { return std::bit_cast<ExternalMemoryHandleTypeFlagBits>(this->handleType); }
};
#endif // VK_KHR_external_memory_fd

#if VK_ANDROID_external_memory_android_hardware_buffer
struct MemoryGetAndroidHardwareBufferInfoANDROID : VkMemoryGetAndroidHardwareBufferInfoANDROID {
  MemoryGetAndroidHardwareBufferInfoANDROID() noexcept : VkMemoryGetAndroidHardwareBufferInfoANDROID{.sType = VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID} {}

  void setMemory(DeviceMemory value) { this->memory = std::bit_cast<VkDeviceMemory>(value); }
  DeviceMemory getMemory() const { return std::bit_cast<DeviceMemory>(this->memory); }
};
#endif // VK_ANDROID_external_memory_android_hardware_buffer

#if VK_EXT_external_memory_metal
struct MemoryGetMetalHandleInfoEXT : VkMemoryGetMetalHandleInfoEXT {
  MemoryGetMetalHandleInfoEXT() noexcept : VkMemoryGetMetalHandleInfoEXT{.sType = VK_STRUCTURE_TYPE_MEMORY_GET_METAL_HANDLE_INFO_EXT} {}

  void setMemory(DeviceMemory value) { this->memory = std::bit_cast<VkDeviceMemory>(value); }
  DeviceMemory getMemory() const { return std::bit_cast<DeviceMemory>(this->memory); }
  void setHandleType(ExternalMemoryHandleTypeFlagBits value) { this->handleType = std::bit_cast<VkExternalMemoryHandleTypeFlagBits>(value); }
  ExternalMemoryHandleTypeFlagBits getHandleType() const { return std::bit_cast<ExternalMemoryHandleTypeFlagBits>(this->handleType); }
};
#endif // VK_EXT_external_memory_metal

#if VK_VERSION_1_0
struct MappedMemoryRange : VkMappedMemoryRange {
  MappedMemoryRange() noexcept : VkMappedMemoryRange{.sType = VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE} {}

  // Mapped memory object
  void setMemory(DeviceMemory value) { this->memory = std::bit_cast<VkDeviceMemory>(value); }
  DeviceMemory getMemory() const { return std::bit_cast<DeviceMemory>(this->memory); }
  // Offset within the memory object where the range starts
  void setOffset(DeviceSize value) { this->offset = value; }
  DeviceSize getOffset() const { return this->offset; }
  // Size of the range within the memory object
  void setSize(DeviceSize value) { this->size = value; }
  DeviceSize getSize() const { return this->size; }
};

struct CommandBufferAllocateInfo : VkCommandBufferAllocateInfo {
  CommandBufferAllocateInfo() noexcept : VkCommandBufferAllocateInfo{.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO} {}

  void setCommandPool(CommandPool value) { this->commandPool = std::bit_cast<VkCommandPool>(value); }
  CommandPool getCommandPool() const { return std::bit_cast<CommandPool>(this->commandPool); }
  void setLevel(CommandBufferLevel value) { this->level = std::bit_cast<VkCommandBufferLevel>(value); }
  CommandBufferLevel getLevel() const { return std::bit_cast<CommandBufferLevel>(this->level); }
  void setCommandBufferCount(uint32_t value) { this->commandBufferCount = value; }
  uint32_t getCommandBufferCount() const { return this->commandBufferCount; }
};
#endif // VK_VERSION_1_0

#if VK_VERSION_1_2
struct BufferDeviceAddressInfo : VkBufferDeviceAddressInfo {
  BufferDeviceAddressInfo() noexcept : VkBufferDeviceAddressInfo{.sType = VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO} {}

  void setBuffer(Buffer value) { this->buffer = std::bit_cast<VkBuffer>(value); }
  Buffer getBuffer() const { return std::bit_cast<Buffer>(this->buffer); }
};
#endif // VK_VERSION_1_2

#if VK_VERSION_1_3
struct CopyBufferInfo2 : VkCopyBufferInfo2 {
  CopyBufferInfo2() noexcept : VkCopyBufferInfo2{.sType = VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2} {}

  void setSrcBuffer(Buffer value) { this->srcBuffer = std::bit_cast<VkBuffer>(value); }
  Buffer getSrcBuffer() const { return std::bit_cast<Buffer>(this->srcBuffer); }
  void setDstBuffer(Buffer value) { this->dstBuffer = std::bit_cast<VkBuffer>(value); }
  Buffer getDstBuffer() const { return std::bit_cast<Buffer>(this->dstBuffer); }
  void setRegionCount(uint32_t value) { this->regionCount = value; }
  uint32_t getRegionCount() const { return this->regionCount; }
  void setRegions(const BufferCopy2* value) { this->pRegions = std::bit_cast<const VkBufferCopy2*>(value); }
  const BufferCopy2* getRegions() const { return std::bit_cast<const BufferCopy2*>(this->pRegions); }
};
#endif // VK_VERSION_1_3

#if VK_EXT_descriptor_buffer
struct BufferCaptureDescriptorDataInfoEXT : VkBufferCaptureDescriptorDataInfoEXT {
  BufferCaptureDescriptorDataInfoEXT() noexcept : VkBufferCaptureDescriptorDataInfoEXT{.sType = VK_STRUCTURE_TYPE_BUFFER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT} {}

  void setBuffer(Buffer value) { this->buffer = std::bit_cast<VkBuffer>(value); }
  Buffer getBuffer() const { return std::bit_cast<Buffer>(this->buffer); }
};
#endif // VK_EXT_descriptor_buffer

#if VK_VERSION_1_1
struct BindBufferMemoryInfo : VkBindBufferMemoryInfo {
  BindBufferMemoryInfo() noexcept : VkBindBufferMemoryInfo{.sType = VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO} {}

  void setBuffer(Buffer value) { this->buffer = std::bit_cast<VkBuffer>(value); }
  Buffer getBuffer() const { return std::bit_cast<Buffer>(this->buffer); }
  void setMemory(DeviceMemory value) { this->memory = std::bit_cast<VkDeviceMemory>(value); }
  DeviceMemory getMemory() const { return std::bit_cast<DeviceMemory>(this->memory); }
  void setMemoryOffset(DeviceSize value) { this->memoryOffset = value; }
  DeviceSize getMemoryOffset() const { return this->memoryOffset; }

  void attach(struct BindBufferMemoryDeviceGroupInfo&);
#if VK_VERSION_1_4
  void attach(struct BindMemoryStatus&);
#endif // VK_VERSION_1_4
};
#endif // VK_VERSION_1_1

#if VK_NV_device_generated_commands
struct IndirectCommandsStreamNV : VkIndirectCommandsStreamNV {
  IndirectCommandsStreamNV() noexcept : VkIndirectCommandsStreamNV{} {}
  IndirectCommandsStreamNV(Buffer buffer, DeviceSize offset) noexcept : VkIndirectCommandsStreamNV{.buffer = std::bit_cast<VkBuffer>(buffer), .offset = offset} {}

  void setBuffer(Buffer value) { this->buffer = std::bit_cast<VkBuffer>(value); }
  Buffer getBuffer() const { return std::bit_cast<Buffer>(this->buffer); }
  void setOffset(DeviceSize value) { this->offset = value; }
  DeviceSize getOffset() const { return this->offset; }
};
#endif // VK_NV_device_generated_commands

#if VK_VERSION_1_1
struct BufferMemoryRequirementsInfo2 : VkBufferMemoryRequirementsInfo2 {
  BufferMemoryRequirementsInfo2() noexcept : VkBufferMemoryRequirementsInfo2{.sType = VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2} {}

  void setBuffer(Buffer value) { this->buffer = std::bit_cast<VkBuffer>(value); }
  Buffer getBuffer() const { return std::bit_cast<Buffer>(this->buffer); }
};
#endif // VK_VERSION_1_1

#if VK_VERSION_1_0
struct DescriptorBufferInfo : VkDescriptorBufferInfo {
  DescriptorBufferInfo() noexcept : VkDescriptorBufferInfo{} {}

  // Base offset from buffer start in bytes to update in the descriptor set.
  void setOffset(DeviceSize value) { this->offset = value; }
  DeviceSize getOffset() const { return this->offset; }
  // Size in bytes of the buffer resource for this descriptor update.
  void setRange(DeviceSize value) { this->range = value; }
  DeviceSize getRange() const { return this->range; }

  // Buffer used for this descriptor slot.
  void setBuffer(Buffer value) { this->buffer = std::bit_cast<VkBuffer>(value); }
  Buffer getBuffer() const { return std::bit_cast<Buffer>(this->buffer); }
};

struct BufferViewCreateInfo : VkBufferViewCreateInfo {
  BufferViewCreateInfo() noexcept : VkBufferViewCreateInfo{.sType = VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO} {}

  void setBuffer(Buffer value) { this->buffer = std::bit_cast<VkBuffer>(value); }
  Buffer getBuffer() const { return std::bit_cast<Buffer>(this->buffer); }
  // Optionally specifies format of elements
  void setFormat(Format value) { this->format = std::bit_cast<VkFormat>(value); }
  Format getFormat() const { return std::bit_cast<Format>(this->format); }
  // Specified in bytes
  void setOffset(DeviceSize value) { this->offset = value; }
  DeviceSize getOffset() const { return this->offset; }
  // View size specified in bytes
  void setRange(DeviceSize value) { this->range = value; }
  DeviceSize getRange() const { return this->range; }

  void setFlags(BufferViewCreateFlags value) { this->flags = std::bit_cast<VkBufferViewCreateFlags>(value); }
  BufferViewCreateFlags getFlags() const { return std::bit_cast<BufferViewCreateFlags>(this->flags); }

#if VK_VERSION_1_4
  void attach(struct BufferUsageFlags2CreateInfo&);
#endif // VK_VERSION_1_4
#if VK_EXT_metal_objects
  void attach(struct ExportMetalObjectCreateInfoEXT&);
#endif // VK_EXT_metal_objects
};
#endif // VK_VERSION_1_0

#if VK_VERSION_1_1
struct ImageSparseMemoryRequirementsInfo2 : VkImageSparseMemoryRequirementsInfo2 {
  ImageSparseMemoryRequirementsInfo2() noexcept : VkImageSparseMemoryRequirementsInfo2{.sType = VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2} {}

  void setImage(Image value) { this->image = std::bit_cast<VkImage>(value); }
  Image getImage() const { return std::bit_cast<Image>(this->image); }
};
#endif // VK_VERSION_1_1

#if VK_EXT_descriptor_buffer
struct ImageCaptureDescriptorDataInfoEXT : VkImageCaptureDescriptorDataInfoEXT {
  ImageCaptureDescriptorDataInfoEXT() noexcept : VkImageCaptureDescriptorDataInfoEXT{.sType = VK_STRUCTURE_TYPE_IMAGE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT} {}

  void setImage(Image value) { this->image = std::bit_cast<VkImage>(value); }
  Image getImage() const { return std::bit_cast<Image>(this->image); }
};
#endif // VK_EXT_descriptor_buffer

#if VK_EXT_metal_objects
struct ExportMetalIOSurfaceInfoEXT : VkExportMetalIOSurfaceInfoEXT {
  ExportMetalIOSurfaceInfoEXT() noexcept : VkExportMetalIOSurfaceInfoEXT{.sType = VK_STRUCTURE_TYPE_EXPORT_METAL_IO_SURFACE_INFO_EXT} {}

  void setImage(Image value) { this->image = std::bit_cast<VkImage>(value); }
  Image getImage() const { return std::bit_cast<Image>(this->image); }
  void setIoSurface(IOSurfaceRef value) { this->ioSurface = value; }
  IOSurfaceRef getIoSurface() const { return this->ioSurface; }
};
inline void ExportMetalObjectsInfoEXT::attach(ExportMetalIOSurfaceInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_metal_objects

#if VK_VERSION_1_1
struct BindImageMemoryInfo : VkBindImageMemoryInfo {
  BindImageMemoryInfo() noexcept : VkBindImageMemoryInfo{.sType = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO} {}

  void setImage(Image value) { this->image = std::bit_cast<VkImage>(value); }
  Image getImage() const { return std::bit_cast<Image>(this->image); }
  void setMemory(DeviceMemory value) { this->memory = std::bit_cast<VkDeviceMemory>(value); }
  DeviceMemory getMemory() const { return std::bit_cast<DeviceMemory>(this->memory); }
  void setMemoryOffset(DeviceSize value) { this->memoryOffset = value; }
  DeviceSize getMemoryOffset() const { return this->memoryOffset; }

  void attach(struct BindImageMemoryDeviceGroupInfo&);
#if VK_KHR_swapchain
  void attach(struct BindImageMemorySwapchainInfoKHR&);
#endif // VK_KHR_swapchain
  void attach(struct BindImagePlaneMemoryInfo&);
#if VK_VERSION_1_4
  void attach(struct BindMemoryStatus&);
#endif // VK_VERSION_1_4
};

struct ImageMemoryRequirementsInfo2 : VkImageMemoryRequirementsInfo2 {
  ImageMemoryRequirementsInfo2() noexcept : VkImageMemoryRequirementsInfo2{.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2} {}

  void setImage(Image value) { this->image = std::bit_cast<VkImage>(value); }
  Image getImage() const { return std::bit_cast<Image>(this->image); }

  void attach(struct ImagePlaneMemoryRequirementsInfo&);
};

struct MemoryDedicatedAllocateInfo : VkMemoryDedicatedAllocateInfo {
  MemoryDedicatedAllocateInfo() noexcept : VkMemoryDedicatedAllocateInfo{.sType = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO} {}

  // Image that this allocation will be bound to
  void setImage(Image value) { this->image = std::bit_cast<VkImage>(value); }
  Image getImage() const { return std::bit_cast<Image>(this->image); }
  // Buffer that this allocation will be bound to
  void setBuffer(Buffer value) { this->buffer = std::bit_cast<VkBuffer>(value); }
  Buffer getBuffer() const { return std::bit_cast<Buffer>(this->buffer); }
};
inline void MemoryAllocateInfo::attach(MemoryDedicatedAllocateInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_1

#if VK_KHR_video_queue
struct VideoPictureResourceInfoKHR : VkVideoPictureResourceInfoKHR {
  VideoPictureResourceInfoKHR() noexcept : VkVideoPictureResourceInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR} {}

  // The offset to be used for the picture resource, currently only used in field mode
  void setCodedOffset(const Offset2D& value) { this->codedOffset = value; }
  const Offset2D& getCodedOffset() const { return static_cast<const Offset2D&>(this->codedOffset); }
  // The extent to be used for the picture resource
  void setCodedExtent(const Extent2D& value) { this->codedExtent = value; }
  const Extent2D& getCodedExtent() const { return static_cast<const Extent2D&>(this->codedExtent); }
  // The first array layer to be accessed for the Decode or Encode Operations
  void setBaseArrayLayer(uint32_t value) { this->baseArrayLayer = value; }
  uint32_t getBaseArrayLayer() const { return this->baseArrayLayer; }
  // The ImageView binding of the resource
  void setImageViewBinding(ImageView value) { this->imageViewBinding = std::bit_cast<VkImageView>(value); }
  ImageView getImageViewBinding() const { return std::bit_cast<ImageView>(this->imageViewBinding); }
};
#endif // VK_KHR_video_queue

#if VK_EXT_descriptor_buffer
struct ImageViewCaptureDescriptorDataInfoEXT : VkImageViewCaptureDescriptorDataInfoEXT {
  ImageViewCaptureDescriptorDataInfoEXT() noexcept : VkImageViewCaptureDescriptorDataInfoEXT{.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_EXT} {}

  void setImageView(ImageView value) { this->imageView = std::bit_cast<VkImageView>(value); }
  ImageView getImageView() const { return std::bit_cast<ImageView>(this->imageView); }
};
#endif // VK_EXT_descriptor_buffer

#if VK_VERSION_1_3
struct RenderingAttachmentInfo : VkRenderingAttachmentInfo {
  RenderingAttachmentInfo() noexcept : VkRenderingAttachmentInfo{.sType = VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO} {}

  void setImageLayout(ImageLayout value) { this->imageLayout = std::bit_cast<VkImageLayout>(value); }
  ImageLayout getImageLayout() const { return std::bit_cast<ImageLayout>(this->imageLayout); }
  void setResolveImageLayout(ImageLayout value) { this->resolveImageLayout = std::bit_cast<VkImageLayout>(value); }
  ImageLayout getResolveImageLayout() const { return std::bit_cast<ImageLayout>(this->resolveImageLayout); }
  void setLoadOp(AttachmentLoadOp value) { this->loadOp = std::bit_cast<VkAttachmentLoadOp>(value); }
  AttachmentLoadOp getLoadOp() const { return std::bit_cast<AttachmentLoadOp>(this->loadOp); }
  void setStoreOp(AttachmentStoreOp value) { this->storeOp = std::bit_cast<VkAttachmentStoreOp>(value); }
  AttachmentStoreOp getStoreOp() const { return std::bit_cast<AttachmentStoreOp>(this->storeOp); }
  void setClearValue(ClearValue value) { this->clearValue = value; }
  ClearValue getClearValue() const { return this->clearValue; }

  void setImageView(ImageView value) { this->imageView = std::bit_cast<VkImageView>(value); }
  ImageView getImageView() const { return std::bit_cast<ImageView>(this->imageView); }
  void setResolveMode(ResolveModeFlagBits value) { this->resolveMode = std::bit_cast<VkResolveModeFlagBits>(value); }
  ResolveModeFlagBits getResolveMode() const { return std::bit_cast<ResolveModeFlagBits>(this->resolveMode); }
  void setResolveImageView(ImageView value) { this->resolveImageView = std::bit_cast<VkImageView>(value); }
  ImageView getResolveImageView() const { return std::bit_cast<ImageView>(this->resolveImageView); }

};
#endif // VK_VERSION_1_3

#if VK_EXT_metal_objects
struct ExportMetalTextureInfoEXT : VkExportMetalTextureInfoEXT {
  ExportMetalTextureInfoEXT() noexcept : VkExportMetalTextureInfoEXT{.sType = VK_STRUCTURE_TYPE_EXPORT_METAL_TEXTURE_INFO_EXT} {}

  void setPlane(ImageAspectFlagBits value) { this->plane = std::bit_cast<VkImageAspectFlagBits>(value); }
  ImageAspectFlagBits getPlane() const { return std::bit_cast<ImageAspectFlagBits>(this->plane); }
  void setMtlTexture(MTLTexture_id value) { this->mtlTexture = value; }
  MTLTexture_id getMtlTexture() const { return this->mtlTexture; }

  void setImage(Image value) { this->image = std::bit_cast<VkImage>(value); }
  Image getImage() const { return std::bit_cast<Image>(this->image); }
  void setImageView(ImageView value) { this->imageView = std::bit_cast<VkImageView>(value); }
  ImageView getImageView() const { return std::bit_cast<ImageView>(this->imageView); }
  void setBufferView(BufferView value) { this->bufferView = std::bit_cast<VkBufferView>(value); }
  BufferView getBufferView() const { return std::bit_cast<BufferView>(this->bufferView); }
};
inline void ExportMetalObjectsInfoEXT::attach(ExportMetalTextureInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_metal_objects

#if VK_KHR_pipeline_binary
struct ReleaseCapturedPipelineDataInfoKHR : VkReleaseCapturedPipelineDataInfoKHR {
  ReleaseCapturedPipelineDataInfoKHR() noexcept : VkReleaseCapturedPipelineDataInfoKHR{.sType = VK_STRUCTURE_TYPE_RELEASE_CAPTURED_PIPELINE_DATA_INFO_KHR} {}

  void setPipeline(Pipeline value) { this->pipeline = std::bit_cast<VkPipeline>(value); }
  Pipeline getPipeline() const { return std::bit_cast<Pipeline>(this->pipeline); }
};
#endif // VK_KHR_pipeline_binary

#if VK_KHR_pipeline_executable_properties
struct PipelineInfoKHR : VkPipelineInfoKHR {
  PipelineInfoKHR() noexcept : VkPipelineInfoKHR{.sType = VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR} {}

  void setPipeline(Pipeline value) { this->pipeline = std::bit_cast<VkPipeline>(value); }
  Pipeline getPipeline() const { return std::bit_cast<Pipeline>(this->pipeline); }
};

struct PipelineExecutableInfoKHR : VkPipelineExecutableInfoKHR {
  PipelineExecutableInfoKHR() noexcept : VkPipelineExecutableInfoKHR{.sType = VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR} {}

  void setPipeline(Pipeline value) { this->pipeline = std::bit_cast<VkPipeline>(value); }
  Pipeline getPipeline() const { return std::bit_cast<Pipeline>(this->pipeline); }
  void setExecutableIndex(uint32_t value) { this->executableIndex = value; }
  uint32_t getExecutableIndex() const { return this->executableIndex; }
};
#endif // VK_KHR_pipeline_executable_properties

#if VK_EXT_device_generated_commands
struct IndirectExecutionSetPipelineInfoEXT : VkIndirectExecutionSetPipelineInfoEXT {
  IndirectExecutionSetPipelineInfoEXT() noexcept : VkIndirectExecutionSetPipelineInfoEXT{.sType = VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_PIPELINE_INFO_EXT} {}

  void setInitialPipeline(Pipeline value) { this->initialPipeline = std::bit_cast<VkPipeline>(value); }
  Pipeline getInitialPipeline() const { return std::bit_cast<Pipeline>(this->initialPipeline); }
  void setMaxPipelineCount(uint32_t value) { this->maxPipelineCount = value; }
  uint32_t getMaxPipelineCount() const { return this->maxPipelineCount; }
};

struct WriteIndirectExecutionSetPipelineEXT : VkWriteIndirectExecutionSetPipelineEXT {
  WriteIndirectExecutionSetPipelineEXT() noexcept : VkWriteIndirectExecutionSetPipelineEXT{.sType = VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_PIPELINE_EXT} {}

  void setIndex(uint32_t value) { this->index = value; }
  uint32_t getIndex() const { return this->index; }
  void setPipeline(Pipeline value) { this->pipeline = std::bit_cast<VkPipeline>(value); }
  Pipeline getPipeline() const { return std::bit_cast<Pipeline>(this->pipeline); }
};
#endif // VK_EXT_device_generated_commands

#if VK_NV_device_generated_commands_compute
struct PipelineIndirectDeviceAddressInfoNV : VkPipelineIndirectDeviceAddressInfoNV {
  PipelineIndirectDeviceAddressInfoNV() noexcept : VkPipelineIndirectDeviceAddressInfoNV{.sType = VK_STRUCTURE_TYPE_PIPELINE_INDIRECT_DEVICE_ADDRESS_INFO_NV} {}

  void setPipelineBindPoint(PipelineBindPoint value) { this->pipelineBindPoint = std::bit_cast<VkPipelineBindPoint>(value); }
  PipelineBindPoint getPipelineBindPoint() const { return std::bit_cast<PipelineBindPoint>(this->pipelineBindPoint); }
  void setPipeline(Pipeline value) { this->pipeline = std::bit_cast<VkPipeline>(value); }
  Pipeline getPipeline() const { return std::bit_cast<Pipeline>(this->pipeline); }
};
#endif // VK_NV_device_generated_commands_compute

#if VK_ARM_data_graph
struct DataGraphPipelineInfoARM : VkDataGraphPipelineInfoARM {
  DataGraphPipelineInfoARM() noexcept : VkDataGraphPipelineInfoARM{.sType = VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_INFO_ARM} {}

  void setDataGraphPipeline(Pipeline value) { this->dataGraphPipeline = std::bit_cast<VkPipeline>(value); }
  Pipeline getDataGraphPipeline() const { return std::bit_cast<Pipeline>(this->dataGraphPipeline); }
};
#endif // VK_ARM_data_graph

#if VK_NVX_image_view_handle
struct ImageViewHandleInfoNVX : VkImageViewHandleInfoNVX {
  ImageViewHandleInfoNVX() noexcept : VkImageViewHandleInfoNVX{.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX} {}

  void setImageView(ImageView value) { this->imageView = std::bit_cast<VkImageView>(value); }
  ImageView getImageView() const { return std::bit_cast<ImageView>(this->imageView); }
  void setDescriptorType(DescriptorType value) { this->descriptorType = std::bit_cast<VkDescriptorType>(value); }
  DescriptorType getDescriptorType() const { return std::bit_cast<DescriptorType>(this->descriptorType); }

  void setSampler(Sampler value) { this->sampler = std::bit_cast<VkSampler>(value); }
  Sampler getSampler() const { return std::bit_cast<Sampler>(this->sampler); }
};
#endif // VK_NVX_image_view_handle

#if VK_EXT_descriptor_buffer
struct SamplerCaptureDescriptorDataInfoEXT : VkSamplerCaptureDescriptorDataInfoEXT {
  SamplerCaptureDescriptorDataInfoEXT() noexcept : VkSamplerCaptureDescriptorDataInfoEXT{.sType = VK_STRUCTURE_TYPE_SAMPLER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT} {}

  void setSampler(Sampler value) { this->sampler = std::bit_cast<VkSampler>(value); }
  Sampler getSampler() const { return std::bit_cast<Sampler>(this->sampler); }
};
#endif // VK_EXT_descriptor_buffer

#if VK_VERSION_1_0
struct DescriptorImageInfo : VkDescriptorImageInfo {
  DescriptorImageInfo() noexcept : VkDescriptorImageInfo{} {}
  DescriptorImageInfo(Sampler sampler, ImageView imageView, ImageLayout imageLayout) noexcept : VkDescriptorImageInfo{.sampler = std::bit_cast<VkSampler>(sampler), .imageView = std::bit_cast<VkImageView>(imageView), .imageLayout = std::bit_cast<VkImageLayout>(imageLayout)} {}

  // Sampler to write to the descriptor in case it is a SAMPLER or COMBINED_IMAGE_SAMPLER descriptor. Ignored otherwise.
  void setSampler(Sampler value) { this->sampler = std::bit_cast<VkSampler>(value); }
  Sampler getSampler() const { return std::bit_cast<Sampler>(this->sampler); }
  // Image view to write to the descriptor in case it is a SAMPLED_IMAGE, STORAGE_IMAGE, COMBINED_IMAGE_SAMPLER, or INPUT_ATTACHMENT descriptor. Ignored otherwise.
  void setImageView(ImageView value) { this->imageView = std::bit_cast<VkImageView>(value); }
  ImageView getImageView() const { return std::bit_cast<ImageView>(this->imageView); }
  // Layout the image is expected to be in when accessed using this descriptor (only used if imageView is not VK_NULL_HANDLE).
  void setImageLayout(ImageLayout value) { this->imageLayout = std::bit_cast<VkImageLayout>(value); }
  ImageLayout getImageLayout() const { return std::bit_cast<ImageLayout>(this->imageLayout); }
};

struct CopyDescriptorSet : VkCopyDescriptorSet {
  CopyDescriptorSet() noexcept : VkCopyDescriptorSet{.sType = VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET} {}

  // Source descriptor set
  void setSrcSet(DescriptorSet value) { this->srcSet = std::bit_cast<VkDescriptorSet>(value); }
  DescriptorSet getSrcSet() const { return std::bit_cast<DescriptorSet>(this->srcSet); }
  // Binding within the source descriptor set to copy from
  void setSrcBinding(uint32_t value) { this->srcBinding = value; }
  uint32_t getSrcBinding() const { return this->srcBinding; }
  // Array element within the source binding to copy from
  void setSrcArrayElement(uint32_t value) { this->srcArrayElement = value; }
  uint32_t getSrcArrayElement() const { return this->srcArrayElement; }
  // Destination descriptor set
  void setDstSet(DescriptorSet value) { this->dstSet = std::bit_cast<VkDescriptorSet>(value); }
  DescriptorSet getDstSet() const { return std::bit_cast<DescriptorSet>(this->dstSet); }
  // Binding within the destination descriptor set to copy to
  void setDstBinding(uint32_t value) { this->dstBinding = value; }
  uint32_t getDstBinding() const { return this->dstBinding; }
  // Array element within the destination binding to copy to
  void setDstArrayElement(uint32_t value) { this->dstArrayElement = value; }
  uint32_t getDstArrayElement() const { return this->dstArrayElement; }
  // Number of descriptors to write (determines the size of the array pointed by pDescriptors)
  void setDescriptorCount(uint32_t value) { this->descriptorCount = value; }
  uint32_t getDescriptorCount() const { return this->descriptorCount; }
};
#endif // VK_VERSION_1_0

#if VK_EXT_device_generated_commands
struct IndirectExecutionSetShaderLayoutInfoEXT : VkIndirectExecutionSetShaderLayoutInfoEXT {
  IndirectExecutionSetShaderLayoutInfoEXT() noexcept : VkIndirectExecutionSetShaderLayoutInfoEXT{.sType = VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_LAYOUT_INFO_EXT} {}

  void setSetLayoutCount(uint32_t value) { this->setLayoutCount = value; }
  uint32_t getSetLayoutCount() const { return this->setLayoutCount; }
  void setSetLayouts(const DescriptorSetLayout* value) { this->pSetLayouts = std::bit_cast<const VkDescriptorSetLayout*>(value); }
  const DescriptorSetLayout* getSetLayouts() const { return std::bit_cast<const DescriptorSetLayout*>(this->pSetLayouts); }
};
#endif // VK_EXT_device_generated_commands

#if VK_VALVE_descriptor_set_host_mapping
struct DescriptorSetBindingReferenceVALVE : VkDescriptorSetBindingReferenceVALVE {
  DescriptorSetBindingReferenceVALVE() noexcept : VkDescriptorSetBindingReferenceVALVE{.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_BINDING_REFERENCE_VALVE} {}

  void setDescriptorSetLayout(DescriptorSetLayout value) { this->descriptorSetLayout = std::bit_cast<VkDescriptorSetLayout>(value); }
  DescriptorSetLayout getDescriptorSetLayout() const { return std::bit_cast<DescriptorSetLayout>(this->descriptorSetLayout); }
  void setBinding(uint32_t value) { this->binding = value; }
  uint32_t getBinding() const { return this->binding; }
};
#endif // VK_VALVE_descriptor_set_host_mapping

#if VK_VERSION_1_1
struct DescriptorUpdateTemplateCreateInfo : VkDescriptorUpdateTemplateCreateInfo {
  DescriptorUpdateTemplateCreateInfo() noexcept : VkDescriptorUpdateTemplateCreateInfo{.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO} {}

  // Number of descriptor update entries to use for the update template
  void setDescriptorUpdateEntryCount(uint32_t value) { this->descriptorUpdateEntryCount = value; }
  uint32_t getDescriptorUpdateEntryCount() const { return this->descriptorUpdateEntryCount; }
  // Descriptor update entries for the template
  void setDescriptorUpdateEntries(const DescriptorUpdateTemplateEntry* value) { this->pDescriptorUpdateEntries = std::bit_cast<const VkDescriptorUpdateTemplateEntry*>(value); }
  const DescriptorUpdateTemplateEntry* getDescriptorUpdateEntries() const { return std::bit_cast<const DescriptorUpdateTemplateEntry*>(this->pDescriptorUpdateEntries); }
  void setTemplateType(DescriptorUpdateTemplateType value) { this->templateType = std::bit_cast<VkDescriptorUpdateTemplateType>(value); }
  DescriptorUpdateTemplateType getTemplateType() const { return std::bit_cast<DescriptorUpdateTemplateType>(this->templateType); }
  void setDescriptorSetLayout(DescriptorSetLayout value) { this->descriptorSetLayout = std::bit_cast<VkDescriptorSetLayout>(value); }
  DescriptorSetLayout getDescriptorSetLayout() const { return std::bit_cast<DescriptorSetLayout>(this->descriptorSetLayout); }
  void setPipelineBindPoint(PipelineBindPoint value) { this->pipelineBindPoint = std::bit_cast<VkPipelineBindPoint>(value); }
  PipelineBindPoint getPipelineBindPoint() const { return std::bit_cast<PipelineBindPoint>(this->pipelineBindPoint); }
  // If used for push descriptors, this is the only allowed layout
  void setPipelineLayout(PipelineLayout value) { this->pipelineLayout = std::bit_cast<VkPipelineLayout>(value); }
  PipelineLayout getPipelineLayout() const { return std::bit_cast<PipelineLayout>(this->pipelineLayout); }
  void setSet(uint32_t value) { this->set = value; }
  uint32_t getSet() const { return this->set; }

  void setFlags(DescriptorUpdateTemplateCreateFlags value) { this->flags = std::bit_cast<VkDescriptorUpdateTemplateCreateFlags>(value); }
  DescriptorUpdateTemplateCreateFlags getFlags() const { return std::bit_cast<DescriptorUpdateTemplateCreateFlags>(this->flags); }
};
#endif // VK_VERSION_1_1

#if VK_VERSION_1_0
struct DescriptorSetAllocateInfo : VkDescriptorSetAllocateInfo {
  DescriptorSetAllocateInfo() noexcept : VkDescriptorSetAllocateInfo{.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO} {}

  void setDescriptorPool(DescriptorPool value) { this->descriptorPool = std::bit_cast<VkDescriptorPool>(value); }
  DescriptorPool getDescriptorPool() const { return std::bit_cast<DescriptorPool>(this->descriptorPool); }
  void setDescriptorSetCount(uint32_t value) { this->descriptorSetCount = value; }
  uint32_t getDescriptorSetCount() const { return this->descriptorSetCount; }
  void setSetLayouts(const DescriptorSetLayout* value) { this->pSetLayouts = std::bit_cast<const VkDescriptorSetLayout*>(value); }
  const DescriptorSetLayout* getSetLayouts() const { return std::bit_cast<const DescriptorSetLayout*>(this->pSetLayouts); }

#if VK_VERSION_1_2
  void attach(struct DescriptorSetVariableDescriptorCountAllocateInfo&);
#endif // VK_VERSION_1_2
};
#endif // VK_VERSION_1_0

#if VK_KHR_external_fence_win32
struct FenceGetWin32HandleInfoKHR : VkFenceGetWin32HandleInfoKHR {
  FenceGetWin32HandleInfoKHR() noexcept : VkFenceGetWin32HandleInfoKHR{.sType = VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR} {}

  void setFence(Fence value) { this->fence = std::bit_cast<VkFence>(value); }
  Fence getFence() const { return std::bit_cast<Fence>(this->fence); }
  void setHandleType(ExternalFenceHandleTypeFlagBits value) { this->handleType = std::bit_cast<VkExternalFenceHandleTypeFlagBits>(value); }
  ExternalFenceHandleTypeFlagBits getHandleType() const { return std::bit_cast<ExternalFenceHandleTypeFlagBits>(this->handleType); }
};
#endif // VK_KHR_external_fence_win32

#if VK_KHR_external_fence_fd
struct FenceGetFdInfoKHR : VkFenceGetFdInfoKHR {
  FenceGetFdInfoKHR() noexcept : VkFenceGetFdInfoKHR{.sType = VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR} {}

  void setFence(Fence value) { this->fence = std::bit_cast<VkFence>(value); }
  Fence getFence() const { return std::bit_cast<Fence>(this->fence); }
  void setHandleType(ExternalFenceHandleTypeFlagBits value) { this->handleType = std::bit_cast<VkExternalFenceHandleTypeFlagBits>(value); }
  ExternalFenceHandleTypeFlagBits getHandleType() const { return std::bit_cast<ExternalFenceHandleTypeFlagBits>(this->handleType); }
};
#endif // VK_KHR_external_fence_fd

#if VK_NV_low_latency2
struct LatencySleepInfoNV : VkLatencySleepInfoNV {
  LatencySleepInfoNV() noexcept : VkLatencySleepInfoNV{.sType = VK_STRUCTURE_TYPE_LATENCY_SLEEP_INFO_NV} {}

  void setSignalSemaphore(Semaphore value) { this->signalSemaphore = std::bit_cast<VkSemaphore>(value); }
  Semaphore getSignalSemaphore() const { return std::bit_cast<Semaphore>(this->signalSemaphore); }
  void setValue(uint64_t value) { this->value = value; }
  uint64_t getValue() const { return this->value; }
};
#endif // VK_NV_low_latency2

#if VK_VERSION_1_2
struct SemaphoreSignalInfo : VkSemaphoreSignalInfo {
  SemaphoreSignalInfo() noexcept : VkSemaphoreSignalInfo{.sType = VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO} {}

  void setSemaphore(Semaphore value) { this->semaphore = std::bit_cast<VkSemaphore>(value); }
  Semaphore getSemaphore() const { return std::bit_cast<Semaphore>(this->semaphore); }
  void setValue(uint64_t value) { this->value = value; }
  uint64_t getValue() const { return this->value; }
};
#endif // VK_VERSION_1_2

#if VK_KHR_external_semaphore_win32
struct SemaphoreGetWin32HandleInfoKHR : VkSemaphoreGetWin32HandleInfoKHR {
  SemaphoreGetWin32HandleInfoKHR() noexcept : VkSemaphoreGetWin32HandleInfoKHR{.sType = VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR} {}

  void setSemaphore(Semaphore value) { this->semaphore = std::bit_cast<VkSemaphore>(value); }
  Semaphore getSemaphore() const { return std::bit_cast<Semaphore>(this->semaphore); }
  void setHandleType(ExternalSemaphoreHandleTypeFlagBits value) { this->handleType = std::bit_cast<VkExternalSemaphoreHandleTypeFlagBits>(value); }
  ExternalSemaphoreHandleTypeFlagBits getHandleType() const { return std::bit_cast<ExternalSemaphoreHandleTypeFlagBits>(this->handleType); }
};
#endif // VK_KHR_external_semaphore_win32

#if VK_FUCHSIA_external_semaphore
struct SemaphoreGetZirconHandleInfoFUCHSIA : VkSemaphoreGetZirconHandleInfoFUCHSIA {
  SemaphoreGetZirconHandleInfoFUCHSIA() noexcept : VkSemaphoreGetZirconHandleInfoFUCHSIA{.sType = VK_STRUCTURE_TYPE_SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA} {}

  void setSemaphore(Semaphore value) { this->semaphore = std::bit_cast<VkSemaphore>(value); }
  Semaphore getSemaphore() const { return std::bit_cast<Semaphore>(this->semaphore); }
  void setHandleType(ExternalSemaphoreHandleTypeFlagBits value) { this->handleType = std::bit_cast<VkExternalSemaphoreHandleTypeFlagBits>(value); }
  ExternalSemaphoreHandleTypeFlagBits getHandleType() const { return std::bit_cast<ExternalSemaphoreHandleTypeFlagBits>(this->handleType); }
};
#endif // VK_FUCHSIA_external_semaphore

#if VK_KHR_external_semaphore_fd
struct SemaphoreGetFdInfoKHR : VkSemaphoreGetFdInfoKHR {
  SemaphoreGetFdInfoKHR() noexcept : VkSemaphoreGetFdInfoKHR{.sType = VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR} {}

  void setSemaphore(Semaphore value) { this->semaphore = std::bit_cast<VkSemaphore>(value); }
  Semaphore getSemaphore() const { return std::bit_cast<Semaphore>(this->semaphore); }
  void setHandleType(ExternalSemaphoreHandleTypeFlagBits value) { this->handleType = std::bit_cast<VkExternalSemaphoreHandleTypeFlagBits>(value); }
  ExternalSemaphoreHandleTypeFlagBits getHandleType() const { return std::bit_cast<ExternalSemaphoreHandleTypeFlagBits>(this->handleType); }
};
#endif // VK_KHR_external_semaphore_fd

#if VK_EXT_metal_objects
struct ExportMetalSharedEventInfoEXT : VkExportMetalSharedEventInfoEXT {
  ExportMetalSharedEventInfoEXT() noexcept : VkExportMetalSharedEventInfoEXT{.sType = VK_STRUCTURE_TYPE_EXPORT_METAL_SHARED_EVENT_INFO_EXT} {}

  void setMtlSharedEvent(MTLSharedEvent_id value) { this->mtlSharedEvent = value; }
  MTLSharedEvent_id getMtlSharedEvent() const { return this->mtlSharedEvent; }

  void setSemaphore(Semaphore value) { this->semaphore = std::bit_cast<VkSemaphore>(value); }
  Semaphore getSemaphore() const { return std::bit_cast<Semaphore>(this->semaphore); }
  void setEvent(Event value) { this->event = std::bit_cast<VkEvent>(value); }
  Event getEvent() const { return std::bit_cast<Event>(this->event); }
};
inline void ExportMetalObjectsInfoEXT::attach(ExportMetalSharedEventInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_metal_objects

#if VK_VERSION_1_0
struct RenderPassBeginInfo : VkRenderPassBeginInfo {
  RenderPassBeginInfo() noexcept : VkRenderPassBeginInfo{.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO} {}

  void setRenderPass(RenderPass value) { this->renderPass = std::bit_cast<VkRenderPass>(value); }
  RenderPass getRenderPass() const { return std::bit_cast<RenderPass>(this->renderPass); }
  void setFramebuffer(Framebuffer value) { this->framebuffer = std::bit_cast<VkFramebuffer>(value); }
  Framebuffer getFramebuffer() const { return std::bit_cast<Framebuffer>(this->framebuffer); }
  void setRenderArea(const Rect2D& value) { this->renderArea = value; }
  const Rect2D& getRenderArea() const { return static_cast<const Rect2D&>(this->renderArea); }

  void setClearValueCount(uint32_t value) { this->clearValueCount = value; }
  uint32_t getClearValueCount() const { return this->clearValueCount; }
  void setClearValues(const ClearValue* value) { this->pClearValues = value; }
  const ClearValue* getClearValues() const { return this->pClearValues; }

#if VK_VERSION_1_1
  void attach(struct DeviceGroupRenderPassBeginInfo&);
#endif // VK_VERSION_1_1
#if VK_EXT_sample_locations
  void attach(struct RenderPassSampleLocationsBeginInfoEXT&);
#endif // VK_EXT_sample_locations
#if VK_VERSION_1_2
  void attach(struct RenderPassAttachmentBeginInfo&);
#endif // VK_VERSION_1_2
#if VK_QCOM_render_pass_transform
  void attach(struct RenderPassTransformBeginInfoQCOM&);
#endif // VK_QCOM_render_pass_transform
#if VK_QCOM_multiview_per_view_render_areas
  void attach(struct MultiviewPerViewRenderAreasRenderPassBeginInfoQCOM&);
#endif // VK_QCOM_multiview_per_view_render_areas
#if VK_ARM_render_pass_striped
  void attach(struct RenderPassStripeBeginInfoARM&);
#endif // VK_ARM_render_pass_striped
};
#endif // VK_VERSION_1_0

#if VK_KHR_pipeline_binary
struct PipelineBinaryDataInfoKHR : VkPipelineBinaryDataInfoKHR {
  PipelineBinaryDataInfoKHR() noexcept : VkPipelineBinaryDataInfoKHR{.sType = VK_STRUCTURE_TYPE_PIPELINE_BINARY_DATA_INFO_KHR} {}

  void setPipelineBinary(PipelineBinaryKHR value) { this->pipelineBinary = std::bit_cast<VkPipelineBinaryKHR>(value); }
  PipelineBinaryKHR getPipelineBinary() const { return std::bit_cast<PipelineBinaryKHR>(this->pipelineBinary); }
};

struct PipelineBinaryHandlesInfoKHR : VkPipelineBinaryHandlesInfoKHR {
  PipelineBinaryHandlesInfoKHR() noexcept : VkPipelineBinaryHandlesInfoKHR{.sType = VK_STRUCTURE_TYPE_PIPELINE_BINARY_HANDLES_INFO_KHR} {}

  void setPipelineBinaryCount(uint32_t value) { this->pipelineBinaryCount = value; }
  uint32_t getPipelineBinaryCount() const { return this->pipelineBinaryCount; }
  void setPipelineBinaries(PipelineBinaryKHR* value) { this->pPipelineBinaries = std::bit_cast<VkPipelineBinaryKHR*>(value); }
  PipelineBinaryKHR* getPipelineBinaries() const { return std::bit_cast<PipelineBinaryKHR*>(this->pPipelineBinaries); }
};
#endif // VK_KHR_pipeline_binary

#if VK_NV_device_generated_commands
struct GeneratedCommandsMemoryRequirementsInfoNV : VkGeneratedCommandsMemoryRequirementsInfoNV {
  GeneratedCommandsMemoryRequirementsInfoNV() noexcept : VkGeneratedCommandsMemoryRequirementsInfoNV{.sType = VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV} {}

  void setPipelineBindPoint(PipelineBindPoint value) { this->pipelineBindPoint = std::bit_cast<VkPipelineBindPoint>(value); }
  PipelineBindPoint getPipelineBindPoint() const { return std::bit_cast<PipelineBindPoint>(this->pipelineBindPoint); }
  void setIndirectCommandsLayout(IndirectCommandsLayoutNV value) { this->indirectCommandsLayout = std::bit_cast<VkIndirectCommandsLayoutNV>(value); }
  IndirectCommandsLayoutNV getIndirectCommandsLayout() const { return std::bit_cast<IndirectCommandsLayoutNV>(this->indirectCommandsLayout); }
  void setMaxSequencesCount(uint32_t value) { this->maxSequencesCount = value; }
  uint32_t getMaxSequencesCount() const { return this->maxSequencesCount; }

  void setPipeline(Pipeline value) { this->pipeline = std::bit_cast<VkPipeline>(value); }
  Pipeline getPipeline() const { return std::bit_cast<Pipeline>(this->pipeline); }
};
#endif // VK_NV_device_generated_commands

#if VK_EXT_device_generated_commands
struct GeneratedCommandsMemoryRequirementsInfoEXT : VkGeneratedCommandsMemoryRequirementsInfoEXT {
  GeneratedCommandsMemoryRequirementsInfoEXT() noexcept : VkGeneratedCommandsMemoryRequirementsInfoEXT{.sType = VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_EXT} {}

  void setIndirectCommandsLayout(IndirectCommandsLayoutEXT value) { this->indirectCommandsLayout = std::bit_cast<VkIndirectCommandsLayoutEXT>(value); }
  IndirectCommandsLayoutEXT getIndirectCommandsLayout() const { return std::bit_cast<IndirectCommandsLayoutEXT>(this->indirectCommandsLayout); }
  void setMaxSequenceCount(uint32_t value) { this->maxSequenceCount = value; }
  uint32_t getMaxSequenceCount() const { return this->maxSequenceCount; }
  void setMaxDrawCount(uint32_t value) { this->maxDrawCount = value; }
  uint32_t getMaxDrawCount() const { return this->maxDrawCount; }

  void setIndirectExecutionSet(IndirectExecutionSetEXT value) { this->indirectExecutionSet = std::bit_cast<VkIndirectExecutionSetEXT>(value); }
  IndirectExecutionSetEXT getIndirectExecutionSet() const { return std::bit_cast<IndirectExecutionSetEXT>(this->indirectExecutionSet); }

  void attach(struct GeneratedCommandsPipelineInfoEXT&);
  void attach(struct GeneratedCommandsShaderInfoEXT&);
};
#endif // VK_EXT_device_generated_commands

#if VK_VERSION_1_4
struct PushDescriptorSetWithTemplateInfo : VkPushDescriptorSetWithTemplateInfo {
  PushDescriptorSetWithTemplateInfo() noexcept : VkPushDescriptorSetWithTemplateInfo{.sType = VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_WITH_TEMPLATE_INFO} {}

  void setDescriptorUpdateTemplate(DescriptorUpdateTemplate value) { this->descriptorUpdateTemplate = std::bit_cast<VkDescriptorUpdateTemplate>(value); }
  DescriptorUpdateTemplate getDescriptorUpdateTemplate() const { return std::bit_cast<DescriptorUpdateTemplate>(this->descriptorUpdateTemplate); }
  void setData(const void* value) { this->pData = value; }
  const void* getData() const { return this->pData; }

  void setLayout(PipelineLayout value) { this->layout = std::bit_cast<VkPipelineLayout>(value); }
  PipelineLayout getLayout() const { return std::bit_cast<PipelineLayout>(this->layout); }
  void setSet(uint32_t value) { this->set = value; }
  uint32_t getSet() const { return this->set; }

  void attach(struct PipelineLayoutCreateInfo&);
};
#endif // VK_VERSION_1_4

#if VK_KHR_descriptor_update_template
using DescriptorUpdateTemplateKHR = DescriptorUpdateTemplate;
#endif // VK_KHR_descriptor_update_template
#if VK_KHR_sampler_ycbcr_conversion
using SamplerYcbcrConversionKHR = SamplerYcbcrConversion;
#endif // VK_KHR_sampler_ycbcr_conversion

#if VK_KHR_acceleration_structure
struct AccelerationStructureDeviceAddressInfoKHR : VkAccelerationStructureDeviceAddressInfoKHR {
  AccelerationStructureDeviceAddressInfoKHR() noexcept : VkAccelerationStructureDeviceAddressInfoKHR{.sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR} {}

  void setAccelerationStructure(AccelerationStructureKHR value) { this->accelerationStructure = std::bit_cast<VkAccelerationStructureKHR>(value); }
  AccelerationStructureKHR getAccelerationStructure() const { return std::bit_cast<AccelerationStructureKHR>(this->accelerationStructure); }
};

struct CopyAccelerationStructureInfoKHR : VkCopyAccelerationStructureInfoKHR {
  CopyAccelerationStructureInfoKHR() noexcept : VkCopyAccelerationStructureInfoKHR{.sType = VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR} {}

  void setSrc(AccelerationStructureKHR value) { this->src = std::bit_cast<VkAccelerationStructureKHR>(value); }
  AccelerationStructureKHR getSrc() const { return std::bit_cast<AccelerationStructureKHR>(this->src); }
  void setDst(AccelerationStructureKHR value) { this->dst = std::bit_cast<VkAccelerationStructureKHR>(value); }
  AccelerationStructureKHR getDst() const { return std::bit_cast<AccelerationStructureKHR>(this->dst); }
  void setMode(CopyAccelerationStructureModeKHR value) { this->mode = std::bit_cast<VkCopyAccelerationStructureModeKHR>(value); }
  CopyAccelerationStructureModeKHR getMode() const { return std::bit_cast<CopyAccelerationStructureModeKHR>(this->mode); }
};

struct CopyAccelerationStructureToMemoryInfoKHR : VkCopyAccelerationStructureToMemoryInfoKHR {
  CopyAccelerationStructureToMemoryInfoKHR() noexcept : VkCopyAccelerationStructureToMemoryInfoKHR{.sType = VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR} {}

  void setSrc(AccelerationStructureKHR value) { this->src = std::bit_cast<VkAccelerationStructureKHR>(value); }
  AccelerationStructureKHR getSrc() const { return std::bit_cast<AccelerationStructureKHR>(this->src); }
  void setDst(DeviceOrHostAddressKHR value) { this->dst = value; }
  DeviceOrHostAddressKHR getDst() const { return this->dst; }
  void setMode(CopyAccelerationStructureModeKHR value) { this->mode = std::bit_cast<VkCopyAccelerationStructureModeKHR>(value); }
  CopyAccelerationStructureModeKHR getMode() const { return std::bit_cast<CopyAccelerationStructureModeKHR>(this->mode); }
};

struct CopyMemoryToAccelerationStructureInfoKHR : VkCopyMemoryToAccelerationStructureInfoKHR {
  CopyMemoryToAccelerationStructureInfoKHR() noexcept : VkCopyMemoryToAccelerationStructureInfoKHR{.sType = VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR} {}

  void setSrc(DeviceOrHostAddressConstKHR value) { this->src = value; }
  DeviceOrHostAddressConstKHR getSrc() const { return this->src; }
  void setDst(AccelerationStructureKHR value) { this->dst = std::bit_cast<VkAccelerationStructureKHR>(value); }
  AccelerationStructureKHR getDst() const { return std::bit_cast<AccelerationStructureKHR>(this->dst); }
  void setMode(CopyAccelerationStructureModeKHR value) { this->mode = std::bit_cast<VkCopyAccelerationStructureModeKHR>(value); }
  CopyAccelerationStructureModeKHR getMode() const { return std::bit_cast<CopyAccelerationStructureModeKHR>(this->mode); }
};
#endif // VK_KHR_acceleration_structure

#if VK_FUCHSIA_buffer_collection
struct ImportMemoryBufferCollectionFUCHSIA : VkImportMemoryBufferCollectionFUCHSIA {
  ImportMemoryBufferCollectionFUCHSIA() noexcept : VkImportMemoryBufferCollectionFUCHSIA{.sType = VK_STRUCTURE_TYPE_IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA} {}

  void setCollection(BufferCollectionFUCHSIA value) { this->collection = std::bit_cast<VkBufferCollectionFUCHSIA>(value); }
  BufferCollectionFUCHSIA getCollection() const { return std::bit_cast<BufferCollectionFUCHSIA>(this->collection); }
  void setIndex(uint32_t value) { this->index = value; }
  uint32_t getIndex() const { return this->index; }
};
inline void MemoryAllocateInfo::attach(ImportMemoryBufferCollectionFUCHSIA& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_FUCHSIA_buffer_collection

#if VK_EXT_private_data
using PrivateDataSlotEXT = PrivateDataSlot;
#endif // VK_EXT_private_data

#if VK_NVX_binary_import
struct CuFunctionCreateInfoNVX : VkCuFunctionCreateInfoNVX {
  CuFunctionCreateInfoNVX() noexcept : VkCuFunctionCreateInfoNVX{.sType = VK_STRUCTURE_TYPE_CU_FUNCTION_CREATE_INFO_NVX} {}

  void setModule(CuModuleNVX value) { this->module = std::bit_cast<VkCuModuleNVX>(value); }
  CuModuleNVX getModule() const { return std::bit_cast<CuModuleNVX>(this->module); }
  void setName(const char* value) { this->pName = value; }
  const char* getName() const { return this->pName; }
};

struct CuLaunchInfoNVX : VkCuLaunchInfoNVX {
  CuLaunchInfoNVX() noexcept : VkCuLaunchInfoNVX{.sType = VK_STRUCTURE_TYPE_CU_LAUNCH_INFO_NVX} {}

  void setFunction(CuFunctionNVX value) { this->function = std::bit_cast<VkCuFunctionNVX>(value); }
  CuFunctionNVX getFunction() const { return std::bit_cast<CuFunctionNVX>(this->function); }
  void setGridDimX(uint32_t value) { this->gridDimX = value; }
  uint32_t getGridDimX() const { return this->gridDimX; }
  void setGridDimY(uint32_t value) { this->gridDimY = value; }
  uint32_t getGridDimY() const { return this->gridDimY; }
  void setGridDimZ(uint32_t value) { this->gridDimZ = value; }
  uint32_t getGridDimZ() const { return this->gridDimZ; }
  void setBlockDimX(uint32_t value) { this->blockDimX = value; }
  uint32_t getBlockDimX() const { return this->blockDimX; }
  void setBlockDimY(uint32_t value) { this->blockDimY = value; }
  uint32_t getBlockDimY() const { return this->blockDimY; }
  void setBlockDimZ(uint32_t value) { this->blockDimZ = value; }
  uint32_t getBlockDimZ() const { return this->blockDimZ; }
  void setSharedMemBytes(uint32_t value) { this->sharedMemBytes = value; }
  uint32_t getSharedMemBytes() const { return this->sharedMemBytes; }

  void setParamCount(size_t value) { this->paramCount = value; }
  size_t getParamCount() const { return this->paramCount; }
  void setParams(const void* const * value) { this->pParams = value; }
  const void* const * getParams() const { return this->pParams; }
  void setExtraCount(size_t value) { this->extraCount = value; }
  size_t getExtraCount() const { return this->extraCount; }
  void setExtras(const void* const * value) { this->pExtras = value; }
  const void* const * getExtras() const { return this->pExtras; }
};
#endif // VK_NVX_binary_import

#if VK_EXT_opacity_micromap
struct CopyMicromapInfoEXT : VkCopyMicromapInfoEXT {
  CopyMicromapInfoEXT() noexcept : VkCopyMicromapInfoEXT{.sType = VK_STRUCTURE_TYPE_COPY_MICROMAP_INFO_EXT} {}

  void setSrc(MicromapEXT value) { this->src = std::bit_cast<VkMicromapEXT>(value); }
  MicromapEXT getSrc() const { return std::bit_cast<MicromapEXT>(this->src); }
  void setDst(MicromapEXT value) { this->dst = std::bit_cast<VkMicromapEXT>(value); }
  MicromapEXT getDst() const { return std::bit_cast<MicromapEXT>(this->dst); }
  void setMode(CopyMicromapModeEXT value) { this->mode = std::bit_cast<VkCopyMicromapModeEXT>(value); }
  CopyMicromapModeEXT getMode() const { return std::bit_cast<CopyMicromapModeEXT>(this->mode); }
};

struct CopyMicromapToMemoryInfoEXT : VkCopyMicromapToMemoryInfoEXT {
  CopyMicromapToMemoryInfoEXT() noexcept : VkCopyMicromapToMemoryInfoEXT{.sType = VK_STRUCTURE_TYPE_COPY_MICROMAP_TO_MEMORY_INFO_EXT} {}

  void setSrc(MicromapEXT value) { this->src = std::bit_cast<VkMicromapEXT>(value); }
  MicromapEXT getSrc() const { return std::bit_cast<MicromapEXT>(this->src); }
  void setDst(DeviceOrHostAddressKHR value) { this->dst = value; }
  DeviceOrHostAddressKHR getDst() const { return this->dst; }
  void setMode(CopyMicromapModeEXT value) { this->mode = std::bit_cast<VkCopyMicromapModeEXT>(value); }
  CopyMicromapModeEXT getMode() const { return std::bit_cast<CopyMicromapModeEXT>(this->mode); }
};

struct CopyMemoryToMicromapInfoEXT : VkCopyMemoryToMicromapInfoEXT {
  CopyMemoryToMicromapInfoEXT() noexcept : VkCopyMemoryToMicromapInfoEXT{.sType = VK_STRUCTURE_TYPE_COPY_MEMORY_TO_MICROMAP_INFO_EXT} {}

  void setSrc(DeviceOrHostAddressConstKHR value) { this->src = value; }
  DeviceOrHostAddressConstKHR getSrc() const { return this->src; }
  void setDst(MicromapEXT value) { this->dst = std::bit_cast<VkMicromapEXT>(value); }
  MicromapEXT getDst() const { return std::bit_cast<MicromapEXT>(this->dst); }
  void setMode(CopyMicromapModeEXT value) { this->mode = std::bit_cast<VkCopyMicromapModeEXT>(value); }
  CopyMicromapModeEXT getMode() const { return std::bit_cast<CopyMicromapModeEXT>(this->mode); }
};

struct AccelerationStructureTrianglesOpacityMicromapEXT : VkAccelerationStructureTrianglesOpacityMicromapEXT {
  AccelerationStructureTrianglesOpacityMicromapEXT() noexcept : VkAccelerationStructureTrianglesOpacityMicromapEXT{.sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT} {}

  void setIndexType(IndexType value) { this->indexType = std::bit_cast<VkIndexType>(value); }
  IndexType getIndexType() const { return std::bit_cast<IndexType>(this->indexType); }
  void setIndexBuffer(DeviceOrHostAddressConstKHR value) { this->indexBuffer = value; }
  DeviceOrHostAddressConstKHR getIndexBuffer() const { return this->indexBuffer; }
  void setIndexStride(DeviceSize value) { this->indexStride = value; }
  DeviceSize getIndexStride() const { return this->indexStride; }
  void setBaseTriangle(uint32_t value) { this->baseTriangle = value; }
  uint32_t getBaseTriangle() const { return this->baseTriangle; }

  void setUsageCountsCount(uint32_t value) { this->usageCountsCount = value; }
  uint32_t getUsageCountsCount() const { return this->usageCountsCount; }
  void setUsageCounts(const MicromapUsageEXT* value) { this->pUsageCounts = std::bit_cast<const VkMicromapUsageEXT*>(value); }
  const MicromapUsageEXT* getUsageCounts() const { return std::bit_cast<const MicromapUsageEXT*>(this->pUsageCounts); }
  void setMicromap(MicromapEXT value) { this->micromap = std::bit_cast<VkMicromapEXT>(value); }
  MicromapEXT getMicromap() const { return std::bit_cast<MicromapEXT>(this->micromap); }
};
inline void AccelerationStructureGeometryTrianglesDataKHR::attach(AccelerationStructureTrianglesOpacityMicromapEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_opacity_micromap

#if VK_EXT_device_generated_commands
struct WriteIndirectExecutionSetShaderEXT : VkWriteIndirectExecutionSetShaderEXT {
  WriteIndirectExecutionSetShaderEXT() noexcept : VkWriteIndirectExecutionSetShaderEXT{.sType = VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_SHADER_EXT} {}

  void setIndex(uint32_t value) { this->index = value; }
  uint32_t getIndex() const { return this->index; }
  void setShader(ShaderEXT value) { this->shader = std::bit_cast<VkShaderEXT>(value); }
  ShaderEXT getShader() const { return std::bit_cast<ShaderEXT>(this->shader); }
};
#endif // VK_EXT_device_generated_commands

#if VK_ARM_tensors
struct TensorMemoryRequirementsInfoARM : VkTensorMemoryRequirementsInfoARM {
  TensorMemoryRequirementsInfoARM() noexcept : VkTensorMemoryRequirementsInfoARM{.sType = VK_STRUCTURE_TYPE_TENSOR_MEMORY_REQUIREMENTS_INFO_ARM} {}

  void setTensor(TensorARM value) { this->tensor = std::bit_cast<VkTensorARM>(value); }
  TensorARM getTensor() const { return std::bit_cast<TensorARM>(this->tensor); }
};

struct BindTensorMemoryInfoARM : VkBindTensorMemoryInfoARM {
  BindTensorMemoryInfoARM() noexcept : VkBindTensorMemoryInfoARM{.sType = VK_STRUCTURE_TYPE_BIND_TENSOR_MEMORY_INFO_ARM} {}

  void setTensor(TensorARM value) { this->tensor = std::bit_cast<VkTensorARM>(value); }
  TensorARM getTensor() const { return std::bit_cast<TensorARM>(this->tensor); }
  void setMemory(DeviceMemory value) { this->memory = std::bit_cast<VkDeviceMemory>(value); }
  DeviceMemory getMemory() const { return std::bit_cast<DeviceMemory>(this->memory); }
  void setMemoryOffset(DeviceSize value) { this->memoryOffset = value; }
  DeviceSize getMemoryOffset() const { return this->memoryOffset; }
};

struct CopyTensorInfoARM : VkCopyTensorInfoARM {
  CopyTensorInfoARM() noexcept : VkCopyTensorInfoARM{.sType = VK_STRUCTURE_TYPE_COPY_TENSOR_INFO_ARM} {}

  void setSrcTensor(TensorARM value) { this->srcTensor = std::bit_cast<VkTensorARM>(value); }
  TensorARM getSrcTensor() const { return std::bit_cast<TensorARM>(this->srcTensor); }
  void setDstTensor(TensorARM value) { this->dstTensor = std::bit_cast<VkTensorARM>(value); }
  TensorARM getDstTensor() const { return std::bit_cast<TensorARM>(this->dstTensor); }
  void setRegionCount(uint32_t value) { this->regionCount = value; }
  uint32_t getRegionCount() const { return this->regionCount; }
  void setRegions(const TensorCopyARM* value) { this->pRegions = std::bit_cast<const VkTensorCopyARM*>(value); }
  const TensorCopyARM* getRegions() const { return std::bit_cast<const TensorCopyARM*>(this->pRegions); }
};

struct MemoryDedicatedAllocateInfoTensorARM : VkMemoryDedicatedAllocateInfoTensorARM {
  MemoryDedicatedAllocateInfoTensorARM() noexcept : VkMemoryDedicatedAllocateInfoTensorARM{.sType = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_TENSOR_ARM} {}

  // Tensor that this allocation will be bound to
  void setTensor(TensorARM value) { this->tensor = std::bit_cast<VkTensorARM>(value); }
  TensorARM getTensor() const { return std::bit_cast<TensorARM>(this->tensor); }
};
inline void MemoryAllocateInfo::attach(MemoryDedicatedAllocateInfoTensorARM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }

struct TensorCaptureDescriptorDataInfoARM : VkTensorCaptureDescriptorDataInfoARM {
  TensorCaptureDescriptorDataInfoARM() noexcept : VkTensorCaptureDescriptorDataInfoARM{.sType = VK_STRUCTURE_TYPE_TENSOR_CAPTURE_DESCRIPTOR_DATA_INFO_ARM} {}

  void setTensor(TensorARM value) { this->tensor = std::bit_cast<VkTensorARM>(value); }
  TensorARM getTensor() const { return std::bit_cast<TensorARM>(this->tensor); }
};

struct TensorViewCaptureDescriptorDataInfoARM : VkTensorViewCaptureDescriptorDataInfoARM {
  TensorViewCaptureDescriptorDataInfoARM() noexcept : VkTensorViewCaptureDescriptorDataInfoARM{.sType = VK_STRUCTURE_TYPE_TENSOR_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_ARM} {}

  void setTensorView(TensorViewARM value) { this->tensorView = std::bit_cast<VkTensorViewARM>(value); }
  TensorViewARM getTensorView() const { return std::bit_cast<TensorViewARM>(this->tensorView); }
};

struct DescriptorGetTensorInfoARM : VkDescriptorGetTensorInfoARM {
  DescriptorGetTensorInfoARM() noexcept : VkDescriptorGetTensorInfoARM{.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_GET_TENSOR_INFO_ARM} {}

  void setTensorView(TensorViewARM value) { this->tensorView = std::bit_cast<VkTensorViewARM>(value); }
  TensorViewARM getTensorView() const { return std::bit_cast<TensorViewARM>(this->tensorView); }
};
inline void DescriptorGetInfoEXT::attach(DescriptorGetTensorInfoARM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_ARM_tensors

#if VK_ARM_data_graph
struct DataGraphPipelineSessionBindPointRequirementsInfoARM : VkDataGraphPipelineSessionBindPointRequirementsInfoARM {
  DataGraphPipelineSessionBindPointRequirementsInfoARM() noexcept : VkDataGraphPipelineSessionBindPointRequirementsInfoARM{.sType = VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_REQUIREMENTS_INFO_ARM} {}

  void setSession(DataGraphPipelineSessionARM value) { this->session = std::bit_cast<VkDataGraphPipelineSessionARM>(value); }
  DataGraphPipelineSessionARM getSession() const { return std::bit_cast<DataGraphPipelineSessionARM>(this->session); }
};

struct DataGraphPipelineSessionMemoryRequirementsInfoARM : VkDataGraphPipelineSessionMemoryRequirementsInfoARM {
  DataGraphPipelineSessionMemoryRequirementsInfoARM() noexcept : VkDataGraphPipelineSessionMemoryRequirementsInfoARM{.sType = VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_MEMORY_REQUIREMENTS_INFO_ARM} {}

  void setSession(DataGraphPipelineSessionARM value) { this->session = std::bit_cast<VkDataGraphPipelineSessionARM>(value); }
  DataGraphPipelineSessionARM getSession() const { return std::bit_cast<DataGraphPipelineSessionARM>(this->session); }
  void setBindPoint(DataGraphPipelineSessionBindPointARM value) { this->bindPoint = std::bit_cast<VkDataGraphPipelineSessionBindPointARM>(value); }
  DataGraphPipelineSessionBindPointARM getBindPoint() const { return std::bit_cast<DataGraphPipelineSessionBindPointARM>(this->bindPoint); }
  void setObjectIndex(uint32_t value) { this->objectIndex = value; }
  uint32_t getObjectIndex() const { return this->objectIndex; }
};

struct BindDataGraphPipelineSessionMemoryInfoARM : VkBindDataGraphPipelineSessionMemoryInfoARM {
  BindDataGraphPipelineSessionMemoryInfoARM() noexcept : VkBindDataGraphPipelineSessionMemoryInfoARM{.sType = VK_STRUCTURE_TYPE_BIND_DATA_GRAPH_PIPELINE_SESSION_MEMORY_INFO_ARM} {}

  void setSession(DataGraphPipelineSessionARM value) { this->session = std::bit_cast<VkDataGraphPipelineSessionARM>(value); }
  DataGraphPipelineSessionARM getSession() const { return std::bit_cast<DataGraphPipelineSessionARM>(this->session); }
  void setBindPoint(DataGraphPipelineSessionBindPointARM value) { this->bindPoint = std::bit_cast<VkDataGraphPipelineSessionBindPointARM>(value); }
  DataGraphPipelineSessionBindPointARM getBindPoint() const { return std::bit_cast<DataGraphPipelineSessionBindPointARM>(this->bindPoint); }
  void setObjectIndex(uint32_t value) { this->objectIndex = value; }
  uint32_t getObjectIndex() const { return this->objectIndex; }
  void setMemory(DeviceMemory value) { this->memory = std::bit_cast<VkDeviceMemory>(value); }
  DeviceMemory getMemory() const { return std::bit_cast<DeviceMemory>(this->memory); }
  void setMemoryOffset(DeviceSize value) { this->memoryOffset = value; }
  DeviceSize getMemoryOffset() const { return this->memoryOffset; }
};
#endif // VK_ARM_data_graph

#if VK_KHR_display
struct DisplayPlanePropertiesKHR : VkDisplayPlanePropertiesKHR {
  DisplayPlanePropertiesKHR() noexcept : VkDisplayPlanePropertiesKHR{} {}

  // Display the plane is currently associated with.  Will be VK_NULL_HANDLE if the plane is not in use.
  DisplayKHR getCurrentDisplay() const { return std::bit_cast<DisplayKHR>(this->currentDisplay); }
  // Current z-order of the plane.
  uint32_t getCurrentStackIndex() const { return this->currentStackIndex; }
};

struct DisplayModePropertiesKHR : VkDisplayModePropertiesKHR {
  DisplayModePropertiesKHR() noexcept : VkDisplayModePropertiesKHR{} {}

  // Handle of this display mode.
  DisplayModeKHR getDisplayMode() const { return std::bit_cast<DisplayModeKHR>(this->displayMode); }
  // The parameters this mode uses.
  const DisplayModeParametersKHR& getParameters() const { return static_cast<const DisplayModeParametersKHR&>(this->parameters); }
};

struct DisplaySurfaceCreateInfoKHR : VkDisplaySurfaceCreateInfoKHR {
  DisplaySurfaceCreateInfoKHR() noexcept : VkDisplaySurfaceCreateInfoKHR{.sType = VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR} {}

  // The mode to use when displaying this surface
  void setDisplayMode(DisplayModeKHR value) { this->displayMode = std::bit_cast<VkDisplayModeKHR>(value); }
  DisplayModeKHR getDisplayMode() const { return std::bit_cast<DisplayModeKHR>(this->displayMode); }
  // The plane on which this surface appears.  Must be between 0 and the value returned by vkGetPhysicalDeviceDisplayPlanePropertiesKHR() in pPropertyCount.
  void setPlaneIndex(uint32_t value) { this->planeIndex = value; }
  uint32_t getPlaneIndex() const { return this->planeIndex; }
  // The z-order of the plane.
  void setPlaneStackIndex(uint32_t value) { this->planeStackIndex = value; }
  uint32_t getPlaneStackIndex() const { return this->planeStackIndex; }
  // Transform to apply to the images as part of the scanout operation
  void setTransform(SurfaceTransformFlagBitsKHR value) { this->transform = std::bit_cast<VkSurfaceTransformFlagBitsKHR>(value); }
  SurfaceTransformFlagBitsKHR getTransform() const { return std::bit_cast<SurfaceTransformFlagBitsKHR>(this->transform); }
  // Global alpha value.  Must be between 0 and 1, inclusive.  Ignored if alphaMode is not VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR
  void setGlobalAlpha(float value) { this->globalAlpha = value; }
  float getGlobalAlpha() const { return this->globalAlpha; }
  // The type of alpha blending to use. Must be one of the bits from VkDisplayPlaneCapabilitiesKHR::supportedAlpha for this display plane
  void setAlphaMode(DisplayPlaneAlphaFlagBitsKHR value) { this->alphaMode = std::bit_cast<VkDisplayPlaneAlphaFlagBitsKHR>(value); }
  DisplayPlaneAlphaFlagBitsKHR getAlphaMode() const { return std::bit_cast<DisplayPlaneAlphaFlagBitsKHR>(this->alphaMode); }
  // size of the images to use with this surface
  void setImageExtent(const Extent2D& value) { this->imageExtent = value; }
  const Extent2D& getImageExtent() const { return static_cast<const Extent2D&>(this->imageExtent); }

  void setFlags(DisplaySurfaceCreateFlagsKHR value) { this->flags = std::bit_cast<VkDisplaySurfaceCreateFlagsKHR>(value); }
  DisplaySurfaceCreateFlagsKHR getFlags() const { return std::bit_cast<DisplaySurfaceCreateFlagsKHR>(this->flags); }

#if VK_NV_display_stereo
  void attach(struct DisplaySurfaceStereoCreateInfoNV&);
#endif // VK_NV_display_stereo
};
#endif // VK_KHR_display

#if VK_KHR_get_display_properties2
struct DisplayPlaneInfo2KHR : VkDisplayPlaneInfo2KHR {
  DisplayPlaneInfo2KHR() noexcept : VkDisplayPlaneInfo2KHR{.sType = VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR} {}

  void setMode(DisplayModeKHR value) { this->mode = std::bit_cast<VkDisplayModeKHR>(value); }
  DisplayModeKHR getMode() const { return std::bit_cast<DisplayModeKHR>(this->mode); }
  void setPlaneIndex(uint32_t value) { this->planeIndex = value; }
  uint32_t getPlaneIndex() const { return this->planeIndex; }
};
#endif // VK_KHR_get_display_properties2

#if VK_KHR_get_surface_capabilities2
struct PhysicalDeviceSurfaceInfo2KHR : VkPhysicalDeviceSurfaceInfo2KHR {
  PhysicalDeviceSurfaceInfo2KHR() noexcept : VkPhysicalDeviceSurfaceInfo2KHR{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR} {}

  void setSurface(SurfaceKHR value) { this->surface = std::bit_cast<VkSurfaceKHR>(value); }
  SurfaceKHR getSurface() const { return std::bit_cast<SurfaceKHR>(this->surface); }

#if VK_EXT_full_screen_exclusive
  void attach(struct SurfaceFullScreenExclusiveInfoEXT&);
  void attach(struct SurfaceFullScreenExclusiveWin32InfoEXT&);
#endif // VK_EXT_full_screen_exclusive
#if VK_KHR_surface_maintenance1
  void attach(struct SurfacePresentModeKHR&);
#endif // VK_KHR_surface_maintenance1
};
#endif // VK_KHR_get_surface_capabilities2

#if VK_KHR_swapchain_maintenance1
struct ReleaseSwapchainImagesInfoKHR : VkReleaseSwapchainImagesInfoKHR {
  ReleaseSwapchainImagesInfoKHR() noexcept : VkReleaseSwapchainImagesInfoKHR{.sType = VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_KHR} {}

  // Swapchain for which images are being released
  void setSwapchain(SwapchainKHR value) { this->swapchain = std::bit_cast<VkSwapchainKHR>(value); }
  SwapchainKHR getSwapchain() const { return std::bit_cast<SwapchainKHR>(this->swapchain); }
  // Number of indices to release
  void setImageIndexCount(uint32_t value) { this->imageIndexCount = value; }
  uint32_t getImageIndexCount() const { return this->imageIndexCount; }
  // Indices of which presentable images to release
  void setImageIndices(const uint32_t* value) { this->pImageIndices = value; }
  const uint32_t* getImageIndices() const { return this->pImageIndices; }
};
#endif // VK_KHR_swapchain_maintenance1

#if VK_KHR_swapchain
struct AcquireNextImageInfoKHR : VkAcquireNextImageInfoKHR {
  AcquireNextImageInfoKHR() noexcept : VkAcquireNextImageInfoKHR{.sType = VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR} {}

  void setSwapchain(SwapchainKHR value) { this->swapchain = std::bit_cast<VkSwapchainKHR>(value); }
  SwapchainKHR getSwapchain() const { return std::bit_cast<SwapchainKHR>(this->swapchain); }
  void setTimeout(uint64_t value) { this->timeout = value; }
  uint64_t getTimeout() const { return this->timeout; }
  void setDeviceMask(uint32_t value) { this->deviceMask = value; }
  uint32_t getDeviceMask() const { return this->deviceMask; }

  void setSemaphore(Semaphore value) { this->semaphore = std::bit_cast<VkSemaphore>(value); }
  Semaphore getSemaphore() const { return std::bit_cast<Semaphore>(this->semaphore); }
  void setFence(Fence value) { this->fence = std::bit_cast<VkFence>(value); }
  Fence getFence() const { return std::bit_cast<Fence>(this->fence); }
};

struct PresentInfoKHR : VkPresentInfoKHR {
  PresentInfoKHR() noexcept : VkPresentInfoKHR{.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR} {}

  // Number of swapchains to present in this call
  void setSwapchainCount(uint32_t value) { this->swapchainCount = value; }
  uint32_t getSwapchainCount() const { return this->swapchainCount; }
  // Swapchains to present an image from
  void setSwapchains(const SwapchainKHR* value) { this->pSwapchains = std::bit_cast<const VkSwapchainKHR*>(value); }
  const SwapchainKHR* getSwapchains() const { return std::bit_cast<const SwapchainKHR*>(this->pSwapchains); }
  // Indices of which presentable images to present
  void setImageIndices(const uint32_t* value) { this->pImageIndices = value; }
  const uint32_t* getImageIndices() const { return this->pImageIndices; }

  // Number of semaphores to wait for before presenting
  void setWaitSemaphoreCount(uint32_t value) { this->waitSemaphoreCount = value; }
  uint32_t getWaitSemaphoreCount() const { return this->waitSemaphoreCount; }
  // Semaphores to wait for before presenting
  void setWaitSemaphores(const Semaphore* value) { this->pWaitSemaphores = std::bit_cast<const VkSemaphore*>(value); }
  const Semaphore* getWaitSemaphores() const { return std::bit_cast<const Semaphore*>(this->pWaitSemaphores); }
  // Optional (i.e. if non-NULL) VkResult for each swapchain
  void setResults(Result* value) { this->pResults = std::bit_cast<VkResult*>(value); }
  Result* getResults() const { return std::bit_cast<Result*>(this->pResults); }

#if VK_KHR_display_swapchain
  void attach(struct DisplayPresentInfoKHR&);
#endif // VK_KHR_display_swapchain
#if VK_KHR_incremental_present
  void attach(struct PresentRegionsKHR&);
#endif // VK_KHR_incremental_present
  void attach(struct DeviceGroupPresentInfoKHR&);
#if VK_KHR_present_id
  void attach(struct PresentIdKHR&);
#endif // VK_KHR_present_id
#if VK_KHR_present_id2
  void attach(struct PresentId2KHR&);
#endif // VK_KHR_present_id2
#if VK_GOOGLE_display_timing
  void attach(struct PresentTimesInfoGOOGLE&);
#endif // VK_GOOGLE_display_timing
#if VK_GGP_frame_token
  void attach(struct PresentFrameTokenGGP&);
#endif // VK_GGP_frame_token
#if VK_EXT_frame_boundary
  void attach(struct FrameBoundaryEXT&);
#endif // VK_EXT_frame_boundary
#if VK_KHR_swapchain_maintenance1
  void attach(struct SwapchainPresentFenceInfoKHR&);
  void attach(struct SwapchainPresentModeInfoKHR&);
#endif // VK_KHR_swapchain_maintenance1
#if VK_ARM_tensors
  void attach(struct FrameBoundaryTensorsARM&);
#endif // VK_ARM_tensors
};
#endif // VK_KHR_swapchain

#if VK_KHR_video_encode_queue
struct VideoEncodeSessionParametersGetInfoKHR : VkVideoEncodeSessionParametersGetInfoKHR {
  VideoEncodeSessionParametersGetInfoKHR() noexcept : VkVideoEncodeSessionParametersGetInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_GET_INFO_KHR} {}

  void setVideoSessionParameters(VideoSessionParametersKHR value) { this->videoSessionParameters = std::bit_cast<VkVideoSessionParametersKHR>(value); }
  VideoSessionParametersKHR getVideoSessionParameters() const { return std::bit_cast<VideoSessionParametersKHR>(this->videoSessionParameters); }

  void attach(struct VideoEncodeH264SessionParametersGetInfoKHR&);
  void attach(struct VideoEncodeH265SessionParametersGetInfoKHR&);
};
#endif // VK_KHR_video_encode_queue

#if VK_AMD_anti_lag
struct AntiLagDataAMD : VkAntiLagDataAMD {
  AntiLagDataAMD() noexcept : VkAntiLagDataAMD{.sType = VK_STRUCTURE_TYPE_ANTI_LAG_DATA_AMD} {}

  void setMode(AntiLagModeAMD value) { this->mode = std::bit_cast<VkAntiLagModeAMD>(value); }
  AntiLagModeAMD getMode() const { return std::bit_cast<AntiLagModeAMD>(this->mode); }
  void setMaxFPS(uint32_t value) { this->maxFPS = value; }
  uint32_t getMaxFPS() const { return this->maxFPS; }

  void setPresentationInfo(const AntiLagPresentationInfoAMD* value) { this->pPresentationInfo = std::bit_cast<const VkAntiLagPresentationInfoAMD*>(value); }
  const AntiLagPresentationInfoAMD* getPresentationInfo() const { return std::bit_cast<const AntiLagPresentationInfoAMD*>(this->pPresentationInfo); }
};
#endif // VK_AMD_anti_lag

#if VK_VERSION_1_0
struct QueueFamilyProperties : VkQueueFamilyProperties {
  QueueFamilyProperties() noexcept : VkQueueFamilyProperties{} {}

  uint32_t getQueueCount() const { return this->queueCount; }
  uint32_t getTimestampValidBits() const { return this->timestampValidBits; }
  // Minimum alignment requirement for image transfers
  const Extent3D& getMinImageTransferGranularity() const { return static_cast<const Extent3D&>(this->minImageTransferGranularity); }

  // Queue flags
  QueueFlags getQueueFlags() const { return std::bit_cast<QueueFlags>(this->queueFlags); }
};

struct PipelineRasterizationStateCreateInfo : VkPipelineRasterizationStateCreateInfo {
  PipelineRasterizationStateCreateInfo() noexcept : VkPipelineRasterizationStateCreateInfo{.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO} {}

  // optional (GL45)
  void setPolygonMode(PolygonMode value) { this->polygonMode = std::bit_cast<VkPolygonMode>(value); }
  PolygonMode getPolygonMode() const { return std::bit_cast<PolygonMode>(this->polygonMode); }
  void setFrontFace(FrontFace value) { this->frontFace = std::bit_cast<VkFrontFace>(value); }
  FrontFace getFrontFace() const { return std::bit_cast<FrontFace>(this->frontFace); }
  void setDepthBiasConstantFactor(float value) { this->depthBiasConstantFactor = value; }
  float getDepthBiasConstantFactor() const { return this->depthBiasConstantFactor; }
  void setDepthBiasClamp(float value) { this->depthBiasClamp = value; }
  float getDepthBiasClamp() const { return this->depthBiasClamp; }
  void setDepthBiasSlopeFactor(float value) { this->depthBiasSlopeFactor = value; }
  float getDepthBiasSlopeFactor() const { return this->depthBiasSlopeFactor; }
  void setLineWidth(float value) { this->lineWidth = value; }
  float getLineWidth() const { return this->lineWidth; }

  void setFlags(PipelineRasterizationStateCreateFlags value) { this->flags = std::bit_cast<VkPipelineRasterizationStateCreateFlags>(value); }
  PipelineRasterizationStateCreateFlags getFlags() const { return std::bit_cast<PipelineRasterizationStateCreateFlags>(this->flags); }
  void setDepthClampEnable(Bool32 value) { this->depthClampEnable = value; }
  Bool32 getDepthClampEnable() const { return this->depthClampEnable; }
  void setRasterizerDiscardEnable(Bool32 value) { this->rasterizerDiscardEnable = value; }
  Bool32 getRasterizerDiscardEnable() const { return this->rasterizerDiscardEnable; }
  void setCullMode(CullModeFlags value) { this->cullMode = std::bit_cast<VkCullModeFlags>(value); }
  CullModeFlags getCullMode() const { return std::bit_cast<CullModeFlags>(this->cullMode); }
  void setDepthBiasEnable(Bool32 value) { this->depthBiasEnable = value; }
  Bool32 getDepthBiasEnable() const { return this->depthBiasEnable; }

#if VK_AMD_rasterization_order
  void attach(struct PipelineRasterizationStateRasterizationOrderAMD&);
#endif // VK_AMD_rasterization_order
#if VK_EXT_conservative_rasterization
  void attach(struct PipelineRasterizationConservativeStateCreateInfoEXT&);
#endif // VK_EXT_conservative_rasterization
#if VK_EXT_transform_feedback
  void attach(struct PipelineRasterizationStateStreamCreateInfoEXT&);
#endif // VK_EXT_transform_feedback
#if VK_EXT_depth_clip_enable
  void attach(struct PipelineRasterizationDepthClipStateCreateInfoEXT&);
#endif // VK_EXT_depth_clip_enable
#if VK_VERSION_1_4
  void attach(struct PipelineRasterizationLineStateCreateInfo&);
#endif // VK_VERSION_1_4
#if VK_EXT_provoking_vertex
  void attach(struct PipelineRasterizationProvokingVertexStateCreateInfoEXT&);
#endif // VK_EXT_provoking_vertex
#if VK_EXT_depth_bias_control
  void attach(struct DepthBiasRepresentationInfoEXT&);
#endif // VK_EXT_depth_bias_control
};
#endif // VK_VERSION_1_0

#if VK_VERSION_1_1
struct DeviceQueueInfo2 : VkDeviceQueueInfo2 {
  DeviceQueueInfo2() noexcept : VkDeviceQueueInfo2{.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2} {}

  void setQueueFamilyIndex(uint32_t value) { this->queueFamilyIndex = value; }
  uint32_t getQueueFamilyIndex() const { return this->queueFamilyIndex; }
  void setQueueIndex(uint32_t value) { this->queueIndex = value; }
  uint32_t getQueueIndex() const { return this->queueIndex; }

  void setFlags(DeviceQueueCreateFlags value) { this->flags = std::bit_cast<VkDeviceQueueCreateFlags>(value); }
  DeviceQueueCreateFlags getFlags() const { return std::bit_cast<DeviceQueueCreateFlags>(this->flags); }
};
#endif // VK_VERSION_1_1

#if VK_VERSION_1_0
struct DeviceQueueCreateInfo : VkDeviceQueueCreateInfo {
  DeviceQueueCreateInfo() noexcept : VkDeviceQueueCreateInfo{.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO} {}

  void setQueueFamilyIndex(uint32_t value) { this->queueFamilyIndex = value; }
  uint32_t getQueueFamilyIndex() const { return this->queueFamilyIndex; }
  void setQueueCount(uint32_t value) { this->queueCount = value; }
  uint32_t getQueueCount() const { return this->queueCount; }
  void setQueuePriorities(const float* value) { this->pQueuePriorities = value; }
  const float* getQueuePriorities() const { return this->pQueuePriorities; }

  void setFlags(DeviceQueueCreateFlags value) { this->flags = std::bit_cast<VkDeviceQueueCreateFlags>(value); }
  DeviceQueueCreateFlags getFlags() const { return std::bit_cast<DeviceQueueCreateFlags>(this->flags); }

#if VK_VERSION_1_4
  void attach(struct DeviceQueueGlobalPriorityCreateInfo&);
#endif // VK_VERSION_1_4
#if VK_ARM_scheduling_controls
  void attach(struct DeviceQueueShaderCoreControlCreateInfoARM&);
#endif // VK_ARM_scheduling_controls
};

struct MemoryType : VkMemoryType {
  MemoryType() noexcept : VkMemoryType{} {}

  // Index of the memory heap allocations of this memory type are taken from
  uint32_t getHeapIndex() const { return this->heapIndex; }

  // Memory properties of this memory type
  MemoryPropertyFlags getPropertyFlags() const { return std::bit_cast<MemoryPropertyFlags>(this->propertyFlags); }
};

struct MemoryHeap : VkMemoryHeap {
  MemoryHeap() noexcept : VkMemoryHeap{} {}

  // Available memory in the heap
  DeviceSize getSize() const { return this->size; }

  // Flags for the heap
  MemoryHeapFlags getFlags() const { return std::bit_cast<MemoryHeapFlags>(this->flags); }
};

struct MemoryBarrier : VkMemoryBarrier {
  MemoryBarrier() noexcept : VkMemoryBarrier{.sType = VK_STRUCTURE_TYPE_MEMORY_BARRIER} {}

  // Memory accesses from the source of the dependency to synchronize
  void setSrcAccessMask(AccessFlags value) { this->srcAccessMask = std::bit_cast<VkAccessFlags>(value); }
  AccessFlags getSrcAccessMask() const { return std::bit_cast<AccessFlags>(this->srcAccessMask); }
  // Memory accesses from the destination of the dependency to synchronize
  void setDstAccessMask(AccessFlags value) { this->dstAccessMask = std::bit_cast<VkAccessFlags>(value); }
  AccessFlags getDstAccessMask() const { return std::bit_cast<AccessFlags>(this->dstAccessMask); }
};

struct BufferMemoryBarrier : VkBufferMemoryBarrier {
  BufferMemoryBarrier() noexcept : VkBufferMemoryBarrier{.sType = VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER} {}

  // Memory accesses from the source of the dependency to synchronize
  void setSrcAccessMask(AccessFlags value) { this->srcAccessMask = std::bit_cast<VkAccessFlags>(value); }
  AccessFlags getSrcAccessMask() const { return std::bit_cast<AccessFlags>(this->srcAccessMask); }
  // Memory accesses from the destination of the dependency to synchronize
  void setDstAccessMask(AccessFlags value) { this->dstAccessMask = std::bit_cast<VkAccessFlags>(value); }
  AccessFlags getDstAccessMask() const { return std::bit_cast<AccessFlags>(this->dstAccessMask); }
  // Queue family to transition ownership from
  void setSrcQueueFamilyIndex(uint32_t value) { this->srcQueueFamilyIndex = value; }
  uint32_t getSrcQueueFamilyIndex() const { return this->srcQueueFamilyIndex; }
  // Queue family to transition ownership to
  void setDstQueueFamilyIndex(uint32_t value) { this->dstQueueFamilyIndex = value; }
  uint32_t getDstQueueFamilyIndex() const { return this->dstQueueFamilyIndex; }
  // Buffer to sync
  void setBuffer(Buffer value) { this->buffer = std::bit_cast<VkBuffer>(value); }
  Buffer getBuffer() const { return std::bit_cast<Buffer>(this->buffer); }
  // Offset within the buffer to sync
  void setOffset(DeviceSize value) { this->offset = value; }
  DeviceSize getOffset() const { return this->offset; }
  // Amount of bytes to sync
  void setSize(DeviceSize value) { this->size = value; }
  DeviceSize getSize() const { return this->size; }

#if VK_EXT_external_memory_acquire_unmodified
  void attach(struct ExternalMemoryAcquireUnmodifiedEXT&);
#endif // VK_EXT_external_memory_acquire_unmodified
};
#endif // VK_VERSION_1_0

#if VK_EXT_descriptor_buffer
struct DescriptorBufferBindingInfoEXT : VkDescriptorBufferBindingInfoEXT {
  DescriptorBufferBindingInfoEXT() noexcept : VkDescriptorBufferBindingInfoEXT{.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_INFO_EXT} {}

  void setAddress(DeviceAddress value) { this->address = value; }
  DeviceAddress getAddress() const { return this->address; }

  void setUsage(BufferUsageFlags value) { this->usage = std::bit_cast<VkBufferUsageFlags>(value); }
  BufferUsageFlags getUsage() const { return std::bit_cast<BufferUsageFlags>(this->usage); }

  void attach(struct BufferUsageFlags2CreateInfo&);
  void attach(struct DescriptorBufferBindingPushDescriptorBufferHandleEXT&);
};
#endif // VK_EXT_descriptor_buffer

#if VK_KHR_maintenance5
using BufferUsageFlags2KHR = BufferUsageFlags2;
#endif // VK_KHR_maintenance5

#if VK_VERSION_1_1
struct PhysicalDeviceExternalBufferInfo : VkPhysicalDeviceExternalBufferInfo {
  PhysicalDeviceExternalBufferInfo() noexcept : VkPhysicalDeviceExternalBufferInfo{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO} {}

  void setHandleType(ExternalMemoryHandleTypeFlagBits value) { this->handleType = std::bit_cast<VkExternalMemoryHandleTypeFlagBits>(value); }
  ExternalMemoryHandleTypeFlagBits getHandleType() const { return std::bit_cast<ExternalMemoryHandleTypeFlagBits>(this->handleType); }

  void setFlags(BufferCreateFlags value) { this->flags = std::bit_cast<VkBufferCreateFlags>(value); }
  BufferCreateFlags getFlags() const { return std::bit_cast<BufferCreateFlags>(this->flags); }
  void setUsage(BufferUsageFlags value) { this->usage = std::bit_cast<VkBufferUsageFlags>(value); }
  BufferUsageFlags getUsage() const { return std::bit_cast<BufferUsageFlags>(this->usage); }

#if VK_VERSION_1_4
  void attach(struct BufferUsageFlags2CreateInfo&);
#endif // VK_VERSION_1_4
};
#endif // VK_VERSION_1_1

#if VK_VERSION_1_0
struct BufferCreateInfo : VkBufferCreateInfo {
  BufferCreateInfo() noexcept : VkBufferCreateInfo{.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO} {}

  // Specified in bytes
  void setSize(DeviceSize value) { this->size = value; }
  DeviceSize getSize() const { return this->size; }
  // Buffer usage flags
  void setUsage(BufferUsageFlags value) { this->usage = std::bit_cast<VkBufferUsageFlags>(value); }
  BufferUsageFlags getUsage() const { return std::bit_cast<BufferUsageFlags>(this->usage); }
  void setSharingMode(SharingMode value) { this->sharingMode = std::bit_cast<VkSharingMode>(value); }
  SharingMode getSharingMode() const { return std::bit_cast<SharingMode>(this->sharingMode); }

  // Buffer creation flags
  void setFlags(BufferCreateFlags value) { this->flags = std::bit_cast<VkBufferCreateFlags>(value); }
  BufferCreateFlags getFlags() const { return std::bit_cast<BufferCreateFlags>(this->flags); }
  void setQueueFamilyIndexCount(uint32_t value) { this->queueFamilyIndexCount = value; }
  uint32_t getQueueFamilyIndexCount() const { return this->queueFamilyIndexCount; }
  void setQueueFamilyIndices(const uint32_t* value) { this->pQueueFamilyIndices = value; }
  const uint32_t* getQueueFamilyIndices() const { return this->pQueueFamilyIndices; }

#if VK_VERSION_1_4
  void attach(struct BufferUsageFlags2CreateInfo&);
#endif // VK_VERSION_1_4
#if VK_VERSION_1_1
  void attach(struct ExternalMemoryBufferCreateInfo&);
#endif // VK_VERSION_1_1
#if VK_VERSION_1_2
  void attach(struct BufferOpaqueCaptureAddressCreateInfo&);
#endif // VK_VERSION_1_2
#if VK_KHR_video_queue
  void attach(struct VideoProfileListInfoKHR&);
#endif // VK_KHR_video_queue
#if VK_EXT_descriptor_buffer
  void attach(struct OpaqueCaptureDescriptorDataCreateInfoEXT&);
#endif // VK_EXT_descriptor_buffer
#if VK_FUCHSIA_buffer_collection
  void attach(struct BufferCollectionBufferCreateInfoFUCHSIA&);
#endif // VK_FUCHSIA_buffer_collection
};
#endif // VK_VERSION_1_0

#if VK_KHR_pipeline_executable_properties
struct PipelineExecutablePropertiesKHR : VkPipelineExecutablePropertiesKHR {
  PipelineExecutablePropertiesKHR() noexcept : VkPipelineExecutablePropertiesKHR{.sType = VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR} {}

  ShaderStageFlags getStages() const { return std::bit_cast<ShaderStageFlags>(this->stages); }
  std::string_view getName() const { return this->name; }
  std::string_view getDescription() const { return this->description; }
  uint32_t getSubgroupSize() const { return this->subgroupSize; }
};
#endif // VK_KHR_pipeline_executable_properties

#if VK_EXT_device_generated_commands
struct GeneratedCommandsInfoEXT : VkGeneratedCommandsInfoEXT {
  GeneratedCommandsInfoEXT() noexcept : VkGeneratedCommandsInfoEXT{.sType = VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_EXT} {}

  void setShaderStages(ShaderStageFlags value) { this->shaderStages = std::bit_cast<VkShaderStageFlags>(value); }
  ShaderStageFlags getShaderStages() const { return std::bit_cast<ShaderStageFlags>(this->shaderStages); }
  void setIndirectCommandsLayout(IndirectCommandsLayoutEXT value) { this->indirectCommandsLayout = std::bit_cast<VkIndirectCommandsLayoutEXT>(value); }
  IndirectCommandsLayoutEXT getIndirectCommandsLayout() const { return std::bit_cast<IndirectCommandsLayoutEXT>(this->indirectCommandsLayout); }
  void setIndirectAddress(DeviceAddress value) { this->indirectAddress = value; }
  DeviceAddress getIndirectAddress() const { return this->indirectAddress; }
  void setIndirectAddressSize(DeviceSize value) { this->indirectAddressSize = value; }
  DeviceSize getIndirectAddressSize() const { return this->indirectAddressSize; }
  void setPreprocessSize(DeviceSize value) { this->preprocessSize = value; }
  DeviceSize getPreprocessSize() const { return this->preprocessSize; }
  void setMaxSequenceCount(uint32_t value) { this->maxSequenceCount = value; }
  uint32_t getMaxSequenceCount() const { return this->maxSequenceCount; }
  void setMaxDrawCount(uint32_t value) { this->maxDrawCount = value; }
  uint32_t getMaxDrawCount() const { return this->maxDrawCount; }

  void setIndirectExecutionSet(IndirectExecutionSetEXT value) { this->indirectExecutionSet = std::bit_cast<VkIndirectExecutionSetEXT>(value); }
  IndirectExecutionSetEXT getIndirectExecutionSet() const { return std::bit_cast<IndirectExecutionSetEXT>(this->indirectExecutionSet); }
  void setPreprocessAddress(DeviceAddress value) { this->preprocessAddress = value; }
  DeviceAddress getPreprocessAddress() const { return this->preprocessAddress; }
  void setSequenceCountAddress(DeviceAddress value) { this->sequenceCountAddress = value; }
  DeviceAddress getSequenceCountAddress() const { return this->sequenceCountAddress; }

  void attach(struct GeneratedCommandsPipelineInfoEXT&);
  void attach(struct GeneratedCommandsShaderInfoEXT&);
};

struct IndirectCommandsExecutionSetTokenEXT : VkIndirectCommandsExecutionSetTokenEXT {
  IndirectCommandsExecutionSetTokenEXT() noexcept : VkIndirectCommandsExecutionSetTokenEXT{} {}
  IndirectCommandsExecutionSetTokenEXT(IndirectExecutionSetInfoTypeEXT type, ShaderStageFlags shaderStages) noexcept : VkIndirectCommandsExecutionSetTokenEXT{.type = std::bit_cast<VkIndirectExecutionSetInfoTypeEXT>(type), .shaderStages = std::bit_cast<VkShaderStageFlags>(shaderStages)} {}

  void setType(IndirectExecutionSetInfoTypeEXT value) { this->type = std::bit_cast<VkIndirectExecutionSetInfoTypeEXT>(value); }
  IndirectExecutionSetInfoTypeEXT getType() const { return std::bit_cast<IndirectExecutionSetInfoTypeEXT>(this->type); }
  void setShaderStages(ShaderStageFlags value) { this->shaderStages = std::bit_cast<VkShaderStageFlags>(value); }
  ShaderStageFlags getShaderStages() const { return std::bit_cast<ShaderStageFlags>(this->shaderStages); }
};
#endif // VK_EXT_device_generated_commands

#if VK_VERSION_1_0
struct PushConstantRange : VkPushConstantRange {
  PushConstantRange() noexcept : VkPushConstantRange{} {}
  PushConstantRange(ShaderStageFlags stageFlags, uint32_t offset, uint32_t size) noexcept : VkPushConstantRange{.stageFlags = std::bit_cast<VkShaderStageFlags>(stageFlags), .offset = offset, .size = size} {}

  // Which stages use the range
  void setStageFlags(ShaderStageFlags value) { this->stageFlags = std::bit_cast<VkShaderStageFlags>(value); }
  ShaderStageFlags getStageFlags() const { return std::bit_cast<ShaderStageFlags>(this->stageFlags); }
  // Start of the range, in bytes
  void setOffset(uint32_t value) { this->offset = value; }
  uint32_t getOffset() const { return this->offset; }
  // Size of the range, in bytes
  void setSize(uint32_t value) { this->size = value; }
  uint32_t getSize() const { return this->size; }
};
#endif // VK_VERSION_1_0

#if VK_AMD_shader_info
struct ShaderStatisticsInfoAMD : VkShaderStatisticsInfoAMD {
  ShaderStatisticsInfoAMD() noexcept : VkShaderStatisticsInfoAMD{} {}

  ShaderStageFlags getShaderStageMask() const { return std::bit_cast<ShaderStageFlags>(this->shaderStageMask); }
  const ShaderResourceUsageAMD& getResourceUsage() const { return static_cast<const ShaderResourceUsageAMD&>(this->resourceUsage); }
  uint32_t getNumPhysicalVgprs() const { return this->numPhysicalVgprs; }
  uint32_t getNumPhysicalSgprs() const { return this->numPhysicalSgprs; }
  uint32_t getNumAvailableVgprs() const { return this->numAvailableVgprs; }
  uint32_t getNumAvailableSgprs() const { return this->numAvailableSgprs; }
  std::span<const uint32_t, 3> getComputeWorkGroupSize() const { return this->computeWorkGroupSize; }
};
#endif // VK_AMD_shader_info

#if VK_VERSION_1_4
struct BindDescriptorSetsInfo : VkBindDescriptorSetsInfo {
  BindDescriptorSetsInfo() noexcept : VkBindDescriptorSetsInfo{.sType = VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_SETS_INFO} {}

  void setStageFlags(ShaderStageFlags value) { this->stageFlags = std::bit_cast<VkShaderStageFlags>(value); }
  ShaderStageFlags getStageFlags() const { return std::bit_cast<ShaderStageFlags>(this->stageFlags); }
  void setDescriptorSetCount(uint32_t value) { this->descriptorSetCount = value; }
  uint32_t getDescriptorSetCount() const { return this->descriptorSetCount; }
  void setDescriptorSets(const DescriptorSet* value) { this->pDescriptorSets = std::bit_cast<const VkDescriptorSet*>(value); }
  const DescriptorSet* getDescriptorSets() const { return std::bit_cast<const DescriptorSet*>(this->pDescriptorSets); }

  void setLayout(PipelineLayout value) { this->layout = std::bit_cast<VkPipelineLayout>(value); }
  PipelineLayout getLayout() const { return std::bit_cast<PipelineLayout>(this->layout); }
  void setFirstSet(uint32_t value) { this->firstSet = value; }
  uint32_t getFirstSet() const { return this->firstSet; }
  void setDynamicOffsetCount(uint32_t value) { this->dynamicOffsetCount = value; }
  uint32_t getDynamicOffsetCount() const { return this->dynamicOffsetCount; }
  void setDynamicOffsets(const uint32_t* value) { this->pDynamicOffsets = value; }
  const uint32_t* getDynamicOffsets() const { return this->pDynamicOffsets; }

  void attach(struct PipelineLayoutCreateInfo&);
};

struct PushConstantsInfo : VkPushConstantsInfo {
  PushConstantsInfo() noexcept : VkPushConstantsInfo{.sType = VK_STRUCTURE_TYPE_PUSH_CONSTANTS_INFO} {}

  void setStageFlags(ShaderStageFlags value) { this->stageFlags = std::bit_cast<VkShaderStageFlags>(value); }
  ShaderStageFlags getStageFlags() const { return std::bit_cast<ShaderStageFlags>(this->stageFlags); }
  void setSize(uint32_t value) { this->size = value; }
  uint32_t getSize() const { return this->size; }
  void setValues(const void* value) { this->pValues = value; }
  const void* getValues() const { return this->pValues; }

  void setLayout(PipelineLayout value) { this->layout = std::bit_cast<VkPipelineLayout>(value); }
  PipelineLayout getLayout() const { return std::bit_cast<PipelineLayout>(this->layout); }
  void setOffset(uint32_t value) { this->offset = value; }
  uint32_t getOffset() const { return this->offset; }

  void attach(struct PipelineLayoutCreateInfo&);
};
#endif // VK_VERSION_1_4

#if VK_KHR_maintenance6
struct SetDescriptorBufferOffsetsInfoEXT : VkSetDescriptorBufferOffsetsInfoEXT {
  SetDescriptorBufferOffsetsInfoEXT() noexcept : VkSetDescriptorBufferOffsetsInfoEXT{.sType = VK_STRUCTURE_TYPE_SET_DESCRIPTOR_BUFFER_OFFSETS_INFO_EXT} {}

  void setStageFlags(ShaderStageFlags value) { this->stageFlags = std::bit_cast<VkShaderStageFlags>(value); }
  ShaderStageFlags getStageFlags() const { return std::bit_cast<ShaderStageFlags>(this->stageFlags); }
  void setSetCount(uint32_t value) { this->setCount = value; }
  uint32_t getSetCount() const { return this->setCount; }
  void setBufferIndices(const uint32_t* value) { this->pBufferIndices = value; }
  const uint32_t* getBufferIndices() const { return this->pBufferIndices; }
  void setOffsets(const DeviceSize* value) { this->pOffsets = value; }
  const DeviceSize* getOffsets() const { return this->pOffsets; }

  void setLayout(PipelineLayout value) { this->layout = std::bit_cast<VkPipelineLayout>(value); }
  PipelineLayout getLayout() const { return std::bit_cast<PipelineLayout>(this->layout); }
  void setFirstSet(uint32_t value) { this->firstSet = value; }
  uint32_t getFirstSet() const { return this->firstSet; }

  void attach(struct PipelineLayoutCreateInfo&);
};

struct BindDescriptorBufferEmbeddedSamplersInfoEXT : VkBindDescriptorBufferEmbeddedSamplersInfoEXT {
  BindDescriptorBufferEmbeddedSamplersInfoEXT() noexcept : VkBindDescriptorBufferEmbeddedSamplersInfoEXT{.sType = VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_BUFFER_EMBEDDED_SAMPLERS_INFO_EXT} {}

  void setStageFlags(ShaderStageFlags value) { this->stageFlags = std::bit_cast<VkShaderStageFlags>(value); }
  ShaderStageFlags getStageFlags() const { return std::bit_cast<ShaderStageFlags>(this->stageFlags); }

  void setLayout(PipelineLayout value) { this->layout = std::bit_cast<VkPipelineLayout>(value); }
  PipelineLayout getLayout() const { return std::bit_cast<PipelineLayout>(this->layout); }
  void setSet(uint32_t value) { this->set = value; }
  uint32_t getSet() const { return this->set; }

  void attach(struct PipelineLayoutCreateInfo&);
};
#endif // VK_KHR_maintenance6

#if VK_VERSION_1_0
struct DescriptorSetLayoutBinding : VkDescriptorSetLayoutBinding {
  DescriptorSetLayoutBinding() noexcept : VkDescriptorSetLayoutBinding{} {}

  // Binding number for this entry
  void setBinding(uint32_t value) { this->binding = value; }
  uint32_t getBinding() const { return this->binding; }
  // Type of the descriptors in this binding
  void setDescriptorType(DescriptorType value) { this->descriptorType = std::bit_cast<VkDescriptorType>(value); }
  DescriptorType getDescriptorType() const { return std::bit_cast<DescriptorType>(this->descriptorType); }
  // Shader stages this binding is visible to
  void setStageFlags(ShaderStageFlags value) { this->stageFlags = std::bit_cast<VkShaderStageFlags>(value); }
  ShaderStageFlags getStageFlags() const { return std::bit_cast<ShaderStageFlags>(this->stageFlags); }

  // Number of descriptors in this binding
  void setDescriptorCount(uint32_t value) { this->descriptorCount = value; }
  uint32_t getDescriptorCount() const { return this->descriptorCount; }
  // Immutable samplers (used if descriptor type is SAMPLER or COMBINED_IMAGE_SAMPLER, is either NULL or contains count number of elements)
  void setImmutableSamplers(const Sampler* value) { this->pImmutableSamplers = std::bit_cast<const VkSampler*>(value); }
  const Sampler* getImmutableSamplers() const { return std::bit_cast<const Sampler*>(this->pImmutableSamplers); }
};
#endif // VK_VERSION_1_0

#if VK_KHR_video_queue
struct PhysicalDeviceVideoFormatInfoKHR : VkPhysicalDeviceVideoFormatInfoKHR {
  PhysicalDeviceVideoFormatInfoKHR() noexcept : VkPhysicalDeviceVideoFormatInfoKHR{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR} {}

  void setImageUsage(ImageUsageFlags value) { this->imageUsage = std::bit_cast<VkImageUsageFlags>(value); }
  ImageUsageFlags getImageUsage() const { return std::bit_cast<ImageUsageFlags>(this->imageUsage); }

  void attach(struct VideoProfileListInfoKHR&);
};
#endif // VK_KHR_video_queue

#if VK_VERSION_1_1
struct PhysicalDeviceSparseImageFormatInfo2 : VkPhysicalDeviceSparseImageFormatInfo2 {
  PhysicalDeviceSparseImageFormatInfo2() noexcept : VkPhysicalDeviceSparseImageFormatInfo2{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2} {}

  void setFormat(Format value) { this->format = std::bit_cast<VkFormat>(value); }
  Format getFormat() const { return std::bit_cast<Format>(this->format); }
  void setType(ImageType value) { this->type = std::bit_cast<VkImageType>(value); }
  ImageType getType() const { return std::bit_cast<ImageType>(this->type); }
  void setSamples(SampleCountFlagBits value) { this->samples = std::bit_cast<VkSampleCountFlagBits>(value); }
  SampleCountFlagBits getSamples() const { return std::bit_cast<SampleCountFlagBits>(this->samples); }
  void setUsage(ImageUsageFlags value) { this->usage = std::bit_cast<VkImageUsageFlags>(value); }
  ImageUsageFlags getUsage() const { return std::bit_cast<ImageUsageFlags>(this->usage); }
  void setTiling(ImageTiling value) { this->tiling = std::bit_cast<VkImageTiling>(value); }
  ImageTiling getTiling() const { return std::bit_cast<ImageTiling>(this->tiling); }
};
#endif // VK_VERSION_1_1

#if VK_KHR_video_queue
struct VideoFormatPropertiesKHR : VkVideoFormatPropertiesKHR {
  VideoFormatPropertiesKHR() noexcept : VkVideoFormatPropertiesKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR} {}

  Format getFormat() const { return std::bit_cast<Format>(this->format); }
  const ComponentMapping& getComponentMapping() const { return static_cast<const ComponentMapping&>(this->componentMapping); }
  ImageCreateFlags getImageCreateFlags() const { return std::bit_cast<ImageCreateFlags>(this->imageCreateFlags); }
  ImageType getImageType() const { return std::bit_cast<ImageType>(this->imageType); }
  ImageTiling getImageTiling() const { return std::bit_cast<ImageTiling>(this->imageTiling); }
  ImageUsageFlags getImageUsageFlags() const { return std::bit_cast<ImageUsageFlags>(this->imageUsageFlags); }

#if VK_KHR_video_encode_quantization_map
  void attach(struct VideoFormatQuantizationMapPropertiesKHR&);
  void attach(struct VideoFormatH265QuantizationMapPropertiesKHR&);
  void attach(struct VideoFormatAV1QuantizationMapPropertiesKHR&);
#endif // VK_KHR_video_encode_quantization_map
};
#endif // VK_KHR_video_queue

#if VK_VERSION_1_1
struct PhysicalDeviceImageFormatInfo2 : VkPhysicalDeviceImageFormatInfo2 {
  PhysicalDeviceImageFormatInfo2() noexcept : VkPhysicalDeviceImageFormatInfo2{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2} {}

  void setFormat(Format value) { this->format = std::bit_cast<VkFormat>(value); }
  Format getFormat() const { return std::bit_cast<Format>(this->format); }
  void setType(ImageType value) { this->type = std::bit_cast<VkImageType>(value); }
  ImageType getType() const { return std::bit_cast<ImageType>(this->type); }
  void setTiling(ImageTiling value) { this->tiling = std::bit_cast<VkImageTiling>(value); }
  ImageTiling getTiling() const { return std::bit_cast<ImageTiling>(this->tiling); }
  void setUsage(ImageUsageFlags value) { this->usage = std::bit_cast<VkImageUsageFlags>(value); }
  ImageUsageFlags getUsage() const { return std::bit_cast<ImageUsageFlags>(this->usage); }

  void setFlags(ImageCreateFlags value) { this->flags = std::bit_cast<VkImageCreateFlags>(value); }
  ImageCreateFlags getFlags() const { return std::bit_cast<ImageCreateFlags>(this->flags); }

  void attach(struct PhysicalDeviceExternalImageFormatInfo&);
#if VK_VERSION_1_2
  void attach(struct ImageFormatListCreateInfo&);
#endif // VK_VERSION_1_2
#if VK_EXT_image_drm_format_modifier
  void attach(struct PhysicalDeviceImageDrmFormatModifierInfoEXT&);
#endif // VK_EXT_image_drm_format_modifier
#if VK_VERSION_1_2
  void attach(struct ImageStencilUsageCreateInfo&);
#endif // VK_VERSION_1_2
#if VK_EXT_filter_cubic
  void attach(struct PhysicalDeviceImageViewImageFormatInfoEXT&);
#endif // VK_EXT_filter_cubic
#if VK_KHR_video_queue
  void attach(struct VideoProfileListInfoKHR&);
#endif // VK_KHR_video_queue
#if VK_EXT_image_compression_control
  void attach(struct ImageCompressionControlEXT&);
#endif // VK_EXT_image_compression_control
#if VK_NV_optical_flow
  void attach(struct OpticalFlowImageFormatInfoNV&);
#endif // VK_NV_optical_flow
};
#endif // VK_VERSION_1_1

#if VK_VERSION_1_2
struct FramebufferAttachmentImageInfo : VkFramebufferAttachmentImageInfo {
  FramebufferAttachmentImageInfo() noexcept : VkFramebufferAttachmentImageInfo{.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO} {}

  // Image usage flags
  void setUsage(ImageUsageFlags value) { this->usage = std::bit_cast<VkImageUsageFlags>(value); }
  ImageUsageFlags getUsage() const { return std::bit_cast<ImageUsageFlags>(this->usage); }
  void setWidth(uint32_t value) { this->width = value; }
  uint32_t getWidth() const { return this->width; }
  void setHeight(uint32_t value) { this->height = value; }
  uint32_t getHeight() const { return this->height; }
  void setLayerCount(uint32_t value) { this->layerCount = value; }
  uint32_t getLayerCount() const { return this->layerCount; }

  // Image creation flags
  void setFlags(ImageCreateFlags value) { this->flags = std::bit_cast<VkImageCreateFlags>(value); }
  ImageCreateFlags getFlags() const { return std::bit_cast<ImageCreateFlags>(this->flags); }
  void setViewFormatCount(uint32_t value) { this->viewFormatCount = value; }
  uint32_t getViewFormatCount() const { return this->viewFormatCount; }
  void setViewFormats(const Format* value) { this->pViewFormats = std::bit_cast<const VkFormat*>(value); }
  const Format* getViewFormats() const { return std::bit_cast<const Format*>(this->pViewFormats); }
};
#endif // VK_VERSION_1_2

#if VK_VERSION_1_0
struct ImageCreateInfo : VkImageCreateInfo {
  ImageCreateInfo() noexcept : VkImageCreateInfo{.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO} {}

  void setImageType(ImageType value) { this->imageType = std::bit_cast<VkImageType>(value); }
  ImageType getImageType() const { return std::bit_cast<ImageType>(this->imageType); }
  void setFormat(Format value) { this->format = std::bit_cast<VkFormat>(value); }
  Format getFormat() const { return std::bit_cast<Format>(this->format); }
  void setExtent(const Extent3D& value) { this->extent = value; }
  const Extent3D& getExtent() const { return static_cast<const Extent3D&>(this->extent); }
  void setMipLevels(uint32_t value) { this->mipLevels = value; }
  uint32_t getMipLevels() const { return this->mipLevels; }
  void setArrayLayers(uint32_t value) { this->arrayLayers = value; }
  uint32_t getArrayLayers() const { return this->arrayLayers; }
  void setSamples(SampleCountFlagBits value) { this->samples = std::bit_cast<VkSampleCountFlagBits>(value); }
  SampleCountFlagBits getSamples() const { return std::bit_cast<SampleCountFlagBits>(this->samples); }
  void setTiling(ImageTiling value) { this->tiling = std::bit_cast<VkImageTiling>(value); }
  ImageTiling getTiling() const { return std::bit_cast<ImageTiling>(this->tiling); }
  // Image usage flags
  void setUsage(ImageUsageFlags value) { this->usage = std::bit_cast<VkImageUsageFlags>(value); }
  ImageUsageFlags getUsage() const { return std::bit_cast<ImageUsageFlags>(this->usage); }
  // Cross-queue-family sharing mode
  void setSharingMode(SharingMode value) { this->sharingMode = std::bit_cast<VkSharingMode>(value); }
  SharingMode getSharingMode() const { return std::bit_cast<SharingMode>(this->sharingMode); }
  // Initial image layout for all subresources
  void setInitialLayout(ImageLayout value) { this->initialLayout = std::bit_cast<VkImageLayout>(value); }
  ImageLayout getInitialLayout() const { return std::bit_cast<ImageLayout>(this->initialLayout); }

  // Image creation flags
  void setFlags(ImageCreateFlags value) { this->flags = std::bit_cast<VkImageCreateFlags>(value); }
  ImageCreateFlags getFlags() const { return std::bit_cast<ImageCreateFlags>(this->flags); }
  // Number of queue families to share across
  void setQueueFamilyIndexCount(uint32_t value) { this->queueFamilyIndexCount = value; }
  uint32_t getQueueFamilyIndexCount() const { return this->queueFamilyIndexCount; }
  // Array of queue family indices to share across
  void setQueueFamilyIndices(const uint32_t* value) { this->pQueueFamilyIndices = value; }
  const uint32_t* getQueueFamilyIndices() const { return this->pQueueFamilyIndices; }

#if VK_VERSION_1_1
  void attach(struct ExternalMemoryImageCreateInfo&);
#endif // VK_VERSION_1_1
#if VK_KHR_swapchain
  void attach(struct ImageSwapchainCreateInfoKHR&);
#endif // VK_KHR_swapchain
#if VK_VERSION_1_2
  void attach(struct ImageFormatListCreateInfo&);
#endif // VK_VERSION_1_2
#if VK_ANDROID_external_memory_android_hardware_buffer
  void attach(struct ExternalFormatANDROID&);
#endif // VK_ANDROID_external_memory_android_hardware_buffer
#if VK_EXT_image_drm_format_modifier
  void attach(struct ImageDrmFormatModifierListCreateInfoEXT&);
  void attach(struct ImageDrmFormatModifierExplicitCreateInfoEXT&);
#endif // VK_EXT_image_drm_format_modifier
#if VK_VERSION_1_2
  void attach(struct ImageStencilUsageCreateInfo&);
#endif // VK_VERSION_1_2
#if VK_KHR_video_queue
  void attach(struct VideoProfileListInfoKHR&);
#endif // VK_KHR_video_queue
#if VK_EXT_descriptor_buffer
  void attach(struct OpaqueCaptureDescriptorDataCreateInfoEXT&);
#endif // VK_EXT_descriptor_buffer
#if VK_FUCHSIA_buffer_collection
  void attach(struct BufferCollectionImageCreateInfoFUCHSIA&);
#endif // VK_FUCHSIA_buffer_collection
#if VK_EXT_image_compression_control
  void attach(struct ImageCompressionControlEXT&);
#endif // VK_EXT_image_compression_control
#if VK_EXT_metal_objects
  void attach(struct ExportMetalObjectCreateInfoEXT&);
  void attach(struct ImportMetalTextureInfoEXT&);
  void attach(struct ImportMetalIOSurfaceInfoEXT&);
#endif // VK_EXT_metal_objects
#if VK_NV_optical_flow
  void attach(struct OpticalFlowImageFormatInfoNV&);
#endif // VK_NV_optical_flow
#if VK_QNX_external_memory_screen_buffer
  void attach(struct ExternalFormatQNX&);
#endif // VK_QNX_external_memory_screen_buffer
#if VK_MESA_image_alignment_control
  void attach(struct ImageAlignmentControlCreateInfoMESA&);
#endif // VK_MESA_image_alignment_control
};

struct SamplerCreateInfo : VkSamplerCreateInfo {
  SamplerCreateInfo() noexcept : VkSamplerCreateInfo{.sType = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO} {}

  // Filter mode for magnification
  void setMagFilter(Filter value) { this->magFilter = std::bit_cast<VkFilter>(value); }
  Filter getMagFilter() const { return std::bit_cast<Filter>(this->magFilter); }
  // Filter mode for minifiation
  void setMinFilter(Filter value) { this->minFilter = std::bit_cast<VkFilter>(value); }
  Filter getMinFilter() const { return std::bit_cast<Filter>(this->minFilter); }
  // Mipmap selection mode
  void setMipmapMode(SamplerMipmapMode value) { this->mipmapMode = std::bit_cast<VkSamplerMipmapMode>(value); }
  SamplerMipmapMode getMipmapMode() const { return std::bit_cast<SamplerMipmapMode>(this->mipmapMode); }
  void setAddressModeU(SamplerAddressMode value) { this->addressModeU = std::bit_cast<VkSamplerAddressMode>(value); }
  SamplerAddressMode getAddressModeU() const { return std::bit_cast<SamplerAddressMode>(this->addressModeU); }
  void setAddressModeV(SamplerAddressMode value) { this->addressModeV = std::bit_cast<VkSamplerAddressMode>(value); }
  SamplerAddressMode getAddressModeV() const { return std::bit_cast<SamplerAddressMode>(this->addressModeV); }
  void setAddressModeW(SamplerAddressMode value) { this->addressModeW = std::bit_cast<VkSamplerAddressMode>(value); }
  SamplerAddressMode getAddressModeW() const { return std::bit_cast<SamplerAddressMode>(this->addressModeW); }
  void setMipLodBias(float value) { this->mipLodBias = value; }
  float getMipLodBias() const { return this->mipLodBias; }
  void setMaxAnisotropy(float value) { this->maxAnisotropy = value; }
  float getMaxAnisotropy() const { return this->maxAnisotropy; }
  void setCompareOp(CompareOp value) { this->compareOp = std::bit_cast<VkCompareOp>(value); }
  CompareOp getCompareOp() const { return std::bit_cast<CompareOp>(this->compareOp); }
  void setMinLod(float value) { this->minLod = value; }
  float getMinLod() const { return this->minLod; }
  void setMaxLod(float value) { this->maxLod = value; }
  float getMaxLod() const { return this->maxLod; }
  void setBorderColor(BorderColor value) { this->borderColor = std::bit_cast<VkBorderColor>(value); }
  BorderColor getBorderColor() const { return std::bit_cast<BorderColor>(this->borderColor); }

  void setFlags(SamplerCreateFlags value) { this->flags = std::bit_cast<VkSamplerCreateFlags>(value); }
  SamplerCreateFlags getFlags() const { return std::bit_cast<SamplerCreateFlags>(this->flags); }
  void setAnisotropyEnable(Bool32 value) { this->anisotropyEnable = value; }
  Bool32 getAnisotropyEnable() const { return this->anisotropyEnable; }
  void setCompareEnable(Bool32 value) { this->compareEnable = value; }
  Bool32 getCompareEnable() const { return this->compareEnable; }
  void setUnnormalizedCoordinates(Bool32 value) { this->unnormalizedCoordinates = value; }
  Bool32 getUnnormalizedCoordinates() const { return this->unnormalizedCoordinates; }

#if VK_VERSION_1_1
  void attach(struct SamplerYcbcrConversionInfo&);
#endif // VK_VERSION_1_1
#if VK_VERSION_1_2
  void attach(struct SamplerReductionModeCreateInfo&);
#endif // VK_VERSION_1_2
#if VK_EXT_custom_border_color
  void attach(struct SamplerCustomBorderColorCreateInfoEXT&);
#endif // VK_EXT_custom_border_color
#if VK_EXT_border_color_swizzle
  void attach(struct SamplerBorderColorComponentMappingCreateInfoEXT&);
#endif // VK_EXT_border_color_swizzle
#if VK_EXT_descriptor_buffer
  void attach(struct OpaqueCaptureDescriptorDataCreateInfoEXT&);
#endif // VK_EXT_descriptor_buffer
#if VK_QCOM_filter_cubic_weights
  void attach(struct SamplerCubicWeightsCreateInfoQCOM&);
#endif // VK_QCOM_filter_cubic_weights
#if VK_QCOM_image_processing2
  void attach(struct SamplerBlockMatchWindowCreateInfoQCOM&);
#endif // VK_QCOM_image_processing2
};
#endif // VK_VERSION_1_0

#if VK_KHR_maintenance5
using PipelineCreateFlags2KHR = PipelineCreateFlags2;
#endif // VK_KHR_maintenance5

#if VK_VERSION_1_0
struct PipelineShaderStageCreateInfo : VkPipelineShaderStageCreateInfo {
  PipelineShaderStageCreateInfo() noexcept : VkPipelineShaderStageCreateInfo{.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO} {}

  // Shader stage
  void setStage(ShaderStageFlagBits value) { this->stage = std::bit_cast<VkShaderStageFlagBits>(value); }
  ShaderStageFlagBits getStage() const { return std::bit_cast<ShaderStageFlagBits>(this->stage); }
  // Null-terminated entry point name
  void setName(const char* value) { this->pName = value; }
  const char* getName() const { return this->pName; }

  void setFlags(PipelineShaderStageCreateFlags value) { this->flags = std::bit_cast<VkPipelineShaderStageCreateFlags>(value); }
  PipelineShaderStageCreateFlags getFlags() const { return std::bit_cast<PipelineShaderStageCreateFlags>(this->flags); }
  // Module containing entry point
  void setModule(ShaderModule value) { this->module = std::bit_cast<VkShaderModule>(value); }
  ShaderModule getModule() const { return std::bit_cast<ShaderModule>(this->module); }
  void setSpecializationInfo(const SpecializationInfo* value) { this->pSpecializationInfo = std::bit_cast<const VkSpecializationInfo*>(value); }
  const SpecializationInfo* getSpecializationInfo() const { return std::bit_cast<const SpecializationInfo*>(this->pSpecializationInfo); }

  void attachHead(struct ShaderModuleCreateInfo&);
#if VK_EXT_validation_cache
  void attach(struct ShaderModuleValidationCacheCreateInfoEXT&);
#endif // VK_EXT_validation_cache
#if VK_EXT_debug_utils
  void attach(struct DebugUtilsObjectNameInfoEXT&);
#endif // VK_EXT_debug_utils
#if VK_VERSION_1_3
  void attach(struct PipelineShaderStageRequiredSubgroupSizeCreateInfo&);
#endif // VK_VERSION_1_3
#if VK_EXT_shader_module_identifier
  void attach(struct PipelineShaderStageModuleIdentifierCreateInfoEXT&);
#endif // VK_EXT_shader_module_identifier
#if VK_VERSION_1_4
  void attach(struct PipelineRobustnessCreateInfo&);
#endif // VK_VERSION_1_4
};

struct PipelineColorBlendAttachmentState : VkPipelineColorBlendAttachmentState {
  PipelineColorBlendAttachmentState() noexcept : VkPipelineColorBlendAttachmentState{} {}

  void setSrcColorBlendFactor(BlendFactor value) { this->srcColorBlendFactor = std::bit_cast<VkBlendFactor>(value); }
  BlendFactor getSrcColorBlendFactor() const { return std::bit_cast<BlendFactor>(this->srcColorBlendFactor); }
  void setDstColorBlendFactor(BlendFactor value) { this->dstColorBlendFactor = std::bit_cast<VkBlendFactor>(value); }
  BlendFactor getDstColorBlendFactor() const { return std::bit_cast<BlendFactor>(this->dstColorBlendFactor); }
  void setColorBlendOp(BlendOp value) { this->colorBlendOp = std::bit_cast<VkBlendOp>(value); }
  BlendOp getColorBlendOp() const { return std::bit_cast<BlendOp>(this->colorBlendOp); }
  void setSrcAlphaBlendFactor(BlendFactor value) { this->srcAlphaBlendFactor = std::bit_cast<VkBlendFactor>(value); }
  BlendFactor getSrcAlphaBlendFactor() const { return std::bit_cast<BlendFactor>(this->srcAlphaBlendFactor); }
  void setDstAlphaBlendFactor(BlendFactor value) { this->dstAlphaBlendFactor = std::bit_cast<VkBlendFactor>(value); }
  BlendFactor getDstAlphaBlendFactor() const { return std::bit_cast<BlendFactor>(this->dstAlphaBlendFactor); }
  void setAlphaBlendOp(BlendOp value) { this->alphaBlendOp = std::bit_cast<VkBlendOp>(value); }
  BlendOp getAlphaBlendOp() const { return std::bit_cast<BlendOp>(this->alphaBlendOp); }

  void setBlendEnable(Bool32 value) { this->blendEnable = value; }
  Bool32 getBlendEnable() const { return this->blendEnable; }
  void setColorWriteMask(ColorComponentFlags value) { this->colorWriteMask = std::bit_cast<VkColorComponentFlags>(value); }
  ColorComponentFlags getColorWriteMask() const { return std::bit_cast<ColorComponentFlags>(this->colorWriteMask); }
};

struct FenceCreateInfo : VkFenceCreateInfo {
  FenceCreateInfo() noexcept : VkFenceCreateInfo{.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO} {}

  // Fence creation flags
  void setFlags(FenceCreateFlags value) { this->flags = std::bit_cast<VkFenceCreateFlags>(value); }
  FenceCreateFlags getFlags() const { return std::bit_cast<FenceCreateFlags>(this->flags); }

#if VK_VERSION_1_1
  void attach(struct ExportFenceCreateInfo&);
#endif // VK_VERSION_1_1
#if VK_KHR_external_fence_win32
  void attach(struct ExportFenceWin32HandleInfoKHR&);
#endif // VK_KHR_external_fence_win32
};
#endif // VK_VERSION_1_0

#if VK_ANDROID_external_memory_android_hardware_buffer
struct AndroidHardwareBufferFormatPropertiesANDROID : VkAndroidHardwareBufferFormatPropertiesANDROID {
  AndroidHardwareBufferFormatPropertiesANDROID() noexcept : VkAndroidHardwareBufferFormatPropertiesANDROID{.sType = VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID} {}

  Format getFormat() const { return std::bit_cast<Format>(this->format); }
  uint64_t getExternalFormat() const { return this->externalFormat; }
  FormatFeatureFlags getFormatFeatures() const { return std::bit_cast<FormatFeatureFlags>(this->formatFeatures); }
  const ComponentMapping& getSamplerYcbcrConversionComponents() const { return static_cast<const ComponentMapping&>(this->samplerYcbcrConversionComponents); }
  SamplerYcbcrModelConversion getSuggestedYcbcrModel() const { return std::bit_cast<SamplerYcbcrModelConversion>(this->suggestedYcbcrModel); }
  SamplerYcbcrRange getSuggestedYcbcrRange() const { return std::bit_cast<SamplerYcbcrRange>(this->suggestedYcbcrRange); }
  ChromaLocation getSuggestedXChromaOffset() const { return std::bit_cast<ChromaLocation>(this->suggestedXChromaOffset); }
  ChromaLocation getSuggestedYChromaOffset() const { return std::bit_cast<ChromaLocation>(this->suggestedYChromaOffset); }
};
inline void AndroidHardwareBufferPropertiesANDROID::attach(AndroidHardwareBufferFormatPropertiesANDROID& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_ANDROID_external_memory_android_hardware_buffer

#if VK_FUCHSIA_buffer_collection
struct BufferCollectionPropertiesFUCHSIA : VkBufferCollectionPropertiesFUCHSIA {
  BufferCollectionPropertiesFUCHSIA() noexcept : VkBufferCollectionPropertiesFUCHSIA{.sType = VK_STRUCTURE_TYPE_BUFFER_COLLECTION_PROPERTIES_FUCHSIA} {}

  uint32_t getMemoryTypeBits() const { return this->memoryTypeBits; }
  uint32_t getBufferCount() const { return this->bufferCount; }
  uint32_t getCreateInfoIndex() const { return this->createInfoIndex; }
  uint64_t getSysmemPixelFormat() const { return this->sysmemPixelFormat; }
  FormatFeatureFlags getFormatFeatures() const { return std::bit_cast<FormatFeatureFlags>(this->formatFeatures); }
  const SysmemColorSpaceFUCHSIA& getSysmemColorSpaceIndex() const { return static_cast<const SysmemColorSpaceFUCHSIA&>(this->sysmemColorSpaceIndex); }
  const ComponentMapping& getSamplerYcbcrConversionComponents() const { return static_cast<const ComponentMapping&>(this->samplerYcbcrConversionComponents); }
  SamplerYcbcrModelConversion getSuggestedYcbcrModel() const { return std::bit_cast<SamplerYcbcrModelConversion>(this->suggestedYcbcrModel); }
  SamplerYcbcrRange getSuggestedYcbcrRange() const { return std::bit_cast<SamplerYcbcrRange>(this->suggestedYcbcrRange); }
  ChromaLocation getSuggestedXChromaOffset() const { return std::bit_cast<ChromaLocation>(this->suggestedXChromaOffset); }
  ChromaLocation getSuggestedYChromaOffset() const { return std::bit_cast<ChromaLocation>(this->suggestedYChromaOffset); }
};
#endif // VK_FUCHSIA_buffer_collection

#if VK_QNX_external_memory_screen_buffer
struct ScreenBufferFormatPropertiesQNX : VkScreenBufferFormatPropertiesQNX {
  ScreenBufferFormatPropertiesQNX() noexcept : VkScreenBufferFormatPropertiesQNX{.sType = VK_STRUCTURE_TYPE_SCREEN_BUFFER_FORMAT_PROPERTIES_QNX} {}

  Format getFormat() const { return std::bit_cast<Format>(this->format); }
  uint64_t getExternalFormat() const { return this->externalFormat; }
  uint64_t getScreenUsage() const { return this->screenUsage; }
  FormatFeatureFlags getFormatFeatures() const { return std::bit_cast<FormatFeatureFlags>(this->formatFeatures); }
  const ComponentMapping& getSamplerYcbcrConversionComponents() const { return static_cast<const ComponentMapping&>(this->samplerYcbcrConversionComponents); }
  SamplerYcbcrModelConversion getSuggestedYcbcrModel() const { return std::bit_cast<SamplerYcbcrModelConversion>(this->suggestedYcbcrModel); }
  SamplerYcbcrRange getSuggestedYcbcrRange() const { return std::bit_cast<SamplerYcbcrRange>(this->suggestedYcbcrRange); }
  ChromaLocation getSuggestedXChromaOffset() const { return std::bit_cast<ChromaLocation>(this->suggestedXChromaOffset); }
  ChromaLocation getSuggestedYChromaOffset() const { return std::bit_cast<ChromaLocation>(this->suggestedYChromaOffset); }
};
inline void ScreenBufferPropertiesQNX::attach(ScreenBufferFormatPropertiesQNX& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_QNX_external_memory_screen_buffer

#if VK_EXT_image_drm_format_modifier
struct DrmFormatModifierPropertiesEXT : VkDrmFormatModifierPropertiesEXT {
  DrmFormatModifierPropertiesEXT() noexcept : VkDrmFormatModifierPropertiesEXT{} {}

  uint64_t getDrmFormatModifier() const { return this->drmFormatModifier; }
  uint32_t getDrmFormatModifierPlaneCount() const { return this->drmFormatModifierPlaneCount; }
  FormatFeatureFlags getDrmFormatModifierTilingFeatures() const { return std::bit_cast<FormatFeatureFlags>(this->drmFormatModifierTilingFeatures); }
};
#endif // VK_EXT_image_drm_format_modifier

#if VK_VERSION_1_0
struct FormatProperties : VkFormatProperties {
  FormatProperties() noexcept : VkFormatProperties{} {}

  // Format features in case of linear tiling
  FormatFeatureFlags getLinearTilingFeatures() const { return std::bit_cast<FormatFeatureFlags>(this->linearTilingFeatures); }
  // Format features in case of optimal tiling
  FormatFeatureFlags getOptimalTilingFeatures() const { return std::bit_cast<FormatFeatureFlags>(this->optimalTilingFeatures); }
  // Format features supported by buffers
  FormatFeatureFlags getBufferFeatures() const { return std::bit_cast<FormatFeatureFlags>(this->bufferFeatures); }
};

struct CommandBufferInheritanceInfo : VkCommandBufferInheritanceInfo {
  CommandBufferInheritanceInfo() noexcept : VkCommandBufferInheritanceInfo{.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO} {}

  void setSubpass(uint32_t value) { this->subpass = value; }
  uint32_t getSubpass() const { return this->subpass; }

  // Render pass for secondary command buffers
  void setRenderPass(RenderPass value) { this->renderPass = std::bit_cast<VkRenderPass>(value); }
  RenderPass getRenderPass() const { return std::bit_cast<RenderPass>(this->renderPass); }
  // Framebuffer for secondary command buffers
  void setFramebuffer(Framebuffer value) { this->framebuffer = std::bit_cast<VkFramebuffer>(value); }
  Framebuffer getFramebuffer() const { return std::bit_cast<Framebuffer>(this->framebuffer); }
  // Whether this secondary command buffer may be executed during an occlusion query
  void setOcclusionQueryEnable(Bool32 value) { this->occlusionQueryEnable = value; }
  Bool32 getOcclusionQueryEnable() const { return this->occlusionQueryEnable; }
  // Query flags used by this secondary command buffer, if executed during an occlusion query
  void setQueryFlags(QueryControlFlags value) { this->queryFlags = std::bit_cast<VkQueryControlFlags>(value); }
  QueryControlFlags getQueryFlags() const { return std::bit_cast<QueryControlFlags>(this->queryFlags); }
  // Pipeline statistics that may be counted for this secondary command buffer
  void setPipelineStatistics(QueryPipelineStatisticFlags value) { this->pipelineStatistics = std::bit_cast<VkQueryPipelineStatisticFlags>(value); }
  QueryPipelineStatisticFlags getPipelineStatistics() const { return std::bit_cast<QueryPipelineStatisticFlags>(this->pipelineStatistics); }

#if VK_EXT_conditional_rendering
  void attach(struct CommandBufferInheritanceConditionalRenderingInfoEXT&);
#endif // VK_EXT_conditional_rendering
#if VK_ANDROID_external_memory_android_hardware_buffer
  void attach(struct ExternalFormatANDROID&);
#endif // VK_ANDROID_external_memory_android_hardware_buffer
#if VK_QCOM_render_pass_transform
  void attach(struct CommandBufferInheritanceRenderPassTransformInfoQCOM&);
#endif // VK_QCOM_render_pass_transform
#if VK_NV_inherited_viewport_scissor
  void attach(struct CommandBufferInheritanceViewportScissorInfoNV&);
#endif // VK_NV_inherited_viewport_scissor
#if VK_VERSION_1_3
  void attach(struct CommandBufferInheritanceRenderingInfo&);
#endif // VK_VERSION_1_3
#if VK_AMD_mixed_attachment_samples
  void attach(struct AttachmentSampleCountInfoAMD&);
#endif // VK_AMD_mixed_attachment_samples
#if VK_NVX_multiview_per_view_attributes
  void attach(struct MultiviewPerViewAttributesInfoNVX&);
#endif // VK_NVX_multiview_per_view_attributes
#if VK_QCOM_tile_memory_heap
  void attach(struct TileMemoryBindInfoQCOM&);
#endif // VK_QCOM_tile_memory_heap
#if VK_VERSION_1_4
  void attach(struct RenderingAttachmentLocationInfo&);
  void attach(struct RenderingInputAttachmentIndexInfo&);
#endif // VK_VERSION_1_4
#if VK_QCOM_tile_shading
  void attach(struct RenderPassTileShadingCreateInfoQCOM&);
#endif // VK_QCOM_tile_shading
};
#endif // VK_VERSION_1_0

#if VK_VERSION_1_4
struct MemoryMapInfo : VkMemoryMapInfo {
  MemoryMapInfo() noexcept : VkMemoryMapInfo{.sType = VK_STRUCTURE_TYPE_MEMORY_MAP_INFO} {}

  void setMemory(DeviceMemory value) { this->memory = std::bit_cast<VkDeviceMemory>(value); }
  DeviceMemory getMemory() const { return std::bit_cast<DeviceMemory>(this->memory); }
  void setOffset(DeviceSize value) { this->offset = value; }
  DeviceSize getOffset() const { return this->offset; }
  void setSize(DeviceSize value) { this->size = value; }
  DeviceSize getSize() const { return this->size; }

  void setFlags(MemoryMapFlags value) { this->flags = std::bit_cast<VkMemoryMapFlags>(value); }
  MemoryMapFlags getFlags() const { return std::bit_cast<MemoryMapFlags>(this->flags); }

#if VK_EXT_map_memory_placed
  void attach(struct MemoryMapPlacedInfoEXT&);
#endif // VK_EXT_map_memory_placed
};
#endif // VK_VERSION_1_4

#if VK_VERSION_1_2
struct AttachmentReference2 : VkAttachmentReference2 {
  AttachmentReference2() noexcept : VkAttachmentReference2{.sType = VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2} {}

  void setAttachment(uint32_t value) { this->attachment = value; }
  uint32_t getAttachment() const { return this->attachment; }
  void setLayout(ImageLayout value) { this->layout = std::bit_cast<VkImageLayout>(value); }
  ImageLayout getLayout() const { return std::bit_cast<ImageLayout>(this->layout); }
  void setAspectMask(ImageAspectFlags value) { this->aspectMask = std::bit_cast<VkImageAspectFlags>(value); }
  ImageAspectFlags getAspectMask() const { return std::bit_cast<ImageAspectFlags>(this->aspectMask); }

  void attach(struct AttachmentReferenceStencilLayout&);
};
#endif // VK_VERSION_1_2

#if VK_VERSION_1_0
struct ClearAttachment : VkClearAttachment {
  ClearAttachment() noexcept : VkClearAttachment{} {}
  ClearAttachment(ImageAspectFlags aspectMask, uint32_t colorAttachment, ClearValue clearValue) noexcept : VkClearAttachment{.aspectMask = std::bit_cast<VkImageAspectFlags>(aspectMask), .colorAttachment = colorAttachment, .clearValue = clearValue} {}

  void setAspectMask(ImageAspectFlags value) { this->aspectMask = std::bit_cast<VkImageAspectFlags>(value); }
  ImageAspectFlags getAspectMask() const { return std::bit_cast<ImageAspectFlags>(this->aspectMask); }
  void setColorAttachment(uint32_t value) { this->colorAttachment = value; }
  uint32_t getColorAttachment() const { return this->colorAttachment; }
  void setClearValue(ClearValue value) { this->clearValue = value; }
  ClearValue getClearValue() const { return this->clearValue; }
};
#endif // VK_VERSION_1_0

#if VK_VERSION_1_1
struct InputAttachmentAspectReference : VkInputAttachmentAspectReference {
  InputAttachmentAspectReference() noexcept : VkInputAttachmentAspectReference{} {}
  InputAttachmentAspectReference(uint32_t subpass, uint32_t inputAttachmentIndex, ImageAspectFlags aspectMask) noexcept : VkInputAttachmentAspectReference{.subpass = subpass, .inputAttachmentIndex = inputAttachmentIndex, .aspectMask = std::bit_cast<VkImageAspectFlags>(aspectMask)} {}

  void setSubpass(uint32_t value) { this->subpass = value; }
  uint32_t getSubpass() const { return this->subpass; }
  void setInputAttachmentIndex(uint32_t value) { this->inputAttachmentIndex = value; }
  uint32_t getInputAttachmentIndex() const { return this->inputAttachmentIndex; }
  void setAspectMask(ImageAspectFlags value) { this->aspectMask = std::bit_cast<VkImageAspectFlags>(value); }
  ImageAspectFlags getAspectMask() const { return std::bit_cast<ImageAspectFlags>(this->aspectMask); }
};
#endif // VK_VERSION_1_1

#if VK_VERSION_1_0
struct ImageSubresource : VkImageSubresource {
  ImageSubresource() noexcept : VkImageSubresource{} {}
  ImageSubresource(ImageAspectFlags aspectMask, uint32_t mipLevel, uint32_t arrayLayer) noexcept : VkImageSubresource{.aspectMask = std::bit_cast<VkImageAspectFlags>(aspectMask), .mipLevel = mipLevel, .arrayLayer = arrayLayer} {}

  void setAspectMask(ImageAspectFlags value) { this->aspectMask = std::bit_cast<VkImageAspectFlags>(value); }
  ImageAspectFlags getAspectMask() const { return std::bit_cast<ImageAspectFlags>(this->aspectMask); }
  void setMipLevel(uint32_t value) { this->mipLevel = value; }
  uint32_t getMipLevel() const { return this->mipLevel; }
  void setArrayLayer(uint32_t value) { this->arrayLayer = value; }
  uint32_t getArrayLayer() const { return this->arrayLayer; }
};

struct ImageSubresourceLayers : VkImageSubresourceLayers {
  ImageSubresourceLayers() noexcept : VkImageSubresourceLayers{} {}
  ImageSubresourceLayers(ImageAspectFlags aspectMask, uint32_t mipLevel, uint32_t baseArrayLayer, uint32_t layerCount) noexcept : VkImageSubresourceLayers{.aspectMask = std::bit_cast<VkImageAspectFlags>(aspectMask), .mipLevel = mipLevel, .baseArrayLayer = baseArrayLayer, .layerCount = layerCount} {}

  void setAspectMask(ImageAspectFlags value) { this->aspectMask = std::bit_cast<VkImageAspectFlags>(value); }
  ImageAspectFlags getAspectMask() const { return std::bit_cast<ImageAspectFlags>(this->aspectMask); }
  void setMipLevel(uint32_t value) { this->mipLevel = value; }
  uint32_t getMipLevel() const { return this->mipLevel; }
  void setBaseArrayLayer(uint32_t value) { this->baseArrayLayer = value; }
  uint32_t getBaseArrayLayer() const { return this->baseArrayLayer; }
  void setLayerCount(uint32_t value) { this->layerCount = value; }
  uint32_t getLayerCount() const { return this->layerCount; }
};

struct ImageSubresourceRange : VkImageSubresourceRange {
  ImageSubresourceRange() noexcept : VkImageSubresourceRange{} {}
  ImageSubresourceRange(ImageAspectFlags aspectMask, uint32_t baseMipLevel, uint32_t levelCount, uint32_t baseArrayLayer, uint32_t layerCount) noexcept : VkImageSubresourceRange{.aspectMask = std::bit_cast<VkImageAspectFlags>(aspectMask), .baseMipLevel = baseMipLevel, .levelCount = levelCount, .baseArrayLayer = baseArrayLayer, .layerCount = layerCount} {}

  void setAspectMask(ImageAspectFlags value) { this->aspectMask = std::bit_cast<VkImageAspectFlags>(value); }
  ImageAspectFlags getAspectMask() const { return std::bit_cast<ImageAspectFlags>(this->aspectMask); }
  void setBaseMipLevel(uint32_t value) { this->baseMipLevel = value; }
  uint32_t getBaseMipLevel() const { return this->baseMipLevel; }
  void setLevelCount(uint32_t value) { this->levelCount = value; }
  uint32_t getLevelCount() const { return this->levelCount; }
  void setBaseArrayLayer(uint32_t value) { this->baseArrayLayer = value; }
  uint32_t getBaseArrayLayer() const { return this->baseArrayLayer; }
  void setLayerCount(uint32_t value) { this->layerCount = value; }
  uint32_t getLayerCount() const { return this->layerCount; }
};

struct SparseImageFormatProperties : VkSparseImageFormatProperties {
  SparseImageFormatProperties() noexcept : VkSparseImageFormatProperties{} {}

  const Extent3D& getImageGranularity() const { return static_cast<const Extent3D&>(this->imageGranularity); }

  ImageAspectFlags getAspectMask() const { return std::bit_cast<ImageAspectFlags>(this->aspectMask); }
  SparseImageFormatFlags getFlags() const { return std::bit_cast<SparseImageFormatFlags>(this->flags); }
};

struct SparseMemoryBind : VkSparseMemoryBind {
  SparseMemoryBind() noexcept : VkSparseMemoryBind{} {}

  // Specified in bytes
  void setResourceOffset(DeviceSize value) { this->resourceOffset = value; }
  DeviceSize getResourceOffset() const { return this->resourceOffset; }
  // Specified in bytes
  void setSize(DeviceSize value) { this->size = value; }
  DeviceSize getSize() const { return this->size; }
  // Specified in bytes
  void setMemoryOffset(DeviceSize value) { this->memoryOffset = value; }
  DeviceSize getMemoryOffset() const { return this->memoryOffset; }

  void setMemory(DeviceMemory value) { this->memory = std::bit_cast<VkDeviceMemory>(value); }
  DeviceMemory getMemory() const { return std::bit_cast<DeviceMemory>(this->memory); }
  void setFlags(SparseMemoryBindFlags value) { this->flags = std::bit_cast<VkSparseMemoryBindFlags>(value); }
  SparseMemoryBindFlags getFlags() const { return std::bit_cast<SparseMemoryBindFlags>(this->flags); }
};

struct CommandPoolCreateInfo : VkCommandPoolCreateInfo {
  CommandPoolCreateInfo() noexcept : VkCommandPoolCreateInfo{.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO} {}

  void setQueueFamilyIndex(uint32_t value) { this->queueFamilyIndex = value; }
  uint32_t getQueueFamilyIndex() const { return this->queueFamilyIndex; }

  // Command pool creation flags
  void setFlags(CommandPoolCreateFlags value) { this->flags = std::bit_cast<VkCommandPoolCreateFlags>(value); }
  CommandPoolCreateFlags getFlags() const { return std::bit_cast<CommandPoolCreateFlags>(this->flags); }

#if VK_ARM_data_graph
  void attach(struct DataGraphProcessingEngineCreateInfoARM&);
#endif // VK_ARM_data_graph
};
#endif // VK_VERSION_1_0

#if VK_NV_coverage_reduction_mode
struct FramebufferMixedSamplesCombinationNV : VkFramebufferMixedSamplesCombinationNV {
  FramebufferMixedSamplesCombinationNV() noexcept : VkFramebufferMixedSamplesCombinationNV{.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV} {}

  CoverageReductionModeNV getCoverageReductionMode() const { return std::bit_cast<CoverageReductionModeNV>(this->coverageReductionMode); }
  SampleCountFlagBits getRasterizationSamples() const { return std::bit_cast<SampleCountFlagBits>(this->rasterizationSamples); }
  SampleCountFlags getDepthStencilSamples() const { return std::bit_cast<SampleCountFlags>(this->depthStencilSamples); }
  SampleCountFlags getColorSamples() const { return std::bit_cast<SampleCountFlags>(this->colorSamples); }
};
#endif // VK_NV_coverage_reduction_mode

#if VK_KHR_fragment_shading_rate
struct PhysicalDeviceFragmentShadingRateKHR : VkPhysicalDeviceFragmentShadingRateKHR {
  PhysicalDeviceFragmentShadingRateKHR() noexcept : VkPhysicalDeviceFragmentShadingRateKHR{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR} {}

  SampleCountFlags getSampleCounts() const { return std::bit_cast<SampleCountFlags>(this->sampleCounts); }
  const Extent2D& getFragmentSize() const { return static_cast<const Extent2D&>(this->fragmentSize); }
};
#endif // VK_KHR_fragment_shading_rate

#if VK_VERSION_1_0
struct ImageFormatProperties : VkImageFormatProperties {
  ImageFormatProperties() noexcept : VkImageFormatProperties{} {}

  // max image dimensions for this resource type
  const Extent3D& getMaxExtent() const { return static_cast<const Extent3D&>(this->maxExtent); }
  // max number of mipmap levels for this resource type
  uint32_t getMaxMipLevels() const { return this->maxMipLevels; }
  // max array size for this resource type
  uint32_t getMaxArrayLayers() const { return this->maxArrayLayers; }
  // max size (in bytes) of this resource type
  DeviceSize getMaxResourceSize() const { return this->maxResourceSize; }

  // supported sample counts for this resource type
  SampleCountFlags getSampleCounts() const { return std::bit_cast<SampleCountFlags>(this->sampleCounts); }
};

struct PhysicalDeviceLimits : VkPhysicalDeviceLimits {
  PhysicalDeviceLimits() noexcept : VkPhysicalDeviceLimits{} {}

  // max 1D image dimension
  uint32_t getMaxImageDimension1D() const { return this->maxImageDimension1D; }
  // max 2D image dimension
  uint32_t getMaxImageDimension2D() const { return this->maxImageDimension2D; }
  // max 3D image dimension
  uint32_t getMaxImageDimension3D() const { return this->maxImageDimension3D; }
  // max cube map image dimension
  uint32_t getMaxImageDimensionCube() const { return this->maxImageDimensionCube; }
  // max layers for image arrays
  uint32_t getMaxImageArrayLayers() const { return this->maxImageArrayLayers; }
  // max texel buffer size (fstexels)
  uint32_t getMaxTexelBufferElements() const { return this->maxTexelBufferElements; }
  // max uniform buffer range (bytes)
  uint32_t getMaxUniformBufferRange() const { return this->maxUniformBufferRange; }
  // max storage buffer range (bytes)
  uint32_t getMaxStorageBufferRange() const { return this->maxStorageBufferRange; }
  // max size of the push constants pool (bytes)
  uint32_t getMaxPushConstantsSize() const { return this->maxPushConstantsSize; }
  // max number of device memory allocations supported
  uint32_t getMaxMemoryAllocationCount() const { return this->maxMemoryAllocationCount; }
  // max number of samplers that can be allocated on a device
  uint32_t getMaxSamplerAllocationCount() const { return this->maxSamplerAllocationCount; }
  // Granularity (in bytes) at which buffers and images can be bound to adjacent memory for simultaneous usage
  DeviceSize getBufferImageGranularity() const { return this->bufferImageGranularity; }
  // Total address space available for sparse allocations (bytes)
  DeviceSize getSparseAddressSpaceSize() const { return this->sparseAddressSpaceSize; }
  // max number of descriptors sets that can be bound to a pipeline
  uint32_t getMaxBoundDescriptorSets() const { return this->maxBoundDescriptorSets; }
  // max number of samplers allowed per-stage in a descriptor set
  uint32_t getMaxPerStageDescriptorSamplers() const { return this->maxPerStageDescriptorSamplers; }
  // max number of uniform buffers allowed per-stage in a descriptor set
  uint32_t getMaxPerStageDescriptorUniformBuffers() const { return this->maxPerStageDescriptorUniformBuffers; }
  // max number of storage buffers allowed per-stage in a descriptor set
  uint32_t getMaxPerStageDescriptorStorageBuffers() const { return this->maxPerStageDescriptorStorageBuffers; }
  // max number of sampled images allowed per-stage in a descriptor set
  uint32_t getMaxPerStageDescriptorSampledImages() const { return this->maxPerStageDescriptorSampledImages; }
  // max number of storage images allowed per-stage in a descriptor set
  uint32_t getMaxPerStageDescriptorStorageImages() const { return this->maxPerStageDescriptorStorageImages; }
  // max number of input attachments allowed per-stage in a descriptor set
  uint32_t getMaxPerStageDescriptorInputAttachments() const { return this->maxPerStageDescriptorInputAttachments; }
  // max number of resources allowed by a single stage
  uint32_t getMaxPerStageResources() const { return this->maxPerStageResources; }
  // max number of samplers allowed in all stages in a descriptor set
  uint32_t getMaxDescriptorSetSamplers() const { return this->maxDescriptorSetSamplers; }
  // max number of uniform buffers allowed in all stages in a descriptor set
  uint32_t getMaxDescriptorSetUniformBuffers() const { return this->maxDescriptorSetUniformBuffers; }
  // max number of dynamic uniform buffers allowed in all stages in a descriptor set
  uint32_t getMaxDescriptorSetUniformBuffersDynamic() const { return this->maxDescriptorSetUniformBuffersDynamic; }
  // max number of storage buffers allowed in all stages in a descriptor set
  uint32_t getMaxDescriptorSetStorageBuffers() const { return this->maxDescriptorSetStorageBuffers; }
  // max number of dynamic storage buffers allowed in all stages in a descriptor set
  uint32_t getMaxDescriptorSetStorageBuffersDynamic() const { return this->maxDescriptorSetStorageBuffersDynamic; }
  // max number of sampled images allowed in all stages in a descriptor set
  uint32_t getMaxDescriptorSetSampledImages() const { return this->maxDescriptorSetSampledImages; }
  // max number of storage images allowed in all stages in a descriptor set
  uint32_t getMaxDescriptorSetStorageImages() const { return this->maxDescriptorSetStorageImages; }
  // max number of input attachments allowed in all stages in a descriptor set
  uint32_t getMaxDescriptorSetInputAttachments() const { return this->maxDescriptorSetInputAttachments; }
  // max number of vertex input attribute slots
  uint32_t getMaxVertexInputAttributes() const { return this->maxVertexInputAttributes; }
  // max number of vertex input binding slots
  uint32_t getMaxVertexInputBindings() const { return this->maxVertexInputBindings; }
  // max vertex input attribute offset added to vertex buffer offset
  uint32_t getMaxVertexInputAttributeOffset() const { return this->maxVertexInputAttributeOffset; }
  // max vertex input binding stride
  uint32_t getMaxVertexInputBindingStride() const { return this->maxVertexInputBindingStride; }
  // max number of output components written by vertex shader
  uint32_t getMaxVertexOutputComponents() const { return this->maxVertexOutputComponents; }
  // max level supported by tessellation primitive generator
  uint32_t getMaxTessellationGenerationLevel() const { return this->maxTessellationGenerationLevel; }
  // max patch size (vertices)
  uint32_t getMaxTessellationPatchSize() const { return this->maxTessellationPatchSize; }
  // max number of input components per-vertex in TCS
  uint32_t getMaxTessellationControlPerVertexInputComponents() const { return this->maxTessellationControlPerVertexInputComponents; }
  // max number of output components per-vertex in TCS
  uint32_t getMaxTessellationControlPerVertexOutputComponents() const { return this->maxTessellationControlPerVertexOutputComponents; }
  // max number of output components per-patch in TCS
  uint32_t getMaxTessellationControlPerPatchOutputComponents() const { return this->maxTessellationControlPerPatchOutputComponents; }
  // max total number of per-vertex and per-patch output components in TCS
  uint32_t getMaxTessellationControlTotalOutputComponents() const { return this->maxTessellationControlTotalOutputComponents; }
  // max number of input components per vertex in TES
  uint32_t getMaxTessellationEvaluationInputComponents() const { return this->maxTessellationEvaluationInputComponents; }
  // max number of output components per vertex in TES
  uint32_t getMaxTessellationEvaluationOutputComponents() const { return this->maxTessellationEvaluationOutputComponents; }
  // max invocation count supported in geometry shader
  uint32_t getMaxGeometryShaderInvocations() const { return this->maxGeometryShaderInvocations; }
  // max number of input components read in geometry stage
  uint32_t getMaxGeometryInputComponents() const { return this->maxGeometryInputComponents; }
  // max number of output components written in geometry stage
  uint32_t getMaxGeometryOutputComponents() const { return this->maxGeometryOutputComponents; }
  // max number of vertices that can be emitted in geometry stage
  uint32_t getMaxGeometryOutputVertices() const { return this->maxGeometryOutputVertices; }
  // max total number of components (all vertices) written in geometry stage
  uint32_t getMaxGeometryTotalOutputComponents() const { return this->maxGeometryTotalOutputComponents; }
  // max number of input components read in fragment stage
  uint32_t getMaxFragmentInputComponents() const { return this->maxFragmentInputComponents; }
  // max number of output attachments written in fragment stage
  uint32_t getMaxFragmentOutputAttachments() const { return this->maxFragmentOutputAttachments; }
  // max number of output attachments written when using dual source blending
  uint32_t getMaxFragmentDualSrcAttachments() const { return this->maxFragmentDualSrcAttachments; }
  // max total number of storage buffers, storage images and output buffers
  uint32_t getMaxFragmentCombinedOutputResources() const { return this->maxFragmentCombinedOutputResources; }
  // max total storage size of work group local storage (bytes)
  uint32_t getMaxComputeSharedMemorySize() const { return this->maxComputeSharedMemorySize; }
  // max num of compute work groups that may be dispatched by a single command (x,y,z)
  std::span<const uint32_t, 3> getMaxComputeWorkGroupCount() const { return this->maxComputeWorkGroupCount; }
  // max total compute invocations in a single local work group
  uint32_t getMaxComputeWorkGroupInvocations() const { return this->maxComputeWorkGroupInvocations; }
  // max local size of a compute work group (x,y,z)
  std::span<const uint32_t, 3> getMaxComputeWorkGroupSize() const { return this->maxComputeWorkGroupSize; }
  // number bits of subpixel precision in screen x and y
  uint32_t getSubPixelPrecisionBits() const { return this->subPixelPrecisionBits; }
  // number bits of precision for selecting texel weights
  uint32_t getSubTexelPrecisionBits() const { return this->subTexelPrecisionBits; }
  // number bits of precision for selecting mipmap weights
  uint32_t getMipmapPrecisionBits() const { return this->mipmapPrecisionBits; }
  // max index value for indexed draw calls (for 32-bit indices)
  uint32_t getMaxDrawIndexedIndexValue() const { return this->maxDrawIndexedIndexValue; }
  // max draw count for indirect drawing calls
  uint32_t getMaxDrawIndirectCount() const { return this->maxDrawIndirectCount; }
  // max absolute sampler LOD bias
  float getMaxSamplerLodBias() const { return this->maxSamplerLodBias; }
  // max degree of sampler anisotropy
  float getMaxSamplerAnisotropy() const { return this->maxSamplerAnisotropy; }
  // max number of active viewports
  uint32_t getMaxViewports() const { return this->maxViewports; }
  // max viewport dimensions (x,y)
  std::span<const uint32_t, 2> getMaxViewportDimensions() const { return this->maxViewportDimensions; }
  // viewport bounds range (min,max)
  std::span<const float, 2> getViewportBoundsRange() const { return this->viewportBoundsRange; }
  // number bits of subpixel precision for viewport
  uint32_t getViewportSubPixelBits() const { return this->viewportSubPixelBits; }
  // min required alignment of pointers returned by MapMemory (bytes)
  size_t getMinMemoryMapAlignment() const { return this->minMemoryMapAlignment; }
  // min required alignment for texel buffer offsets (bytes) 
  DeviceSize getMinTexelBufferOffsetAlignment() const { return this->minTexelBufferOffsetAlignment; }
  // min required alignment for uniform buffer sizes and offsets (bytes)
  DeviceSize getMinUniformBufferOffsetAlignment() const { return this->minUniformBufferOffsetAlignment; }
  // min required alignment for storage buffer offsets (bytes)
  DeviceSize getMinStorageBufferOffsetAlignment() const { return this->minStorageBufferOffsetAlignment; }
  // min texel offset for OpTextureSampleOffset
  int32_t getMinTexelOffset() const { return this->minTexelOffset; }
  // max texel offset for OpTextureSampleOffset
  uint32_t getMaxTexelOffset() const { return this->maxTexelOffset; }
  // min texel offset for OpTextureGatherOffset
  int32_t getMinTexelGatherOffset() const { return this->minTexelGatherOffset; }
  // max texel offset for OpTextureGatherOffset
  uint32_t getMaxTexelGatherOffset() const { return this->maxTexelGatherOffset; }
  // furthest negative offset for interpolateAtOffset
  float getMinInterpolationOffset() const { return this->minInterpolationOffset; }
  // furthest positive offset for interpolateAtOffset
  float getMaxInterpolationOffset() const { return this->maxInterpolationOffset; }
  // number of subpixel bits for interpolateAtOffset
  uint32_t getSubPixelInterpolationOffsetBits() const { return this->subPixelInterpolationOffsetBits; }
  // max width for a framebuffer
  uint32_t getMaxFramebufferWidth() const { return this->maxFramebufferWidth; }
  // max height for a framebuffer
  uint32_t getMaxFramebufferHeight() const { return this->maxFramebufferHeight; }
  // max layer count for a layered framebuffer
  uint32_t getMaxFramebufferLayers() const { return this->maxFramebufferLayers; }
  // max number of color attachments per subpass
  uint32_t getMaxColorAttachments() const { return this->maxColorAttachments; }
  // max number of sample mask words
  uint32_t getMaxSampleMaskWords() const { return this->maxSampleMaskWords; }
  // timestamps on graphics and compute queues
  Bool32 getTimestampComputeAndGraphics() const { return this->timestampComputeAndGraphics; }
  // number of nanoseconds it takes for timestamp query value to increment by 1
  float getTimestampPeriod() const { return this->timestampPeriod; }
  // max number of clip distances
  uint32_t getMaxClipDistances() const { return this->maxClipDistances; }
  // max number of cull distances
  uint32_t getMaxCullDistances() const { return this->maxCullDistances; }
  // max combined number of user clipping
  uint32_t getMaxCombinedClipAndCullDistances() const { return this->maxCombinedClipAndCullDistances; }
  // distinct queue priorities available 
  uint32_t getDiscreteQueuePriorities() const { return this->discreteQueuePriorities; }
  // range (min,max) of supported point sizes
  std::span<const float, 2> getPointSizeRange() const { return this->pointSizeRange; }
  // range (min,max) of supported line widths
  std::span<const float, 2> getLineWidthRange() const { return this->lineWidthRange; }
  // granularity of supported point sizes
  float getPointSizeGranularity() const { return this->pointSizeGranularity; }
  // granularity of supported line widths
  float getLineWidthGranularity() const { return this->lineWidthGranularity; }
  // line rasterization follows preferred rules
  Bool32 getStrictLines() const { return this->strictLines; }
  // supports standard sample locations for all supported sample counts
  Bool32 getStandardSampleLocations() const { return this->standardSampleLocations; }
  // optimal offset of buffer copies
  DeviceSize getOptimalBufferCopyOffsetAlignment() const { return this->optimalBufferCopyOffsetAlignment; }
  // optimal pitch of buffer copies
  DeviceSize getOptimalBufferCopyRowPitchAlignment() const { return this->optimalBufferCopyRowPitchAlignment; }
  // minimum size and alignment for non-coherent host-mapped device memory access
  DeviceSize getNonCoherentAtomSize() const { return this->nonCoherentAtomSize; }

  // supported color sample counts for a framebuffer
  SampleCountFlags getFramebufferColorSampleCounts() const { return std::bit_cast<SampleCountFlags>(this->framebufferColorSampleCounts); }
  // supported depth sample counts for a framebuffer
  SampleCountFlags getFramebufferDepthSampleCounts() const { return std::bit_cast<SampleCountFlags>(this->framebufferDepthSampleCounts); }
  // supported stencil sample counts for a framebuffer
  SampleCountFlags getFramebufferStencilSampleCounts() const { return std::bit_cast<SampleCountFlags>(this->framebufferStencilSampleCounts); }
  // supported sample counts for a subpass which uses no attachments
  SampleCountFlags getFramebufferNoAttachmentsSampleCounts() const { return std::bit_cast<SampleCountFlags>(this->framebufferNoAttachmentsSampleCounts); }
  // supported color sample counts for a non-integer sampled image
  SampleCountFlags getSampledImageColorSampleCounts() const { return std::bit_cast<SampleCountFlags>(this->sampledImageColorSampleCounts); }
  // supported sample counts for an integer image
  SampleCountFlags getSampledImageIntegerSampleCounts() const { return std::bit_cast<SampleCountFlags>(this->sampledImageIntegerSampleCounts); }
  // supported depth sample counts for a sampled image
  SampleCountFlags getSampledImageDepthSampleCounts() const { return std::bit_cast<SampleCountFlags>(this->sampledImageDepthSampleCounts); }
  // supported stencil sample counts for a sampled image
  SampleCountFlags getSampledImageStencilSampleCounts() const { return std::bit_cast<SampleCountFlags>(this->sampledImageStencilSampleCounts); }
  // supported sample counts for a storage image
  SampleCountFlags getStorageImageSampleCounts() const { return std::bit_cast<SampleCountFlags>(this->storageImageSampleCounts); }
};
#endif // VK_VERSION_1_0

#if VK_NV_coverage_reduction_mode
struct PipelineCoverageReductionStateCreateInfoNV : VkPipelineCoverageReductionStateCreateInfoNV {
  PipelineCoverageReductionStateCreateInfoNV() noexcept : VkPipelineCoverageReductionStateCreateInfoNV{.sType = VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV} {}

  void setCoverageReductionMode(CoverageReductionModeNV value) { this->coverageReductionMode = std::bit_cast<VkCoverageReductionModeNV>(value); }
  CoverageReductionModeNV getCoverageReductionMode() const { return std::bit_cast<CoverageReductionModeNV>(this->coverageReductionMode); }

  void setFlags(PipelineCoverageReductionStateCreateFlagsNV value) { this->flags = std::bit_cast<VkPipelineCoverageReductionStateCreateFlagsNV>(value); }
  PipelineCoverageReductionStateCreateFlagsNV getFlags() const { return std::bit_cast<PipelineCoverageReductionStateCreateFlagsNV>(this->flags); }
};
inline void PipelineMultisampleStateCreateInfo::attach(PipelineCoverageReductionStateCreateInfoNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_coverage_reduction_mode

#if VK_NV_fragment_coverage_to_color
struct PipelineCoverageToColorStateCreateInfoNV : VkPipelineCoverageToColorStateCreateInfoNV {
  PipelineCoverageToColorStateCreateInfoNV() noexcept : VkPipelineCoverageToColorStateCreateInfoNV{.sType = VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV} {}

  void setFlags(PipelineCoverageToColorStateCreateFlagsNV value) { this->flags = std::bit_cast<VkPipelineCoverageToColorStateCreateFlagsNV>(value); }
  PipelineCoverageToColorStateCreateFlagsNV getFlags() const { return std::bit_cast<PipelineCoverageToColorStateCreateFlagsNV>(this->flags); }
  void setCoverageToColorEnable(Bool32 value) { this->coverageToColorEnable = value; }
  Bool32 getCoverageToColorEnable() const { return this->coverageToColorEnable; }
  void setCoverageToColorLocation(uint32_t value) { this->coverageToColorLocation = value; }
  uint32_t getCoverageToColorLocation() const { return this->coverageToColorLocation; }
};
inline void PipelineMultisampleStateCreateInfo::attach(PipelineCoverageToColorStateCreateInfoNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_fragment_coverage_to_color

#if VK_NV_framebuffer_mixed_samples
struct PipelineCoverageModulationStateCreateInfoNV : VkPipelineCoverageModulationStateCreateInfoNV {
  PipelineCoverageModulationStateCreateInfoNV() noexcept : VkPipelineCoverageModulationStateCreateInfoNV{.sType = VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV} {}

  void setCoverageModulationMode(CoverageModulationModeNV value) { this->coverageModulationMode = std::bit_cast<VkCoverageModulationModeNV>(value); }
  CoverageModulationModeNV getCoverageModulationMode() const { return std::bit_cast<CoverageModulationModeNV>(this->coverageModulationMode); }

  void setFlags(PipelineCoverageModulationStateCreateFlagsNV value) { this->flags = std::bit_cast<VkPipelineCoverageModulationStateCreateFlagsNV>(value); }
  PipelineCoverageModulationStateCreateFlagsNV getFlags() const { return std::bit_cast<PipelineCoverageModulationStateCreateFlagsNV>(this->flags); }
  void setCoverageModulationTableEnable(Bool32 value) { this->coverageModulationTableEnable = value; }
  Bool32 getCoverageModulationTableEnable() const { return this->coverageModulationTableEnable; }
  void setCoverageModulationTableCount(uint32_t value) { this->coverageModulationTableCount = value; }
  uint32_t getCoverageModulationTableCount() const { return this->coverageModulationTableCount; }
  void setCoverageModulationTable(const float* value) { this->pCoverageModulationTable = value; }
  const float* getCoverageModulationTable() const { return this->pCoverageModulationTable; }
};
inline void PipelineMultisampleStateCreateInfo::attach(PipelineCoverageModulationStateCreateInfoNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_framebuffer_mixed_samples

#if VK_VERSION_1_0
struct AttachmentDescription : VkAttachmentDescription {
  AttachmentDescription() noexcept : VkAttachmentDescription{} {}

  void setFormat(Format value) { this->format = std::bit_cast<VkFormat>(value); }
  Format getFormat() const { return std::bit_cast<Format>(this->format); }
  void setSamples(SampleCountFlagBits value) { this->samples = std::bit_cast<VkSampleCountFlagBits>(value); }
  SampleCountFlagBits getSamples() const { return std::bit_cast<SampleCountFlagBits>(this->samples); }
  // Load operation for color or depth data
  void setLoadOp(AttachmentLoadOp value) { this->loadOp = std::bit_cast<VkAttachmentLoadOp>(value); }
  AttachmentLoadOp getLoadOp() const { return std::bit_cast<AttachmentLoadOp>(this->loadOp); }
  // Store operation for color or depth data
  void setStoreOp(AttachmentStoreOp value) { this->storeOp = std::bit_cast<VkAttachmentStoreOp>(value); }
  AttachmentStoreOp getStoreOp() const { return std::bit_cast<AttachmentStoreOp>(this->storeOp); }
  // Load operation for stencil data
  void setStencilLoadOp(AttachmentLoadOp value) { this->stencilLoadOp = std::bit_cast<VkAttachmentLoadOp>(value); }
  AttachmentLoadOp getStencilLoadOp() const { return std::bit_cast<AttachmentLoadOp>(this->stencilLoadOp); }
  // Store operation for stencil data
  void setStencilStoreOp(AttachmentStoreOp value) { this->stencilStoreOp = std::bit_cast<VkAttachmentStoreOp>(value); }
  AttachmentStoreOp getStencilStoreOp() const { return std::bit_cast<AttachmentStoreOp>(this->stencilStoreOp); }
  void setInitialLayout(ImageLayout value) { this->initialLayout = std::bit_cast<VkImageLayout>(value); }
  ImageLayout getInitialLayout() const { return std::bit_cast<ImageLayout>(this->initialLayout); }
  void setFinalLayout(ImageLayout value) { this->finalLayout = std::bit_cast<VkImageLayout>(value); }
  ImageLayout getFinalLayout() const { return std::bit_cast<ImageLayout>(this->finalLayout); }

  void setFlags(AttachmentDescriptionFlags value) { this->flags = std::bit_cast<VkAttachmentDescriptionFlags>(value); }
  AttachmentDescriptionFlags getFlags() const { return std::bit_cast<AttachmentDescriptionFlags>(this->flags); }
};
#endif // VK_VERSION_1_0

#if VK_VERSION_1_2
struct AttachmentDescription2 : VkAttachmentDescription2 {
  AttachmentDescription2() noexcept : VkAttachmentDescription2{.sType = VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2} {}

  void setFormat(Format value) { this->format = std::bit_cast<VkFormat>(value); }
  Format getFormat() const { return std::bit_cast<Format>(this->format); }
  void setSamples(SampleCountFlagBits value) { this->samples = std::bit_cast<VkSampleCountFlagBits>(value); }
  SampleCountFlagBits getSamples() const { return std::bit_cast<SampleCountFlagBits>(this->samples); }
  // Load operation for color or depth data
  void setLoadOp(AttachmentLoadOp value) { this->loadOp = std::bit_cast<VkAttachmentLoadOp>(value); }
  AttachmentLoadOp getLoadOp() const { return std::bit_cast<AttachmentLoadOp>(this->loadOp); }
  // Store operation for color or depth data
  void setStoreOp(AttachmentStoreOp value) { this->storeOp = std::bit_cast<VkAttachmentStoreOp>(value); }
  AttachmentStoreOp getStoreOp() const { return std::bit_cast<AttachmentStoreOp>(this->storeOp); }
  // Load operation for stencil data
  void setStencilLoadOp(AttachmentLoadOp value) { this->stencilLoadOp = std::bit_cast<VkAttachmentLoadOp>(value); }
  AttachmentLoadOp getStencilLoadOp() const { return std::bit_cast<AttachmentLoadOp>(this->stencilLoadOp); }
  // Store operation for stencil data
  void setStencilStoreOp(AttachmentStoreOp value) { this->stencilStoreOp = std::bit_cast<VkAttachmentStoreOp>(value); }
  AttachmentStoreOp getStencilStoreOp() const { return std::bit_cast<AttachmentStoreOp>(this->stencilStoreOp); }
  void setInitialLayout(ImageLayout value) { this->initialLayout = std::bit_cast<VkImageLayout>(value); }
  ImageLayout getInitialLayout() const { return std::bit_cast<ImageLayout>(this->initialLayout); }
  void setFinalLayout(ImageLayout value) { this->finalLayout = std::bit_cast<VkImageLayout>(value); }
  ImageLayout getFinalLayout() const { return std::bit_cast<ImageLayout>(this->finalLayout); }

  void setFlags(AttachmentDescriptionFlags value) { this->flags = std::bit_cast<VkAttachmentDescriptionFlags>(value); }
  AttachmentDescriptionFlags getFlags() const { return std::bit_cast<AttachmentDescriptionFlags>(this->flags); }

#if VK_ANDROID_external_memory_android_hardware_buffer
  void attach(struct ExternalFormatANDROID&);
#endif // VK_ANDROID_external_memory_android_hardware_buffer
  void attach(struct AttachmentDescriptionStencilLayout&);
};
#endif // VK_VERSION_1_2

#if VK_VERSION_1_0
struct DescriptorPoolCreateInfo : VkDescriptorPoolCreateInfo {
  DescriptorPoolCreateInfo() noexcept : VkDescriptorPoolCreateInfo{.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO} {}

  void setMaxSets(uint32_t value) { this->maxSets = value; }
  uint32_t getMaxSets() const { return this->maxSets; }

  void setFlags(DescriptorPoolCreateFlags value) { this->flags = std::bit_cast<VkDescriptorPoolCreateFlags>(value); }
  DescriptorPoolCreateFlags getFlags() const { return std::bit_cast<DescriptorPoolCreateFlags>(this->flags); }
  void setPoolSizeCount(uint32_t value) { this->poolSizeCount = value; }
  uint32_t getPoolSizeCount() const { return this->poolSizeCount; }
  void setPoolSizes(const DescriptorPoolSize* value) { this->pPoolSizes = std::bit_cast<const VkDescriptorPoolSize*>(value); }
  const DescriptorPoolSize* getPoolSizes() const { return std::bit_cast<const DescriptorPoolSize*>(this->pPoolSizes); }

#if VK_VERSION_1_3
  void attach(struct DescriptorPoolInlineUniformBlockCreateInfo&);
#endif // VK_VERSION_1_3
#if VK_EXT_mutable_descriptor_type
  void attach(struct MutableDescriptorTypeCreateInfoEXT&);
#endif // VK_EXT_mutable_descriptor_type
#if VK_ARM_data_graph
  void attach(struct DataGraphProcessingEngineCreateInfoARM&);
#endif // VK_ARM_data_graph
};

struct SubpassDependency : VkSubpassDependency {
  SubpassDependency() noexcept : VkSubpassDependency{} {}

  void setSrcSubpass(uint32_t value) { this->srcSubpass = value; }
  uint32_t getSrcSubpass() const { return this->srcSubpass; }
  void setDstSubpass(uint32_t value) { this->dstSubpass = value; }
  uint32_t getDstSubpass() const { return this->dstSubpass; }

  void setSrcStageMask(PipelineStageFlags value) { this->srcStageMask = std::bit_cast<VkPipelineStageFlags>(value); }
  PipelineStageFlags getSrcStageMask() const { return std::bit_cast<PipelineStageFlags>(this->srcStageMask); }
  void setDstStageMask(PipelineStageFlags value) { this->dstStageMask = std::bit_cast<VkPipelineStageFlags>(value); }
  PipelineStageFlags getDstStageMask() const { return std::bit_cast<PipelineStageFlags>(this->dstStageMask); }
  // Memory accesses from the source of the dependency to synchronize
  void setSrcAccessMask(AccessFlags value) { this->srcAccessMask = std::bit_cast<VkAccessFlags>(value); }
  AccessFlags getSrcAccessMask() const { return std::bit_cast<AccessFlags>(this->srcAccessMask); }
  // Memory accesses from the destination of the dependency to synchronize
  void setDstAccessMask(AccessFlags value) { this->dstAccessMask = std::bit_cast<VkAccessFlags>(value); }
  AccessFlags getDstAccessMask() const { return std::bit_cast<AccessFlags>(this->dstAccessMask); }
  void setDependencyFlags(DependencyFlags value) { this->dependencyFlags = std::bit_cast<VkDependencyFlags>(value); }
  DependencyFlags getDependencyFlags() const { return std::bit_cast<DependencyFlags>(this->dependencyFlags); }
};
#endif // VK_VERSION_1_0

#if VK_VERSION_1_2
struct SubpassDependency2 : VkSubpassDependency2 {
  SubpassDependency2() noexcept : VkSubpassDependency2{.sType = VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2} {}

  void setSrcSubpass(uint32_t value) { this->srcSubpass = value; }
  uint32_t getSrcSubpass() const { return this->srcSubpass; }
  void setDstSubpass(uint32_t value) { this->dstSubpass = value; }
  uint32_t getDstSubpass() const { return this->dstSubpass; }
  void setViewOffset(int32_t value) { this->viewOffset = value; }
  int32_t getViewOffset() const { return this->viewOffset; }

  void setSrcStageMask(PipelineStageFlags value) { this->srcStageMask = std::bit_cast<VkPipelineStageFlags>(value); }
  PipelineStageFlags getSrcStageMask() const { return std::bit_cast<PipelineStageFlags>(this->srcStageMask); }
  void setDstStageMask(PipelineStageFlags value) { this->dstStageMask = std::bit_cast<VkPipelineStageFlags>(value); }
  PipelineStageFlags getDstStageMask() const { return std::bit_cast<PipelineStageFlags>(this->dstStageMask); }
  void setSrcAccessMask(AccessFlags value) { this->srcAccessMask = std::bit_cast<VkAccessFlags>(value); }
  AccessFlags getSrcAccessMask() const { return std::bit_cast<AccessFlags>(this->srcAccessMask); }
  void setDstAccessMask(AccessFlags value) { this->dstAccessMask = std::bit_cast<VkAccessFlags>(value); }
  AccessFlags getDstAccessMask() const { return std::bit_cast<AccessFlags>(this->dstAccessMask); }
  void setDependencyFlags(DependencyFlags value) { this->dependencyFlags = std::bit_cast<VkDependencyFlags>(value); }
  DependencyFlags getDependencyFlags() const { return std::bit_cast<DependencyFlags>(this->dependencyFlags); }

#if VK_VERSION_1_3
  void attach(struct MemoryBarrier2&);
#endif // VK_VERSION_1_3
#if VK_KHR_maintenance8
  void attach(struct MemoryBarrierAccessFlags3KHR&);
#endif // VK_KHR_maintenance8
};

struct SemaphoreWaitInfo : VkSemaphoreWaitInfo {
  SemaphoreWaitInfo() noexcept : VkSemaphoreWaitInfo{.sType = VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO} {}

  void setSemaphoreCount(uint32_t value) { this->semaphoreCount = value; }
  uint32_t getSemaphoreCount() const { return this->semaphoreCount; }
  void setSemaphores(const Semaphore* value) { this->pSemaphores = std::bit_cast<const VkSemaphore*>(value); }
  const Semaphore* getSemaphores() const { return std::bit_cast<const Semaphore*>(this->pSemaphores); }
  void setValues(const uint64_t* value) { this->pValues = value; }
  const uint64_t* getValues() const { return this->pValues; }

  void setFlags(SemaphoreWaitFlags value) { this->flags = std::bit_cast<VkSemaphoreWaitFlags>(value); }
  SemaphoreWaitFlags getFlags() const { return std::bit_cast<SemaphoreWaitFlags>(this->flags); }
};
#endif // VK_VERSION_1_2

#if VK_KHR_timeline_semaphore
using SemaphoreWaitFlagsKHR = SemaphoreWaitFlags;
#endif // VK_KHR_timeline_semaphore

#if VK_KHR_get_surface_capabilities2
struct SurfaceFormat2KHR : VkSurfaceFormat2KHR {
  SurfaceFormat2KHR() noexcept : VkSurfaceFormat2KHR{.sType = VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR} {}

  const SurfaceFormatKHR& getSurfaceFormat() const { return static_cast<const SurfaceFormatKHR&>(this->surfaceFormat); }

#if VK_EXT_image_compression_control
  void attach(struct ImageCompressionPropertiesEXT&);
#endif // VK_EXT_image_compression_control
};
#endif // VK_KHR_get_surface_capabilities2

#if VK_KHR_display
struct DisplayPlaneCapabilitiesKHR : VkDisplayPlaneCapabilitiesKHR {
  DisplayPlaneCapabilitiesKHR() noexcept : VkDisplayPlaneCapabilitiesKHR{} {}

  // Does the plane have any position and extent restrictions?
  const Offset2D& getMinSrcPosition() const { return static_cast<const Offset2D&>(this->minSrcPosition); }
  const Offset2D& getMaxSrcPosition() const { return static_cast<const Offset2D&>(this->maxSrcPosition); }
  const Extent2D& getMinSrcExtent() const { return static_cast<const Extent2D&>(this->minSrcExtent); }
  const Extent2D& getMaxSrcExtent() const { return static_cast<const Extent2D&>(this->maxSrcExtent); }
  const Offset2D& getMinDstPosition() const { return static_cast<const Offset2D&>(this->minDstPosition); }
  const Offset2D& getMaxDstPosition() const { return static_cast<const Offset2D&>(this->maxDstPosition); }
  const Extent2D& getMinDstExtent() const { return static_cast<const Extent2D&>(this->minDstExtent); }
  const Extent2D& getMaxDstExtent() const { return static_cast<const Extent2D&>(this->maxDstExtent); }

  // Types of alpha blending supported, if any.
  DisplayPlaneAlphaFlagsKHR getSupportedAlpha() const { return std::bit_cast<DisplayPlaneAlphaFlagsKHR>(this->supportedAlpha); }
};

struct DisplayPropertiesKHR : VkDisplayPropertiesKHR {
  DisplayPropertiesKHR() noexcept : VkDisplayPropertiesKHR{} {}

  // Handle of the display object
  DisplayKHR getDisplay() const { return std::bit_cast<DisplayKHR>(this->display); }
  // Name of the display
  const char* getdisplayName() const { return this->displayName; }
  // In millimeters?
  const Extent2D& getPhysicalDimensions() const { return static_cast<const Extent2D&>(this->physicalDimensions); }
  // Max resolution for CRT?
  const Extent2D& getPhysicalResolution() const { return static_cast<const Extent2D&>(this->physicalResolution); }
  // VK_TRUE if the overlay plane's z-order can be changed on this display.
  Bool32 getPlaneReorderPossible() const { return this->planeReorderPossible; }
  // VK_TRUE if this is a "smart" display that supports self-refresh/internal buffering.
  Bool32 getPersistentContent() const { return this->persistentContent; }

  // one or more bits from VkSurfaceTransformFlagsKHR
  SurfaceTransformFlagsKHR getSupportedTransforms() const { return std::bit_cast<SurfaceTransformFlagsKHR>(this->supportedTransforms); }
};
#endif // VK_KHR_display

#if VK_KHR_surface
struct SurfaceCapabilitiesKHR : VkSurfaceCapabilitiesKHR {
  SurfaceCapabilitiesKHR() noexcept : VkSurfaceCapabilitiesKHR{} {}

  // Supported minimum number of images for the surface
  uint32_t getMinImageCount() const { return this->minImageCount; }
  // Supported maximum number of images for the surface, 0 for unlimited
  uint32_t getMaxImageCount() const { return this->maxImageCount; }
  // Current image width and height for the surface, (0, 0) if undefined
  const Extent2D& getCurrentExtent() const { return static_cast<const Extent2D&>(this->currentExtent); }
  // Supported minimum image width and height for the surface
  const Extent2D& getMinImageExtent() const { return static_cast<const Extent2D&>(this->minImageExtent); }
  // Supported maximum image width and height for the surface
  const Extent2D& getMaxImageExtent() const { return static_cast<const Extent2D&>(this->maxImageExtent); }
  // Supported maximum number of image layers for the surface
  uint32_t getMaxImageArrayLayers() const { return this->maxImageArrayLayers; }
  // 1 or more bits representing the transforms supported
  SurfaceTransformFlagsKHR getSupportedTransforms() const { return std::bit_cast<SurfaceTransformFlagsKHR>(this->supportedTransforms); }
  // The surface's current transform relative to the device's natural orientation
  SurfaceTransformFlagBitsKHR getCurrentTransform() const { return std::bit_cast<SurfaceTransformFlagBitsKHR>(this->currentTransform); }
  // 1 or more bits representing the alpha compositing modes supported
  CompositeAlphaFlagsKHR getSupportedCompositeAlpha() const { return std::bit_cast<CompositeAlphaFlagsKHR>(this->supportedCompositeAlpha); }
  // Supported image usage flags for the surface
  ImageUsageFlags getSupportedUsageFlags() const { return std::bit_cast<ImageUsageFlags>(this->supportedUsageFlags); }
};
#endif // VK_KHR_surface

#if VK_EXT_calibrated_timestamps
using CalibratedTimestampInfoEXT = CalibratedTimestampInfoKHR;
#endif // VK_EXT_calibrated_timestamps

#if VK_NV_cluster_acceleration_structure
struct ClusterAccelerationStructureBuildTriangleClusterInfoNV : VkClusterAccelerationStructureBuildTriangleClusterInfoNV {
  ClusterAccelerationStructureBuildTriangleClusterInfoNV() noexcept : VkClusterAccelerationStructureBuildTriangleClusterInfoNV{} {}

  void setClusterID(uint32_t value) { this->clusterID = value; }
  uint32_t getClusterID() const { return this->clusterID; }
  void setTriangleCount(uint32_t value) { this->triangleCount = value; }
  uint32_t getTriangleCount() const { return this->triangleCount; }
  void setVertexCount(uint32_t value) { this->vertexCount = value; }
  uint32_t getVertexCount() const { return this->vertexCount; }
  void setPositionTruncateBitCount(uint32_t value) { this->positionTruncateBitCount = value; }
  uint32_t getPositionTruncateBitCount() const { return this->positionTruncateBitCount; }
  void setIndexType(uint32_t value) { this->indexType = value; }
  uint32_t getIndexType() const { return this->indexType; }
  void setOpacityMicromapIndexType(uint32_t value) { this->opacityMicromapIndexType = value; }
  uint32_t getOpacityMicromapIndexType() const { return this->opacityMicromapIndexType; }
  void setBaseGeometryIndexAndGeometryFlags(const ClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV& value) { this->baseGeometryIndexAndGeometryFlags = value; }
  const ClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV& getBaseGeometryIndexAndGeometryFlags() const { return static_cast<const ClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV&>(this->baseGeometryIndexAndGeometryFlags); }
  void setIndexBufferStride(uint16_t value) { this->indexBufferStride = value; }
  uint16_t getIndexBufferStride() const { return this->indexBufferStride; }
  void setVertexBufferStride(uint16_t value) { this->vertexBufferStride = value; }
  uint16_t getVertexBufferStride() const { return this->vertexBufferStride; }
  void setGeometryIndexAndFlagsBufferStride(uint16_t value) { this->geometryIndexAndFlagsBufferStride = value; }
  uint16_t getGeometryIndexAndFlagsBufferStride() const { return this->geometryIndexAndFlagsBufferStride; }
  void setOpacityMicromapIndexBufferStride(uint16_t value) { this->opacityMicromapIndexBufferStride = value; }
  uint16_t getOpacityMicromapIndexBufferStride() const { return this->opacityMicromapIndexBufferStride; }
  void setIndexBuffer(DeviceAddress value) { this->indexBuffer = value; }
  DeviceAddress getIndexBuffer() const { return this->indexBuffer; }
  void setVertexBuffer(DeviceAddress value) { this->vertexBuffer = value; }
  DeviceAddress getVertexBuffer() const { return this->vertexBuffer; }
  void setGeometryIndexAndFlagsBuffer(DeviceAddress value) { this->geometryIndexAndFlagsBuffer = value; }
  DeviceAddress getGeometryIndexAndFlagsBuffer() const { return this->geometryIndexAndFlagsBuffer; }
  void setOpacityMicromapArray(DeviceAddress value) { this->opacityMicromapArray = value; }
  DeviceAddress getOpacityMicromapArray() const { return this->opacityMicromapArray; }
  void setOpacityMicromapIndexBuffer(DeviceAddress value) { this->opacityMicromapIndexBuffer = value; }
  DeviceAddress getOpacityMicromapIndexBuffer() const { return this->opacityMicromapIndexBuffer; }

  void setClusterFlags(ClusterAccelerationStructureClusterFlagsNV value) { this->clusterFlags = std::bit_cast<VkClusterAccelerationStructureClusterFlagsNV>(value); }
  ClusterAccelerationStructureClusterFlagsNV getClusterFlags() const { return std::bit_cast<ClusterAccelerationStructureClusterFlagsNV>(this->clusterFlags); }
};

struct ClusterAccelerationStructureBuildTriangleClusterTemplateInfoNV : VkClusterAccelerationStructureBuildTriangleClusterTemplateInfoNV {
  ClusterAccelerationStructureBuildTriangleClusterTemplateInfoNV() noexcept : VkClusterAccelerationStructureBuildTriangleClusterTemplateInfoNV{} {}

  void setClusterID(uint32_t value) { this->clusterID = value; }
  uint32_t getClusterID() const { return this->clusterID; }
  void setTriangleCount(uint32_t value) { this->triangleCount = value; }
  uint32_t getTriangleCount() const { return this->triangleCount; }
  void setVertexCount(uint32_t value) { this->vertexCount = value; }
  uint32_t getVertexCount() const { return this->vertexCount; }
  void setPositionTruncateBitCount(uint32_t value) { this->positionTruncateBitCount = value; }
  uint32_t getPositionTruncateBitCount() const { return this->positionTruncateBitCount; }
  void setIndexType(uint32_t value) { this->indexType = value; }
  uint32_t getIndexType() const { return this->indexType; }
  void setOpacityMicromapIndexType(uint32_t value) { this->opacityMicromapIndexType = value; }
  uint32_t getOpacityMicromapIndexType() const { return this->opacityMicromapIndexType; }
  void setBaseGeometryIndexAndGeometryFlags(const ClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV& value) { this->baseGeometryIndexAndGeometryFlags = value; }
  const ClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV& getBaseGeometryIndexAndGeometryFlags() const { return static_cast<const ClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV&>(this->baseGeometryIndexAndGeometryFlags); }
  void setIndexBufferStride(uint16_t value) { this->indexBufferStride = value; }
  uint16_t getIndexBufferStride() const { return this->indexBufferStride; }
  void setVertexBufferStride(uint16_t value) { this->vertexBufferStride = value; }
  uint16_t getVertexBufferStride() const { return this->vertexBufferStride; }
  void setGeometryIndexAndFlagsBufferStride(uint16_t value) { this->geometryIndexAndFlagsBufferStride = value; }
  uint16_t getGeometryIndexAndFlagsBufferStride() const { return this->geometryIndexAndFlagsBufferStride; }
  void setOpacityMicromapIndexBufferStride(uint16_t value) { this->opacityMicromapIndexBufferStride = value; }
  uint16_t getOpacityMicromapIndexBufferStride() const { return this->opacityMicromapIndexBufferStride; }
  void setIndexBuffer(DeviceAddress value) { this->indexBuffer = value; }
  DeviceAddress getIndexBuffer() const { return this->indexBuffer; }
  void setVertexBuffer(DeviceAddress value) { this->vertexBuffer = value; }
  DeviceAddress getVertexBuffer() const { return this->vertexBuffer; }
  void setGeometryIndexAndFlagsBuffer(DeviceAddress value) { this->geometryIndexAndFlagsBuffer = value; }
  DeviceAddress getGeometryIndexAndFlagsBuffer() const { return this->geometryIndexAndFlagsBuffer; }
  void setOpacityMicromapArray(DeviceAddress value) { this->opacityMicromapArray = value; }
  DeviceAddress getOpacityMicromapArray() const { return this->opacityMicromapArray; }
  void setOpacityMicromapIndexBuffer(DeviceAddress value) { this->opacityMicromapIndexBuffer = value; }
  DeviceAddress getOpacityMicromapIndexBuffer() const { return this->opacityMicromapIndexBuffer; }
  void setInstantiationBoundingBoxLimit(DeviceAddress value) { this->instantiationBoundingBoxLimit = value; }
  DeviceAddress getInstantiationBoundingBoxLimit() const { return this->instantiationBoundingBoxLimit; }

  void setClusterFlags(ClusterAccelerationStructureClusterFlagsNV value) { this->clusterFlags = std::bit_cast<VkClusterAccelerationStructureClusterFlagsNV>(value); }
  ClusterAccelerationStructureClusterFlagsNV getClusterFlags() const { return std::bit_cast<ClusterAccelerationStructureClusterFlagsNV>(this->clusterFlags); }
};
#endif // VK_NV_cluster_acceleration_structure

#if VK_NV_device_generated_commands
struct IndirectCommandsLayoutTokenNV : VkIndirectCommandsLayoutTokenNV {
  IndirectCommandsLayoutTokenNV() noexcept : VkIndirectCommandsLayoutTokenNV{.sType = VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV} {}

  void setTokenType(IndirectCommandsTokenTypeNV value) { this->tokenType = std::bit_cast<VkIndirectCommandsTokenTypeNV>(value); }
  IndirectCommandsTokenTypeNV getTokenType() const { return std::bit_cast<IndirectCommandsTokenTypeNV>(this->tokenType); }
  void setStream(uint32_t value) { this->stream = value; }
  uint32_t getStream() const { return this->stream; }
  void setOffset(uint32_t value) { this->offset = value; }
  uint32_t getOffset() const { return this->offset; }
  void setVertexBindingUnit(uint32_t value) { this->vertexBindingUnit = value; }
  uint32_t getVertexBindingUnit() const { return this->vertexBindingUnit; }
  void setPushconstantOffset(uint32_t value) { this->pushconstantOffset = value; }
  uint32_t getPushconstantOffset() const { return this->pushconstantOffset; }
  void setPushconstantSize(uint32_t value) { this->pushconstantSize = value; }
  uint32_t getPushconstantSize() const { return this->pushconstantSize; }

  void setVertexDynamicStride(Bool32 value) { this->vertexDynamicStride = value; }
  Bool32 getVertexDynamicStride() const { return this->vertexDynamicStride; }
  void setPushconstantPipelineLayout(PipelineLayout value) { this->pushconstantPipelineLayout = std::bit_cast<VkPipelineLayout>(value); }
  PipelineLayout getPushconstantPipelineLayout() const { return std::bit_cast<PipelineLayout>(this->pushconstantPipelineLayout); }
  void setPushconstantShaderStageFlags(ShaderStageFlags value) { this->pushconstantShaderStageFlags = std::bit_cast<VkShaderStageFlags>(value); }
  ShaderStageFlags getPushconstantShaderStageFlags() const { return std::bit_cast<ShaderStageFlags>(this->pushconstantShaderStageFlags); }
  void setIndirectStateFlags(IndirectStateFlagsNV value) { this->indirectStateFlags = std::bit_cast<VkIndirectStateFlagsNV>(value); }
  IndirectStateFlagsNV getIndirectStateFlags() const { return std::bit_cast<IndirectStateFlagsNV>(this->indirectStateFlags); }
  void setIndexTypeCount(uint32_t value) { this->indexTypeCount = value; }
  uint32_t getIndexTypeCount() const { return this->indexTypeCount; }
  void setIndexTypes(const IndexType* value) { this->pIndexTypes = std::bit_cast<const VkIndexType*>(value); }
  const IndexType* getIndexTypes() const { return std::bit_cast<const IndexType*>(this->pIndexTypes); }
  void setIndexTypeValues(const uint32_t* value) { this->pIndexTypeValues = value; }
  const uint32_t* getIndexTypeValues() const { return this->pIndexTypeValues; }
};
#endif // VK_NV_device_generated_commands

#if VK_KHR_external_memory_capabilities
using ExternalMemoryHandleTypeFlagsKHR = ExternalMemoryHandleTypeFlags;
#endif // VK_KHR_external_memory_capabilities

#if VK_VERSION_1_1
struct ExportMemoryAllocateInfo : VkExportMemoryAllocateInfo {
  ExportMemoryAllocateInfo() noexcept : VkExportMemoryAllocateInfo{.sType = VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO} {}

  void setHandleTypes(ExternalMemoryHandleTypeFlags value) { this->handleTypes = std::bit_cast<VkExternalMemoryHandleTypeFlags>(value); }
  ExternalMemoryHandleTypeFlags getHandleTypes() const { return std::bit_cast<ExternalMemoryHandleTypeFlags>(this->handleTypes); }
};
inline void MemoryAllocateInfo::attach(ExportMemoryAllocateInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_1

#if VK_KHR_external_memory_capabilities
using ExternalMemoryFeatureFlagsKHR = ExternalMemoryFeatureFlags;
#endif // VK_KHR_external_memory_capabilities

#if VK_VERSION_1_1
struct ExternalMemoryProperties : VkExternalMemoryProperties {
  ExternalMemoryProperties() noexcept : VkExternalMemoryProperties{} {}

  ExternalMemoryFeatureFlags getExternalMemoryFeatures() const { return std::bit_cast<ExternalMemoryFeatureFlags>(this->externalMemoryFeatures); }
  ExternalMemoryHandleTypeFlags getCompatibleHandleTypes() const { return std::bit_cast<ExternalMemoryHandleTypeFlags>(this->compatibleHandleTypes); }

  ExternalMemoryHandleTypeFlags getExportFromImportedHandleTypes() const { return std::bit_cast<ExternalMemoryHandleTypeFlags>(this->exportFromImportedHandleTypes); }
};
#endif // VK_VERSION_1_1

#if VK_ARM_data_graph
struct QueueFamilyDataGraphProcessingEnginePropertiesARM : VkQueueFamilyDataGraphProcessingEnginePropertiesARM {
  QueueFamilyDataGraphProcessingEnginePropertiesARM() noexcept : VkQueueFamilyDataGraphProcessingEnginePropertiesARM{.sType = VK_STRUCTURE_TYPE_QUEUE_FAMILY_DATA_GRAPH_PROCESSING_ENGINE_PROPERTIES_ARM} {}

  void setForeignSemaphoreHandleTypes(ExternalSemaphoreHandleTypeFlags value) { this->foreignSemaphoreHandleTypes = std::bit_cast<VkExternalSemaphoreHandleTypeFlags>(value); }
  ExternalSemaphoreHandleTypeFlags getForeignSemaphoreHandleTypes() const { return std::bit_cast<ExternalSemaphoreHandleTypeFlags>(this->foreignSemaphoreHandleTypes); }
  void setForeignMemoryHandleTypes(ExternalMemoryHandleTypeFlags value) { this->foreignMemoryHandleTypes = std::bit_cast<VkExternalMemoryHandleTypeFlags>(value); }
  ExternalMemoryHandleTypeFlags getForeignMemoryHandleTypes() const { return std::bit_cast<ExternalMemoryHandleTypeFlags>(this->foreignMemoryHandleTypes); }
};
#endif // VK_ARM_data_graph

#if VK_KHR_external_semaphore_capabilities
using ExternalSemaphoreHandleTypeFlagsKHR = ExternalSemaphoreHandleTypeFlags;
#endif // VK_KHR_external_semaphore_capabilities

#if VK_VERSION_1_1
struct ExportSemaphoreCreateInfo : VkExportSemaphoreCreateInfo {
  ExportSemaphoreCreateInfo() noexcept : VkExportSemaphoreCreateInfo{.sType = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO} {}

  void setHandleTypes(ExternalSemaphoreHandleTypeFlags value) { this->handleTypes = std::bit_cast<VkExternalSemaphoreHandleTypeFlags>(value); }
  ExternalSemaphoreHandleTypeFlags getHandleTypes() const { return std::bit_cast<ExternalSemaphoreHandleTypeFlags>(this->handleTypes); }
};
inline void SemaphoreCreateInfo::attach(ExportSemaphoreCreateInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_1

#if VK_VERSION_1_2
struct SemaphoreTypeCreateInfo : VkSemaphoreTypeCreateInfo {
  SemaphoreTypeCreateInfo() noexcept : VkSemaphoreTypeCreateInfo{.sType = VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO} {}

  void setSemaphoreType(SemaphoreType value) { this->semaphoreType = std::bit_cast<VkSemaphoreType>(value); }
  SemaphoreType getSemaphoreType() const { return std::bit_cast<SemaphoreType>(this->semaphoreType); }
  void setInitialValue(uint64_t value) { this->initialValue = value; }
  uint64_t getInitialValue() const { return this->initialValue; }
};
inline void SemaphoreCreateInfo::attach(SemaphoreTypeCreateInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void PhysicalDeviceExternalSemaphoreInfo::attach(SemaphoreTypeCreateInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_2

#if VK_KHR_external_semaphore_capabilities
using PhysicalDeviceExternalSemaphoreInfoKHR = PhysicalDeviceExternalSemaphoreInfo;
#endif // VK_KHR_external_semaphore_capabilities

#if VK_VERSION_1_1
struct ExternalSemaphoreProperties : VkExternalSemaphoreProperties {
  ExternalSemaphoreProperties() noexcept : VkExternalSemaphoreProperties{.sType = VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES} {}

  ExternalSemaphoreHandleTypeFlags getExportFromImportedHandleTypes() const { return std::bit_cast<ExternalSemaphoreHandleTypeFlags>(this->exportFromImportedHandleTypes); }
  ExternalSemaphoreHandleTypeFlags getCompatibleHandleTypes() const { return std::bit_cast<ExternalSemaphoreHandleTypeFlags>(this->compatibleHandleTypes); }

  ExternalSemaphoreFeatureFlags getExternalSemaphoreFeatures() const { return std::bit_cast<ExternalSemaphoreFeatureFlags>(this->externalSemaphoreFeatures); }
};
#endif // VK_VERSION_1_1

#if VK_KHR_external_semaphore_capabilities
using ExternalSemaphoreFeatureFlagsKHR = ExternalSemaphoreFeatureFlags;
#endif // VK_KHR_external_semaphore_capabilities

#if VK_KHR_external_semaphore_fd
struct ImportSemaphoreFdInfoKHR : VkImportSemaphoreFdInfoKHR {
  ImportSemaphoreFdInfoKHR() noexcept : VkImportSemaphoreFdInfoKHR{.sType = VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR} {}

  void setSemaphore(Semaphore value) { this->semaphore = std::bit_cast<VkSemaphore>(value); }
  Semaphore getSemaphore() const { return std::bit_cast<Semaphore>(this->semaphore); }
  void setHandleType(ExternalSemaphoreHandleTypeFlagBits value) { this->handleType = std::bit_cast<VkExternalSemaphoreHandleTypeFlagBits>(value); }
  ExternalSemaphoreHandleTypeFlagBits getHandleType() const { return std::bit_cast<ExternalSemaphoreHandleTypeFlagBits>(this->handleType); }
  void setFd(int value) { this->fd = value; }
  int getFd() const { return this->fd; }

  void setFlags(SemaphoreImportFlags value) { this->flags = std::bit_cast<VkSemaphoreImportFlags>(value); }
  SemaphoreImportFlags getFlags() const { return std::bit_cast<SemaphoreImportFlags>(this->flags); }
};
#endif // VK_KHR_external_semaphore_fd

#if VK_KHR_external_semaphore_win32
struct ImportSemaphoreWin32HandleInfoKHR : VkImportSemaphoreWin32HandleInfoKHR {
  ImportSemaphoreWin32HandleInfoKHR() noexcept : VkImportSemaphoreWin32HandleInfoKHR{.sType = VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR} {}

  void setSemaphore(Semaphore value) { this->semaphore = std::bit_cast<VkSemaphore>(value); }
  Semaphore getSemaphore() const { return std::bit_cast<Semaphore>(this->semaphore); }
  void setHandleType(ExternalSemaphoreHandleTypeFlagBits value) { this->handleType = std::bit_cast<VkExternalSemaphoreHandleTypeFlagBits>(value); }
  ExternalSemaphoreHandleTypeFlagBits getHandleType() const { return std::bit_cast<ExternalSemaphoreHandleTypeFlagBits>(this->handleType); }

  void setFlags(SemaphoreImportFlags value) { this->flags = std::bit_cast<VkSemaphoreImportFlags>(value); }
  SemaphoreImportFlags getFlags() const { return std::bit_cast<SemaphoreImportFlags>(this->flags); }
  void setHandle(HANDLE value) { this->handle = value; }
  HANDLE getHandle() const { return this->handle; }
  void setName(LPCWSTR value) { this->name = value; }
  LPCWSTR getName() const { return this->name; }
};
#endif // VK_KHR_external_semaphore_win32

#if VK_FUCHSIA_external_semaphore
struct ImportSemaphoreZirconHandleInfoFUCHSIA : VkImportSemaphoreZirconHandleInfoFUCHSIA {
  ImportSemaphoreZirconHandleInfoFUCHSIA() noexcept : VkImportSemaphoreZirconHandleInfoFUCHSIA{.sType = VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA} {}

  void setSemaphore(Semaphore value) { this->semaphore = std::bit_cast<VkSemaphore>(value); }
  Semaphore getSemaphore() const { return std::bit_cast<Semaphore>(this->semaphore); }
  void setHandleType(ExternalSemaphoreHandleTypeFlagBits value) { this->handleType = std::bit_cast<VkExternalSemaphoreHandleTypeFlagBits>(value); }
  ExternalSemaphoreHandleTypeFlagBits getHandleType() const { return std::bit_cast<ExternalSemaphoreHandleTypeFlagBits>(this->handleType); }
  void setZirconHandle(zx_handle_t value) { this->zirconHandle = value; }
  zx_handle_t getZirconHandle() const { return this->zirconHandle; }

  void setFlags(SemaphoreImportFlags value) { this->flags = std::bit_cast<VkSemaphoreImportFlags>(value); }
  SemaphoreImportFlags getFlags() const { return std::bit_cast<SemaphoreImportFlags>(this->flags); }
};
#endif // VK_FUCHSIA_external_semaphore

#if VK_KHR_external_semaphore
using SemaphoreImportFlagsKHR = SemaphoreImportFlags;
#endif // VK_KHR_external_semaphore
#if VK_KHR_external_fence_capabilities
using PhysicalDeviceExternalFenceInfoKHR = PhysicalDeviceExternalFenceInfo;
using ExternalFenceHandleTypeFlagsKHR = ExternalFenceHandleTypeFlags;
#endif // VK_KHR_external_fence_capabilities

#if VK_VERSION_1_1
struct ExternalFenceProperties : VkExternalFenceProperties {
  ExternalFenceProperties() noexcept : VkExternalFenceProperties{.sType = VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES} {}

  ExternalFenceHandleTypeFlags getExportFromImportedHandleTypes() const { return std::bit_cast<ExternalFenceHandleTypeFlags>(this->exportFromImportedHandleTypes); }
  ExternalFenceHandleTypeFlags getCompatibleHandleTypes() const { return std::bit_cast<ExternalFenceHandleTypeFlags>(this->compatibleHandleTypes); }

  ExternalFenceFeatureFlags getExternalFenceFeatures() const { return std::bit_cast<ExternalFenceFeatureFlags>(this->externalFenceFeatures); }
};
#endif // VK_VERSION_1_1

#if VK_KHR_external_fence_capabilities
using ExternalFenceFeatureFlagsKHR = ExternalFenceFeatureFlags;
#endif // VK_KHR_external_fence_capabilities

#if VK_KHR_external_fence_fd
struct ImportFenceFdInfoKHR : VkImportFenceFdInfoKHR {
  ImportFenceFdInfoKHR() noexcept : VkImportFenceFdInfoKHR{.sType = VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR} {}

  void setFence(Fence value) { this->fence = std::bit_cast<VkFence>(value); }
  Fence getFence() const { return std::bit_cast<Fence>(this->fence); }
  void setHandleType(ExternalFenceHandleTypeFlagBits value) { this->handleType = std::bit_cast<VkExternalFenceHandleTypeFlagBits>(value); }
  ExternalFenceHandleTypeFlagBits getHandleType() const { return std::bit_cast<ExternalFenceHandleTypeFlagBits>(this->handleType); }
  void setFd(int value) { this->fd = value; }
  int getFd() const { return this->fd; }

  void setFlags(FenceImportFlags value) { this->flags = std::bit_cast<VkFenceImportFlags>(value); }
  FenceImportFlags getFlags() const { return std::bit_cast<FenceImportFlags>(this->flags); }
};
#endif // VK_KHR_external_fence_fd

#if VK_KHR_external_fence
using FenceImportFlagsKHR = FenceImportFlags;
#endif // VK_KHR_external_fence

#if VK_KHR_external_fence_win32
struct ImportFenceWin32HandleInfoKHR : VkImportFenceWin32HandleInfoKHR {
  ImportFenceWin32HandleInfoKHR() noexcept : VkImportFenceWin32HandleInfoKHR{.sType = VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR} {}

  void setFence(Fence value) { this->fence = std::bit_cast<VkFence>(value); }
  Fence getFence() const { return std::bit_cast<Fence>(this->fence); }
  void setHandleType(ExternalFenceHandleTypeFlagBits value) { this->handleType = std::bit_cast<VkExternalFenceHandleTypeFlagBits>(value); }
  ExternalFenceHandleTypeFlagBits getHandleType() const { return std::bit_cast<ExternalFenceHandleTypeFlagBits>(this->handleType); }

  void setFlags(FenceImportFlags value) { this->flags = std::bit_cast<VkFenceImportFlags>(value); }
  FenceImportFlags getFlags() const { return std::bit_cast<FenceImportFlags>(this->flags); }
  void setHandle(HANDLE value) { this->handle = value; }
  HANDLE getHandle() const { return this->handle; }
  void setName(LPCWSTR value) { this->name = value; }
  LPCWSTR getName() const { return this->name; }
};
#endif // VK_KHR_external_fence_win32

#if VK_EXT_display_surface_counter
struct SurfaceCapabilities2EXT : VkSurfaceCapabilities2EXT {
  SurfaceCapabilities2EXT() noexcept : VkSurfaceCapabilities2EXT{.sType = VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT} {}

  // Supported minimum number of images for the surface
  uint32_t getMinImageCount() const { return this->minImageCount; }
  // Supported maximum number of images for the surface, 0 for unlimited
  uint32_t getMaxImageCount() const { return this->maxImageCount; }
  // Current image width and height for the surface, (0, 0) if undefined
  const Extent2D& getCurrentExtent() const { return static_cast<const Extent2D&>(this->currentExtent); }
  // Supported minimum image width and height for the surface
  const Extent2D& getMinImageExtent() const { return static_cast<const Extent2D&>(this->minImageExtent); }
  // Supported maximum image width and height for the surface
  const Extent2D& getMaxImageExtent() const { return static_cast<const Extent2D&>(this->maxImageExtent); }
  // Supported maximum number of image layers for the surface
  uint32_t getMaxImageArrayLayers() const { return this->maxImageArrayLayers; }
  // 1 or more bits representing the transforms supported
  SurfaceTransformFlagsKHR getSupportedTransforms() const { return std::bit_cast<SurfaceTransformFlagsKHR>(this->supportedTransforms); }
  // The surface's current transform relative to the device's natural orientation
  SurfaceTransformFlagBitsKHR getCurrentTransform() const { return std::bit_cast<SurfaceTransformFlagBitsKHR>(this->currentTransform); }
  // 1 or more bits representing the alpha compositing modes supported
  CompositeAlphaFlagsKHR getSupportedCompositeAlpha() const { return std::bit_cast<CompositeAlphaFlagsKHR>(this->supportedCompositeAlpha); }
  // Supported image usage flags for the surface
  ImageUsageFlags getSupportedUsageFlags() const { return std::bit_cast<ImageUsageFlags>(this->supportedUsageFlags); }

  SurfaceCounterFlagsEXT getSupportedSurfaceCounters() const { return std::bit_cast<SurfaceCounterFlagsEXT>(this->supportedSurfaceCounters); }
};
#endif // VK_EXT_display_surface_counter

#if VK_KHR_device_group
using PeerMemoryFeatureFlagsKHR = PeerMemoryFeatureFlags;
#endif // VK_KHR_device_group

#if VK_VERSION_1_1
struct MemoryAllocateFlagsInfo : VkMemoryAllocateFlagsInfo {
  MemoryAllocateFlagsInfo() noexcept : VkMemoryAllocateFlagsInfo{.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO} {}

  void setDeviceMask(uint32_t value) { this->deviceMask = value; }
  uint32_t getDeviceMask() const { return this->deviceMask; }

  void setFlags(MemoryAllocateFlags value) { this->flags = std::bit_cast<VkMemoryAllocateFlags>(value); }
  MemoryAllocateFlags getFlags() const { return std::bit_cast<MemoryAllocateFlags>(this->flags); }
};
inline void MemoryAllocateInfo::attach(MemoryAllocateFlagsInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_1

#if VK_KHR_device_group
using MemoryAllocateFlagsKHR = MemoryAllocateFlags;
#endif // VK_KHR_device_group

#if VK_KHR_swapchain
struct DeviceGroupPresentCapabilitiesKHR : VkDeviceGroupPresentCapabilitiesKHR {
  DeviceGroupPresentCapabilitiesKHR() noexcept : VkDeviceGroupPresentCapabilitiesKHR{.sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR} {}

  std::span<const uint32_t, VK_MAX_DEVICE_GROUP_SIZE> getPresentMask() const { return this->presentMask; }
  DeviceGroupPresentModeFlagsKHR getModes() const { return std::bit_cast<DeviceGroupPresentModeFlagsKHR>(this->modes); }
};

struct SwapchainCreateInfoKHR : VkSwapchainCreateInfoKHR {
  SwapchainCreateInfoKHR() noexcept : VkSwapchainCreateInfoKHR{.sType = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR} {}

  // The swapchain's target surface
  void setSurface(SurfaceKHR value) { this->surface = std::bit_cast<VkSurfaceKHR>(value); }
  SurfaceKHR getSurface() const { return std::bit_cast<SurfaceKHR>(this->surface); }
  // Minimum number of presentation images the application needs
  void setMinImageCount(uint32_t value) { this->minImageCount = value; }
  uint32_t getMinImageCount() const { return this->minImageCount; }
  // Format of the presentation images
  void setImageFormat(Format value) { this->imageFormat = std::bit_cast<VkFormat>(value); }
  Format getImageFormat() const { return std::bit_cast<Format>(this->imageFormat); }
  // Colorspace of the presentation images
  void setImageColorSpace(ColorSpaceKHR value) { this->imageColorSpace = std::bit_cast<VkColorSpaceKHR>(value); }
  ColorSpaceKHR getImageColorSpace() const { return std::bit_cast<ColorSpaceKHR>(this->imageColorSpace); }
  // Dimensions of the presentation images
  void setImageExtent(const Extent2D& value) { this->imageExtent = value; }
  const Extent2D& getImageExtent() const { return static_cast<const Extent2D&>(this->imageExtent); }
  // Determines the number of views for multiview/stereo presentation
  void setImageArrayLayers(uint32_t value) { this->imageArrayLayers = value; }
  uint32_t getImageArrayLayers() const { return this->imageArrayLayers; }
  // Bits indicating how the presentation images will be used
  void setImageUsage(ImageUsageFlags value) { this->imageUsage = std::bit_cast<VkImageUsageFlags>(value); }
  ImageUsageFlags getImageUsage() const { return std::bit_cast<ImageUsageFlags>(this->imageUsage); }
  // Sharing mode used for the presentation images
  void setImageSharingMode(SharingMode value) { this->imageSharingMode = std::bit_cast<VkSharingMode>(value); }
  SharingMode getImageSharingMode() const { return std::bit_cast<SharingMode>(this->imageSharingMode); }
  // The transform, relative to the device's natural orientation, applied to the image content prior to presentation
  void setPreTransform(SurfaceTransformFlagBitsKHR value) { this->preTransform = std::bit_cast<VkSurfaceTransformFlagBitsKHR>(value); }
  SurfaceTransformFlagBitsKHR getPreTransform() const { return std::bit_cast<SurfaceTransformFlagBitsKHR>(this->preTransform); }
  // The alpha blending mode used when compositing this surface with other surfaces in the window system
  void setCompositeAlpha(CompositeAlphaFlagBitsKHR value) { this->compositeAlpha = std::bit_cast<VkCompositeAlphaFlagBitsKHR>(value); }
  CompositeAlphaFlagBitsKHR getCompositeAlpha() const { return std::bit_cast<CompositeAlphaFlagBitsKHR>(this->compositeAlpha); }
  // Which presentation mode to use for presents on this swap chain
  void setPresentMode(PresentModeKHR value) { this->presentMode = std::bit_cast<VkPresentModeKHR>(value); }
  PresentModeKHR getPresentMode() const { return std::bit_cast<PresentModeKHR>(this->presentMode); }

  void setFlags(SwapchainCreateFlagsKHR value) { this->flags = std::bit_cast<VkSwapchainCreateFlagsKHR>(value); }
  SwapchainCreateFlagsKHR getFlags() const { return std::bit_cast<SwapchainCreateFlagsKHR>(this->flags); }
  // Number of queue families having access to the images in case of concurrent sharing mode
  void setQueueFamilyIndexCount(uint32_t value) { this->queueFamilyIndexCount = value; }
  uint32_t getQueueFamilyIndexCount() const { return this->queueFamilyIndexCount; }
  // Array of queue family indices having access to the images in case of concurrent sharing mode
  void setQueueFamilyIndices(const uint32_t* value) { this->pQueueFamilyIndices = value; }
  const uint32_t* getQueueFamilyIndices() const { return this->pQueueFamilyIndices; }
  // Specifies whether presentable images may be affected by window clip regions
  void setClipped(Bool32 value) { this->clipped = value; }
  Bool32 getClipped() const { return this->clipped; }
  // Existing swap chain to replace, if any
  void setOldSwapchain(SwapchainKHR value) { this->oldSwapchain = std::bit_cast<VkSwapchainKHR>(value); }
  SwapchainKHR getOldSwapchain() const { return std::bit_cast<SwapchainKHR>(this->oldSwapchain); }

#if VK_EXT_display_control
  void attach(struct SwapchainCounterCreateInfoEXT&);
#endif // VK_EXT_display_control
  void attach(struct DeviceGroupSwapchainCreateInfoKHR&);
#if VK_AMD_display_native_hdr
  void attach(struct SwapchainDisplayNativeHdrCreateInfoAMD&);
#endif // VK_AMD_display_native_hdr
  void attach(struct ImageFormatListCreateInfo&);
#if VK_EXT_full_screen_exclusive
  void attach(struct SurfaceFullScreenExclusiveInfoEXT&);
  void attach(struct SurfaceFullScreenExclusiveWin32InfoEXT&);
#endif // VK_EXT_full_screen_exclusive
#if VK_NV_present_barrier
  void attach(struct SwapchainPresentBarrierCreateInfoNV&);
#endif // VK_NV_present_barrier
#if VK_EXT_image_compression_control
  void attach(struct ImageCompressionControlEXT&);
#endif // VK_EXT_image_compression_control
#if VK_KHR_swapchain_maintenance1
  void attach(struct SwapchainPresentModesCreateInfoKHR&);
  void attach(struct SwapchainPresentScalingCreateInfoKHR&);
#endif // VK_KHR_swapchain_maintenance1
#if VK_NV_low_latency2
  void attach(struct SwapchainLatencyCreateInfoNV&);
#endif // VK_NV_low_latency2
};
#endif // VK_KHR_swapchain

#if VK_VERSION_1_0
struct SubpassDescription : VkSubpassDescription {
  SubpassDescription() noexcept : VkSubpassDescription{} {}

  // Must be VK_PIPELINE_BIND_POINT_GRAPHICS for now
  void setPipelineBindPoint(PipelineBindPoint value) { this->pipelineBindPoint = std::bit_cast<VkPipelineBindPoint>(value); }
  PipelineBindPoint getPipelineBindPoint() const { return std::bit_cast<PipelineBindPoint>(this->pipelineBindPoint); }

  void setFlags(SubpassDescriptionFlags value) { this->flags = std::bit_cast<VkSubpassDescriptionFlags>(value); }
  SubpassDescriptionFlags getFlags() const { return std::bit_cast<SubpassDescriptionFlags>(this->flags); }
  void setInputAttachmentCount(uint32_t value) { this->inputAttachmentCount = value; }
  uint32_t getInputAttachmentCount() const { return this->inputAttachmentCount; }
  void setInputAttachments(const AttachmentReference* value) { this->pInputAttachments = std::bit_cast<const VkAttachmentReference*>(value); }
  const AttachmentReference* getInputAttachments() const { return std::bit_cast<const AttachmentReference*>(this->pInputAttachments); }
  void setColorAttachmentCount(uint32_t value) { this->colorAttachmentCount = value; }
  uint32_t getColorAttachmentCount() const { return this->colorAttachmentCount; }
  void setColorAttachments(const AttachmentReference* value) { this->pColorAttachments = std::bit_cast<const VkAttachmentReference*>(value); }
  const AttachmentReference* getColorAttachments() const { return std::bit_cast<const AttachmentReference*>(this->pColorAttachments); }
  void setResolveAttachments(const AttachmentReference* value) { this->pResolveAttachments = std::bit_cast<const VkAttachmentReference*>(value); }
  const AttachmentReference* getResolveAttachments() const { return std::bit_cast<const AttachmentReference*>(this->pResolveAttachments); }
  void setDepthStencilAttachment(const AttachmentReference* value) { this->pDepthStencilAttachment = std::bit_cast<const VkAttachmentReference*>(value); }
  const AttachmentReference* getDepthStencilAttachment() const { return std::bit_cast<const AttachmentReference*>(this->pDepthStencilAttachment); }
  void setPreserveAttachmentCount(uint32_t value) { this->preserveAttachmentCount = value; }
  uint32_t getPreserveAttachmentCount() const { return this->preserveAttachmentCount; }
  void setPreserveAttachments(const uint32_t* value) { this->pPreserveAttachments = value; }
  const uint32_t* getPreserveAttachments() const { return this->pPreserveAttachments; }
};
#endif // VK_VERSION_1_0

#if VK_EXT_descriptor_indexing
using DescriptorBindingFlagsEXT = DescriptorBindingFlags;
#endif // VK_EXT_descriptor_indexing

#if VK_EXT_conditional_rendering
struct ConditionalRenderingBeginInfoEXT : VkConditionalRenderingBeginInfoEXT {
  ConditionalRenderingBeginInfoEXT() noexcept : VkConditionalRenderingBeginInfoEXT{.sType = VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT} {}

  void setBuffer(Buffer value) { this->buffer = std::bit_cast<VkBuffer>(value); }
  Buffer getBuffer() const { return std::bit_cast<Buffer>(this->buffer); }
  void setOffset(DeviceSize value) { this->offset = value; }
  DeviceSize getOffset() const { return this->offset; }

  void setFlags(ConditionalRenderingFlagsEXT value) { this->flags = std::bit_cast<VkConditionalRenderingFlagsEXT>(value); }
  ConditionalRenderingFlagsEXT getFlags() const { return std::bit_cast<ConditionalRenderingFlagsEXT>(this->flags); }
};
#endif // VK_EXT_conditional_rendering

#if VK_KHR_depth_stencil_resolve
using ResolveModeFlagsKHR = ResolveModeFlags;
#endif // VK_KHR_depth_stencil_resolve

#if VK_KHR_acceleration_structure
struct AccelerationStructureInstanceKHR : VkAccelerationStructureInstanceKHR {
  AccelerationStructureInstanceKHR() noexcept : VkAccelerationStructureInstanceKHR{} {}

  void setTransform(const TransformMatrixKHR& value) { this->transform = value; }
  const TransformMatrixKHR& getTransform() const { return static_cast<const TransformMatrixKHR&>(this->transform); }
  void setInstanceCustomIndex(uint32_t value) { this->instanceCustomIndex = value; }
  uint32_t getInstanceCustomIndex() const { return this->instanceCustomIndex; }
  void setMask(uint32_t value) { this->mask = value; }
  uint32_t getMask() const { return this->mask; }
  void setInstanceShaderBindingTableRecordOffset(uint32_t value) { this->instanceShaderBindingTableRecordOffset = value; }
  uint32_t getInstanceShaderBindingTableRecordOffset() const { return this->instanceShaderBindingTableRecordOffset; }
  void setAccelerationStructureReference(uint64_t value) { this->accelerationStructureReference = value; }
  uint64_t getAccelerationStructureReference() const { return this->accelerationStructureReference; }

  void setFlags(GeometryInstanceFlagsKHR value) { this->flags = std::bit_cast<VkGeometryInstanceFlagsKHR>(value); }
  GeometryInstanceFlagsKHR getFlags() const { return std::bit_cast<GeometryInstanceFlagsKHR>(this->flags); }
};
#endif // VK_KHR_acceleration_structure

#if VK_NV_ray_tracing_motion_blur
struct AccelerationStructureSRTMotionInstanceNV : VkAccelerationStructureSRTMotionInstanceNV {
  AccelerationStructureSRTMotionInstanceNV() noexcept : VkAccelerationStructureSRTMotionInstanceNV{} {}

  void setTransformT0(const SRTDataNV& value) { this->transformT0 = value; }
  const SRTDataNV& getTransformT0() const { return static_cast<const SRTDataNV&>(this->transformT0); }
  void setTransformT1(const SRTDataNV& value) { this->transformT1 = value; }
  const SRTDataNV& getTransformT1() const { return static_cast<const SRTDataNV&>(this->transformT1); }
  void setInstanceCustomIndex(uint32_t value) { this->instanceCustomIndex = value; }
  uint32_t getInstanceCustomIndex() const { return this->instanceCustomIndex; }
  void setMask(uint32_t value) { this->mask = value; }
  uint32_t getMask() const { return this->mask; }
  void setInstanceShaderBindingTableRecordOffset(uint32_t value) { this->instanceShaderBindingTableRecordOffset = value; }
  uint32_t getInstanceShaderBindingTableRecordOffset() const { return this->instanceShaderBindingTableRecordOffset; }
  void setAccelerationStructureReference(uint64_t value) { this->accelerationStructureReference = value; }
  uint64_t getAccelerationStructureReference() const { return this->accelerationStructureReference; }

  void setFlags(GeometryInstanceFlagsKHR value) { this->flags = std::bit_cast<VkGeometryInstanceFlagsKHR>(value); }
  GeometryInstanceFlagsKHR getFlags() const { return std::bit_cast<GeometryInstanceFlagsKHR>(this->flags); }
};

struct AccelerationStructureMatrixMotionInstanceNV : VkAccelerationStructureMatrixMotionInstanceNV {
  AccelerationStructureMatrixMotionInstanceNV() noexcept : VkAccelerationStructureMatrixMotionInstanceNV{} {}

  void setTransformT0(const TransformMatrixKHR& value) { this->transformT0 = value; }
  const TransformMatrixKHR& getTransformT0() const { return static_cast<const TransformMatrixKHR&>(this->transformT0); }
  void setTransformT1(const TransformMatrixKHR& value) { this->transformT1 = value; }
  const TransformMatrixKHR& getTransformT1() const { return static_cast<const TransformMatrixKHR&>(this->transformT1); }
  void setInstanceCustomIndex(uint32_t value) { this->instanceCustomIndex = value; }
  uint32_t getInstanceCustomIndex() const { return this->instanceCustomIndex; }
  void setMask(uint32_t value) { this->mask = value; }
  uint32_t getMask() const { return this->mask; }
  void setInstanceShaderBindingTableRecordOffset(uint32_t value) { this->instanceShaderBindingTableRecordOffset = value; }
  uint32_t getInstanceShaderBindingTableRecordOffset() const { return this->instanceShaderBindingTableRecordOffset; }
  void setAccelerationStructureReference(uint64_t value) { this->accelerationStructureReference = value; }
  uint64_t getAccelerationStructureReference() const { return this->accelerationStructureReference; }

  void setFlags(GeometryInstanceFlagsKHR value) { this->flags = std::bit_cast<VkGeometryInstanceFlagsKHR>(value); }
  GeometryInstanceFlagsKHR getFlags() const { return std::bit_cast<GeometryInstanceFlagsKHR>(this->flags); }
};
#endif // VK_NV_ray_tracing_motion_blur

#if VK_KHR_acceleration_structure
struct AccelerationStructureGeometryKHR : VkAccelerationStructureGeometryKHR {
  AccelerationStructureGeometryKHR() noexcept : VkAccelerationStructureGeometryKHR{.sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR} {}

  void setGeometryType(GeometryTypeKHR value) { this->geometryType = std::bit_cast<VkGeometryTypeKHR>(value); }
  GeometryTypeKHR getGeometryType() const { return std::bit_cast<GeometryTypeKHR>(this->geometryType); }
  void setGeometry(AccelerationStructureGeometryDataKHR value) { this->geometry = value; }
  AccelerationStructureGeometryDataKHR getGeometry() const { return this->geometry; }

  void setFlags(GeometryFlagsKHR value) { this->flags = std::bit_cast<VkGeometryFlagsKHR>(value); }
  GeometryFlagsKHR getFlags() const { return std::bit_cast<GeometryFlagsKHR>(this->flags); }

#if VK_NV_ray_tracing_linear_swept_spheres
  void attach(struct AccelerationStructureGeometryLinearSweptSpheresDataNV&);
  void attach(struct AccelerationStructureGeometrySpheresDataNV&);
#endif // VK_NV_ray_tracing_linear_swept_spheres
};
#endif // VK_KHR_acceleration_structure

#if VK_NV_partitioned_acceleration_structure
struct PartitionedAccelerationStructureInstancesInputNV : VkPartitionedAccelerationStructureInstancesInputNV {
  PartitionedAccelerationStructureInstancesInputNV() noexcept : VkPartitionedAccelerationStructureInstancesInputNV{.sType = VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCES_INPUT_NV} {}

  void setInstanceCount(uint32_t value) { this->instanceCount = value; }
  uint32_t getInstanceCount() const { return this->instanceCount; }
  void setMaxInstancePerPartitionCount(uint32_t value) { this->maxInstancePerPartitionCount = value; }
  uint32_t getMaxInstancePerPartitionCount() const { return this->maxInstancePerPartitionCount; }
  void setPartitionCount(uint32_t value) { this->partitionCount = value; }
  uint32_t getPartitionCount() const { return this->partitionCount; }
  void setMaxInstanceInGlobalPartitionCount(uint32_t value) { this->maxInstanceInGlobalPartitionCount = value; }
  uint32_t getMaxInstanceInGlobalPartitionCount() const { return this->maxInstanceInGlobalPartitionCount; }

  void setFlags(BuildAccelerationStructureFlagsKHR value) { this->flags = std::bit_cast<VkBuildAccelerationStructureFlagsKHR>(value); }
  BuildAccelerationStructureFlagsKHR getFlags() const { return std::bit_cast<BuildAccelerationStructureFlagsKHR>(this->flags); }

  void attach(struct PartitionedAccelerationStructureFlagsNV&);
};
#endif // VK_NV_partitioned_acceleration_structure

#if VK_NV_cluster_acceleration_structure
struct ClusterAccelerationStructureInputInfoNV : VkClusterAccelerationStructureInputInfoNV {
  ClusterAccelerationStructureInputInfoNV() noexcept : VkClusterAccelerationStructureInputInfoNV{.sType = VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_INPUT_INFO_NV} {}

  void setMaxAccelerationStructureCount(uint32_t value) { this->maxAccelerationStructureCount = value; }
  uint32_t getMaxAccelerationStructureCount() const { return this->maxAccelerationStructureCount; }
  void setOpType(ClusterAccelerationStructureOpTypeNV value) { this->opType = std::bit_cast<VkClusterAccelerationStructureOpTypeNV>(value); }
  ClusterAccelerationStructureOpTypeNV getOpType() const { return std::bit_cast<ClusterAccelerationStructureOpTypeNV>(this->opType); }
  void setOpMode(ClusterAccelerationStructureOpModeNV value) { this->opMode = std::bit_cast<VkClusterAccelerationStructureOpModeNV>(value); }
  ClusterAccelerationStructureOpModeNV getOpMode() const { return std::bit_cast<ClusterAccelerationStructureOpModeNV>(this->opMode); }
  void setOpInput(ClusterAccelerationStructureOpInputNV value) { this->opInput = value; }
  ClusterAccelerationStructureOpInputNV getOpInput() const { return this->opInput; }

  void setFlags(BuildAccelerationStructureFlagsKHR value) { this->flags = std::bit_cast<VkBuildAccelerationStructureFlagsKHR>(value); }
  BuildAccelerationStructureFlagsKHR getFlags() const { return std::bit_cast<BuildAccelerationStructureFlagsKHR>(this->flags); }
};
#endif // VK_NV_cluster_acceleration_structure

#if VK_KHR_acceleration_structure
struct AccelerationStructureCreateInfoKHR : VkAccelerationStructureCreateInfoKHR {
  AccelerationStructureCreateInfoKHR() noexcept : VkAccelerationStructureCreateInfoKHR{.sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR} {}

  void setBuffer(Buffer value) { this->buffer = std::bit_cast<VkBuffer>(value); }
  Buffer getBuffer() const { return std::bit_cast<Buffer>(this->buffer); }
  // Specified in bytes
  void setOffset(DeviceSize value) { this->offset = value; }
  DeviceSize getOffset() const { return this->offset; }
  void setSize(DeviceSize value) { this->size = value; }
  DeviceSize getSize() const { return this->size; }
  void setType(AccelerationStructureTypeKHR value) { this->type = std::bit_cast<VkAccelerationStructureTypeKHR>(value); }
  AccelerationStructureTypeKHR getType() const { return std::bit_cast<AccelerationStructureTypeKHR>(this->type); }

  void setCreateFlags(AccelerationStructureCreateFlagsKHR value) { this->createFlags = std::bit_cast<VkAccelerationStructureCreateFlagsKHR>(value); }
  AccelerationStructureCreateFlagsKHR getCreateFlags() const { return std::bit_cast<AccelerationStructureCreateFlagsKHR>(this->createFlags); }
  void setDeviceAddress(DeviceAddress value) { this->deviceAddress = value; }
  DeviceAddress getDeviceAddress() const { return this->deviceAddress; }

#if VK_EXT_descriptor_buffer
  void attach(struct OpaqueCaptureDescriptorDataCreateInfoEXT&);
#endif // VK_EXT_descriptor_buffer
#if VK_NV_ray_tracing_motion_blur
  void attach(struct AccelerationStructureMotionInfoNV&);
#endif // VK_NV_ray_tracing_motion_blur
};
#endif // VK_KHR_acceleration_structure

#if VK_VERSION_1_0
struct FramebufferCreateInfo : VkFramebufferCreateInfo {
  FramebufferCreateInfo() noexcept : VkFramebufferCreateInfo{.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO} {}

  void setRenderPass(RenderPass value) { this->renderPass = std::bit_cast<VkRenderPass>(value); }
  RenderPass getRenderPass() const { return std::bit_cast<RenderPass>(this->renderPass); }
  void setWidth(uint32_t value) { this->width = value; }
  uint32_t getWidth() const { return this->width; }
  void setHeight(uint32_t value) { this->height = value; }
  uint32_t getHeight() const { return this->height; }
  void setLayers(uint32_t value) { this->layers = value; }
  uint32_t getLayers() const { return this->layers; }

  void setFlags(FramebufferCreateFlags value) { this->flags = std::bit_cast<VkFramebufferCreateFlags>(value); }
  FramebufferCreateFlags getFlags() const { return std::bit_cast<FramebufferCreateFlags>(this->flags); }
  void setAttachmentCount(uint32_t value) { this->attachmentCount = value; }
  uint32_t getAttachmentCount() const { return this->attachmentCount; }
  void setAttachments(const ImageView* value) { this->pAttachments = std::bit_cast<const VkImageView*>(value); }
  const ImageView* getAttachments() const { return std::bit_cast<const ImageView*>(this->pAttachments); }

#if VK_VERSION_1_2
  void attach(struct FramebufferAttachmentsCreateInfo&);
#endif // VK_VERSION_1_2
};

struct QueryPoolCreateInfo : VkQueryPoolCreateInfo {
  QueryPoolCreateInfo() noexcept : VkQueryPoolCreateInfo{.sType = VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO} {}

  void setQueryType(QueryType value) { this->queryType = std::bit_cast<VkQueryType>(value); }
  QueryType getQueryType() const { return std::bit_cast<QueryType>(this->queryType); }
  void setQueryCount(uint32_t value) { this->queryCount = value; }
  uint32_t getQueryCount() const { return this->queryCount; }

  void setFlags(QueryPoolCreateFlags value) { this->flags = std::bit_cast<VkQueryPoolCreateFlags>(value); }
  QueryPoolCreateFlags getFlags() const { return std::bit_cast<QueryPoolCreateFlags>(this->flags); }
  // Optional
  void setPipelineStatistics(QueryPipelineStatisticFlags value) { this->pipelineStatistics = std::bit_cast<VkQueryPipelineStatisticFlags>(value); }
  QueryPipelineStatisticFlags getPipelineStatistics() const { return std::bit_cast<QueryPipelineStatisticFlags>(this->pipelineStatistics); }

#if VK_KHR_performance_query
  void attach(struct QueryPoolPerformanceCreateInfoKHR&);
#endif // VK_KHR_performance_query
#if VK_INTEL_performance_query
  void attach(struct QueryPoolPerformanceQueryCreateInfoINTEL&);
#endif // VK_INTEL_performance_query
#if VK_KHR_video_queue
  void attachHead(struct VideoProfileInfoKHR&);
#endif // VK_KHR_video_queue
#if VK_KHR_video_decode_queue
  void attach(struct VideoDecodeUsageInfoKHR&);
#endif // VK_KHR_video_decode_queue
#if VK_KHR_video_decode_h264
  void attach(struct VideoDecodeH264ProfileInfoKHR&);
#endif // VK_KHR_video_decode_h264
#if VK_KHR_video_decode_h265
  void attach(struct VideoDecodeH265ProfileInfoKHR&);
#endif // VK_KHR_video_decode_h265
#if VK_KHR_video_decode_vp9
  void attach(struct VideoDecodeVP9ProfileInfoKHR&);
#endif // VK_KHR_video_decode_vp9
#if VK_KHR_video_decode_av1
  void attach(struct VideoDecodeAV1ProfileInfoKHR&);
#endif // VK_KHR_video_decode_av1
#if VK_KHR_video_encode_queue
  void attach(struct VideoEncodeUsageInfoKHR&);
  void attach(struct QueryPoolVideoEncodeFeedbackCreateInfoKHR&);
#endif // VK_KHR_video_encode_queue
#if VK_KHR_video_encode_h264
  void attach(struct VideoEncodeH264ProfileInfoKHR&);
#endif // VK_KHR_video_encode_h264
#if VK_KHR_video_encode_h265
  void attach(struct VideoEncodeH265ProfileInfoKHR&);
#endif // VK_KHR_video_encode_h265
#if VK_KHR_video_encode_av1
  void attach(struct VideoEncodeAV1ProfileInfoKHR&);
#endif // VK_KHR_video_encode_av1
};
#endif // VK_VERSION_1_0

#if VK_VERSION_1_3
struct PipelineCreationFeedback : VkPipelineCreationFeedback {
  PipelineCreationFeedback() noexcept : VkPipelineCreationFeedback{} {}

  PipelineCreationFeedbackFlags getFlags() const { return std::bit_cast<PipelineCreationFeedbackFlags>(this->flags); }
  uint64_t getDuration() const { return this->duration; }
};
#endif // VK_VERSION_1_3

#if VK_EXT_pipeline_creation_feedback
using PipelineCreationFeedbackFlagsEXT = PipelineCreationFeedbackFlags;
#endif // VK_EXT_pipeline_creation_feedback

#if VK_NV_memory_decompression
struct DecompressMemoryRegionNV : VkDecompressMemoryRegionNV {
  DecompressMemoryRegionNV() noexcept : VkDecompressMemoryRegionNV{} {}
  DecompressMemoryRegionNV(DeviceAddress srcAddress, DeviceAddress dstAddress, DeviceSize compressedSize, DeviceSize decompressedSize, MemoryDecompressionMethodFlagsNV decompressionMethod) noexcept : VkDecompressMemoryRegionNV{.srcAddress = srcAddress, .dstAddress = dstAddress, .compressedSize = compressedSize, .decompressedSize = decompressedSize, .decompressionMethod = std::bit_cast<VkMemoryDecompressionMethodFlagsNV>(decompressionMethod)} {}

  void setSrcAddress(DeviceAddress value) { this->srcAddress = value; }
  DeviceAddress getSrcAddress() const { return this->srcAddress; }
  void setDstAddress(DeviceAddress value) { this->dstAddress = value; }
  DeviceAddress getDstAddress() const { return this->dstAddress; }
  // Specified in bytes
  void setCompressedSize(DeviceSize value) { this->compressedSize = value; }
  DeviceSize getCompressedSize() const { return this->compressedSize; }
  // Specified in bytes
  void setDecompressedSize(DeviceSize value) { this->decompressedSize = value; }
  DeviceSize getDecompressedSize() const { return this->decompressedSize; }
  void setDecompressionMethod(MemoryDecompressionMethodFlagsNV value) { this->decompressionMethod = std::bit_cast<VkMemoryDecompressionMethodFlagsNV>(value); }
  MemoryDecompressionMethodFlagsNV getDecompressionMethod() const { return std::bit_cast<MemoryDecompressionMethodFlagsNV>(this->decompressionMethod); }
};
#endif // VK_NV_memory_decompression

#if VK_KHR_performance_query
struct PerformanceCounterDescriptionKHR : VkPerformanceCounterDescriptionKHR {
  PerformanceCounterDescriptionKHR() noexcept : VkPerformanceCounterDescriptionKHR{.sType = VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR} {}

  std::string_view getName() const { return this->name; }
  std::string_view getCategory() const { return this->category; }
  std::string_view getDescription() const { return this->description; }

  PerformanceCounterDescriptionFlagsKHR getFlags() const { return std::bit_cast<PerformanceCounterDescriptionFlagsKHR>(this->flags); }
};

struct AcquireProfilingLockInfoKHR : VkAcquireProfilingLockInfoKHR {
  AcquireProfilingLockInfoKHR() noexcept : VkAcquireProfilingLockInfoKHR{.sType = VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR} {}

  void setTimeout(uint64_t value) { this->timeout = value; }
  uint64_t getTimeout() const { return this->timeout; }

  // Acquire profiling lock flags
  void setFlags(AcquireProfilingLockFlagsKHR value) { this->flags = std::bit_cast<VkAcquireProfilingLockFlagsKHR>(value); }
  AcquireProfilingLockFlagsKHR getFlags() const { return std::bit_cast<AcquireProfilingLockFlagsKHR>(this->flags); }
};
#endif // VK_KHR_performance_query

#if VK_VERSION_1_3
struct PhysicalDeviceToolProperties : VkPhysicalDeviceToolProperties {
  PhysicalDeviceToolProperties() noexcept : VkPhysicalDeviceToolProperties{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES} {}

  std::string_view getName() const { return this->name; }
  std::string_view getVersion() const { return this->version; }
  ToolPurposeFlags getPurposes() const { return std::bit_cast<ToolPurposeFlags>(this->purposes); }
  std::string_view getDescription() const { return this->description; }
  std::string_view getLayer() const { return this->layer; }
};
#endif // VK_VERSION_1_3

#if VK_EXT_tooling_info
using ToolPurposeFlagsEXT = ToolPurposeFlags;
#endif // VK_EXT_tooling_info
#if VK_KHR_synchronization2
using AccessFlags2KHR = AccessFlags2;
#endif // VK_KHR_synchronization2

#if VK_VERSION_1_3
struct BufferMemoryBarrier2 : VkBufferMemoryBarrier2 {
  BufferMemoryBarrier2() noexcept : VkBufferMemoryBarrier2{.sType = VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2} {}

  void setSrcQueueFamilyIndex(uint32_t value) { this->srcQueueFamilyIndex = value; }
  uint32_t getSrcQueueFamilyIndex() const { return this->srcQueueFamilyIndex; }
  void setDstQueueFamilyIndex(uint32_t value) { this->dstQueueFamilyIndex = value; }
  uint32_t getDstQueueFamilyIndex() const { return this->dstQueueFamilyIndex; }
  void setBuffer(Buffer value) { this->buffer = std::bit_cast<VkBuffer>(value); }
  Buffer getBuffer() const { return std::bit_cast<Buffer>(this->buffer); }
  void setOffset(DeviceSize value) { this->offset = value; }
  DeviceSize getOffset() const { return this->offset; }
  void setSize(DeviceSize value) { this->size = value; }
  DeviceSize getSize() const { return this->size; }

  void setSrcStageMask(PipelineStageFlags2 value) { this->srcStageMask = std::bit_cast<VkPipelineStageFlags2>(value); }
  PipelineStageFlags2 getSrcStageMask() const { return std::bit_cast<PipelineStageFlags2>(this->srcStageMask); }
  void setSrcAccessMask(AccessFlags2 value) { this->srcAccessMask = std::bit_cast<VkAccessFlags2>(value); }
  AccessFlags2 getSrcAccessMask() const { return std::bit_cast<AccessFlags2>(this->srcAccessMask); }
  void setDstStageMask(PipelineStageFlags2 value) { this->dstStageMask = std::bit_cast<VkPipelineStageFlags2>(value); }
  PipelineStageFlags2 getDstStageMask() const { return std::bit_cast<PipelineStageFlags2>(this->dstStageMask); }
  void setDstAccessMask(AccessFlags2 value) { this->dstAccessMask = std::bit_cast<VkAccessFlags2>(value); }
  AccessFlags2 getDstAccessMask() const { return std::bit_cast<AccessFlags2>(this->dstAccessMask); }

#if VK_KHR_maintenance8
  void attach(struct MemoryBarrierAccessFlags3KHR&);
#endif // VK_KHR_maintenance8
#if VK_EXT_external_memory_acquire_unmodified
  void attach(struct ExternalMemoryAcquireUnmodifiedEXT&);
#endif // VK_EXT_external_memory_acquire_unmodified
};

struct SemaphoreSubmitInfo : VkSemaphoreSubmitInfo {
  SemaphoreSubmitInfo() noexcept : VkSemaphoreSubmitInfo{.sType = VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO} {}

  void setSemaphore(Semaphore value) { this->semaphore = std::bit_cast<VkSemaphore>(value); }
  Semaphore getSemaphore() const { return std::bit_cast<Semaphore>(this->semaphore); }
  void setValue(uint64_t value) { this->value = value; }
  uint64_t getValue() const { return this->value; }
  void setDeviceIndex(uint32_t value) { this->deviceIndex = value; }
  uint32_t getDeviceIndex() const { return this->deviceIndex; }

  void setStageMask(PipelineStageFlags2 value) { this->stageMask = std::bit_cast<VkPipelineStageFlags2>(value); }
  PipelineStageFlags2 getStageMask() const { return std::bit_cast<PipelineStageFlags2>(this->stageMask); }
};
#endif // VK_VERSION_1_3

#if VK_KHR_synchronization2
using PipelineStageFlags2KHR = PipelineStageFlags2;
using SubmitFlagsKHR = SubmitFlags;
#endif // VK_KHR_synchronization2

#if VK_VERSION_1_0
struct EventCreateInfo : VkEventCreateInfo {
  EventCreateInfo() noexcept : VkEventCreateInfo{.sType = VK_STRUCTURE_TYPE_EVENT_CREATE_INFO} {}

  // Event creation flags
  void setFlags(EventCreateFlags value) { this->flags = std::bit_cast<VkEventCreateFlags>(value); }
  EventCreateFlags getFlags() const { return std::bit_cast<EventCreateFlags>(this->flags); }

#if VK_EXT_metal_objects
  void attach(struct ExportMetalObjectCreateInfoEXT&);
  void attach(struct ImportMetalSharedEventInfoEXT&);
#endif // VK_EXT_metal_objects
};

struct PipelineDepthStencilStateCreateInfo : VkPipelineDepthStencilStateCreateInfo {
  PipelineDepthStencilStateCreateInfo() noexcept : VkPipelineDepthStencilStateCreateInfo{.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO} {}

  void setDepthCompareOp(CompareOp value) { this->depthCompareOp = std::bit_cast<VkCompareOp>(value); }
  CompareOp getDepthCompareOp() const { return std::bit_cast<CompareOp>(this->depthCompareOp); }
  void setFront(const StencilOpState& value) { this->front = value; }
  const StencilOpState& getFront() const { return static_cast<const StencilOpState&>(this->front); }
  void setBack(const StencilOpState& value) { this->back = value; }
  const StencilOpState& getBack() const { return static_cast<const StencilOpState&>(this->back); }
  void setMinDepthBounds(float value) { this->minDepthBounds = value; }
  float getMinDepthBounds() const { return this->minDepthBounds; }
  void setMaxDepthBounds(float value) { this->maxDepthBounds = value; }
  float getMaxDepthBounds() const { return this->maxDepthBounds; }

  void setFlags(PipelineDepthStencilStateCreateFlags value) { this->flags = std::bit_cast<VkPipelineDepthStencilStateCreateFlags>(value); }
  PipelineDepthStencilStateCreateFlags getFlags() const { return std::bit_cast<PipelineDepthStencilStateCreateFlags>(this->flags); }
  void setDepthTestEnable(Bool32 value) { this->depthTestEnable = value; }
  Bool32 getDepthTestEnable() const { return this->depthTestEnable; }
  void setDepthWriteEnable(Bool32 value) { this->depthWriteEnable = value; }
  Bool32 getDepthWriteEnable() const { return this->depthWriteEnable; }
  // optional (depth_bounds_test)
  void setDepthBoundsTestEnable(Bool32 value) { this->depthBoundsTestEnable = value; }
  Bool32 getDepthBoundsTestEnable() const { return this->depthBoundsTestEnable; }
  void setStencilTestEnable(Bool32 value) { this->stencilTestEnable = value; }
  Bool32 getStencilTestEnable() const { return this->stencilTestEnable; }
};
#endif // VK_VERSION_1_0

#if VK_EXT_surface_maintenance1
using PresentScalingFlagsEXT = PresentScalingFlagsKHR;
using PresentGravityFlagsEXT = PresentGravityFlagsKHR;
#endif // VK_EXT_surface_maintenance1

#if VK_KHR_video_queue
struct VideoCapabilitiesKHR : VkVideoCapabilitiesKHR {
  VideoCapabilitiesKHR() noexcept : VkVideoCapabilitiesKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR} {}

  VideoCapabilityFlagsKHR getFlags() const { return std::bit_cast<VideoCapabilityFlagsKHR>(this->flags); }
  DeviceSize getMinBitstreamBufferOffsetAlignment() const { return this->minBitstreamBufferOffsetAlignment; }
  DeviceSize getMinBitstreamBufferSizeAlignment() const { return this->minBitstreamBufferSizeAlignment; }
  const Extent2D& getPictureAccessGranularity() const { return static_cast<const Extent2D&>(this->pictureAccessGranularity); }
  const Extent2D& getMinCodedExtent() const { return static_cast<const Extent2D&>(this->minCodedExtent); }
  const Extent2D& getMaxCodedExtent() const { return static_cast<const Extent2D&>(this->maxCodedExtent); }
  uint32_t getMaxDpbSlots() const { return this->maxDpbSlots; }
  uint32_t getMaxActiveReferencePictures() const { return this->maxActiveReferencePictures; }
  const ExtensionProperties& getStdHeaderVersion() const { return static_cast<const ExtensionProperties&>(this->stdHeaderVersion); }

#if VK_KHR_video_encode_quantization_map
  void attach(struct VideoEncodeQuantizationMapCapabilitiesKHR&);
  void attach(struct VideoEncodeH264QuantizationMapCapabilitiesKHR&);
  void attach(struct VideoEncodeH265QuantizationMapCapabilitiesKHR&);
  void attach(struct VideoEncodeAV1QuantizationMapCapabilitiesKHR&);
#endif // VK_KHR_video_encode_quantization_map
#if VK_KHR_video_decode_queue
  void attach(struct VideoDecodeCapabilitiesKHR&);
#endif // VK_KHR_video_decode_queue
#if VK_KHR_video_decode_h264
  void attach(struct VideoDecodeH264CapabilitiesKHR&);
#endif // VK_KHR_video_decode_h264
#if VK_KHR_video_decode_h265
  void attach(struct VideoDecodeH265CapabilitiesKHR&);
#endif // VK_KHR_video_decode_h265
#if VK_KHR_video_decode_vp9
  void attach(struct VideoDecodeVP9CapabilitiesKHR&);
#endif // VK_KHR_video_decode_vp9
#if VK_KHR_video_decode_av1
  void attach(struct VideoDecodeAV1CapabilitiesKHR&);
#endif // VK_KHR_video_decode_av1
#if VK_KHR_video_encode_queue
  void attach(struct VideoEncodeCapabilitiesKHR&);
#endif // VK_KHR_video_encode_queue
#if VK_KHR_video_encode_h264
  void attach(struct VideoEncodeH264CapabilitiesKHR&);
#endif // VK_KHR_video_encode_h264
#if VK_KHR_video_encode_h265
  void attach(struct VideoEncodeH265CapabilitiesKHR&);
#endif // VK_KHR_video_encode_h265
#if VK_KHR_video_encode_av1
  void attach(struct VideoEncodeAV1CapabilitiesKHR&);
#endif // VK_KHR_video_encode_av1
#if VK_KHR_video_encode_intra_refresh
  void attach(struct VideoEncodeIntraRefreshCapabilitiesKHR&);
#endif // VK_KHR_video_encode_intra_refresh
};

struct VideoSessionParametersCreateInfoKHR : VkVideoSessionParametersCreateInfoKHR {
  VideoSessionParametersCreateInfoKHR() noexcept : VkVideoSessionParametersCreateInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR} {}

  void setVideoSession(VideoSessionKHR value) { this->videoSession = std::bit_cast<VkVideoSessionKHR>(value); }
  VideoSessionKHR getVideoSession() const { return std::bit_cast<VideoSessionKHR>(this->videoSession); }

  void setFlags(VideoSessionParametersCreateFlagsKHR value) { this->flags = std::bit_cast<VkVideoSessionParametersCreateFlagsKHR>(value); }
  VideoSessionParametersCreateFlagsKHR getFlags() const { return std::bit_cast<VideoSessionParametersCreateFlagsKHR>(this->flags); }
  void setVideoSessionParametersTemplate(VideoSessionParametersKHR value) { this->videoSessionParametersTemplate = std::bit_cast<VkVideoSessionParametersKHR>(value); }
  VideoSessionParametersKHR getVideoSessionParametersTemplate() const { return std::bit_cast<VideoSessionParametersKHR>(this->videoSessionParametersTemplate); }

#if VK_KHR_video_decode_h264
  void attach(struct VideoDecodeH264SessionParametersCreateInfoKHR&);
#endif // VK_KHR_video_decode_h264
#if VK_KHR_video_decode_h265
  void attach(struct VideoDecodeH265SessionParametersCreateInfoKHR&);
#endif // VK_KHR_video_decode_h265
#if VK_KHR_video_decode_av1
  void attach(struct VideoDecodeAV1SessionParametersCreateInfoKHR&);
#endif // VK_KHR_video_decode_av1
#if VK_KHR_video_encode_quantization_map
  void attach(struct VideoEncodeQuantizationMapSessionParametersCreateInfoKHR&);
#endif // VK_KHR_video_encode_quantization_map
#if VK_KHR_video_encode_queue
  void attach(struct VideoEncodeQualityLevelInfoKHR&);
#endif // VK_KHR_video_encode_queue
#if VK_KHR_video_encode_h264
  void attach(struct VideoEncodeH264SessionParametersCreateInfoKHR&);
#endif // VK_KHR_video_encode_h264
#if VK_KHR_video_encode_h265
  void attach(struct VideoEncodeH265SessionParametersCreateInfoKHR&);
#endif // VK_KHR_video_encode_h265
#if VK_KHR_video_encode_av1
  void attach(struct VideoEncodeAV1SessionParametersCreateInfoKHR&);
#endif // VK_KHR_video_encode_av1
};

struct VideoCodingControlInfoKHR : VkVideoCodingControlInfoKHR {
  VideoCodingControlInfoKHR() noexcept : VkVideoCodingControlInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR} {}

  void setFlags(VideoCodingControlFlagsKHR value) { this->flags = std::bit_cast<VkVideoCodingControlFlagsKHR>(value); }
  VideoCodingControlFlagsKHR getFlags() const { return std::bit_cast<VideoCodingControlFlagsKHR>(this->flags); }

#if VK_KHR_video_encode_queue
  void attach(struct VideoEncodeQualityLevelInfoKHR&);
  void attach(struct VideoEncodeRateControlInfoKHR&);
#endif // VK_KHR_video_encode_queue
#if VK_KHR_video_encode_h264
  void attach(struct VideoEncodeH264RateControlInfoKHR&);
#endif // VK_KHR_video_encode_h264
#if VK_KHR_video_encode_h265
  void attach(struct VideoEncodeH265RateControlInfoKHR&);
#endif // VK_KHR_video_encode_h265
#if VK_KHR_video_encode_av1
  void attach(struct VideoEncodeAV1RateControlInfoKHR&);
#endif // VK_KHR_video_encode_av1
};
#endif // VK_KHR_video_queue

#if VK_KHR_video_encode_h264
struct VideoEncodeH264QualityLevelPropertiesKHR : VkVideoEncodeH264QualityLevelPropertiesKHR {
  VideoEncodeH264QualityLevelPropertiesKHR() noexcept : VkVideoEncodeH264QualityLevelPropertiesKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUALITY_LEVEL_PROPERTIES_KHR} {}

  VideoEncodeH264RateControlFlagsKHR getPreferredRateControlFlags() const { return std::bit_cast<VideoEncodeH264RateControlFlagsKHR>(this->preferredRateControlFlags); }
  uint32_t getPreferredGopFrameCount() const { return this->preferredGopFrameCount; }
  uint32_t getPreferredIdrPeriod() const { return this->preferredIdrPeriod; }
  uint32_t getPreferredConsecutiveBFrameCount() const { return this->preferredConsecutiveBFrameCount; }
  uint32_t getPreferredTemporalLayerCount() const { return this->preferredTemporalLayerCount; }
  const VideoEncodeH264QpKHR& getPreferredConstantQp() const { return static_cast<const VideoEncodeH264QpKHR&>(this->preferredConstantQp); }
  uint32_t getPreferredMaxL0ReferenceCount() const { return this->preferredMaxL0ReferenceCount; }
  uint32_t getPreferredMaxL1ReferenceCount() const { return this->preferredMaxL1ReferenceCount; }
  Bool32 getPreferredStdEntropyCodingModeFlag() const { return this->preferredStdEntropyCodingModeFlag; }
};
#if VK_KHR_video_encode_queue
inline void VideoEncodeQualityLevelPropertiesKHR::attach(VideoEncodeH264QualityLevelPropertiesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_encode_queue
#endif // VK_KHR_video_encode_h264

#if VK_EXT_host_image_copy
using HostImageCopyFlagsEXT = HostImageCopyFlags;
#endif // VK_EXT_host_image_copy

#if VK_NV_partitioned_acceleration_structure
struct PartitionedAccelerationStructureWriteInstanceDataNV : VkPartitionedAccelerationStructureWriteInstanceDataNV {
  PartitionedAccelerationStructureWriteInstanceDataNV() noexcept : VkPartitionedAccelerationStructureWriteInstanceDataNV{} {}

  void setTransform(const TransformMatrixKHR& value) { this->transform = value; }
  const TransformMatrixKHR& getTransform() const { return static_cast<const TransformMatrixKHR&>(this->transform); }
  void setExplicitAABB(std::span<const float, 6> value) { std::memcpy(&this->explicitAABB, value.data(), value.size_bytes()); }
  std::span<const float, 6> getExplicitAABB() const { return this->explicitAABB; }
  void setInstanceID(uint32_t value) { this->instanceID = value; }
  uint32_t getInstanceID() const { return this->instanceID; }
  void setInstanceMask(uint32_t value) { this->instanceMask = value; }
  uint32_t getInstanceMask() const { return this->instanceMask; }
  void setInstanceContributionToHitGroupIndex(uint32_t value) { this->instanceContributionToHitGroupIndex = value; }
  uint32_t getInstanceContributionToHitGroupIndex() const { return this->instanceContributionToHitGroupIndex; }
  void setInstanceIndex(uint32_t value) { this->instanceIndex = value; }
  uint32_t getInstanceIndex() const { return this->instanceIndex; }
  void setPartitionIndex(uint32_t value) { this->partitionIndex = value; }
  uint32_t getPartitionIndex() const { return this->partitionIndex; }
  void setAccelerationStructure(DeviceAddress value) { this->accelerationStructure = value; }
  DeviceAddress getAccelerationStructure() const { return this->accelerationStructure; }

  void setInstanceFlags(PartitionedAccelerationStructureInstanceFlagsNV value) { this->instanceFlags = std::bit_cast<VkPartitionedAccelerationStructureInstanceFlagsNV>(value); }
  PartitionedAccelerationStructureInstanceFlagsNV getInstanceFlags() const { return std::bit_cast<PartitionedAccelerationStructureInstanceFlagsNV>(this->instanceFlags); }
};
#endif // VK_NV_partitioned_acceleration_structure

#if VK_KHR_format_feature_flags2
using FormatFeatureFlags2KHR = FormatFeatureFlags2;
#endif // VK_KHR_format_feature_flags2

#if VK_KHR_dynamic_rendering
using RenderingFlagsKHR = RenderingFlags;
#endif // VK_KHR_dynamic_rendering

#if VK_KHR_video_encode_h265
struct VideoEncodeH265QualityLevelPropertiesKHR : VkVideoEncodeH265QualityLevelPropertiesKHR {
  VideoEncodeH265QualityLevelPropertiesKHR() noexcept : VkVideoEncodeH265QualityLevelPropertiesKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUALITY_LEVEL_PROPERTIES_KHR} {}

  VideoEncodeH265RateControlFlagsKHR getPreferredRateControlFlags() const { return std::bit_cast<VideoEncodeH265RateControlFlagsKHR>(this->preferredRateControlFlags); }
  uint32_t getPreferredGopFrameCount() const { return this->preferredGopFrameCount; }
  uint32_t getPreferredIdrPeriod() const { return this->preferredIdrPeriod; }
  uint32_t getPreferredConsecutiveBFrameCount() const { return this->preferredConsecutiveBFrameCount; }
  uint32_t getPreferredSubLayerCount() const { return this->preferredSubLayerCount; }
  const VideoEncodeH265QpKHR& getPreferredConstantQp() const { return static_cast<const VideoEncodeH265QpKHR&>(this->preferredConstantQp); }
  uint32_t getPreferredMaxL0ReferenceCount() const { return this->preferredMaxL0ReferenceCount; }
  uint32_t getPreferredMaxL1ReferenceCount() const { return this->preferredMaxL1ReferenceCount; }
};
#if VK_KHR_video_encode_queue
inline void VideoEncodeQualityLevelPropertiesKHR::attach(VideoEncodeH265QualityLevelPropertiesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_encode_queue
#endif // VK_KHR_video_encode_h265

#if VK_KHR_video_encode_av1
struct VideoEncodeAV1QualityLevelPropertiesKHR : VkVideoEncodeAV1QualityLevelPropertiesKHR {
  VideoEncodeAV1QualityLevelPropertiesKHR() noexcept : VkVideoEncodeAV1QualityLevelPropertiesKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUALITY_LEVEL_PROPERTIES_KHR} {}

  VideoEncodeAV1RateControlFlagsKHR getPreferredRateControlFlags() const { return std::bit_cast<VideoEncodeAV1RateControlFlagsKHR>(this->preferredRateControlFlags); }
  uint32_t getPreferredGopFrameCount() const { return this->preferredGopFrameCount; }
  uint32_t getPreferredKeyFramePeriod() const { return this->preferredKeyFramePeriod; }
  uint32_t getPreferredConsecutiveBipredictiveFrameCount() const { return this->preferredConsecutiveBipredictiveFrameCount; }
  uint32_t getPreferredTemporalLayerCount() const { return this->preferredTemporalLayerCount; }
  const VideoEncodeAV1QIndexKHR& getPreferredConstantQIndex() const { return static_cast<const VideoEncodeAV1QIndexKHR&>(this->preferredConstantQIndex); }
  uint32_t getPreferredMaxSingleReferenceCount() const { return this->preferredMaxSingleReferenceCount; }
  uint32_t getPreferredSingleReferenceNameMask() const { return this->preferredSingleReferenceNameMask; }
  uint32_t getPreferredMaxUnidirectionalCompoundReferenceCount() const { return this->preferredMaxUnidirectionalCompoundReferenceCount; }
  uint32_t getPreferredMaxUnidirectionalCompoundGroup1ReferenceCount() const { return this->preferredMaxUnidirectionalCompoundGroup1ReferenceCount; }
  uint32_t getPreferredUnidirectionalCompoundReferenceNameMask() const { return this->preferredUnidirectionalCompoundReferenceNameMask; }
  uint32_t getPreferredMaxBidirectionalCompoundReferenceCount() const { return this->preferredMaxBidirectionalCompoundReferenceCount; }
  uint32_t getPreferredMaxBidirectionalCompoundGroup1ReferenceCount() const { return this->preferredMaxBidirectionalCompoundGroup1ReferenceCount; }
  uint32_t getPreferredMaxBidirectionalCompoundGroup2ReferenceCount() const { return this->preferredMaxBidirectionalCompoundGroup2ReferenceCount; }
  uint32_t getPreferredBidirectionalCompoundReferenceNameMask() const { return this->preferredBidirectionalCompoundReferenceNameMask; }
};
inline void VideoEncodeQualityLevelPropertiesKHR::attach(VideoEncodeAV1QualityLevelPropertiesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_encode_av1

#if VK_VERSION_1_0
struct InstanceCreateInfo : VkInstanceCreateInfo {
  InstanceCreateInfo() noexcept : VkInstanceCreateInfo{.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO} {}

  void setFlags(InstanceCreateFlags value) { this->flags = std::bit_cast<VkInstanceCreateFlags>(value); }
  InstanceCreateFlags getFlags() const { return std::bit_cast<InstanceCreateFlags>(this->flags); }
  void setApplicationInfo(const ApplicationInfo* value) { this->pApplicationInfo = std::bit_cast<const VkApplicationInfo*>(value); }
  const ApplicationInfo* getApplicationInfo() const { return std::bit_cast<const ApplicationInfo*>(this->pApplicationInfo); }
  void setEnabledLayerCount(uint32_t value) { this->enabledLayerCount = value; }
  uint32_t getEnabledLayerCount() const { return this->enabledLayerCount; }
  // Ordered list of layer names to be enabled
  void setEnabledLayerNames(const char* const* value) { this->ppEnabledLayerNames = value; }
  const char* const* getEnabledLayerNames() const { return this->ppEnabledLayerNames; }
  void setEnabledExtensionCount(uint32_t value) { this->enabledExtensionCount = value; }
  uint32_t getEnabledExtensionCount() const { return this->enabledExtensionCount; }
  // Extension names to be enabled
  void setEnabledExtensionNames(const char* const* value) { this->ppEnabledExtensionNames = value; }
  const char* const* getEnabledExtensionNames() const { return this->ppEnabledExtensionNames; }

#if VK_EXT_layer_settings
  void attach(struct LayerSettingsCreateInfoEXT&);
#endif // VK_EXT_layer_settings
#if VK_EXT_debug_utils
  void attach(struct DebugUtilsMessengerCreateInfoEXT&);
#endif // VK_EXT_debug_utils
#if VK_EXT_metal_objects
  void attach(struct ExportMetalObjectCreateInfoEXT&);
#endif // VK_EXT_metal_objects
#if VK_LUNARG_direct_driver_loading
  void attach(struct DirectDriverLoadingListLUNARG&);
#endif // VK_LUNARG_direct_driver_loading
};
#endif // VK_VERSION_1_0

#if VK_NV_optical_flow
struct OpticalFlowSessionCreateInfoNV : VkOpticalFlowSessionCreateInfoNV {
  OpticalFlowSessionCreateInfoNV() noexcept : VkOpticalFlowSessionCreateInfoNV{.sType = VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_INFO_NV} {}

  void setWidth(uint32_t value) { this->width = value; }
  uint32_t getWidth() const { return this->width; }
  void setHeight(uint32_t value) { this->height = value; }
  uint32_t getHeight() const { return this->height; }
  void setImageFormat(Format value) { this->imageFormat = std::bit_cast<VkFormat>(value); }
  Format getImageFormat() const { return std::bit_cast<Format>(this->imageFormat); }
  void setFlowVectorFormat(Format value) { this->flowVectorFormat = std::bit_cast<VkFormat>(value); }
  Format getFlowVectorFormat() const { return std::bit_cast<Format>(this->flowVectorFormat); }
  void setOutputGridSize(OpticalFlowGridSizeFlagsNV value) { this->outputGridSize = std::bit_cast<VkOpticalFlowGridSizeFlagsNV>(value); }
  OpticalFlowGridSizeFlagsNV getOutputGridSize() const { return std::bit_cast<OpticalFlowGridSizeFlagsNV>(this->outputGridSize); }

  void setCostFormat(Format value) { this->costFormat = std::bit_cast<VkFormat>(value); }
  Format getCostFormat() const { return std::bit_cast<Format>(this->costFormat); }
  void setHintGridSize(OpticalFlowGridSizeFlagsNV value) { this->hintGridSize = std::bit_cast<VkOpticalFlowGridSizeFlagsNV>(value); }
  OpticalFlowGridSizeFlagsNV getHintGridSize() const { return std::bit_cast<OpticalFlowGridSizeFlagsNV>(this->hintGridSize); }
  void setPerformanceLevel(OpticalFlowPerformanceLevelNV value) { this->performanceLevel = std::bit_cast<VkOpticalFlowPerformanceLevelNV>(value); }
  OpticalFlowPerformanceLevelNV getPerformanceLevel() const { return std::bit_cast<OpticalFlowPerformanceLevelNV>(this->performanceLevel); }
  void setFlags(OpticalFlowSessionCreateFlagsNV value) { this->flags = std::bit_cast<VkOpticalFlowSessionCreateFlagsNV>(value); }
  OpticalFlowSessionCreateFlagsNV getFlags() const { return std::bit_cast<OpticalFlowSessionCreateFlagsNV>(this->flags); }

  void attach(struct OpticalFlowSessionCreatePrivateDataInfoNV&);
};

struct OpticalFlowExecuteInfoNV : VkOpticalFlowExecuteInfoNV {
  OpticalFlowExecuteInfoNV() noexcept : VkOpticalFlowExecuteInfoNV{.sType = VK_STRUCTURE_TYPE_OPTICAL_FLOW_EXECUTE_INFO_NV} {}

  void setFlags(OpticalFlowExecuteFlagsNV value) { this->flags = std::bit_cast<VkOpticalFlowExecuteFlagsNV>(value); }
  OpticalFlowExecuteFlagsNV getFlags() const { return std::bit_cast<OpticalFlowExecuteFlagsNV>(this->flags); }
  void setRegionCount(uint32_t value) { this->regionCount = value; }
  uint32_t getRegionCount() const { return this->regionCount; }
  void setRegions(const Rect2D* value) { this->pRegions = std::bit_cast<const VkRect2D*>(value); }
  const Rect2D* getRegions() const { return std::bit_cast<const Rect2D*>(this->pRegions); }
};
#endif // VK_NV_optical_flow

#if VK_EXT_opacity_micromap
struct MicromapBuildInfoEXT : VkMicromapBuildInfoEXT {
  MicromapBuildInfoEXT() noexcept : VkMicromapBuildInfoEXT{.sType = VK_STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT} {}

  void setType(MicromapTypeEXT value) { this->type = std::bit_cast<VkMicromapTypeEXT>(value); }
  MicromapTypeEXT getType() const { return std::bit_cast<MicromapTypeEXT>(this->type); }
  void setMode(BuildMicromapModeEXT value) { this->mode = std::bit_cast<VkBuildMicromapModeEXT>(value); }
  BuildMicromapModeEXT getMode() const { return std::bit_cast<BuildMicromapModeEXT>(this->mode); }
  void setData(DeviceOrHostAddressConstKHR value) { this->data = value; }
  DeviceOrHostAddressConstKHR getData() const { return this->data; }
  void setScratchData(DeviceOrHostAddressKHR value) { this->scratchData = value; }
  DeviceOrHostAddressKHR getScratchData() const { return this->scratchData; }
  void setTriangleArray(DeviceOrHostAddressConstKHR value) { this->triangleArray = value; }
  DeviceOrHostAddressConstKHR getTriangleArray() const { return this->triangleArray; }
  void setTriangleArrayStride(DeviceSize value) { this->triangleArrayStride = value; }
  DeviceSize getTriangleArrayStride() const { return this->triangleArrayStride; }

  void setFlags(BuildMicromapFlagsEXT value) { this->flags = std::bit_cast<VkBuildMicromapFlagsEXT>(value); }
  BuildMicromapFlagsEXT getFlags() const { return std::bit_cast<BuildMicromapFlagsEXT>(this->flags); }
  void setDstMicromap(MicromapEXT value) { this->dstMicromap = std::bit_cast<VkMicromapEXT>(value); }
  MicromapEXT getDstMicromap() const { return std::bit_cast<MicromapEXT>(this->dstMicromap); }
  void setUsageCountsCount(uint32_t value) { this->usageCountsCount = value; }
  uint32_t getUsageCountsCount() const { return this->usageCountsCount; }
  void setUsageCounts(const MicromapUsageEXT* value) { this->pUsageCounts = std::bit_cast<const VkMicromapUsageEXT*>(value); }
  const MicromapUsageEXT* getUsageCounts() const { return std::bit_cast<const MicromapUsageEXT*>(this->pUsageCounts); }
};

struct MicromapCreateInfoEXT : VkMicromapCreateInfoEXT {
  MicromapCreateInfoEXT() noexcept : VkMicromapCreateInfoEXT{.sType = VK_STRUCTURE_TYPE_MICROMAP_CREATE_INFO_EXT} {}

  void setBuffer(Buffer value) { this->buffer = std::bit_cast<VkBuffer>(value); }
  Buffer getBuffer() const { return std::bit_cast<Buffer>(this->buffer); }
  // Specified in bytes
  void setOffset(DeviceSize value) { this->offset = value; }
  DeviceSize getOffset() const { return this->offset; }
  void setSize(DeviceSize value) { this->size = value; }
  DeviceSize getSize() const { return this->size; }
  void setType(MicromapTypeEXT value) { this->type = std::bit_cast<VkMicromapTypeEXT>(value); }
  MicromapTypeEXT getType() const { return std::bit_cast<MicromapTypeEXT>(this->type); }

  void setCreateFlags(MicromapCreateFlagsEXT value) { this->createFlags = std::bit_cast<VkMicromapCreateFlagsEXT>(value); }
  MicromapCreateFlagsEXT getCreateFlags() const { return std::bit_cast<MicromapCreateFlagsEXT>(this->createFlags); }
  void setDeviceAddress(DeviceAddress value) { this->deviceAddress = value; }
  DeviceAddress getDeviceAddress() const { return this->deviceAddress; }
};
#endif // VK_EXT_opacity_micromap

#if VK_EXT_device_fault
struct DeviceFaultInfoEXT : VkDeviceFaultInfoEXT {
  DeviceFaultInfoEXT() noexcept : VkDeviceFaultInfoEXT{.sType = VK_STRUCTURE_TYPE_DEVICE_FAULT_INFO_EXT} {}

  // Free-form description of the fault
  std::string_view getDescription() const { return this->description; }

  DeviceFaultAddressInfoEXT* getAddressInfos() const { return std::bit_cast<DeviceFaultAddressInfoEXT*>(this->pAddressInfos); }
  DeviceFaultVendorInfoEXT* getVendorInfos() const { return std::bit_cast<DeviceFaultVendorInfoEXT*>(this->pVendorInfos); }
  void* getVendorBinaryData() const { return this->pVendorBinaryData; }
};
#endif // VK_EXT_device_fault

#if VK_EXT_device_generated_commands
struct IndirectCommandsLayoutCreateInfoEXT : VkIndirectCommandsLayoutCreateInfoEXT {
  IndirectCommandsLayoutCreateInfoEXT() noexcept : VkIndirectCommandsLayoutCreateInfoEXT{.sType = VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_EXT} {}

  void setShaderStages(ShaderStageFlags value) { this->shaderStages = std::bit_cast<VkShaderStageFlags>(value); }
  ShaderStageFlags getShaderStages() const { return std::bit_cast<ShaderStageFlags>(this->shaderStages); }
  void setIndirectStride(uint32_t value) { this->indirectStride = value; }
  uint32_t getIndirectStride() const { return this->indirectStride; }
  void setTokenCount(uint32_t value) { this->tokenCount = value; }
  uint32_t getTokenCount() const { return this->tokenCount; }
  void setTokens(const IndirectCommandsLayoutTokenEXT* value) { this->pTokens = std::bit_cast<const VkIndirectCommandsLayoutTokenEXT*>(value); }
  const IndirectCommandsLayoutTokenEXT* getTokens() const { return std::bit_cast<const IndirectCommandsLayoutTokenEXT*>(this->pTokens); }

  void setFlags(IndirectCommandsLayoutUsageFlagsEXT value) { this->flags = std::bit_cast<VkIndirectCommandsLayoutUsageFlagsEXT>(value); }
  IndirectCommandsLayoutUsageFlagsEXT getFlags() const { return std::bit_cast<IndirectCommandsLayoutUsageFlagsEXT>(this->flags); }
  void setPipelineLayout(PipelineLayout value) { this->pipelineLayout = std::bit_cast<VkPipelineLayout>(value); }
  PipelineLayout getPipelineLayout() const { return std::bit_cast<PipelineLayout>(this->pipelineLayout); }

  void attach(struct PipelineLayoutCreateInfo&);
};
#endif // VK_EXT_device_generated_commands

#if VK_NV_cooperative_matrix
struct CooperativeMatrixPropertiesNV : VkCooperativeMatrixPropertiesNV {
  CooperativeMatrixPropertiesNV() noexcept : VkCooperativeMatrixPropertiesNV{.sType = VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV} {}

  uint32_t getMSize() const { return this->MSize; }
  uint32_t getNSize() const { return this->NSize; }
  uint32_t getKSize() const { return this->KSize; }
  ComponentTypeNV getAType() const { return std::bit_cast<ComponentTypeNV>(this->AType); }
  ComponentTypeNV getBType() const { return std::bit_cast<ComponentTypeNV>(this->BType); }
  ComponentTypeNV getCType() const { return std::bit_cast<ComponentTypeNV>(this->CType); }
  ComponentTypeNV getDType() const { return std::bit_cast<ComponentTypeNV>(this->DType); }
  ScopeNV getScope() const { return std::bit_cast<ScopeNV>(this->scope); }
};
#endif // VK_NV_cooperative_matrix

#if VK_VERSION_1_4
struct MemoryUnmapInfo : VkMemoryUnmapInfo {
  MemoryUnmapInfo() noexcept : VkMemoryUnmapInfo{.sType = VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO} {}

  void setMemory(DeviceMemory value) { this->memory = std::bit_cast<VkDeviceMemory>(value); }
  DeviceMemory getMemory() const { return std::bit_cast<DeviceMemory>(this->memory); }

  void setFlags(MemoryUnmapFlags value) { this->flags = std::bit_cast<VkMemoryUnmapFlags>(value); }
  MemoryUnmapFlags getFlags() const { return std::bit_cast<MemoryUnmapFlags>(this->flags); }
};
#endif // VK_VERSION_1_4

#if VK_KHR_map_memory2
using MemoryUnmapFlagsKHR = MemoryUnmapFlags;
#endif // VK_KHR_map_memory2

#if VK_ARM_tensors
struct TensorDescriptionARM : VkTensorDescriptionARM {
  TensorDescriptionARM() noexcept : VkTensorDescriptionARM{.sType = VK_STRUCTURE_TYPE_TENSOR_DESCRIPTION_ARM} {}

  void setTiling(TensorTilingARM value) { this->tiling = std::bit_cast<VkTensorTilingARM>(value); }
  TensorTilingARM getTiling() const { return std::bit_cast<TensorTilingARM>(this->tiling); }
  void setFormat(Format value) { this->format = std::bit_cast<VkFormat>(value); }
  Format getFormat() const { return std::bit_cast<Format>(this->format); }
  void setDimensionCount(uint32_t value) { this->dimensionCount = value; }
  uint32_t getDimensionCount() const { return this->dimensionCount; }
  void setDimensions(const int64_t* value) { this->pDimensions = value; }
  const int64_t* getDimensions() const { return this->pDimensions; }
  void setUsage(TensorUsageFlagsARM value) { this->usage = std::bit_cast<VkTensorUsageFlagsARM>(value); }
  TensorUsageFlagsARM getUsage() const { return std::bit_cast<TensorUsageFlagsARM>(this->usage); }

  void setStrides(const int64_t* value) { this->pStrides = value; }
  const int64_t* getStrides() const { return this->pStrides; }
};
#if VK_ARM_data_graph
inline void DataGraphPipelineResourceInfoARM::attach(TensorDescriptionARM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DataGraphPipelineConstantARM::attach(TensorDescriptionARM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_ARM_data_graph

struct TensorViewCreateInfoARM : VkTensorViewCreateInfoARM {
  TensorViewCreateInfoARM() noexcept : VkTensorViewCreateInfoARM{.sType = VK_STRUCTURE_TYPE_TENSOR_VIEW_CREATE_INFO_ARM} {}

  void setTensor(TensorARM value) { this->tensor = std::bit_cast<VkTensorARM>(value); }
  TensorARM getTensor() const { return std::bit_cast<TensorARM>(this->tensor); }
  void setFormat(Format value) { this->format = std::bit_cast<VkFormat>(value); }
  Format getFormat() const { return std::bit_cast<Format>(this->format); }

  void setFlags(TensorViewCreateFlagsARM value) { this->flags = std::bit_cast<VkTensorViewCreateFlagsARM>(value); }
  TensorViewCreateFlagsARM getFlags() const { return std::bit_cast<TensorViewCreateFlagsARM>(this->flags); }

  void attach(struct OpaqueCaptureDescriptorDataCreateInfoEXT&);
};
#endif // VK_ARM_tensors

#if VK_ARM_data_graph
struct DataGraphPipelineSessionCreateInfoARM : VkDataGraphPipelineSessionCreateInfoARM {
  DataGraphPipelineSessionCreateInfoARM() noexcept : VkDataGraphPipelineSessionCreateInfoARM{.sType = VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_CREATE_INFO_ARM} {}

  void setDataGraphPipeline(Pipeline value) { this->dataGraphPipeline = std::bit_cast<VkPipeline>(value); }
  Pipeline getDataGraphPipeline() const { return std::bit_cast<Pipeline>(this->dataGraphPipeline); }

  void setFlags(DataGraphPipelineSessionCreateFlagsARM value) { this->flags = std::bit_cast<VkDataGraphPipelineSessionCreateFlagsARM>(value); }
  DataGraphPipelineSessionCreateFlagsARM getFlags() const { return std::bit_cast<DataGraphPipelineSessionCreateFlagsARM>(this->flags); }
};

struct DataGraphPipelineDispatchInfoARM : VkDataGraphPipelineDispatchInfoARM {
  DataGraphPipelineDispatchInfoARM() noexcept : VkDataGraphPipelineDispatchInfoARM{.sType = VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_DISPATCH_INFO_ARM} {}

  void setFlags(DataGraphPipelineDispatchFlagsARM value) { this->flags = std::bit_cast<VkDataGraphPipelineDispatchFlagsARM>(value); }
  DataGraphPipelineDispatchFlagsARM getFlags() const { return std::bit_cast<DataGraphPipelineDispatchFlagsARM>(this->flags); }
};

struct QueueFamilyDataGraphPropertiesARM : VkQueueFamilyDataGraphPropertiesARM {
  QueueFamilyDataGraphPropertiesARM() noexcept : VkQueueFamilyDataGraphPropertiesARM{.sType = VK_STRUCTURE_TYPE_QUEUE_FAMILY_DATA_GRAPH_PROPERTIES_ARM} {}

  void setEngine(const PhysicalDeviceDataGraphProcessingEngineARM& value) { this->engine = value; }
  const PhysicalDeviceDataGraphProcessingEngineARM& getEngine() const { return static_cast<const PhysicalDeviceDataGraphProcessingEngineARM&>(this->engine); }
  void setOperation(const PhysicalDeviceDataGraphOperationSupportARM& value) { this->operation = value; }
  const PhysicalDeviceDataGraphOperationSupportARM& getOperation() const { return static_cast<const PhysicalDeviceDataGraphOperationSupportARM&>(this->operation); }
};
#endif // VK_ARM_data_graph

#if VK_KHR_get_memory_requirements2
using MemoryRequirements2KHR = MemoryRequirements2;
#endif // VK_KHR_get_memory_requirements2

#if VK_QCOM_tile_memory_heap
struct TileMemoryRequirementsQCOM : VkTileMemoryRequirementsQCOM {
  TileMemoryRequirementsQCOM() noexcept : VkTileMemoryRequirementsQCOM{.sType = VK_STRUCTURE_TYPE_TILE_MEMORY_REQUIREMENTS_QCOM} {}

  void setSize(DeviceSize value) { this->size = value; }
  DeviceSize getSize() const { return this->size; }
  void setAlignment(DeviceSize value) { this->alignment = value; }
  DeviceSize getAlignment() const { return this->alignment; }
};
inline void MemoryRequirements2::attach(TileMemoryRequirementsQCOM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_QCOM_tile_memory_heap

#if VK_VERSION_1_1
struct MemoryDedicatedRequirements : VkMemoryDedicatedRequirements {
  MemoryDedicatedRequirements() noexcept : VkMemoryDedicatedRequirements{.sType = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS} {}

  Bool32 getPrefersDedicatedAllocation() const { return this->prefersDedicatedAllocation; }
  Bool32 getRequiresDedicatedAllocation() const { return this->requiresDedicatedAllocation; }
};
inline void MemoryRequirements2::attach(MemoryDedicatedRequirements& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_1

#if VK_VERSION_1_4
struct SubresourceHostMemcpySize : VkSubresourceHostMemcpySize {
  SubresourceHostMemcpySize() noexcept : VkSubresourceHostMemcpySize{.sType = VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE} {}

  // Specified in bytes
  DeviceSize getSize() const { return this->size; }
};
inline void SubresourceLayout2::attach(SubresourceHostMemcpySize& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_4

#if VK_KHR_maintenance5
using SubresourceLayout2KHR = SubresourceLayout2;
#endif // VK_KHR_maintenance5
#if VK_EXT_host_image_copy
using SubresourceLayout2EXT = SubresourceLayout2;
#endif // VK_EXT_host_image_copy

#if VK_NV_shading_rate_image
struct PipelineViewportCoarseSampleOrderStateCreateInfoNV : VkPipelineViewportCoarseSampleOrderStateCreateInfoNV {
  PipelineViewportCoarseSampleOrderStateCreateInfoNV() noexcept : VkPipelineViewportCoarseSampleOrderStateCreateInfoNV{.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV} {}

  void setSampleOrderType(CoarseSampleOrderTypeNV value) { this->sampleOrderType = std::bit_cast<VkCoarseSampleOrderTypeNV>(value); }
  CoarseSampleOrderTypeNV getSampleOrderType() const { return std::bit_cast<CoarseSampleOrderTypeNV>(this->sampleOrderType); }

  void setCustomSampleOrderCount(uint32_t value) { this->customSampleOrderCount = value; }
  uint32_t getCustomSampleOrderCount() const { return this->customSampleOrderCount; }
  void setCustomSampleOrders(const CoarseSampleOrderCustomNV* value) { this->pCustomSampleOrders = std::bit_cast<const VkCoarseSampleOrderCustomNV*>(value); }
  const CoarseSampleOrderCustomNV* getCustomSampleOrders() const { return std::bit_cast<const CoarseSampleOrderCustomNV*>(this->pCustomSampleOrders); }
};
inline void PipelineViewportStateCreateInfo::attach(PipelineViewportCoarseSampleOrderStateCreateInfoNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_shading_rate_image

#if VK_EXT_depth_clip_control
struct PipelineViewportDepthClipControlCreateInfoEXT : VkPipelineViewportDepthClipControlCreateInfoEXT {
  PipelineViewportDepthClipControlCreateInfoEXT() noexcept : VkPipelineViewportDepthClipControlCreateInfoEXT{.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT} {}

  void setNegativeOneToOne(Bool32 value) { this->negativeOneToOne = value; }
  Bool32 getNegativeOneToOne() const { return this->negativeOneToOne; }
};
inline void PipelineViewportStateCreateInfo::attach(PipelineViewportDepthClipControlCreateInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_depth_clip_control

#if VK_EXT_depth_clamp_control
struct PipelineViewportDepthClampControlCreateInfoEXT : VkPipelineViewportDepthClampControlCreateInfoEXT {
  PipelineViewportDepthClampControlCreateInfoEXT() noexcept : VkPipelineViewportDepthClampControlCreateInfoEXT{.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLAMP_CONTROL_CREATE_INFO_EXT} {}

  void setDepthClampMode(DepthClampModeEXT value) { this->depthClampMode = std::bit_cast<VkDepthClampModeEXT>(value); }
  DepthClampModeEXT getDepthClampMode() const { return std::bit_cast<DepthClampModeEXT>(this->depthClampMode); }

  void setDepthClampRange(const DepthClampRangeEXT* value) { this->pDepthClampRange = std::bit_cast<const VkDepthClampRangeEXT*>(value); }
  const DepthClampRangeEXT* getDepthClampRange() const { return std::bit_cast<const DepthClampRangeEXT*>(this->pDepthClampRange); }
};
inline void PipelineViewportStateCreateInfo::attach(PipelineViewportDepthClampControlCreateInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_depth_clamp_control

#if VK_NV_scissor_exclusive
struct PipelineViewportExclusiveScissorStateCreateInfoNV : VkPipelineViewportExclusiveScissorStateCreateInfoNV {
  PipelineViewportExclusiveScissorStateCreateInfoNV() noexcept : VkPipelineViewportExclusiveScissorStateCreateInfoNV{.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV} {}

  void setExclusiveScissorCount(uint32_t value) { this->exclusiveScissorCount = value; }
  uint32_t getExclusiveScissorCount() const { return this->exclusiveScissorCount; }
  void setExclusiveScissors(const Rect2D* value) { this->pExclusiveScissors = std::bit_cast<const VkRect2D*>(value); }
  const Rect2D* getExclusiveScissors() const { return std::bit_cast<const Rect2D*>(this->pExclusiveScissors); }
};
inline void PipelineViewportStateCreateInfo::attach(PipelineViewportExclusiveScissorStateCreateInfoNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_scissor_exclusive

#if VK_NV_shading_rate_image
struct PipelineViewportShadingRateImageStateCreateInfoNV : VkPipelineViewportShadingRateImageStateCreateInfoNV {
  PipelineViewportShadingRateImageStateCreateInfoNV() noexcept : VkPipelineViewportShadingRateImageStateCreateInfoNV{.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV} {}

  void setShadingRateImageEnable(Bool32 value) { this->shadingRateImageEnable = value; }
  Bool32 getShadingRateImageEnable() const { return this->shadingRateImageEnable; }
  void setViewportCount(uint32_t value) { this->viewportCount = value; }
  uint32_t getViewportCount() const { return this->viewportCount; }
  void setShadingRatePalettes(const ShadingRatePaletteNV* value) { this->pShadingRatePalettes = std::bit_cast<const VkShadingRatePaletteNV*>(value); }
  const ShadingRatePaletteNV* getShadingRatePalettes() const { return std::bit_cast<const ShadingRatePaletteNV*>(this->pShadingRatePalettes); }
};
inline void PipelineViewportStateCreateInfo::attach(PipelineViewportShadingRateImageStateCreateInfoNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_shading_rate_image

#if VK_NV_clip_space_w_scaling
struct PipelineViewportWScalingStateCreateInfoNV : VkPipelineViewportWScalingStateCreateInfoNV {
  PipelineViewportWScalingStateCreateInfoNV() noexcept : VkPipelineViewportWScalingStateCreateInfoNV{.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV} {}

  void setViewportCount(uint32_t value) { this->viewportCount = value; }
  uint32_t getViewportCount() const { return this->viewportCount; }

  void setViewportWScalingEnable(Bool32 value) { this->viewportWScalingEnable = value; }
  Bool32 getViewportWScalingEnable() const { return this->viewportWScalingEnable; }
  void setViewportWScalings(const ViewportWScalingNV* value) { this->pViewportWScalings = std::bit_cast<const VkViewportWScalingNV*>(value); }
  const ViewportWScalingNV* getViewportWScalings() const { return std::bit_cast<const ViewportWScalingNV*>(this->pViewportWScalings); }
};
inline void PipelineViewportStateCreateInfo::attach(PipelineViewportWScalingStateCreateInfoNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_clip_space_w_scaling

#if VK_NV_viewport_swizzle
struct PipelineViewportSwizzleStateCreateInfoNV : VkPipelineViewportSwizzleStateCreateInfoNV {
  PipelineViewportSwizzleStateCreateInfoNV() noexcept : VkPipelineViewportSwizzleStateCreateInfoNV{.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV} {}

  void setViewportCount(uint32_t value) { this->viewportCount = value; }
  uint32_t getViewportCount() const { return this->viewportCount; }
  void setViewportSwizzles(const ViewportSwizzleNV* value) { this->pViewportSwizzles = std::bit_cast<const VkViewportSwizzleNV*>(value); }
  const ViewportSwizzleNV* getViewportSwizzles() const { return std::bit_cast<const ViewportSwizzleNV*>(this->pViewportSwizzles); }

  void setFlags(PipelineViewportSwizzleStateCreateFlagsNV value) { this->flags = std::bit_cast<VkPipelineViewportSwizzleStateCreateFlagsNV>(value); }
  PipelineViewportSwizzleStateCreateFlagsNV getFlags() const { return std::bit_cast<PipelineViewportSwizzleStateCreateFlagsNV>(this->flags); }
};
inline void PipelineViewportStateCreateInfo::attach(PipelineViewportSwizzleStateCreateInfoNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_viewport_swizzle

#if VK_QCOM_ycbcr_degamma
struct SamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM : VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM {
  SamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM() noexcept : VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM{.sType = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_YCBCR_DEGAMMA_CREATE_INFO_QCOM} {}

  void setEnableYDegamma(Bool32 value) { this->enableYDegamma = value; }
  Bool32 getEnableYDegamma() const { return this->enableYDegamma; }
  void setEnableCbCrDegamma(Bool32 value) { this->enableCbCrDegamma = value; }
  Bool32 getEnableCbCrDegamma() const { return this->enableCbCrDegamma; }
};
inline void SamplerYcbcrConversionCreateInfo::attach(SamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_QCOM_ycbcr_degamma

#if VK_KHR_sampler_ycbcr_conversion
using SamplerYcbcrConversionCreateInfoKHR = SamplerYcbcrConversionCreateInfo;
#endif // VK_KHR_sampler_ycbcr_conversion

#if VK_VERSION_1_4
struct PipelineVertexInputDivisorStateCreateInfo : VkPipelineVertexInputDivisorStateCreateInfo {
  PipelineVertexInputDivisorStateCreateInfo() noexcept : VkPipelineVertexInputDivisorStateCreateInfo{.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO} {}

  void setVertexBindingDivisorCount(uint32_t value) { this->vertexBindingDivisorCount = value; }
  uint32_t getVertexBindingDivisorCount() const { return this->vertexBindingDivisorCount; }
  void setVertexBindingDivisors(const VertexInputBindingDivisorDescription* value) { this->pVertexBindingDivisors = std::bit_cast<const VkVertexInputBindingDivisorDescription*>(value); }
  const VertexInputBindingDivisorDescription* getVertexBindingDivisors() const { return std::bit_cast<const VertexInputBindingDivisorDescription*>(this->pVertexBindingDivisors); }
};
inline void PipelineVertexInputStateCreateInfo::attach(PipelineVertexInputDivisorStateCreateInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_4

#if VK_KHR_pipeline_binary
struct PipelineBinaryCreateInfoKHR : VkPipelineBinaryCreateInfoKHR {
  PipelineBinaryCreateInfoKHR() noexcept : VkPipelineBinaryCreateInfoKHR{.sType = VK_STRUCTURE_TYPE_PIPELINE_BINARY_CREATE_INFO_KHR} {}

  void setKeysAndDataInfo(const PipelineBinaryKeysAndDataKHR* value) { this->pKeysAndDataInfo = std::bit_cast<const VkPipelineBinaryKeysAndDataKHR*>(value); }
  const PipelineBinaryKeysAndDataKHR* getKeysAndDataInfo() const { return std::bit_cast<const PipelineBinaryKeysAndDataKHR*>(this->pKeysAndDataInfo); }
  void setPipeline(Pipeline value) { this->pipeline = std::bit_cast<VkPipeline>(value); }
  Pipeline getPipeline() const { return std::bit_cast<Pipeline>(this->pipeline); }
  void setPipelineCreateInfo(const PipelineCreateInfoKHR* value) { this->pPipelineCreateInfo = std::bit_cast<const VkPipelineCreateInfoKHR*>(value); }
  const PipelineCreateInfoKHR* getPipelineCreateInfo() const { return std::bit_cast<const PipelineCreateInfoKHR*>(this->pPipelineCreateInfo); }
};
#endif // VK_KHR_pipeline_binary

#if VK_EXT_descriptor_indexing
using DescriptorSetVariableDescriptorCountLayoutSupportEXT = DescriptorSetVariableDescriptorCountLayoutSupport;
#endif // VK_EXT_descriptor_indexing
#if VK_QCOM_fragment_density_map_offset
using SubpassFragmentDensityMapOffsetEndInfoQCOM = RenderPassFragmentDensityMapOffsetEndInfoEXT;
#endif // VK_QCOM_fragment_density_map_offset
#if VK_KHR_buffer_device_address
using MemoryOpaqueCaptureAddressAllocateInfoKHR = MemoryOpaqueCaptureAddressAllocateInfo;
#endif // VK_KHR_buffer_device_address
#if VK_KHR_maintenance2
using PipelineTessellationDomainOriginStateCreateInfoKHR = PipelineTessellationDomainOriginStateCreateInfo;
#endif // VK_KHR_maintenance2
#if VK_KHR_buffer_device_address
using DeviceMemoryOpaqueCaptureAddressInfoKHR = DeviceMemoryOpaqueCaptureAddressInfo;

using BufferDeviceAddressInfoKHR = BufferDeviceAddressInfo;
#endif // VK_KHR_buffer_device_address
#if VK_KHR_copy_commands2
using CopyBufferInfo2KHR = CopyBufferInfo2;
#endif // VK_KHR_copy_commands2

#if VK_VERSION_1_1
struct BindBufferMemoryDeviceGroupInfo : VkBindBufferMemoryDeviceGroupInfo {
  BindBufferMemoryDeviceGroupInfo() noexcept : VkBindBufferMemoryDeviceGroupInfo{.sType = VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO} {}

  void setDeviceIndexCount(uint32_t value) { this->deviceIndexCount = value; }
  uint32_t getDeviceIndexCount() const { return this->deviceIndexCount; }
  void setDeviceIndices(const uint32_t* value) { this->pDeviceIndices = value; }
  const uint32_t* getDeviceIndices() const { return this->pDeviceIndices; }
};
inline void BindBufferMemoryInfo::attach(BindBufferMemoryDeviceGroupInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_1

#if VK_KHR_bind_memory2
using BindBufferMemoryInfoKHR = BindBufferMemoryInfo;
#endif // VK_KHR_bind_memory2

#if VK_NV_device_generated_commands
struct GeneratedCommandsInfoNV : VkGeneratedCommandsInfoNV {
  GeneratedCommandsInfoNV() noexcept : VkGeneratedCommandsInfoNV{.sType = VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV} {}

  void setPipelineBindPoint(PipelineBindPoint value) { this->pipelineBindPoint = std::bit_cast<VkPipelineBindPoint>(value); }
  PipelineBindPoint getPipelineBindPoint() const { return std::bit_cast<PipelineBindPoint>(this->pipelineBindPoint); }
  void setIndirectCommandsLayout(IndirectCommandsLayoutNV value) { this->indirectCommandsLayout = std::bit_cast<VkIndirectCommandsLayoutNV>(value); }
  IndirectCommandsLayoutNV getIndirectCommandsLayout() const { return std::bit_cast<IndirectCommandsLayoutNV>(this->indirectCommandsLayout); }
  void setStreamCount(uint32_t value) { this->streamCount = value; }
  uint32_t getStreamCount() const { return this->streamCount; }
  void setStreams(const IndirectCommandsStreamNV* value) { this->pStreams = std::bit_cast<const VkIndirectCommandsStreamNV*>(value); }
  const IndirectCommandsStreamNV* getStreams() const { return std::bit_cast<const IndirectCommandsStreamNV*>(this->pStreams); }
  void setSequencesCount(uint32_t value) { this->sequencesCount = value; }
  uint32_t getSequencesCount() const { return this->sequencesCount; }
  void setPreprocessBuffer(Buffer value) { this->preprocessBuffer = std::bit_cast<VkBuffer>(value); }
  Buffer getPreprocessBuffer() const { return std::bit_cast<Buffer>(this->preprocessBuffer); }
  void setPreprocessOffset(DeviceSize value) { this->preprocessOffset = value; }
  DeviceSize getPreprocessOffset() const { return this->preprocessOffset; }
  void setPreprocessSize(DeviceSize value) { this->preprocessSize = value; }
  DeviceSize getPreprocessSize() const { return this->preprocessSize; }
  void setSequencesCountOffset(DeviceSize value) { this->sequencesCountOffset = value; }
  DeviceSize getSequencesCountOffset() const { return this->sequencesCountOffset; }
  void setSequencesIndexOffset(DeviceSize value) { this->sequencesIndexOffset = value; }
  DeviceSize getSequencesIndexOffset() const { return this->sequencesIndexOffset; }

  void setPipeline(Pipeline value) { this->pipeline = std::bit_cast<VkPipeline>(value); }
  Pipeline getPipeline() const { return std::bit_cast<Pipeline>(this->pipeline); }
  void setSequencesCountBuffer(Buffer value) { this->sequencesCountBuffer = std::bit_cast<VkBuffer>(value); }
  Buffer getSequencesCountBuffer() const { return std::bit_cast<Buffer>(this->sequencesCountBuffer); }
  void setSequencesIndexBuffer(Buffer value) { this->sequencesIndexBuffer = std::bit_cast<VkBuffer>(value); }
  Buffer getSequencesIndexBuffer() const { return std::bit_cast<Buffer>(this->sequencesIndexBuffer); }
};
#endif // VK_NV_device_generated_commands

#if VK_KHR_get_memory_requirements2
using BufferMemoryRequirementsInfo2KHR = BufferMemoryRequirementsInfo2;
using ImageSparseMemoryRequirementsInfo2KHR = ImageSparseMemoryRequirementsInfo2;
#endif // VK_KHR_get_memory_requirements2

#if VK_VERSION_1_4
struct BindMemoryStatus : VkBindMemoryStatus {
  BindMemoryStatus() noexcept : VkBindMemoryStatus{.sType = VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS} {}

  void setResult(Result* value) { this->pResult = std::bit_cast<VkResult*>(value); }
  Result* getResult() const { return std::bit_cast<Result*>(this->pResult); }
};
inline void BindBufferMemoryInfo::attach(BindMemoryStatus& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void BindImageMemoryInfo::attach(BindMemoryStatus& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_4

#if VK_KHR_swapchain
struct BindImageMemorySwapchainInfoKHR : VkBindImageMemorySwapchainInfoKHR {
  BindImageMemorySwapchainInfoKHR() noexcept : VkBindImageMemorySwapchainInfoKHR{.sType = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR} {}

  void setSwapchain(SwapchainKHR value) { this->swapchain = std::bit_cast<VkSwapchainKHR>(value); }
  SwapchainKHR getSwapchain() const { return std::bit_cast<SwapchainKHR>(this->swapchain); }
  void setImageIndex(uint32_t value) { this->imageIndex = value; }
  uint32_t getImageIndex() const { return this->imageIndex; }
};
inline void BindImageMemoryInfo::attach(BindImageMemorySwapchainInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_swapchain

#if VK_KHR_bind_memory2
using BindImageMemoryInfoKHR = BindImageMemoryInfo;
#endif // VK_KHR_bind_memory2

#if VK_VERSION_1_1
struct BindImageMemoryDeviceGroupInfo : VkBindImageMemoryDeviceGroupInfo {
  BindImageMemoryDeviceGroupInfo() noexcept : VkBindImageMemoryDeviceGroupInfo{.sType = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO} {}

  void setDeviceIndexCount(uint32_t value) { this->deviceIndexCount = value; }
  uint32_t getDeviceIndexCount() const { return this->deviceIndexCount; }
  void setDeviceIndices(const uint32_t* value) { this->pDeviceIndices = value; }
  const uint32_t* getDeviceIndices() const { return this->pDeviceIndices; }
  void setSplitInstanceBindRegionCount(uint32_t value) { this->splitInstanceBindRegionCount = value; }
  uint32_t getSplitInstanceBindRegionCount() const { return this->splitInstanceBindRegionCount; }
  void setSplitInstanceBindRegions(const Rect2D* value) { this->pSplitInstanceBindRegions = std::bit_cast<const VkRect2D*>(value); }
  const Rect2D* getSplitInstanceBindRegions() const { return std::bit_cast<const Rect2D*>(this->pSplitInstanceBindRegions); }
};
inline void BindImageMemoryInfo::attach(BindImageMemoryDeviceGroupInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }

struct BindImagePlaneMemoryInfo : VkBindImagePlaneMemoryInfo {
  BindImagePlaneMemoryInfo() noexcept : VkBindImagePlaneMemoryInfo{.sType = VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO} {}

  void setPlaneAspect(ImageAspectFlagBits value) { this->planeAspect = std::bit_cast<VkImageAspectFlagBits>(value); }
  ImageAspectFlagBits getPlaneAspect() const { return std::bit_cast<ImageAspectFlagBits>(this->planeAspect); }
};
inline void BindImageMemoryInfo::attach(BindImagePlaneMemoryInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_1

#if VK_KHR_get_memory_requirements2
using ImageMemoryRequirementsInfo2KHR = ImageMemoryRequirementsInfo2;
#endif // VK_KHR_get_memory_requirements2

#if VK_VERSION_1_1
struct ImagePlaneMemoryRequirementsInfo : VkImagePlaneMemoryRequirementsInfo {
  ImagePlaneMemoryRequirementsInfo() noexcept : VkImagePlaneMemoryRequirementsInfo{.sType = VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO} {}

  void setPlaneAspect(ImageAspectFlagBits value) { this->planeAspect = std::bit_cast<VkImageAspectFlagBits>(value); }
  ImageAspectFlagBits getPlaneAspect() const { return std::bit_cast<ImageAspectFlagBits>(this->planeAspect); }
};
inline void ImageMemoryRequirementsInfo2::attach(ImagePlaneMemoryRequirementsInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_1

#if VK_KHR_dedicated_allocation
using MemoryDedicatedAllocateInfoKHR = MemoryDedicatedAllocateInfo;
#endif // VK_KHR_dedicated_allocation

#if VK_KHR_video_queue
struct VideoReferenceSlotInfoKHR : VkVideoReferenceSlotInfoKHR {
  VideoReferenceSlotInfoKHR() noexcept : VkVideoReferenceSlotInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR} {}

  // The reference slot index
  void setSlotIndex(int32_t value) { this->slotIndex = value; }
  int32_t getSlotIndex() const { return this->slotIndex; }

  // The reference picture resource
  void setPictureResource(const VideoPictureResourceInfoKHR* value) { this->pPictureResource = std::bit_cast<const VkVideoPictureResourceInfoKHR*>(value); }
  const VideoPictureResourceInfoKHR* getPictureResource() const { return std::bit_cast<const VideoPictureResourceInfoKHR*>(this->pPictureResource); }

#if VK_KHR_video_decode_h264
  void attach(struct VideoDecodeH264DpbSlotInfoKHR&);
#endif // VK_KHR_video_decode_h264
#if VK_KHR_video_decode_h265
  void attach(struct VideoDecodeH265DpbSlotInfoKHR&);
#endif // VK_KHR_video_decode_h265
#if VK_KHR_video_decode_av1
  void attach(struct VideoDecodeAV1DpbSlotInfoKHR&);
#endif // VK_KHR_video_decode_av1
#if VK_KHR_video_encode_h264
  void attach(struct VideoEncodeH264DpbSlotInfoKHR&);
#endif // VK_KHR_video_encode_h264
#if VK_KHR_video_encode_h265
  void attach(struct VideoEncodeH265DpbSlotInfoKHR&);
#endif // VK_KHR_video_encode_h265
#if VK_KHR_video_encode_av1
  void attach(struct VideoEncodeAV1DpbSlotInfoKHR&);
#endif // VK_KHR_video_encode_av1
#if VK_KHR_video_encode_intra_refresh
  void attach(struct VideoReferenceIntraRefreshInfoKHR&);
#endif // VK_KHR_video_encode_intra_refresh
};
#endif // VK_KHR_video_queue

#if VK_VERSION_1_3
struct RenderingInfo : VkRenderingInfo {
  RenderingInfo() noexcept : VkRenderingInfo{.sType = VK_STRUCTURE_TYPE_RENDERING_INFO} {}

  void setRenderArea(const Rect2D& value) { this->renderArea = value; }
  const Rect2D& getRenderArea() const { return static_cast<const Rect2D&>(this->renderArea); }
  void setLayerCount(uint32_t value) { this->layerCount = value; }
  uint32_t getLayerCount() const { return this->layerCount; }
  void setViewMask(uint32_t value) { this->viewMask = value; }
  uint32_t getViewMask() const { return this->viewMask; }

  void setFlags(RenderingFlags value) { this->flags = std::bit_cast<VkRenderingFlags>(value); }
  RenderingFlags getFlags() const { return std::bit_cast<RenderingFlags>(this->flags); }
  void setColorAttachmentCount(uint32_t value) { this->colorAttachmentCount = value; }
  uint32_t getColorAttachmentCount() const { return this->colorAttachmentCount; }
  void setColorAttachments(const RenderingAttachmentInfo* value) { this->pColorAttachments = std::bit_cast<const VkRenderingAttachmentInfo*>(value); }
  const RenderingAttachmentInfo* getColorAttachments() const { return std::bit_cast<const RenderingAttachmentInfo*>(this->pColorAttachments); }
  void setDepthAttachment(const RenderingAttachmentInfo* value) { this->pDepthAttachment = std::bit_cast<const VkRenderingAttachmentInfo*>(value); }
  const RenderingAttachmentInfo* getDepthAttachment() const { return std::bit_cast<const RenderingAttachmentInfo*>(this->pDepthAttachment); }
  void setStencilAttachment(const RenderingAttachmentInfo* value) { this->pStencilAttachment = std::bit_cast<const VkRenderingAttachmentInfo*>(value); }
  const RenderingAttachmentInfo* getStencilAttachment() const { return std::bit_cast<const RenderingAttachmentInfo*>(this->pStencilAttachment); }

  void attach(struct DeviceGroupRenderPassBeginInfo&);
#if VK_EXT_multisampled_render_to_single_sampled
  void attach(struct MultisampledRenderToSingleSampledInfoEXT&);
#endif // VK_EXT_multisampled_render_to_single_sampled
#if VK_KHR_fragment_shading_rate
  void attach(struct RenderingFragmentShadingRateAttachmentInfoKHR&);
#endif // VK_KHR_fragment_shading_rate
#if VK_EXT_fragment_density_map
  void attach(struct RenderingFragmentDensityMapAttachmentInfoEXT&);
#endif // VK_EXT_fragment_density_map
#if VK_NVX_multiview_per_view_attributes
  void attach(struct MultiviewPerViewAttributesInfoNVX&);
#endif // VK_NVX_multiview_per_view_attributes
#if VK_QCOM_multiview_per_view_render_areas
  void attach(struct MultiviewPerViewRenderAreasRenderPassBeginInfoQCOM&);
#endif // VK_QCOM_multiview_per_view_render_areas
#if VK_QCOM_tile_memory_heap
  void attach(struct TileMemorySizeInfoQCOM&);
#endif // VK_QCOM_tile_memory_heap
#if VK_ARM_render_pass_striped
  void attach(struct RenderPassStripeBeginInfoARM&);
#endif // VK_ARM_render_pass_striped
#if VK_QCOM_tile_shading
  void attach(struct RenderPassTileShadingCreateInfoQCOM&);
#endif // VK_QCOM_tile_shading
};
#endif // VK_VERSION_1_3

#if VK_KHR_dynamic_rendering
using RenderingAttachmentInfoKHR = RenderingAttachmentInfo;
#endif // VK_KHR_dynamic_rendering

#if VK_EXT_pipeline_properties
using PipelineInfoEXT = PipelineInfoKHR;
#endif // VK_EXT_pipeline_properties

#if VK_VERSION_1_0
struct WriteDescriptorSet : VkWriteDescriptorSet {
  WriteDescriptorSet() noexcept : VkWriteDescriptorSet{.sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET} {}

  // Destination descriptor set
  void setDstSet(DescriptorSet value) { this->dstSet = std::bit_cast<VkDescriptorSet>(value); }
  DescriptorSet getDstSet() const { return std::bit_cast<DescriptorSet>(this->dstSet); }
  // Binding within the destination descriptor set to write
  void setDstBinding(uint32_t value) { this->dstBinding = value; }
  uint32_t getDstBinding() const { return this->dstBinding; }
  // Array element within the destination binding to write
  void setDstArrayElement(uint32_t value) { this->dstArrayElement = value; }
  uint32_t getDstArrayElement() const { return this->dstArrayElement; }
  // Number of descriptors to write (determines the size of the array pointed by pDescriptors)
  void setDescriptorCount(uint32_t value) { this->descriptorCount = value; }
  uint32_t getDescriptorCount() const { return this->descriptorCount; }
  // Descriptor type to write (determines which members of the array pointed by pDescriptors are going to be used)
  void setDescriptorType(DescriptorType value) { this->descriptorType = std::bit_cast<VkDescriptorType>(value); }
  DescriptorType getDescriptorType() const { return std::bit_cast<DescriptorType>(this->descriptorType); }
  // Sampler, image view, and layout for SAMPLER, COMBINED_IMAGE_SAMPLER, {SAMPLED,STORAGE}_IMAGE, and INPUT_ATTACHMENT descriptor types.
  void setImageInfo(const DescriptorImageInfo* value) { this->pImageInfo = std::bit_cast<const VkDescriptorImageInfo*>(value); }
  const DescriptorImageInfo* getImageInfo() const { return std::bit_cast<const DescriptorImageInfo*>(this->pImageInfo); }
  // Raw buffer, size, and offset for {UNIFORM,STORAGE}_BUFFER[_DYNAMIC] descriptor types.
  void setBufferInfo(const DescriptorBufferInfo* value) { this->pBufferInfo = std::bit_cast<const VkDescriptorBufferInfo*>(value); }
  const DescriptorBufferInfo* getBufferInfo() const { return std::bit_cast<const DescriptorBufferInfo*>(this->pBufferInfo); }
  // Buffer view to write to the descriptor for {UNIFORM,STORAGE}_TEXEL_BUFFER descriptor types.
  void setTexelBufferView(const BufferView* value) { this->pTexelBufferView = std::bit_cast<const VkBufferView*>(value); }
  const BufferView* getTexelBufferView() const { return std::bit_cast<const BufferView*>(this->pTexelBufferView); }

#if VK_VERSION_1_3
  void attach(struct WriteDescriptorSetInlineUniformBlock&);
#endif // VK_VERSION_1_3
#if VK_KHR_acceleration_structure
  void attach(struct WriteDescriptorSetAccelerationStructureKHR&);
#endif // VK_KHR_acceleration_structure
#if VK_NV_partitioned_acceleration_structure
  void attach(struct WriteDescriptorSetPartitionedAccelerationStructureNV&);
#endif // VK_NV_partitioned_acceleration_structure
#if VK_ARM_tensors
  void attach(struct WriteDescriptorSetTensorARM&);
#endif // VK_ARM_tensors
};
#endif // VK_VERSION_1_0

#if VK_KHR_descriptor_update_template
using DescriptorUpdateTemplateCreateInfoKHR = DescriptorUpdateTemplateCreateInfo;
#endif // VK_KHR_descriptor_update_template

#if VK_VERSION_1_2
struct DescriptorSetVariableDescriptorCountAllocateInfo : VkDescriptorSetVariableDescriptorCountAllocateInfo {
  DescriptorSetVariableDescriptorCountAllocateInfo() noexcept : VkDescriptorSetVariableDescriptorCountAllocateInfo{.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO} {}

  void setDescriptorSetCount(uint32_t value) { this->descriptorSetCount = value; }
  uint32_t getDescriptorSetCount() const { return this->descriptorSetCount; }
  void setDescriptorCounts(const uint32_t* value) { this->pDescriptorCounts = value; }
  const uint32_t* getDescriptorCounts() const { return this->pDescriptorCounts; }
};
inline void DescriptorSetAllocateInfo::attach(DescriptorSetVariableDescriptorCountAllocateInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_2

#if VK_KHR_timeline_semaphore
using SemaphoreSignalInfoKHR = SemaphoreSignalInfo;
#endif // VK_KHR_timeline_semaphore

#if VK_QCOM_render_pass_transform
struct RenderPassTransformBeginInfoQCOM : VkRenderPassTransformBeginInfoQCOM {
  RenderPassTransformBeginInfoQCOM() noexcept : VkRenderPassTransformBeginInfoQCOM{.sType = VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM} {}

  void setTransform(SurfaceTransformFlagBitsKHR value) { this->transform = std::bit_cast<VkSurfaceTransformFlagBitsKHR>(value); }
  SurfaceTransformFlagBitsKHR getTransform() const { return std::bit_cast<SurfaceTransformFlagBitsKHR>(this->transform); }
};
inline void RenderPassBeginInfo::attach(RenderPassTransformBeginInfoQCOM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_QCOM_render_pass_transform

#if VK_VERSION_1_2
struct RenderPassAttachmentBeginInfo : VkRenderPassAttachmentBeginInfo {
  RenderPassAttachmentBeginInfo() noexcept : VkRenderPassAttachmentBeginInfo{.sType = VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO} {}

  void setAttachmentCount(uint32_t value) { this->attachmentCount = value; }
  uint32_t getAttachmentCount() const { return this->attachmentCount; }
  void setAttachments(const ImageView* value) { this->pAttachments = std::bit_cast<const VkImageView*>(value); }
  const ImageView* getAttachments() const { return std::bit_cast<const ImageView*>(this->pAttachments); }
};
inline void RenderPassBeginInfo::attach(RenderPassAttachmentBeginInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_2

#if VK_KHR_maintenance6
using PushDescriptorSetWithTemplateInfoKHR = PushDescriptorSetWithTemplateInfo;
#endif // VK_KHR_maintenance6

#if VK_KHR_get_display_properties2
struct DisplayPlaneProperties2KHR : VkDisplayPlaneProperties2KHR {
  DisplayPlaneProperties2KHR() noexcept : VkDisplayPlaneProperties2KHR{.sType = VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR} {}

  const DisplayPlanePropertiesKHR& getDisplayPlaneProperties() const { return static_cast<const DisplayPlanePropertiesKHR&>(this->displayPlaneProperties); }
};

struct DisplayModeProperties2KHR : VkDisplayModeProperties2KHR {
  DisplayModeProperties2KHR() noexcept : VkDisplayModeProperties2KHR{.sType = VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR} {}

  const DisplayModePropertiesKHR& getDisplayModeProperties() const { return static_cast<const DisplayModePropertiesKHR&>(this->displayModeProperties); }

#if VK_NV_display_stereo
  void attach(struct DisplayModeStereoPropertiesNV&);
#endif // VK_NV_display_stereo
};
#endif // VK_KHR_get_display_properties2

#if VK_NV_display_stereo
struct DisplaySurfaceStereoCreateInfoNV : VkDisplaySurfaceStereoCreateInfoNV {
  DisplaySurfaceStereoCreateInfoNV() noexcept : VkDisplaySurfaceStereoCreateInfoNV{.sType = VK_STRUCTURE_TYPE_DISPLAY_SURFACE_STEREO_CREATE_INFO_NV} {}

  // The 3D stereo type to use when presenting this surface.
  void setStereoType(DisplaySurfaceStereoTypeNV value) { this->stereoType = std::bit_cast<VkDisplaySurfaceStereoTypeNV>(value); }
  DisplaySurfaceStereoTypeNV getStereoType() const { return std::bit_cast<DisplaySurfaceStereoTypeNV>(this->stereoType); }
};
inline void DisplaySurfaceCreateInfoKHR::attach(DisplaySurfaceStereoCreateInfoNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_display_stereo

#if VK_KHR_surface_maintenance1
struct SurfacePresentModeKHR : VkSurfacePresentModeKHR {
  SurfacePresentModeKHR() noexcept : VkSurfacePresentModeKHR{.sType = VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_KHR} {}

  void setPresentMode(PresentModeKHR value) { this->presentMode = std::bit_cast<VkPresentModeKHR>(value); }
  PresentModeKHR getPresentMode() const { return std::bit_cast<PresentModeKHR>(this->presentMode); }
};
inline void PhysicalDeviceSurfaceInfo2KHR::attach(SurfacePresentModeKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_surface_maintenance1

#if VK_EXT_swapchain_maintenance1
using ReleaseSwapchainImagesInfoEXT = ReleaseSwapchainImagesInfoKHR;
#endif // VK_EXT_swapchain_maintenance1

#if VK_KHR_swapchain_maintenance1
struct SwapchainPresentFenceInfoKHR : VkSwapchainPresentFenceInfoKHR {
  SwapchainPresentFenceInfoKHR() noexcept : VkSwapchainPresentFenceInfoKHR{.sType = VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_KHR} {}

  // Copy of VkPresentInfoKHR::swapchainCount
  void setSwapchainCount(uint32_t value) { this->swapchainCount = value; }
  uint32_t getSwapchainCount() const { return this->swapchainCount; }

  // Fence to signal for each swapchain
  void setFences(const Fence* value) { this->pFences = std::bit_cast<const VkFence*>(value); }
  const Fence* getFences() const { return std::bit_cast<const Fence*>(this->pFences); }
};
inline void PresentInfoKHR::attach(SwapchainPresentFenceInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }

struct SwapchainPresentModeInfoKHR : VkSwapchainPresentModeInfoKHR {
  SwapchainPresentModeInfoKHR() noexcept : VkSwapchainPresentModeInfoKHR{.sType = VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_KHR} {}

  // Copy of VkPresentInfoKHR::swapchainCount
  void setSwapchainCount(uint32_t value) { this->swapchainCount = value; }
  uint32_t getSwapchainCount() const { return this->swapchainCount; }
  // Presentation mode for each swapchain
  void setPresentModes(const PresentModeKHR* value) { this->pPresentModes = std::bit_cast<const VkPresentModeKHR*>(value); }
  const PresentModeKHR* getPresentModes() const { return std::bit_cast<const PresentModeKHR*>(this->pPresentModes); }
};
inline void PresentInfoKHR::attach(SwapchainPresentModeInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_swapchain_maintenance1

#if VK_KHR_present_id
struct PresentIdKHR : VkPresentIdKHR {
  PresentIdKHR() noexcept : VkPresentIdKHR{.sType = VK_STRUCTURE_TYPE_PRESENT_ID_KHR} {}

  // Copy of VkPresentInfoKHR::swapchainCount
  void setSwapchainCount(uint32_t value) { this->swapchainCount = value; }
  uint32_t getSwapchainCount() const { return this->swapchainCount; }

  // Present ID values for each swapchain
  void setPresentIds(const uint64_t* value) { this->pPresentIds = value; }
  const uint64_t* getPresentIds() const { return this->pPresentIds; }
};
inline void PresentInfoKHR::attach(PresentIdKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_present_id

#if VK_KHR_incremental_present
struct PresentRegionsKHR : VkPresentRegionsKHR {
  PresentRegionsKHR() noexcept : VkPresentRegionsKHR{.sType = VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR} {}

  // Copy of VkPresentInfoKHR::swapchainCount
  void setSwapchainCount(uint32_t value) { this->swapchainCount = value; }
  uint32_t getSwapchainCount() const { return this->swapchainCount; }

  // The regions that have changed
  void setRegions(const PresentRegionKHR* value) { this->pRegions = std::bit_cast<const VkPresentRegionKHR*>(value); }
  const PresentRegionKHR* getRegions() const { return std::bit_cast<const PresentRegionKHR*>(this->pRegions); }
};
inline void PresentInfoKHR::attach(PresentRegionsKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_incremental_present

#if VK_KHR_swapchain
struct DeviceGroupPresentInfoKHR : VkDeviceGroupPresentInfoKHR {
  DeviceGroupPresentInfoKHR() noexcept : VkDeviceGroupPresentInfoKHR{.sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR} {}

  void setMode(DeviceGroupPresentModeFlagBitsKHR value) { this->mode = std::bit_cast<VkDeviceGroupPresentModeFlagBitsKHR>(value); }
  DeviceGroupPresentModeFlagBitsKHR getMode() const { return std::bit_cast<DeviceGroupPresentModeFlagBitsKHR>(this->mode); }

  void setSwapchainCount(uint32_t value) { this->swapchainCount = value; }
  uint32_t getSwapchainCount() const { return this->swapchainCount; }
  void setDeviceMasks(const uint32_t* value) { this->pDeviceMasks = value; }
  const uint32_t* getDeviceMasks() const { return this->pDeviceMasks; }
};
inline void PresentInfoKHR::attach(DeviceGroupPresentInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_swapchain

#if VK_KHR_present_id2
struct PresentId2KHR : VkPresentId2KHR {
  PresentId2KHR() noexcept : VkPresentId2KHR{.sType = VK_STRUCTURE_TYPE_PRESENT_ID_2_KHR} {}

  // Copy of VkPresentInfoKHR::swapchainCount
  void setSwapchainCount(uint32_t value) { this->swapchainCount = value; }
  uint32_t getSwapchainCount() const { return this->swapchainCount; }

  // Present ID values for each swapchain
  void setPresentIds(const uint64_t* value) { this->pPresentIds = value; }
  const uint64_t* getPresentIds() const { return this->pPresentIds; }
};
inline void PresentInfoKHR::attach(PresentId2KHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_present_id2

#if VK_GOOGLE_display_timing
struct PresentTimesInfoGOOGLE : VkPresentTimesInfoGOOGLE {
  PresentTimesInfoGOOGLE() noexcept : VkPresentTimesInfoGOOGLE{.sType = VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE} {}

  // Copy of VkPresentInfoKHR::swapchainCount
  void setSwapchainCount(uint32_t value) { this->swapchainCount = value; }
  uint32_t getSwapchainCount() const { return this->swapchainCount; }

  // The earliest times to present images
  void setTimes(const PresentTimeGOOGLE* value) { this->pTimes = std::bit_cast<const VkPresentTimeGOOGLE*>(value); }
  const PresentTimeGOOGLE* getTimes() const { return std::bit_cast<const PresentTimeGOOGLE*>(this->pTimes); }
};
inline void PresentInfoKHR::attach(PresentTimesInfoGOOGLE& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_GOOGLE_display_timing

#if VK_KHR_display_swapchain
struct DisplayPresentInfoKHR : VkDisplayPresentInfoKHR {
  DisplayPresentInfoKHR() noexcept : VkDisplayPresentInfoKHR{.sType = VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR} {}

  // Rectangle within the presentable image to read pixel data from when presenting to the display.
  void setSrcRect(const Rect2D& value) { this->srcRect = value; }
  const Rect2D& getSrcRect() const { return static_cast<const Rect2D&>(this->srcRect); }
  // Rectangle within the current display mode's visible region to display srcRectangle in.
  void setDstRect(const Rect2D& value) { this->dstRect = value; }
  const Rect2D& getDstRect() const { return static_cast<const Rect2D&>(this->dstRect); }

  // For smart displays, use buffered mode.  If the display properties member "persistentMode" is VK_FALSE, this member must always be VK_FALSE.
  void setPersistent(Bool32 value) { this->persistent = value; }
  Bool32 getPersistent() const { return this->persistent; }
};
inline void PresentInfoKHR::attach(DisplayPresentInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_display_swapchain

#if VK_GGP_frame_token
struct PresentFrameTokenGGP : VkPresentFrameTokenGGP {
  PresentFrameTokenGGP() noexcept : VkPresentFrameTokenGGP{.sType = VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP} {}

  void setFrameToken(GgpFrameToken value) { this->frameToken = value; }
  GgpFrameToken getFrameToken() const { return this->frameToken; }
};
inline void PresentInfoKHR::attach(PresentFrameTokenGGP& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_GGP_frame_token

#if VK_KHR_video_encode_h264
struct VideoEncodeH264SessionParametersGetInfoKHR : VkVideoEncodeH264SessionParametersGetInfoKHR {
  VideoEncodeH264SessionParametersGetInfoKHR() noexcept : VkVideoEncodeH264SessionParametersGetInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_GET_INFO_KHR} {}

  void setStdSPSId(uint32_t value) { this->stdSPSId = value; }
  uint32_t getStdSPSId() const { return this->stdSPSId; }
  void setStdPPSId(uint32_t value) { this->stdPPSId = value; }
  uint32_t getStdPPSId() const { return this->stdPPSId; }

  void setWriteStdSPS(Bool32 value) { this->writeStdSPS = value; }
  Bool32 getWriteStdSPS() const { return this->writeStdSPS; }
  void setWriteStdPPS(Bool32 value) { this->writeStdPPS = value; }
  Bool32 getWriteStdPPS() const { return this->writeStdPPS; }
};
#if VK_KHR_video_encode_queue
inline void VideoEncodeSessionParametersGetInfoKHR::attach(VideoEncodeH264SessionParametersGetInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_encode_queue
#endif // VK_KHR_video_encode_h264

#if VK_KHR_video_encode_h265
struct VideoEncodeH265SessionParametersGetInfoKHR : VkVideoEncodeH265SessionParametersGetInfoKHR {
  VideoEncodeH265SessionParametersGetInfoKHR() noexcept : VkVideoEncodeH265SessionParametersGetInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_GET_INFO_KHR} {}

  void setStdVPSId(uint32_t value) { this->stdVPSId = value; }
  uint32_t getStdVPSId() const { return this->stdVPSId; }
  void setStdSPSId(uint32_t value) { this->stdSPSId = value; }
  uint32_t getStdSPSId() const { return this->stdSPSId; }
  void setStdPPSId(uint32_t value) { this->stdPPSId = value; }
  uint32_t getStdPPSId() const { return this->stdPPSId; }

  void setWriteStdVPS(Bool32 value) { this->writeStdVPS = value; }
  Bool32 getWriteStdVPS() const { return this->writeStdVPS; }
  void setWriteStdSPS(Bool32 value) { this->writeStdSPS = value; }
  Bool32 getWriteStdSPS() const { return this->writeStdSPS; }
  void setWriteStdPPS(Bool32 value) { this->writeStdPPS = value; }
  Bool32 getWriteStdPPS() const { return this->writeStdPPS; }
};
#if VK_KHR_video_encode_queue
inline void VideoEncodeSessionParametersGetInfoKHR::attach(VideoEncodeH265SessionParametersGetInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_encode_queue
#endif // VK_KHR_video_encode_h265

#if VK_VERSION_1_1
struct QueueFamilyProperties2 : VkQueueFamilyProperties2 {
  QueueFamilyProperties2() noexcept : VkQueueFamilyProperties2{.sType = VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2} {}

  const QueueFamilyProperties& getQueueFamilyProperties() const { return static_cast<const QueueFamilyProperties&>(this->queueFamilyProperties); }

#if VK_KHR_maintenance9
  void attach(struct QueueFamilyOwnershipTransferPropertiesKHR&);
#endif // VK_KHR_maintenance9
#if VK_VERSION_1_4
  void attach(struct QueueFamilyGlobalPriorityProperties&);
#endif // VK_VERSION_1_4
#if VK_NV_device_diagnostic_checkpoints
  void attach(struct QueueFamilyCheckpointPropertiesNV&);
#endif // VK_NV_device_diagnostic_checkpoints
#if VK_KHR_video_queue
  void attach(struct QueueFamilyVideoPropertiesKHR&);
  void attach(struct QueueFamilyQueryResultStatusPropertiesKHR&);
#endif // VK_KHR_video_queue
};
#endif // VK_VERSION_1_1

#if VK_EXT_provoking_vertex
struct PipelineRasterizationProvokingVertexStateCreateInfoEXT : VkPipelineRasterizationProvokingVertexStateCreateInfoEXT {
  PipelineRasterizationProvokingVertexStateCreateInfoEXT() noexcept : VkPipelineRasterizationProvokingVertexStateCreateInfoEXT{.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT} {}

  void setProvokingVertexMode(ProvokingVertexModeEXT value) { this->provokingVertexMode = std::bit_cast<VkProvokingVertexModeEXT>(value); }
  ProvokingVertexModeEXT getProvokingVertexMode() const { return std::bit_cast<ProvokingVertexModeEXT>(this->provokingVertexMode); }
};
inline void PipelineRasterizationStateCreateInfo::attach(PipelineRasterizationProvokingVertexStateCreateInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_provoking_vertex

#if VK_EXT_depth_bias_control
struct DepthBiasRepresentationInfoEXT : VkDepthBiasRepresentationInfoEXT {
  DepthBiasRepresentationInfoEXT() noexcept : VkDepthBiasRepresentationInfoEXT{.sType = VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT} {}

  void setDepthBiasRepresentation(DepthBiasRepresentationEXT value) { this->depthBiasRepresentation = std::bit_cast<VkDepthBiasRepresentationEXT>(value); }
  DepthBiasRepresentationEXT getDepthBiasRepresentation() const { return std::bit_cast<DepthBiasRepresentationEXT>(this->depthBiasRepresentation); }

  void setDepthBiasExact(Bool32 value) { this->depthBiasExact = value; }
  Bool32 getDepthBiasExact() const { return this->depthBiasExact; }
};
inline void DepthBiasInfoEXT::attach(DepthBiasRepresentationInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void PipelineRasterizationStateCreateInfo::attach(DepthBiasRepresentationInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_depth_bias_control

#if VK_AMD_rasterization_order
struct PipelineRasterizationStateRasterizationOrderAMD : VkPipelineRasterizationStateRasterizationOrderAMD {
  PipelineRasterizationStateRasterizationOrderAMD() noexcept : VkPipelineRasterizationStateRasterizationOrderAMD{.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD} {}

  // Rasterization order to use for the pipeline
  void setRasterizationOrder(RasterizationOrderAMD value) { this->rasterizationOrder = std::bit_cast<VkRasterizationOrderAMD>(value); }
  RasterizationOrderAMD getRasterizationOrder() const { return std::bit_cast<RasterizationOrderAMD>(this->rasterizationOrder); }
};
inline void PipelineRasterizationStateCreateInfo::attach(PipelineRasterizationStateRasterizationOrderAMD& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_AMD_rasterization_order

#if VK_EXT_depth_clip_enable
struct PipelineRasterizationDepthClipStateCreateInfoEXT : VkPipelineRasterizationDepthClipStateCreateInfoEXT {
  PipelineRasterizationDepthClipStateCreateInfoEXT() noexcept : VkPipelineRasterizationDepthClipStateCreateInfoEXT{.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT} {}

  // Reserved
  void setFlags(PipelineRasterizationDepthClipStateCreateFlagsEXT value) { this->flags = std::bit_cast<VkPipelineRasterizationDepthClipStateCreateFlagsEXT>(value); }
  PipelineRasterizationDepthClipStateCreateFlagsEXT getFlags() const { return std::bit_cast<PipelineRasterizationDepthClipStateCreateFlagsEXT>(this->flags); }
  void setDepthClipEnable(Bool32 value) { this->depthClipEnable = value; }
  Bool32 getDepthClipEnable() const { return this->depthClipEnable; }
};
inline void PipelineRasterizationStateCreateInfo::attach(PipelineRasterizationDepthClipStateCreateInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_depth_clip_enable

#if VK_VERSION_1_4
struct PipelineRasterizationLineStateCreateInfo : VkPipelineRasterizationLineStateCreateInfo {
  PipelineRasterizationLineStateCreateInfo() noexcept : VkPipelineRasterizationLineStateCreateInfo{.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO} {}

  void setLineRasterizationMode(LineRasterizationMode value) { this->lineRasterizationMode = std::bit_cast<VkLineRasterizationMode>(value); }
  LineRasterizationMode getLineRasterizationMode() const { return std::bit_cast<LineRasterizationMode>(this->lineRasterizationMode); }
  void setLineStippleFactor(uint32_t value) { this->lineStippleFactor = value; }
  uint32_t getLineStippleFactor() const { return this->lineStippleFactor; }
  void setLineStipplePattern(uint16_t value) { this->lineStipplePattern = value; }
  uint16_t getLineStipplePattern() const { return this->lineStipplePattern; }

  void setStippledLineEnable(Bool32 value) { this->stippledLineEnable = value; }
  Bool32 getStippledLineEnable() const { return this->stippledLineEnable; }
};
inline void PipelineRasterizationStateCreateInfo::attach(PipelineRasterizationLineStateCreateInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_4

#if VK_EXT_conservative_rasterization
struct PipelineRasterizationConservativeStateCreateInfoEXT : VkPipelineRasterizationConservativeStateCreateInfoEXT {
  PipelineRasterizationConservativeStateCreateInfoEXT() noexcept : VkPipelineRasterizationConservativeStateCreateInfoEXT{.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT} {}

  // Conservative rasterization mode
  void setConservativeRasterizationMode(ConservativeRasterizationModeEXT value) { this->conservativeRasterizationMode = std::bit_cast<VkConservativeRasterizationModeEXT>(value); }
  ConservativeRasterizationModeEXT getConservativeRasterizationMode() const { return std::bit_cast<ConservativeRasterizationModeEXT>(this->conservativeRasterizationMode); }
  // Extra overestimation to add to the primitive
  void setExtraPrimitiveOverestimationSize(float value) { this->extraPrimitiveOverestimationSize = value; }
  float getExtraPrimitiveOverestimationSize() const { return this->extraPrimitiveOverestimationSize; }

  // Reserved
  void setFlags(PipelineRasterizationConservativeStateCreateFlagsEXT value) { this->flags = std::bit_cast<VkPipelineRasterizationConservativeStateCreateFlagsEXT>(value); }
  PipelineRasterizationConservativeStateCreateFlagsEXT getFlags() const { return std::bit_cast<PipelineRasterizationConservativeStateCreateFlagsEXT>(this->flags); }
};
inline void PipelineRasterizationStateCreateInfo::attach(PipelineRasterizationConservativeStateCreateInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_conservative_rasterization

#if VK_EXT_transform_feedback
struct PipelineRasterizationStateStreamCreateInfoEXT : VkPipelineRasterizationStateStreamCreateInfoEXT {
  PipelineRasterizationStateStreamCreateInfoEXT() noexcept : VkPipelineRasterizationStateStreamCreateInfoEXT{.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT} {}

  void setRasterizationStream(uint32_t value) { this->rasterizationStream = value; }
  uint32_t getRasterizationStream() const { return this->rasterizationStream; }

  void setFlags(PipelineRasterizationStateStreamCreateFlagsEXT value) { this->flags = std::bit_cast<VkPipelineRasterizationStateStreamCreateFlagsEXT>(value); }
  PipelineRasterizationStateStreamCreateFlagsEXT getFlags() const { return std::bit_cast<PipelineRasterizationStateStreamCreateFlagsEXT>(this->flags); }
};
inline void PipelineRasterizationStateCreateInfo::attach(PipelineRasterizationStateStreamCreateInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_transform_feedback

#if VK_VERSION_1_4
struct DeviceQueueGlobalPriorityCreateInfo : VkDeviceQueueGlobalPriorityCreateInfo {
  DeviceQueueGlobalPriorityCreateInfo() noexcept : VkDeviceQueueGlobalPriorityCreateInfo{.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO} {}

  void setGlobalPriority(QueueGlobalPriority value) { this->globalPriority = std::bit_cast<VkQueueGlobalPriority>(value); }
  QueueGlobalPriority getGlobalPriority() const { return std::bit_cast<QueueGlobalPriority>(this->globalPriority); }
};
inline void DeviceQueueCreateInfo::attach(DeviceQueueGlobalPriorityCreateInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_4

#if VK_VERSION_1_0
struct DeviceCreateInfo : VkDeviceCreateInfo {
  DeviceCreateInfo() noexcept : VkDeviceCreateInfo{.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO} {}

  void setFlags(DeviceCreateFlags value) { this->flags = std::bit_cast<VkDeviceCreateFlags>(value); }
  DeviceCreateFlags getFlags() const { return std::bit_cast<DeviceCreateFlags>(this->flags); }
  void setQueueCreateInfoCount(uint32_t value) { this->queueCreateInfoCount = value; }
  uint32_t getQueueCreateInfoCount() const { return this->queueCreateInfoCount; }
  void setQueueCreateInfos(const DeviceQueueCreateInfo* value) { this->pQueueCreateInfos = std::bit_cast<const VkDeviceQueueCreateInfo*>(value); }
  const DeviceQueueCreateInfo* getQueueCreateInfos() const { return std::bit_cast<const DeviceQueueCreateInfo*>(this->pQueueCreateInfos); }
  void setEnabledExtensionCount(uint32_t value) { this->enabledExtensionCount = value; }
  uint32_t getEnabledExtensionCount() const { return this->enabledExtensionCount; }
  void setEnabledExtensionNames(const char* const* value) { this->ppEnabledExtensionNames = value; }
  const char* const* getEnabledExtensionNames() const { return this->ppEnabledExtensionNames; }
  void setEnabledFeatures(const PhysicalDeviceFeatures* value) { this->pEnabledFeatures = std::bit_cast<const VkPhysicalDeviceFeatures*>(value); }
  const PhysicalDeviceFeatures* getEnabledFeatures() const { return std::bit_cast<const PhysicalDeviceFeatures*>(this->pEnabledFeatures); }

#if VK_NV_device_generated_commands
  void attach(struct PhysicalDeviceDeviceGeneratedCommandsFeaturesNV&);
#endif // VK_NV_device_generated_commands
#if VK_NV_device_generated_commands_compute
  void attach(struct PhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV&);
#endif // VK_NV_device_generated_commands_compute
#if VK_VERSION_1_3
  void attach(struct DevicePrivateDataCreateInfo&);
  void attach(struct PhysicalDevicePrivateDataFeatures&);
#endif // VK_VERSION_1_3
#if VK_NV_cluster_acceleration_structure
  void attach(struct PhysicalDeviceClusterAccelerationStructureFeaturesNV&);
#endif // VK_NV_cluster_acceleration_structure
#if VK_VERSION_1_1
  void attachHead(struct PhysicalDeviceFeatures2&);
  void attach(struct PhysicalDeviceVariablePointersFeatures&);
  void attach(struct PhysicalDeviceMultiviewFeatures&);
  void attach(struct DeviceGroupDeviceCreateInfo&);
#endif // VK_VERSION_1_1
#if VK_KHR_present_id
  void attach(struct PhysicalDevicePresentIdFeaturesKHR&);
#endif // VK_KHR_present_id
#if VK_KHR_present_id2
  void attach(struct PhysicalDevicePresentId2FeaturesKHR&);
#endif // VK_KHR_present_id2
#if VK_KHR_present_wait
  void attach(struct PhysicalDevicePresentWaitFeaturesKHR&);
#endif // VK_KHR_present_wait
#if VK_KHR_present_wait2
  void attach(struct PhysicalDevicePresentWait2FeaturesKHR&);
#endif // VK_KHR_present_wait2
#if VK_VERSION_1_1
  void attach(struct PhysicalDevice16BitStorageFeatures&);
#endif // VK_VERSION_1_1
#if VK_VERSION_1_2
  void attach(struct PhysicalDeviceShaderSubgroupExtendedTypesFeatures&);
#endif // VK_VERSION_1_2
#if VK_VERSION_1_1
  void attach(struct PhysicalDeviceSamplerYcbcrConversionFeatures&);
  void attach(struct PhysicalDeviceProtectedMemoryFeatures&);
#endif // VK_VERSION_1_1
#if VK_EXT_blend_operation_advanced
  void attach(struct PhysicalDeviceBlendOperationAdvancedFeaturesEXT&);
#endif // VK_EXT_blend_operation_advanced
#if VK_EXT_multi_draw
  void attach(struct PhysicalDeviceMultiDrawFeaturesEXT&);
#endif // VK_EXT_multi_draw
#if VK_VERSION_1_3
  void attach(struct PhysicalDeviceInlineUniformBlockFeatures&);
  void attach(struct PhysicalDeviceMaintenance4Features&);
#endif // VK_VERSION_1_3
#if VK_VERSION_1_4
  void attach(struct PhysicalDeviceMaintenance5Features&);
  void attach(struct PhysicalDeviceMaintenance6Features&);
#endif // VK_VERSION_1_4
#if VK_KHR_maintenance7
  void attach(struct PhysicalDeviceMaintenance7FeaturesKHR&);
#endif // VK_KHR_maintenance7
#if VK_KHR_maintenance8
  void attach(struct PhysicalDeviceMaintenance8FeaturesKHR&);
#endif // VK_KHR_maintenance8
#if VK_KHR_maintenance9
  void attach(struct PhysicalDeviceMaintenance9FeaturesKHR&);
#endif // VK_KHR_maintenance9
#if VK_VERSION_1_1
  void attach(struct PhysicalDeviceShaderDrawParametersFeatures&);
#endif // VK_VERSION_1_1
#if VK_VERSION_1_2
  void attach(struct PhysicalDeviceShaderFloat16Int8Features&);
  void attach(struct PhysicalDeviceHostQueryResetFeatures&);
#endif // VK_VERSION_1_2
#if VK_VERSION_1_4
  void attach(struct PhysicalDeviceGlobalPriorityQueryFeatures&);
#endif // VK_VERSION_1_4
#if VK_EXT_device_memory_report
  void attach(struct PhysicalDeviceDeviceMemoryReportFeaturesEXT&);
  void attach(struct DeviceDeviceMemoryReportCreateInfoEXT&);
#endif // VK_EXT_device_memory_report
#if VK_VERSION_1_2
  void attach(struct PhysicalDeviceDescriptorIndexingFeatures&);
  void attach(struct PhysicalDeviceTimelineSemaphoreFeatures&);
  void attach(struct PhysicalDevice8BitStorageFeatures&);
#endif // VK_VERSION_1_2
#if VK_EXT_conditional_rendering
  void attach(struct PhysicalDeviceConditionalRenderingFeaturesEXT&);
#endif // VK_EXT_conditional_rendering
#if VK_VERSION_1_2
  void attach(struct PhysicalDeviceVulkanMemoryModelFeatures&);
  void attach(struct PhysicalDeviceShaderAtomicInt64Features&);
#endif // VK_VERSION_1_2
#if VK_EXT_shader_atomic_float
  void attach(struct PhysicalDeviceShaderAtomicFloatFeaturesEXT&);
#endif // VK_EXT_shader_atomic_float
#if VK_EXT_shader_atomic_float2
  void attach(struct PhysicalDeviceShaderAtomicFloat2FeaturesEXT&);
#endif // VK_EXT_shader_atomic_float2
#if VK_VERSION_1_4
  void attach(struct PhysicalDeviceVertexAttributeDivisorFeatures&);
#endif // VK_VERSION_1_4
#if VK_EXT_astc_decode_mode
  void attach(struct PhysicalDeviceASTCDecodeFeaturesEXT&);
#endif // VK_EXT_astc_decode_mode
#if VK_EXT_transform_feedback
  void attach(struct PhysicalDeviceTransformFeedbackFeaturesEXT&);
#endif // VK_EXT_transform_feedback
#if VK_NV_representative_fragment_test
  void attach(struct PhysicalDeviceRepresentativeFragmentTestFeaturesNV&);
#endif // VK_NV_representative_fragment_test
#if VK_NV_scissor_exclusive
  void attach(struct PhysicalDeviceExclusiveScissorFeaturesNV&);
#endif // VK_NV_scissor_exclusive
#if VK_NV_corner_sampled_image
  void attach(struct PhysicalDeviceCornerSampledImageFeaturesNV&);
#endif // VK_NV_corner_sampled_image
#if VK_KHR_compute_shader_derivatives
  void attach(struct PhysicalDeviceComputeShaderDerivativesFeaturesKHR&);
#endif // VK_KHR_compute_shader_derivatives
#if VK_NV_shader_image_footprint
  void attach(struct PhysicalDeviceShaderImageFootprintFeaturesNV&);
#endif // VK_NV_shader_image_footprint
#if VK_NV_dedicated_allocation_image_aliasing
  void attach(struct PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV&);
#endif // VK_NV_dedicated_allocation_image_aliasing
#if VK_NV_copy_memory_indirect
  void attach(struct PhysicalDeviceCopyMemoryIndirectFeaturesNV&);
#endif // VK_NV_copy_memory_indirect
#if VK_NV_memory_decompression
  void attach(struct PhysicalDeviceMemoryDecompressionFeaturesNV&);
#endif // VK_NV_memory_decompression
#if VK_NV_shading_rate_image
  void attach(struct PhysicalDeviceShadingRateImageFeaturesNV&);
#endif // VK_NV_shading_rate_image
#if VK_HUAWEI_invocation_mask
  void attach(struct PhysicalDeviceInvocationMaskFeaturesHUAWEI&);
#endif // VK_HUAWEI_invocation_mask
#if VK_NV_mesh_shader
  void attach(struct PhysicalDeviceMeshShaderFeaturesNV&);
#endif // VK_NV_mesh_shader
#if VK_EXT_mesh_shader
  void attach(struct PhysicalDeviceMeshShaderFeaturesEXT&);
#endif // VK_EXT_mesh_shader
#if VK_KHR_acceleration_structure
  void attach(struct PhysicalDeviceAccelerationStructureFeaturesKHR&);
#endif // VK_KHR_acceleration_structure
#if VK_KHR_ray_tracing_pipeline
  void attach(struct PhysicalDeviceRayTracingPipelineFeaturesKHR&);
#endif // VK_KHR_ray_tracing_pipeline
#if VK_KHR_ray_query
  void attach(struct PhysicalDeviceRayQueryFeaturesKHR&);
#endif // VK_KHR_ray_query
#if VK_KHR_ray_tracing_maintenance1
  void attach(struct PhysicalDeviceRayTracingMaintenance1FeaturesKHR&);
#endif // VK_KHR_ray_tracing_maintenance1
#if VK_AMD_memory_overallocation_behavior
  void attach(struct DeviceMemoryOverallocationCreateInfoAMD&);
#endif // VK_AMD_memory_overallocation_behavior
#if VK_EXT_fragment_density_map
  void attach(struct PhysicalDeviceFragmentDensityMapFeaturesEXT&);
#endif // VK_EXT_fragment_density_map
#if VK_EXT_fragment_density_map2
  void attach(struct PhysicalDeviceFragmentDensityMap2FeaturesEXT&);
#endif // VK_EXT_fragment_density_map2
#if VK_EXT_fragment_density_map_offset
  void attach(struct PhysicalDeviceFragmentDensityMapOffsetFeaturesEXT&);
#endif // VK_EXT_fragment_density_map_offset
#if VK_VERSION_1_2
  void attach(struct PhysicalDeviceScalarBlockLayoutFeatures&);
  void attach(struct PhysicalDeviceUniformBufferStandardLayoutFeatures&);
#endif // VK_VERSION_1_2
#if VK_EXT_depth_clip_enable
  void attach(struct PhysicalDeviceDepthClipEnableFeaturesEXT&);
#endif // VK_EXT_depth_clip_enable
#if VK_EXT_memory_priority
  void attach(struct PhysicalDeviceMemoryPriorityFeaturesEXT&);
#endif // VK_EXT_memory_priority
#if VK_EXT_pageable_device_local_memory
  void attach(struct PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT&);
#endif // VK_EXT_pageable_device_local_memory
#if VK_VERSION_1_2
  void attach(struct PhysicalDeviceBufferDeviceAddressFeatures&);
  void attach(struct PhysicalDeviceImagelessFramebufferFeatures&);
#endif // VK_VERSION_1_2
#if VK_VERSION_1_3
  void attach(struct PhysicalDeviceTextureCompressionASTCHDRFeatures&);
#endif // VK_VERSION_1_3
#if VK_NV_cooperative_matrix
  void attach(struct PhysicalDeviceCooperativeMatrixFeaturesNV&);
#endif // VK_NV_cooperative_matrix
#if VK_EXT_ycbcr_image_arrays
  void attach(struct PhysicalDeviceYcbcrImageArraysFeaturesEXT&);
#endif // VK_EXT_ycbcr_image_arrays
#if VK_NV_present_barrier
  void attach(struct PhysicalDevicePresentBarrierFeaturesNV&);
#endif // VK_NV_present_barrier
#if VK_KHR_performance_query
  void attach(struct PhysicalDevicePerformanceQueryFeaturesKHR&);
#endif // VK_KHR_performance_query
#if VK_NV_coverage_reduction_mode
  void attach(struct PhysicalDeviceCoverageReductionModeFeaturesNV&);
#endif // VK_NV_coverage_reduction_mode
#if VK_INTEL_shader_integer_functions2
  void attach(struct PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL&);
#endif // VK_INTEL_shader_integer_functions2
#if VK_KHR_shader_clock
  void attach(struct PhysicalDeviceShaderClockFeaturesKHR&);
#endif // VK_KHR_shader_clock
#if VK_VERSION_1_4
  void attach(struct PhysicalDeviceIndexTypeUint8Features&);
#endif // VK_VERSION_1_4
#if VK_NV_shader_sm_builtins
  void attach(struct PhysicalDeviceShaderSMBuiltinsFeaturesNV&);
#endif // VK_NV_shader_sm_builtins
#if VK_EXT_fragment_shader_interlock
  void attach(struct PhysicalDeviceFragmentShaderInterlockFeaturesEXT&);
#endif // VK_EXT_fragment_shader_interlock
#if VK_VERSION_1_2
  void attach(struct PhysicalDeviceSeparateDepthStencilLayoutsFeatures&);
#endif // VK_VERSION_1_2
#if VK_EXT_primitive_topology_list_restart
  void attach(struct PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT&);
#endif // VK_EXT_primitive_topology_list_restart
#if VK_KHR_pipeline_executable_properties
  void attach(struct PhysicalDevicePipelineExecutablePropertiesFeaturesKHR&);
#endif // VK_KHR_pipeline_executable_properties
#if VK_VERSION_1_3
  void attach(struct PhysicalDeviceShaderDemoteToHelperInvocationFeatures&);
#endif // VK_VERSION_1_3
#if VK_EXT_texel_buffer_alignment
  void attach(struct PhysicalDeviceTexelBufferAlignmentFeaturesEXT&);
#endif // VK_EXT_texel_buffer_alignment
#if VK_VERSION_1_3
  void attach(struct PhysicalDeviceSubgroupSizeControlFeatures&);
#endif // VK_VERSION_1_3
#if VK_VERSION_1_4
  void attach(struct PhysicalDeviceLineRasterizationFeatures&);
#endif // VK_VERSION_1_4
#if VK_VERSION_1_3
  void attach(struct PhysicalDevicePipelineCreationCacheControlFeatures&);
#endif // VK_VERSION_1_3
#if VK_VERSION_1_2
  void attach(struct PhysicalDeviceVulkan11Features&);
  void attach(struct PhysicalDeviceVulkan12Features&);
#endif // VK_VERSION_1_2
#if VK_VERSION_1_3
  void attach(struct PhysicalDeviceVulkan13Features&);
#endif // VK_VERSION_1_3
#if VK_VERSION_1_4
  void attach(struct PhysicalDeviceVulkan14Features&);
#endif // VK_VERSION_1_4
#if VK_AMD_device_coherent_memory
  void attach(struct PhysicalDeviceCoherentMemoryFeaturesAMD&);
#endif // VK_AMD_device_coherent_memory
#if VK_EXT_custom_border_color
  void attach(struct PhysicalDeviceCustomBorderColorFeaturesEXT&);
#endif // VK_EXT_custom_border_color
#if VK_EXT_border_color_swizzle
  void attach(struct PhysicalDeviceBorderColorSwizzleFeaturesEXT&);
#endif // VK_EXT_border_color_swizzle
#if VK_EXT_extended_dynamic_state
  void attach(struct PhysicalDeviceExtendedDynamicStateFeaturesEXT&);
#endif // VK_EXT_extended_dynamic_state
#if VK_EXT_extended_dynamic_state2
  void attach(struct PhysicalDeviceExtendedDynamicState2FeaturesEXT&);
#endif // VK_EXT_extended_dynamic_state2
#if VK_EXT_extended_dynamic_state3
  void attach(struct PhysicalDeviceExtendedDynamicState3FeaturesEXT&);
#endif // VK_EXT_extended_dynamic_state3
#if VK_NV_partitioned_acceleration_structure
  void attach(struct PhysicalDevicePartitionedAccelerationStructureFeaturesNV&);
#endif // VK_NV_partitioned_acceleration_structure
#if VK_NV_device_diagnostics_config
  void attach(struct PhysicalDeviceDiagnosticsConfigFeaturesNV&);
  void attach(struct DeviceDiagnosticsConfigCreateInfoNV&);
#endif // VK_NV_device_diagnostics_config
#if VK_VERSION_1_3
  void attach(struct PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures&);
#endif // VK_VERSION_1_3
#if VK_KHR_shader_subgroup_uniform_control_flow
  void attach(struct PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR&);
#endif // VK_KHR_shader_subgroup_uniform_control_flow
#if VK_KHR_robustness2
  void attach(struct PhysicalDeviceRobustness2FeaturesKHR&);
#endif // VK_KHR_robustness2
#if VK_VERSION_1_3
  void attach(struct PhysicalDeviceImageRobustnessFeatures&);
#endif // VK_VERSION_1_3
#if VK_KHR_workgroup_memory_explicit_layout
  void attach(struct PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR&);
#endif // VK_KHR_workgroup_memory_explicit_layout
#if VK_EXT_4444_formats
  void attach(struct PhysicalDevice4444FormatsFeaturesEXT&);
#endif // VK_EXT_4444_formats
#if VK_HUAWEI_subpass_shading
  void attach(struct PhysicalDeviceSubpassShadingFeaturesHUAWEI&);
#endif // VK_HUAWEI_subpass_shading
#if VK_HUAWEI_cluster_culling_shader
  void attachHead(struct PhysicalDeviceClusterCullingShaderFeaturesHUAWEI&);
#endif // VK_HUAWEI_cluster_culling_shader
#if VK_EXT_shader_image_atomic_int64
  void attach(struct PhysicalDeviceShaderImageAtomicInt64FeaturesEXT&);
#endif // VK_EXT_shader_image_atomic_int64
#if VK_KHR_fragment_shading_rate
  void attach(struct PhysicalDeviceFragmentShadingRateFeaturesKHR&);
#endif // VK_KHR_fragment_shading_rate
#if VK_VERSION_1_3
  void attach(struct PhysicalDeviceShaderTerminateInvocationFeatures&);
#endif // VK_VERSION_1_3
#if VK_NV_fragment_shading_rate_enums
  void attach(struct PhysicalDeviceFragmentShadingRateEnumsFeaturesNV&);
#endif // VK_NV_fragment_shading_rate_enums
#if VK_EXT_image_2d_view_of_3d
  void attach(struct PhysicalDeviceImage2DViewOf3DFeaturesEXT&);
#endif // VK_EXT_image_2d_view_of_3d
#if VK_EXT_image_sliced_view_of_3d
  void attach(struct PhysicalDeviceImageSlicedViewOf3DFeaturesEXT&);
#endif // VK_EXT_image_sliced_view_of_3d
#if VK_EXT_attachment_feedback_loop_dynamic_state
  void attach(struct PhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT&);
#endif // VK_EXT_attachment_feedback_loop_dynamic_state
#if VK_EXT_legacy_vertex_attributes
  void attach(struct PhysicalDeviceLegacyVertexAttributesFeaturesEXT&);
#endif // VK_EXT_legacy_vertex_attributes
#if VK_EXT_mutable_descriptor_type
  void attach(struct PhysicalDeviceMutableDescriptorTypeFeaturesEXT&);
#endif // VK_EXT_mutable_descriptor_type
#if VK_EXT_depth_clip_control
  void attach(struct PhysicalDeviceDepthClipControlFeaturesEXT&);
#endif // VK_EXT_depth_clip_control
#if VK_EXT_zero_initialize_device_memory
  void attach(struct PhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT&);
#endif // VK_EXT_zero_initialize_device_memory
#if VK_EXT_device_generated_commands
  void attach(struct PhysicalDeviceDeviceGeneratedCommandsFeaturesEXT&);
#endif // VK_EXT_device_generated_commands
#if VK_EXT_depth_clamp_control
  void attach(struct PhysicalDeviceDepthClampControlFeaturesEXT&);
#endif // VK_EXT_depth_clamp_control
#if VK_EXT_vertex_input_dynamic_state
  void attach(struct PhysicalDeviceVertexInputDynamicStateFeaturesEXT&);
#endif // VK_EXT_vertex_input_dynamic_state
#if VK_NV_external_memory_rdma
  void attach(struct PhysicalDeviceExternalMemoryRDMAFeaturesNV&);
#endif // VK_NV_external_memory_rdma
#if VK_KHR_shader_relaxed_extended_instruction
  void attach(struct PhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR&);
#endif // VK_KHR_shader_relaxed_extended_instruction
#if VK_EXT_color_write_enable
  void attach(struct PhysicalDeviceColorWriteEnableFeaturesEXT&);
#endif // VK_EXT_color_write_enable
#if VK_VERSION_1_3
  void attach(struct PhysicalDeviceSynchronization2Features&);
#endif // VK_VERSION_1_3
#if VK_KHR_unified_image_layouts
  void attach(struct PhysicalDeviceUnifiedImageLayoutsFeaturesKHR&);
#endif // VK_KHR_unified_image_layouts
#if VK_VERSION_1_4
  void attach(struct PhysicalDeviceHostImageCopyFeatures&);
#endif // VK_VERSION_1_4
#if VK_EXT_primitives_generated_query
  void attach(struct PhysicalDevicePrimitivesGeneratedQueryFeaturesEXT&);
#endif // VK_EXT_primitives_generated_query
#if VK_EXT_legacy_dithering
  void attach(struct PhysicalDeviceLegacyDitheringFeaturesEXT&);
#endif // VK_EXT_legacy_dithering
#if VK_EXT_multisampled_render_to_single_sampled
  void attach(struct PhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT&);
#endif // VK_EXT_multisampled_render_to_single_sampled
#if VK_VERSION_1_4
  void attach(struct PhysicalDevicePipelineProtectedAccessFeatures&);
#endif // VK_VERSION_1_4
#if VK_KHR_video_maintenance1
  void attach(struct PhysicalDeviceVideoMaintenance1FeaturesKHR&);
#endif // VK_KHR_video_maintenance1
#if VK_KHR_video_maintenance2
  void attach(struct PhysicalDeviceVideoMaintenance2FeaturesKHR&);
#endif // VK_KHR_video_maintenance2
#if VK_KHR_video_decode_vp9
  void attach(struct PhysicalDeviceVideoDecodeVP9FeaturesKHR&);
#endif // VK_KHR_video_decode_vp9
#if VK_KHR_video_encode_quantization_map
  void attach(struct PhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR&);
#endif // VK_KHR_video_encode_quantization_map
#if VK_KHR_video_encode_av1
  void attach(struct PhysicalDeviceVideoEncodeAV1FeaturesKHR&);
#endif // VK_KHR_video_encode_av1
#if VK_NV_inherited_viewport_scissor
  void attach(struct PhysicalDeviceInheritedViewportScissorFeaturesNV&);
#endif // VK_NV_inherited_viewport_scissor
#if VK_EXT_ycbcr_2plane_444_formats
  void attach(struct PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT&);
#endif // VK_EXT_ycbcr_2plane_444_formats
#if VK_EXT_provoking_vertex
  void attach(struct PhysicalDeviceProvokingVertexFeaturesEXT&);
#endif // VK_EXT_provoking_vertex
#if VK_KHR_video_encode_intra_refresh
  void attach(struct PhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR&);
#endif // VK_KHR_video_encode_intra_refresh
#if VK_EXT_descriptor_buffer
  void attach(struct PhysicalDeviceDescriptorBufferFeaturesEXT&);
#endif // VK_EXT_descriptor_buffer
#if VK_VERSION_1_3
  void attach(struct PhysicalDeviceShaderIntegerDotProductFeatures&);
#endif // VK_VERSION_1_3
#if VK_KHR_fragment_shader_barycentric
  void attach(struct PhysicalDeviceFragmentShaderBarycentricFeaturesKHR&);
#endif // VK_KHR_fragment_shader_barycentric
#if VK_NV_ray_tracing_motion_blur
  void attach(struct PhysicalDeviceRayTracingMotionBlurFeaturesNV&);
#endif // VK_NV_ray_tracing_motion_blur
#if VK_NV_ray_tracing_validation
  void attach(struct PhysicalDeviceRayTracingValidationFeaturesNV&);
#endif // VK_NV_ray_tracing_validation
#if VK_NV_ray_tracing_linear_swept_spheres
  void attach(struct PhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV&);
#endif // VK_NV_ray_tracing_linear_swept_spheres
#if VK_EXT_rgba10x6_formats
  void attach(struct PhysicalDeviceRGBA10X6FormatsFeaturesEXT&);
#endif // VK_EXT_rgba10x6_formats
#if VK_VERSION_1_3
  void attach(struct PhysicalDeviceDynamicRenderingFeatures&);
#endif // VK_VERSION_1_3
#if VK_EXT_image_view_min_lod
  void attach(struct PhysicalDeviceImageViewMinLodFeaturesEXT&);
#endif // VK_EXT_image_view_min_lod
#if VK_EXT_rasterization_order_attachment_access
  void attach(struct PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT&);
#endif // VK_EXT_rasterization_order_attachment_access
#if VK_NV_linear_color_attachment
  void attach(struct PhysicalDeviceLinearColorAttachmentFeaturesNV&);
#endif // VK_NV_linear_color_attachment
#if VK_EXT_graphics_pipeline_library
  void attach(struct PhysicalDeviceGraphicsPipelineLibraryFeaturesEXT&);
#endif // VK_EXT_graphics_pipeline_library
#if VK_KHR_pipeline_binary
  void attach(struct PhysicalDevicePipelineBinaryFeaturesKHR&);
  void attach(struct DevicePipelineBinaryInternalCacheControlKHR&);
#endif // VK_KHR_pipeline_binary
#if VK_VALVE_descriptor_set_host_mapping
  void attach(struct PhysicalDeviceDescriptorSetHostMappingFeaturesVALVE&);
#endif // VK_VALVE_descriptor_set_host_mapping
#if VK_EXT_nested_command_buffer
  void attach(struct PhysicalDeviceNestedCommandBufferFeaturesEXT&);
#endif // VK_EXT_nested_command_buffer
#if VK_EXT_shader_module_identifier
  void attach(struct PhysicalDeviceShaderModuleIdentifierFeaturesEXT&);
#endif // VK_EXT_shader_module_identifier
#if VK_EXT_image_compression_control
  void attach(struct PhysicalDeviceImageCompressionControlFeaturesEXT&);
#endif // VK_EXT_image_compression_control
#if VK_EXT_image_compression_control_swapchain
  void attach(struct PhysicalDeviceImageCompressionControlSwapchainFeaturesEXT&);
#endif // VK_EXT_image_compression_control_swapchain
#if VK_EXT_subpass_merge_feedback
  void attach(struct PhysicalDeviceSubpassMergeFeedbackFeaturesEXT&);
#endif // VK_EXT_subpass_merge_feedback
#if VK_EXT_opacity_micromap
  void attach(struct PhysicalDeviceOpacityMicromapFeaturesEXT&);
#endif // VK_EXT_opacity_micromap
#if VK_EXT_pipeline_properties
  void attach(struct PhysicalDevicePipelinePropertiesFeaturesEXT&);
#endif // VK_EXT_pipeline_properties
#if VK_AMD_shader_early_and_late_fragment_tests
  void attach(struct PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD&);
#endif // VK_AMD_shader_early_and_late_fragment_tests
#if VK_EXT_non_seamless_cube_map
  void attach(struct PhysicalDeviceNonSeamlessCubeMapFeaturesEXT&);
#endif // VK_EXT_non_seamless_cube_map
#if VK_VERSION_1_4
  void attach(struct PhysicalDevicePipelineRobustnessFeatures&);
#endif // VK_VERSION_1_4
#if VK_QCOM_image_processing
  void attach(struct PhysicalDeviceImageProcessingFeaturesQCOM&);
#endif // VK_QCOM_image_processing
#if VK_QCOM_tile_properties
  void attach(struct PhysicalDeviceTilePropertiesFeaturesQCOM&);
#endif // VK_QCOM_tile_properties
#if VK_SEC_amigo_profiling
  void attach(struct PhysicalDeviceAmigoProfilingFeaturesSEC&);
#endif // VK_SEC_amigo_profiling
#if VK_EXT_attachment_feedback_loop_layout
  void attach(struct PhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT&);
#endif // VK_EXT_attachment_feedback_loop_layout
#if VK_EXT_device_address_binding_report
  void attach(struct PhysicalDeviceAddressBindingReportFeaturesEXT&);
#endif // VK_EXT_device_address_binding_report
#if VK_NV_optical_flow
  void attach(struct PhysicalDeviceOpticalFlowFeaturesNV&);
#endif // VK_NV_optical_flow
#if VK_EXT_device_fault
  void attach(struct PhysicalDeviceFaultFeaturesEXT&);
#endif // VK_EXT_device_fault
#if VK_EXT_pipeline_library_group_handles
  void attach(struct PhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT&);
#endif // VK_EXT_pipeline_library_group_handles
#if VK_ARM_shader_core_builtins
  void attach(struct PhysicalDeviceShaderCoreBuiltinsFeaturesARM&);
#endif // VK_ARM_shader_core_builtins
#if VK_EXT_frame_boundary
  void attach(struct PhysicalDeviceFrameBoundaryFeaturesEXT&);
#endif // VK_EXT_frame_boundary
#if VK_EXT_dynamic_rendering_unused_attachments
  void attach(struct PhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT&);
#endif // VK_EXT_dynamic_rendering_unused_attachments
#if VK_KHR_swapchain_maintenance1
  void attach(struct PhysicalDeviceSwapchainMaintenance1FeaturesKHR&);
#endif // VK_KHR_swapchain_maintenance1
#if VK_EXT_depth_bias_control
  void attach(struct PhysicalDeviceDepthBiasControlFeaturesEXT&);
#endif // VK_EXT_depth_bias_control
#if VK_NV_ray_tracing_invocation_reorder
  void attach(struct PhysicalDeviceRayTracingInvocationReorderFeaturesNV&);
#endif // VK_NV_ray_tracing_invocation_reorder
#if VK_NV_extended_sparse_address_space
  void attach(struct PhysicalDeviceExtendedSparseAddressSpaceFeaturesNV&);
#endif // VK_NV_extended_sparse_address_space
#if VK_QCOM_multiview_per_view_viewports
  void attach(struct PhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM&);
#endif // VK_QCOM_multiview_per_view_viewports
#if VK_KHR_ray_tracing_position_fetch
  void attach(struct PhysicalDeviceRayTracingPositionFetchFeaturesKHR&);
#endif // VK_KHR_ray_tracing_position_fetch
#if VK_QCOM_multiview_per_view_render_areas
  void attach(struct PhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM&);
#endif // VK_QCOM_multiview_per_view_render_areas
#if VK_EXT_shader_object
  void attach(struct PhysicalDeviceShaderObjectFeaturesEXT&);
#endif // VK_EXT_shader_object
#if VK_EXT_shader_tile_image
  void attach(struct PhysicalDeviceShaderTileImageFeaturesEXT&);
#endif // VK_EXT_shader_tile_image
#if VK_QNX_external_memory_screen_buffer
  void attach(struct PhysicalDeviceExternalMemoryScreenBufferFeaturesQNX&);
#endif // VK_QNX_external_memory_screen_buffer
#if VK_KHR_cooperative_matrix
  void attach(struct PhysicalDeviceCooperativeMatrixFeaturesKHR&);
#endif // VK_KHR_cooperative_matrix
#if VK_AMD_anti_lag
  void attach(struct PhysicalDeviceAntiLagFeaturesAMD&);
#endif // VK_AMD_anti_lag
#if VK_QCOM_tile_memory_heap
  void attach(struct PhysicalDeviceTileMemoryHeapFeaturesQCOM&);
#endif // VK_QCOM_tile_memory_heap
#if VK_QCOM_filter_cubic_clamp
  void attach(struct PhysicalDeviceCubicClampFeaturesQCOM&);
#endif // VK_QCOM_filter_cubic_clamp
#if VK_QCOM_ycbcr_degamma
  void attach(struct PhysicalDeviceYcbcrDegammaFeaturesQCOM&);
#endif // VK_QCOM_ycbcr_degamma
#if VK_QCOM_filter_cubic_weights
  void attach(struct PhysicalDeviceCubicWeightsFeaturesQCOM&);
#endif // VK_QCOM_filter_cubic_weights
#if VK_QCOM_image_processing2
  void attach(struct PhysicalDeviceImageProcessing2FeaturesQCOM&);
#endif // VK_QCOM_image_processing2
#if VK_NV_descriptor_pool_overallocation
  void attach(struct PhysicalDeviceDescriptorPoolOverallocationFeaturesNV&);
#endif // VK_NV_descriptor_pool_overallocation
#if VK_NV_per_stage_descriptor_set
  void attach(struct PhysicalDevicePerStageDescriptorSetFeaturesNV&);
#endif // VK_NV_per_stage_descriptor_set
#if VK_ANDROID_external_format_resolve
  void attach(struct PhysicalDeviceExternalFormatResolveFeaturesANDROID&);
#endif // VK_ANDROID_external_format_resolve
#if VK_ARM_scheduling_controls
  void attach(struct DeviceQueueShaderCoreControlCreateInfoARM&);
  void attach(struct PhysicalDeviceSchedulingControlsFeaturesARM&);
#endif // VK_ARM_scheduling_controls
#if VK_IMG_relaxed_line_rasterization
  void attach(struct PhysicalDeviceRelaxedLineRasterizationFeaturesIMG&);
#endif // VK_IMG_relaxed_line_rasterization
#if VK_ARM_render_pass_striped
  void attach(struct PhysicalDeviceRenderPassStripedFeaturesARM&);
#endif // VK_ARM_render_pass_striped
#if VK_ARM_pipeline_opacity_micromap
  void attach(struct PhysicalDevicePipelineOpacityMicromapFeaturesARM&);
#endif // VK_ARM_pipeline_opacity_micromap
#if VK_KHR_shader_maximal_reconvergence
  void attach(struct PhysicalDeviceShaderMaximalReconvergenceFeaturesKHR&);
#endif // VK_KHR_shader_maximal_reconvergence
#if VK_VERSION_1_4
  void attach(struct PhysicalDeviceShaderSubgroupRotateFeatures&);
  void attach(struct PhysicalDeviceShaderExpectAssumeFeatures&);
  void attach(struct PhysicalDeviceShaderFloatControls2Features&);
  void attach(struct PhysicalDeviceDynamicRenderingLocalReadFeatures&);
#endif // VK_VERSION_1_4
#if VK_KHR_shader_quad_control
  void attach(struct PhysicalDeviceShaderQuadControlFeaturesKHR&);
#endif // VK_KHR_shader_quad_control
#if VK_NV_shader_atomic_float16_vector
  void attach(struct PhysicalDeviceShaderAtomicFloat16VectorFeaturesNV&);
#endif // VK_NV_shader_atomic_float16_vector
#if VK_EXT_map_memory_placed
  void attach(struct PhysicalDeviceMapMemoryPlacedFeaturesEXT&);
#endif // VK_EXT_map_memory_placed
#if VK_KHR_shader_bfloat16
  void attach(struct PhysicalDeviceShaderBfloat16FeaturesKHR&);
#endif // VK_KHR_shader_bfloat16
#if VK_NV_raw_access_chains
  void attach(struct PhysicalDeviceRawAccessChainsFeaturesNV&);
#endif // VK_NV_raw_access_chains
#if VK_NV_command_buffer_inheritance
  void attach(struct PhysicalDeviceCommandBufferInheritanceFeaturesNV&);
#endif // VK_NV_command_buffer_inheritance
#if VK_MESA_image_alignment_control
  void attach(struct PhysicalDeviceImageAlignmentControlFeaturesMESA&);
#endif // VK_MESA_image_alignment_control
#if VK_EXT_shader_replicated_composites
  void attach(struct PhysicalDeviceShaderReplicatedCompositesFeaturesEXT&);
#endif // VK_EXT_shader_replicated_composites
#if VK_KHR_present_mode_fifo_latest_ready
  void attach(struct PhysicalDevicePresentModeFifoLatestReadyFeaturesKHR&);
#endif // VK_KHR_present_mode_fifo_latest_ready
#if VK_NV_cooperative_matrix2
  void attach(struct PhysicalDeviceCooperativeMatrix2FeaturesNV&);
#endif // VK_NV_cooperative_matrix2
#if VK_HUAWEI_hdr_vivid
  void attach(struct PhysicalDeviceHdrVividFeaturesHUAWEI&);
#endif // VK_HUAWEI_hdr_vivid
#if VK_EXT_vertex_attribute_robustness
  void attach(struct PhysicalDeviceVertexAttributeRobustnessFeaturesEXT&);
#endif // VK_EXT_vertex_attribute_robustness
#if VK_KHR_depth_clamp_zero_one
  void attach(struct PhysicalDeviceDepthClampZeroOneFeaturesKHR&);
#endif // VK_KHR_depth_clamp_zero_one
#if VK_NV_cooperative_vector
  void attach(struct PhysicalDeviceCooperativeVectorFeaturesNV&);
#endif // VK_NV_cooperative_vector
#if VK_QCOM_tile_shading
  void attach(struct PhysicalDeviceTileShadingFeaturesQCOM&);
#endif // VK_QCOM_tile_shading
#if VK_VALVE_fragment_density_map_layered
  void attach(struct PhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE&);
#endif // VK_VALVE_fragment_density_map_layered
#if VK_NV_external_compute_queue
  void attach(struct ExternalComputeQueueDeviceCreateInfoNV&);
#endif // VK_NV_external_compute_queue
#if VK_ARM_format_pack
  void attach(struct PhysicalDeviceFormatPackFeaturesARM&);
#endif // VK_ARM_format_pack
#if VK_ARM_tensors
  void attach(struct PhysicalDeviceTensorFeaturesARM&);
  void attach(struct PhysicalDeviceDescriptorBufferTensorFeaturesARM&);
#endif // VK_ARM_tensors
#if VK_EXT_shader_float8
  void attach(struct PhysicalDeviceShaderFloat8FeaturesEXT&);
#endif // VK_EXT_shader_float8
#if VK_ARM_data_graph
  void attach(struct PhysicalDeviceDataGraphFeaturesARM&);
#endif // VK_ARM_data_graph
#if VK_SEC_pipeline_cache_incremental_mode
  void attach(struct PhysicalDevicePipelineCacheIncrementalModeFeaturesSEC&);
#endif // VK_SEC_pipeline_cache_incremental_mode
};

struct PhysicalDeviceMemoryProperties : VkPhysicalDeviceMemoryProperties {
  PhysicalDeviceMemoryProperties() noexcept : VkPhysicalDeviceMemoryProperties{} {}

  std::span<const MemoryType> getMemoryTypes() const { return std::span<const MemoryType>(std::bit_cast<const MemoryType*>(&this->memoryTypes), memoryTypeCount); }
  std::span<const MemoryHeap> getMemoryHeaps() const { return std::span<const MemoryHeap>(std::bit_cast<const MemoryHeap*>(&this->memoryHeaps), memoryHeapCount); }
};
#endif // VK_VERSION_1_0

#if VK_EXT_descriptor_buffer
struct DescriptorBufferBindingPushDescriptorBufferHandleEXT : VkDescriptorBufferBindingPushDescriptorBufferHandleEXT {
  DescriptorBufferBindingPushDescriptorBufferHandleEXT() noexcept : VkDescriptorBufferBindingPushDescriptorBufferHandleEXT{.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT} {}

  void setBuffer(Buffer value) { this->buffer = std::bit_cast<VkBuffer>(value); }
  Buffer getBuffer() const { return std::bit_cast<Buffer>(this->buffer); }
};
inline void DescriptorBufferBindingInfoEXT::attach(DescriptorBufferBindingPushDescriptorBufferHandleEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_descriptor_buffer

#if VK_KHR_external_memory_capabilities
using PhysicalDeviceExternalBufferInfoKHR = PhysicalDeviceExternalBufferInfo;
#endif // VK_KHR_external_memory_capabilities

#if VK_FUCHSIA_buffer_collection
struct BufferCollectionBufferCreateInfoFUCHSIA : VkBufferCollectionBufferCreateInfoFUCHSIA {
  BufferCollectionBufferCreateInfoFUCHSIA() noexcept : VkBufferCollectionBufferCreateInfoFUCHSIA{.sType = VK_STRUCTURE_TYPE_BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA} {}

  void setCollection(BufferCollectionFUCHSIA value) { this->collection = std::bit_cast<VkBufferCollectionFUCHSIA>(value); }
  BufferCollectionFUCHSIA getCollection() const { return std::bit_cast<BufferCollectionFUCHSIA>(this->collection); }
  void setIndex(uint32_t value) { this->index = value; }
  uint32_t getIndex() const { return this->index; }
};
inline void BufferCreateInfo::attach(BufferCollectionBufferCreateInfoFUCHSIA& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }

struct BufferConstraintsInfoFUCHSIA : VkBufferConstraintsInfoFUCHSIA {
  BufferConstraintsInfoFUCHSIA() noexcept : VkBufferConstraintsInfoFUCHSIA{.sType = VK_STRUCTURE_TYPE_BUFFER_CONSTRAINTS_INFO_FUCHSIA} {}

  void setCreateInfo(const BufferCreateInfo& value) { this->createInfo = value; }
  const BufferCreateInfo& getCreateInfo() const { return static_cast<const BufferCreateInfo&>(this->createInfo); }
  void setBufferCollectionConstraints(const BufferCollectionConstraintsInfoFUCHSIA& value) { this->bufferCollectionConstraints = value; }
  const BufferCollectionConstraintsInfoFUCHSIA& getBufferCollectionConstraints() const { return static_cast<const BufferCollectionConstraintsInfoFUCHSIA&>(this->bufferCollectionConstraints); }

  void setRequiredFormatFeatures(FormatFeatureFlags value) { this->requiredFormatFeatures = std::bit_cast<VkFormatFeatureFlags>(value); }
  FormatFeatureFlags getRequiredFormatFeatures() const { return std::bit_cast<FormatFeatureFlags>(this->requiredFormatFeatures); }
};
#endif // VK_FUCHSIA_buffer_collection

#if VK_VERSION_1_1
struct ExternalMemoryBufferCreateInfo : VkExternalMemoryBufferCreateInfo {
  ExternalMemoryBufferCreateInfo() noexcept : VkExternalMemoryBufferCreateInfo{.sType = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO} {}

  void setHandleTypes(ExternalMemoryHandleTypeFlags value) { this->handleTypes = std::bit_cast<VkExternalMemoryHandleTypeFlags>(value); }
  ExternalMemoryHandleTypeFlags getHandleTypes() const { return std::bit_cast<ExternalMemoryHandleTypeFlags>(this->handleTypes); }
};
inline void BufferCreateInfo::attach(ExternalMemoryBufferCreateInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_1

#if VK_VERSION_1_3
struct DeviceBufferMemoryRequirements : VkDeviceBufferMemoryRequirements {
  DeviceBufferMemoryRequirements() noexcept : VkDeviceBufferMemoryRequirements{.sType = VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS} {}

  void setCreateInfo(const BufferCreateInfo* value) { this->pCreateInfo = std::bit_cast<const VkBufferCreateInfo*>(value); }
  const BufferCreateInfo* getCreateInfo() const { return std::bit_cast<const BufferCreateInfo*>(this->pCreateInfo); }
};
#endif // VK_VERSION_1_3

#if VK_VERSION_1_4
struct BufferUsageFlags2CreateInfo : VkBufferUsageFlags2CreateInfo {
  BufferUsageFlags2CreateInfo() noexcept : VkBufferUsageFlags2CreateInfo{.sType = VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO} {}

  void setUsage(BufferUsageFlags2 value) { this->usage = std::bit_cast<VkBufferUsageFlags2>(value); }
  BufferUsageFlags2 getUsage() const { return std::bit_cast<BufferUsageFlags2>(this->usage); }
};
inline void BufferViewCreateInfo::attach(BufferUsageFlags2CreateInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void BufferCreateInfo::attach(BufferUsageFlags2CreateInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void PhysicalDeviceExternalBufferInfo::attach(BufferUsageFlags2CreateInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#if VK_EXT_descriptor_buffer
inline void DescriptorBufferBindingInfoEXT::attach(BufferUsageFlags2CreateInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_descriptor_buffer
#endif // VK_VERSION_1_4

#if VK_VERSION_1_2
struct BufferOpaqueCaptureAddressCreateInfo : VkBufferOpaqueCaptureAddressCreateInfo {
  BufferOpaqueCaptureAddressCreateInfo() noexcept : VkBufferOpaqueCaptureAddressCreateInfo{.sType = VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO} {}

  void setOpaqueCaptureAddress(uint64_t value) { this->opaqueCaptureAddress = value; }
  uint64_t getOpaqueCaptureAddress() const { return this->opaqueCaptureAddress; }
};
inline void BufferCreateInfo::attach(BufferOpaqueCaptureAddressCreateInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_2

#if VK_EXT_device_generated_commands
struct GeneratedCommandsPipelineInfoEXT : VkGeneratedCommandsPipelineInfoEXT {
  GeneratedCommandsPipelineInfoEXT() noexcept : VkGeneratedCommandsPipelineInfoEXT{.sType = VK_STRUCTURE_TYPE_GENERATED_COMMANDS_PIPELINE_INFO_EXT} {}

  void setPipeline(Pipeline value) { this->pipeline = std::bit_cast<VkPipeline>(value); }
  Pipeline getPipeline() const { return std::bit_cast<Pipeline>(this->pipeline); }
};
inline void GeneratedCommandsInfoEXT::attach(GeneratedCommandsPipelineInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void GeneratedCommandsMemoryRequirementsInfoEXT::attach(GeneratedCommandsPipelineInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }

struct GeneratedCommandsShaderInfoEXT : VkGeneratedCommandsShaderInfoEXT {
  GeneratedCommandsShaderInfoEXT() noexcept : VkGeneratedCommandsShaderInfoEXT{.sType = VK_STRUCTURE_TYPE_GENERATED_COMMANDS_SHADER_INFO_EXT} {}

  void setShaderCount(uint32_t value) { this->shaderCount = value; }
  uint32_t getShaderCount() const { return this->shaderCount; }
  void setShaders(const ShaderEXT* value) { this->pShaders = std::bit_cast<const VkShaderEXT*>(value); }
  const ShaderEXT* getShaders() const { return std::bit_cast<const ShaderEXT*>(this->pShaders); }
};
inline void GeneratedCommandsInfoEXT::attach(GeneratedCommandsShaderInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void GeneratedCommandsMemoryRequirementsInfoEXT::attach(GeneratedCommandsShaderInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }

struct IndirectCommandsPushConstantTokenEXT : VkIndirectCommandsPushConstantTokenEXT {
  IndirectCommandsPushConstantTokenEXT() noexcept : VkIndirectCommandsPushConstantTokenEXT{} {}
  IndirectCommandsPushConstantTokenEXT(const PushConstantRange& updateRange) noexcept : VkIndirectCommandsPushConstantTokenEXT{.updateRange = updateRange} {}

  void setUpdateRange(const PushConstantRange& value) { this->updateRange = value; }
  const PushConstantRange& getUpdateRange() const { return static_cast<const PushConstantRange&>(this->updateRange); }
};
#endif // VK_EXT_device_generated_commands

#if VK_EXT_shader_object
struct ShaderCreateInfoEXT : VkShaderCreateInfoEXT {
  ShaderCreateInfoEXT() noexcept : VkShaderCreateInfoEXT{.sType = VK_STRUCTURE_TYPE_SHADER_CREATE_INFO_EXT} {}

  void setStage(ShaderStageFlagBits value) { this->stage = std::bit_cast<VkShaderStageFlagBits>(value); }
  ShaderStageFlagBits getStage() const { return std::bit_cast<ShaderStageFlagBits>(this->stage); }
  void setCodeType(ShaderCodeTypeEXT value) { this->codeType = std::bit_cast<VkShaderCodeTypeEXT>(value); }
  ShaderCodeTypeEXT getCodeType() const { return std::bit_cast<ShaderCodeTypeEXT>(this->codeType); }
  void setCodeSize(size_t value) { this->codeSize = value; }
  size_t getCodeSize() const { return this->codeSize; }
  void setCode(const void* value) { this->pCode = value; }
  const void* getCode() const { return this->pCode; }

  void setFlags(ShaderCreateFlagsEXT value) { this->flags = std::bit_cast<VkShaderCreateFlagsEXT>(value); }
  ShaderCreateFlagsEXT getFlags() const { return std::bit_cast<ShaderCreateFlagsEXT>(this->flags); }
  void setNextStage(ShaderStageFlags value) { this->nextStage = std::bit_cast<VkShaderStageFlags>(value); }
  ShaderStageFlags getNextStage() const { return std::bit_cast<ShaderStageFlags>(this->nextStage); }
  void setName(const char* value) { this->pName = value; }
  const char* getName() const { return this->pName; }
  void setSetLayoutCount(uint32_t value) { this->setLayoutCount = value; }
  uint32_t getSetLayoutCount() const { return this->setLayoutCount; }
  void setSetLayouts(const DescriptorSetLayout* value) { this->pSetLayouts = std::bit_cast<const VkDescriptorSetLayout*>(value); }
  const DescriptorSetLayout* getSetLayouts() const { return std::bit_cast<const DescriptorSetLayout*>(this->pSetLayouts); }
  void setPushConstantRangeCount(uint32_t value) { this->pushConstantRangeCount = value; }
  uint32_t getPushConstantRangeCount() const { return this->pushConstantRangeCount; }
  void setPushConstantRanges(const PushConstantRange* value) { this->pPushConstantRanges = std::bit_cast<const VkPushConstantRange*>(value); }
  const PushConstantRange* getPushConstantRanges() const { return std::bit_cast<const PushConstantRange*>(this->pPushConstantRanges); }
  void setSpecializationInfo(const SpecializationInfo* value) { this->pSpecializationInfo = std::bit_cast<const VkSpecializationInfo*>(value); }
  const SpecializationInfo* getSpecializationInfo() const { return std::bit_cast<const SpecializationInfo*>(this->pSpecializationInfo); }

  void attach(struct PipelineShaderStageRequiredSubgroupSizeCreateInfo&);
};
#endif // VK_EXT_shader_object

#if VK_EXT_device_generated_commands
struct IndirectExecutionSetShaderInfoEXT : VkIndirectExecutionSetShaderInfoEXT {
  IndirectExecutionSetShaderInfoEXT() noexcept : VkIndirectExecutionSetShaderInfoEXT{.sType = VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_INFO_EXT} {}

  void setShaderCount(uint32_t value) { this->shaderCount = value; }
  uint32_t getShaderCount() const { return this->shaderCount; }
  void setInitialShaders(const ShaderEXT* value) { this->pInitialShaders = std::bit_cast<const VkShaderEXT*>(value); }
  const ShaderEXT* getInitialShaders() const { return std::bit_cast<const ShaderEXT*>(this->pInitialShaders); }
  void setMaxShaderCount(uint32_t value) { this->maxShaderCount = value; }
  uint32_t getMaxShaderCount() const { return this->maxShaderCount; }

  void setSetLayoutInfos(const IndirectExecutionSetShaderLayoutInfoEXT* value) { this->pSetLayoutInfos = std::bit_cast<const VkIndirectExecutionSetShaderLayoutInfoEXT*>(value); }
  const IndirectExecutionSetShaderLayoutInfoEXT* getSetLayoutInfos() const { return std::bit_cast<const IndirectExecutionSetShaderLayoutInfoEXT*>(this->pSetLayoutInfos); }
  void setPushConstantRangeCount(uint32_t value) { this->pushConstantRangeCount = value; }
  uint32_t getPushConstantRangeCount() const { return this->pushConstantRangeCount; }
  void setPushConstantRanges(const PushConstantRange* value) { this->pPushConstantRanges = std::bit_cast<const VkPushConstantRange*>(value); }
  const PushConstantRange* getPushConstantRanges() const { return std::bit_cast<const PushConstantRange*>(this->pPushConstantRanges); }
};
#endif // VK_EXT_device_generated_commands

#if VK_KHR_maintenance6
using BindDescriptorSetsInfoKHR = BindDescriptorSetsInfo;
using PushConstantsInfoKHR = PushConstantsInfo;
#endif // VK_KHR_maintenance6

#if VK_VERSION_1_0
struct DescriptorSetLayoutCreateInfo : VkDescriptorSetLayoutCreateInfo {
  DescriptorSetLayoutCreateInfo() noexcept : VkDescriptorSetLayoutCreateInfo{.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO} {}

  void setFlags(DescriptorSetLayoutCreateFlags value) { this->flags = std::bit_cast<VkDescriptorSetLayoutCreateFlags>(value); }
  DescriptorSetLayoutCreateFlags getFlags() const { return std::bit_cast<DescriptorSetLayoutCreateFlags>(this->flags); }
  // Number of bindings in the descriptor set layout
  void setBindingCount(uint32_t value) { this->bindingCount = value; }
  uint32_t getBindingCount() const { return this->bindingCount; }
  // Array of descriptor set layout bindings
  void setBindings(const DescriptorSetLayoutBinding* value) { this->pBindings = std::bit_cast<const VkDescriptorSetLayoutBinding*>(value); }
  const DescriptorSetLayoutBinding* getBindings() const { return std::bit_cast<const DescriptorSetLayoutBinding*>(this->pBindings); }

#if VK_VERSION_1_2
  void attach(struct DescriptorSetLayoutBindingFlagsCreateInfo&);
#endif // VK_VERSION_1_2
#if VK_EXT_mutable_descriptor_type
  void attach(struct MutableDescriptorTypeCreateInfoEXT&);
#endif // VK_EXT_mutable_descriptor_type
};
#endif // VK_VERSION_1_0

#if VK_KHR_get_physical_device_properties2
using PhysicalDeviceSparseImageFormatInfo2KHR = PhysicalDeviceSparseImageFormatInfo2;
#endif // VK_KHR_get_physical_device_properties2

#if VK_KHR_video_encode_quantization_map
struct VideoFormatQuantizationMapPropertiesKHR : VkVideoFormatQuantizationMapPropertiesKHR {
  VideoFormatQuantizationMapPropertiesKHR() noexcept : VkVideoFormatQuantizationMapPropertiesKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_FORMAT_QUANTIZATION_MAP_PROPERTIES_KHR} {}

  const Extent2D& getQuantizationMapTexelSize() const { return static_cast<const Extent2D&>(this->quantizationMapTexelSize); }
};
inline void VideoFormatPropertiesKHR::attach(VideoFormatQuantizationMapPropertiesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }

struct VideoFormatH265QuantizationMapPropertiesKHR : VkVideoFormatH265QuantizationMapPropertiesKHR {
  VideoFormatH265QuantizationMapPropertiesKHR() noexcept : VkVideoFormatH265QuantizationMapPropertiesKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_FORMAT_H265_QUANTIZATION_MAP_PROPERTIES_KHR} {}

  VideoEncodeH265CtbSizeFlagsKHR getCompatibleCtbSizes() const { return std::bit_cast<VideoEncodeH265CtbSizeFlagsKHR>(this->compatibleCtbSizes); }
};
inline void VideoFormatPropertiesKHR::attach(VideoFormatH265QuantizationMapPropertiesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }

struct VideoFormatAV1QuantizationMapPropertiesKHR : VkVideoFormatAV1QuantizationMapPropertiesKHR {
  VideoFormatAV1QuantizationMapPropertiesKHR() noexcept : VkVideoFormatAV1QuantizationMapPropertiesKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_FORMAT_AV1_QUANTIZATION_MAP_PROPERTIES_KHR} {}

  VideoEncodeAV1SuperblockSizeFlagsKHR getCompatibleSuperblockSizes() const { return std::bit_cast<VideoEncodeAV1SuperblockSizeFlagsKHR>(this->compatibleSuperblockSizes); }
};
inline void VideoFormatPropertiesKHR::attach(VideoFormatAV1QuantizationMapPropertiesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_encode_quantization_map

#if VK_EXT_image_drm_format_modifier
struct PhysicalDeviceImageDrmFormatModifierInfoEXT : VkPhysicalDeviceImageDrmFormatModifierInfoEXT {
  PhysicalDeviceImageDrmFormatModifierInfoEXT() noexcept : VkPhysicalDeviceImageDrmFormatModifierInfoEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT} {}

  void setDrmFormatModifier(uint64_t value) { this->drmFormatModifier = value; }
  uint64_t getDrmFormatModifier() const { return this->drmFormatModifier; }
  void setSharingMode(SharingMode value) { this->sharingMode = std::bit_cast<VkSharingMode>(value); }
  SharingMode getSharingMode() const { return std::bit_cast<SharingMode>(this->sharingMode); }

  void setQueueFamilyIndexCount(uint32_t value) { this->queueFamilyIndexCount = value; }
  uint32_t getQueueFamilyIndexCount() const { return this->queueFamilyIndexCount; }
  void setQueueFamilyIndices(const uint32_t* value) { this->pQueueFamilyIndices = value; }
  const uint32_t* getQueueFamilyIndices() const { return this->pQueueFamilyIndices; }
};
inline void PhysicalDeviceImageFormatInfo2::attach(PhysicalDeviceImageDrmFormatModifierInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_image_drm_format_modifier

#if VK_VERSION_1_1
struct PhysicalDeviceExternalImageFormatInfo : VkPhysicalDeviceExternalImageFormatInfo {
  PhysicalDeviceExternalImageFormatInfo() noexcept : VkPhysicalDeviceExternalImageFormatInfo{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO} {}

  void setHandleType(ExternalMemoryHandleTypeFlagBits value) { this->handleType = std::bit_cast<VkExternalMemoryHandleTypeFlagBits>(value); }
  ExternalMemoryHandleTypeFlagBits getHandleType() const { return std::bit_cast<ExternalMemoryHandleTypeFlagBits>(this->handleType); }
};
inline void PhysicalDeviceImageFormatInfo2::attach(PhysicalDeviceExternalImageFormatInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_1

#if VK_EXT_filter_cubic
struct PhysicalDeviceImageViewImageFormatInfoEXT : VkPhysicalDeviceImageViewImageFormatInfoEXT {
  PhysicalDeviceImageViewImageFormatInfoEXT() noexcept : VkPhysicalDeviceImageViewImageFormatInfoEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT} {}

  void setImageViewType(ImageViewType value) { this->imageViewType = std::bit_cast<VkImageViewType>(value); }
  ImageViewType getImageViewType() const { return std::bit_cast<ImageViewType>(this->imageViewType); }
};
inline void PhysicalDeviceImageFormatInfo2::attach(PhysicalDeviceImageViewImageFormatInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_filter_cubic

#if VK_KHR_get_physical_device_properties2
using PhysicalDeviceImageFormatInfo2KHR = PhysicalDeviceImageFormatInfo2;
#endif // VK_KHR_get_physical_device_properties2
#if VK_KHR_imageless_framebuffer
using FramebufferAttachmentImageInfoKHR = FramebufferAttachmentImageInfo;
#endif // VK_KHR_imageless_framebuffer

#if VK_EXT_image_drm_format_modifier
struct ImageDrmFormatModifierListCreateInfoEXT : VkImageDrmFormatModifierListCreateInfoEXT {
  ImageDrmFormatModifierListCreateInfoEXT() noexcept : VkImageDrmFormatModifierListCreateInfoEXT{.sType = VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT} {}

  void setDrmFormatModifierCount(uint32_t value) { this->drmFormatModifierCount = value; }
  uint32_t getDrmFormatModifierCount() const { return this->drmFormatModifierCount; }
  void setDrmFormatModifiers(const uint64_t* value) { this->pDrmFormatModifiers = value; }
  const uint64_t* getDrmFormatModifiers() const { return this->pDrmFormatModifiers; }
};
inline void ImageCreateInfo::attach(ImageDrmFormatModifierListCreateInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_image_drm_format_modifier

#if VK_FUCHSIA_buffer_collection
struct BufferCollectionImageCreateInfoFUCHSIA : VkBufferCollectionImageCreateInfoFUCHSIA {
  BufferCollectionImageCreateInfoFUCHSIA() noexcept : VkBufferCollectionImageCreateInfoFUCHSIA{.sType = VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA} {}

  void setCollection(BufferCollectionFUCHSIA value) { this->collection = std::bit_cast<VkBufferCollectionFUCHSIA>(value); }
  BufferCollectionFUCHSIA getCollection() const { return std::bit_cast<BufferCollectionFUCHSIA>(this->collection); }
  void setIndex(uint32_t value) { this->index = value; }
  uint32_t getIndex() const { return this->index; }
};
inline void ImageCreateInfo::attach(BufferCollectionImageCreateInfoFUCHSIA& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }

struct ImageFormatConstraintsInfoFUCHSIA : VkImageFormatConstraintsInfoFUCHSIA {
  ImageFormatConstraintsInfoFUCHSIA() noexcept : VkImageFormatConstraintsInfoFUCHSIA{.sType = VK_STRUCTURE_TYPE_IMAGE_FORMAT_CONSTRAINTS_INFO_FUCHSIA} {}

  void setImageCreateInfo(const ImageCreateInfo& value) { this->imageCreateInfo = value; }
  const ImageCreateInfo& getImageCreateInfo() const { return static_cast<const ImageCreateInfo&>(this->imageCreateInfo); }
  void setRequiredFormatFeatures(FormatFeatureFlags value) { this->requiredFormatFeatures = std::bit_cast<VkFormatFeatureFlags>(value); }
  FormatFeatureFlags getRequiredFormatFeatures() const { return std::bit_cast<FormatFeatureFlags>(this->requiredFormatFeatures); }
  void setColorSpaceCount(uint32_t value) { this->colorSpaceCount = value; }
  uint32_t getColorSpaceCount() const { return this->colorSpaceCount; }
  void setColorSpaces(const SysmemColorSpaceFUCHSIA* value) { this->pColorSpaces = std::bit_cast<const VkSysmemColorSpaceFUCHSIA*>(value); }
  const SysmemColorSpaceFUCHSIA* getColorSpaces() const { return std::bit_cast<const SysmemColorSpaceFUCHSIA*>(this->pColorSpaces); }

  void setFlags(ImageFormatConstraintsFlagsFUCHSIA value) { this->flags = std::bit_cast<VkImageFormatConstraintsFlagsFUCHSIA>(value); }
  ImageFormatConstraintsFlagsFUCHSIA getFlags() const { return std::bit_cast<ImageFormatConstraintsFlagsFUCHSIA>(this->flags); }
  void setSysmemPixelFormat(uint64_t value) { this->sysmemPixelFormat = value; }
  uint64_t getSysmemPixelFormat() const { return this->sysmemPixelFormat; }
};
#endif // VK_FUCHSIA_buffer_collection

#if VK_VERSION_1_3
struct DeviceImageMemoryRequirements : VkDeviceImageMemoryRequirements {
  DeviceImageMemoryRequirements() noexcept : VkDeviceImageMemoryRequirements{.sType = VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS} {}

  void setCreateInfo(const ImageCreateInfo* value) { this->pCreateInfo = std::bit_cast<const VkImageCreateInfo*>(value); }
  const ImageCreateInfo* getCreateInfo() const { return std::bit_cast<const ImageCreateInfo*>(this->pCreateInfo); }

  void setPlaneAspect(ImageAspectFlagBits value) { this->planeAspect = std::bit_cast<VkImageAspectFlagBits>(value); }
  ImageAspectFlagBits getPlaneAspect() const { return std::bit_cast<ImageAspectFlagBits>(this->planeAspect); }
};
#endif // VK_VERSION_1_3

#if VK_EXT_image_drm_format_modifier
struct ImageDrmFormatModifierExplicitCreateInfoEXT : VkImageDrmFormatModifierExplicitCreateInfoEXT {
  ImageDrmFormatModifierExplicitCreateInfoEXT() noexcept : VkImageDrmFormatModifierExplicitCreateInfoEXT{.sType = VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT} {}

  void setDrmFormatModifier(uint64_t value) { this->drmFormatModifier = value; }
  uint64_t getDrmFormatModifier() const { return this->drmFormatModifier; }
  void setDrmFormatModifierPlaneCount(uint32_t value) { this->drmFormatModifierPlaneCount = value; }
  uint32_t getDrmFormatModifierPlaneCount() const { return this->drmFormatModifierPlaneCount; }
  void setPlaneLayouts(const SubresourceLayout* value) { this->pPlaneLayouts = std::bit_cast<const VkSubresourceLayout*>(value); }
  const SubresourceLayout* getPlaneLayouts() const { return std::bit_cast<const SubresourceLayout*>(this->pPlaneLayouts); }
};
inline void ImageCreateInfo::attach(ImageDrmFormatModifierExplicitCreateInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_image_drm_format_modifier

#if VK_VERSION_1_2
struct ImageStencilUsageCreateInfo : VkImageStencilUsageCreateInfo {
  ImageStencilUsageCreateInfo() noexcept : VkImageStencilUsageCreateInfo{.sType = VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO} {}

  void setStencilUsage(ImageUsageFlags value) { this->stencilUsage = std::bit_cast<VkImageUsageFlags>(value); }
  ImageUsageFlags getStencilUsage() const { return std::bit_cast<ImageUsageFlags>(this->stencilUsage); }
};
inline void ImageCreateInfo::attach(ImageStencilUsageCreateInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void PhysicalDeviceImageFormatInfo2::attach(ImageStencilUsageCreateInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_2

#if VK_EXT_metal_objects
struct ImportMetalTextureInfoEXT : VkImportMetalTextureInfoEXT {
  ImportMetalTextureInfoEXT() noexcept : VkImportMetalTextureInfoEXT{.sType = VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT} {}

  void setPlane(ImageAspectFlagBits value) { this->plane = std::bit_cast<VkImageAspectFlagBits>(value); }
  ImageAspectFlagBits getPlane() const { return std::bit_cast<ImageAspectFlagBits>(this->plane); }
  void setMtlTexture(MTLTexture_id value) { this->mtlTexture = value; }
  MTLTexture_id getMtlTexture() const { return this->mtlTexture; }
};
inline void ImageCreateInfo::attach(ImportMetalTextureInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }

struct ImportMetalIOSurfaceInfoEXT : VkImportMetalIOSurfaceInfoEXT {
  ImportMetalIOSurfaceInfoEXT() noexcept : VkImportMetalIOSurfaceInfoEXT{.sType = VK_STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT} {}

  void setIoSurface(IOSurfaceRef value) { this->ioSurface = value; }
  IOSurfaceRef getIoSurface() const { return this->ioSurface; }
};
inline void ImageCreateInfo::attach(ImportMetalIOSurfaceInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_metal_objects

#if VK_NV_optical_flow
struct OpticalFlowImageFormatInfoNV : VkOpticalFlowImageFormatInfoNV {
  OpticalFlowImageFormatInfoNV() noexcept : VkOpticalFlowImageFormatInfoNV{.sType = VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV} {}

  void setUsage(OpticalFlowUsageFlagsNV value) { this->usage = std::bit_cast<VkOpticalFlowUsageFlagsNV>(value); }
  OpticalFlowUsageFlagsNV getUsage() const { return std::bit_cast<OpticalFlowUsageFlagsNV>(this->usage); }
};
inline void PhysicalDeviceImageFormatInfo2::attach(OpticalFlowImageFormatInfoNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void ImageCreateInfo::attach(OpticalFlowImageFormatInfoNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_optical_flow

#if VK_QNX_external_memory_screen_buffer
struct ExternalFormatQNX : VkExternalFormatQNX {
  ExternalFormatQNX() noexcept : VkExternalFormatQNX{.sType = VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX} {}

  void setExternalFormat(uint64_t value) { this->externalFormat = value; }
  uint64_t getExternalFormat() const { return this->externalFormat; }
};
inline void ImageCreateInfo::attach(ExternalFormatQNX& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void SamplerYcbcrConversionCreateInfo::attach(ExternalFormatQNX& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_QNX_external_memory_screen_buffer

#if VK_MESA_image_alignment_control
struct ImageAlignmentControlCreateInfoMESA : VkImageAlignmentControlCreateInfoMESA {
  ImageAlignmentControlCreateInfoMESA() noexcept : VkImageAlignmentControlCreateInfoMESA{.sType = VK_STRUCTURE_TYPE_IMAGE_ALIGNMENT_CONTROL_CREATE_INFO_MESA} {}

  void setMaximumRequestedAlignment(uint32_t value) { this->maximumRequestedAlignment = value; }
  uint32_t getMaximumRequestedAlignment() const { return this->maximumRequestedAlignment; }
};
inline void ImageCreateInfo::attach(ImageAlignmentControlCreateInfoMESA& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_MESA_image_alignment_control

#if VK_VERSION_1_1
struct ExternalMemoryImageCreateInfo : VkExternalMemoryImageCreateInfo {
  ExternalMemoryImageCreateInfo() noexcept : VkExternalMemoryImageCreateInfo{.sType = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO} {}

  void setHandleTypes(ExternalMemoryHandleTypeFlags value) { this->handleTypes = std::bit_cast<VkExternalMemoryHandleTypeFlags>(value); }
  ExternalMemoryHandleTypeFlags getHandleTypes() const { return std::bit_cast<ExternalMemoryHandleTypeFlags>(this->handleTypes); }
};
inline void ImageCreateInfo::attach(ExternalMemoryImageCreateInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_1

#if VK_KHR_swapchain
struct ImageSwapchainCreateInfoKHR : VkImageSwapchainCreateInfoKHR {
  ImageSwapchainCreateInfoKHR() noexcept : VkImageSwapchainCreateInfoKHR{.sType = VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR} {}

  void setSwapchain(SwapchainKHR value) { this->swapchain = std::bit_cast<VkSwapchainKHR>(value); }
  SwapchainKHR getSwapchain() const { return std::bit_cast<SwapchainKHR>(this->swapchain); }
};
inline void ImageCreateInfo::attach(ImageSwapchainCreateInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_swapchain

#if VK_EXT_custom_border_color
struct SamplerCustomBorderColorCreateInfoEXT : VkSamplerCustomBorderColorCreateInfoEXT {
  SamplerCustomBorderColorCreateInfoEXT() noexcept : VkSamplerCustomBorderColorCreateInfoEXT{.sType = VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT} {}

  void setCustomBorderColor(ClearColorValue value) { this->customBorderColor = value; }
  ClearColorValue getCustomBorderColor() const { return this->customBorderColor; }
  void setFormat(Format value) { this->format = std::bit_cast<VkFormat>(value); }
  Format getFormat() const { return std::bit_cast<Format>(this->format); }
};
inline void SamplerCreateInfo::attach(SamplerCustomBorderColorCreateInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_custom_border_color

#if VK_QCOM_filter_cubic_weights
struct SamplerCubicWeightsCreateInfoQCOM : VkSamplerCubicWeightsCreateInfoQCOM {
  SamplerCubicWeightsCreateInfoQCOM() noexcept : VkSamplerCubicWeightsCreateInfoQCOM{.sType = VK_STRUCTURE_TYPE_SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_QCOM} {}

  void setCubicWeights(CubicFilterWeightsQCOM value) { this->cubicWeights = std::bit_cast<VkCubicFilterWeightsQCOM>(value); }
  CubicFilterWeightsQCOM getCubicWeights() const { return std::bit_cast<CubicFilterWeightsQCOM>(this->cubicWeights); }
};
inline void SamplerCreateInfo::attach(SamplerCubicWeightsCreateInfoQCOM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_QCOM_filter_cubic_weights

#if VK_QCOM_image_processing2
struct SamplerBlockMatchWindowCreateInfoQCOM : VkSamplerBlockMatchWindowCreateInfoQCOM {
  SamplerBlockMatchWindowCreateInfoQCOM() noexcept : VkSamplerBlockMatchWindowCreateInfoQCOM{.sType = VK_STRUCTURE_TYPE_SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_QCOM} {}

  void setWindowExtent(const Extent2D& value) { this->windowExtent = value; }
  const Extent2D& getWindowExtent() const { return static_cast<const Extent2D&>(this->windowExtent); }
  void setWindowCompareMode(BlockMatchWindowCompareModeQCOM value) { this->windowCompareMode = std::bit_cast<VkBlockMatchWindowCompareModeQCOM>(value); }
  BlockMatchWindowCompareModeQCOM getWindowCompareMode() const { return std::bit_cast<BlockMatchWindowCompareModeQCOM>(this->windowCompareMode); }
};
inline void SamplerCreateInfo::attach(SamplerBlockMatchWindowCreateInfoQCOM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_QCOM_image_processing2

#if VK_EXT_border_color_swizzle
struct SamplerBorderColorComponentMappingCreateInfoEXT : VkSamplerBorderColorComponentMappingCreateInfoEXT {
  SamplerBorderColorComponentMappingCreateInfoEXT() noexcept : VkSamplerBorderColorComponentMappingCreateInfoEXT{.sType = VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT} {}

  void setComponents(const ComponentMapping& value) { this->components = value; }
  const ComponentMapping& getComponents() const { return static_cast<const ComponentMapping&>(this->components); }

  void setSrgb(Bool32 value) { this->srgb = value; }
  Bool32 getSrgb() const { return this->srgb; }
};
inline void SamplerCreateInfo::attach(SamplerBorderColorComponentMappingCreateInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_border_color_swizzle

#if VK_VERSION_1_2
struct SamplerReductionModeCreateInfo : VkSamplerReductionModeCreateInfo {
  SamplerReductionModeCreateInfo() noexcept : VkSamplerReductionModeCreateInfo{.sType = VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO} {}

  void setReductionMode(SamplerReductionMode value) { this->reductionMode = std::bit_cast<VkSamplerReductionMode>(value); }
  SamplerReductionMode getReductionMode() const { return std::bit_cast<SamplerReductionMode>(this->reductionMode); }
};
inline void SamplerCreateInfo::attach(SamplerReductionModeCreateInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_2

#if VK_ARM_data_graph
struct DataGraphPipelineCreateInfoARM : VkDataGraphPipelineCreateInfoARM {
  DataGraphPipelineCreateInfoARM() noexcept : VkDataGraphPipelineCreateInfoARM{.sType = VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CREATE_INFO_ARM} {}

  void setLayout(PipelineLayout value) { this->layout = std::bit_cast<VkPipelineLayout>(value); }
  PipelineLayout getLayout() const { return std::bit_cast<PipelineLayout>(this->layout); }
  void setResourceInfoCount(uint32_t value) { this->resourceInfoCount = value; }
  uint32_t getResourceInfoCount() const { return this->resourceInfoCount; }
  void setResourceInfos(const DataGraphPipelineResourceInfoARM* value) { this->pResourceInfos = std::bit_cast<const VkDataGraphPipelineResourceInfoARM*>(value); }
  const DataGraphPipelineResourceInfoARM* getResourceInfos() const { return std::bit_cast<const DataGraphPipelineResourceInfoARM*>(this->pResourceInfos); }

  void setFlags(PipelineCreateFlags2KHR value) { this->flags = std::bit_cast<VkPipelineCreateFlags2KHR>(value); }
  PipelineCreateFlags2KHR getFlags() const { return std::bit_cast<PipelineCreateFlags2KHR>(this->flags); }

  void attach(struct PipelineCreationFeedbackCreateInfo&);
  void attach(struct DataGraphPipelineCompilerControlCreateInfoARM&);
  void attachHead(struct DataGraphPipelineShaderModuleCreateInfoARM&);
  void attach(struct DataGraphPipelineIdentifierCreateInfoARM&);
  void attach(struct DataGraphProcessingEngineCreateInfoARM&);
};
#endif // VK_ARM_data_graph

#if VK_EXT_debug_utils
struct DebugUtilsObjectNameInfoEXT : VkDebugUtilsObjectNameInfoEXT {
  DebugUtilsObjectNameInfoEXT() noexcept : VkDebugUtilsObjectNameInfoEXT{.sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT} {}

  void setObject(Object value) { this->objectType = std::bit_cast<VkObjectType>(value.type); this->objectHandle = value.handle; }
  Object getObject() const { return {std::bit_cast<ObjectType>(this->objectType), this->objectHandle}; }

  void setObjectName(const char* value) { this->pObjectName = value; }
  const char* getObjectName() const { return this->pObjectName; }
};
inline void PipelineShaderStageCreateInfo::attach(DebugUtilsObjectNameInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_debug_utils

#if VK_EXT_shader_module_identifier
struct PipelineShaderStageModuleIdentifierCreateInfoEXT : VkPipelineShaderStageModuleIdentifierCreateInfoEXT {
  PipelineShaderStageModuleIdentifierCreateInfoEXT() noexcept : VkPipelineShaderStageModuleIdentifierCreateInfoEXT{.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT} {}

  void setIdentifierSize(uint32_t value) { this->identifierSize = value; }
  uint32_t getIdentifierSize() const { return this->identifierSize; }
  void setIdentifier(const uint8_t* value) { this->pIdentifier = value; }
  const uint8_t* getIdentifier() const { return this->pIdentifier; }
};
inline void PipelineShaderStageCreateInfo::attach(PipelineShaderStageModuleIdentifierCreateInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_shader_module_identifier

#if VK_NV_device_generated_commands
struct GraphicsShaderGroupCreateInfoNV : VkGraphicsShaderGroupCreateInfoNV {
  GraphicsShaderGroupCreateInfoNV() noexcept : VkGraphicsShaderGroupCreateInfoNV{.sType = VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV} {}

  void setStageCount(uint32_t value) { this->stageCount = value; }
  uint32_t getStageCount() const { return this->stageCount; }
  void setStages(const PipelineShaderStageCreateInfo* value) { this->pStages = std::bit_cast<const VkPipelineShaderStageCreateInfo*>(value); }
  const PipelineShaderStageCreateInfo* getStages() const { return std::bit_cast<const PipelineShaderStageCreateInfo*>(this->pStages); }

  void setVertexInputState(const PipelineVertexInputStateCreateInfo* value) { this->pVertexInputState = std::bit_cast<const VkPipelineVertexInputStateCreateInfo*>(value); }
  const PipelineVertexInputStateCreateInfo* getVertexInputState() const { return std::bit_cast<const PipelineVertexInputStateCreateInfo*>(this->pVertexInputState); }
  void setTessellationState(const PipelineTessellationStateCreateInfo* value) { this->pTessellationState = std::bit_cast<const VkPipelineTessellationStateCreateInfo*>(value); }
  const PipelineTessellationStateCreateInfo* getTessellationState() const { return std::bit_cast<const PipelineTessellationStateCreateInfo*>(this->pTessellationState); }
};
#endif // VK_NV_device_generated_commands

#if VK_VERSION_1_0
struct ComputePipelineCreateInfo : VkComputePipelineCreateInfo {
  ComputePipelineCreateInfo() noexcept : VkComputePipelineCreateInfo{.sType = VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO} {}

  void setStage(const PipelineShaderStageCreateInfo& value) { this->stage = value; }
  const PipelineShaderStageCreateInfo& getStage() const { return static_cast<const PipelineShaderStageCreateInfo&>(this->stage); }
  // Interface layout of the pipeline
  void setLayout(PipelineLayout value) { this->layout = std::bit_cast<VkPipelineLayout>(value); }
  PipelineLayout getLayout() const { return std::bit_cast<PipelineLayout>(this->layout); }
  // If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is not -1, it specifies an index into pCreateInfos of the base pipeline this is a derivative of
  void setBasePipelineIndex(int32_t value) { this->basePipelineIndex = value; }
  int32_t getBasePipelineIndex() const { return this->basePipelineIndex; }

  // Pipeline creation flags
  void setFlags(PipelineCreateFlags value) { this->flags = std::bit_cast<VkPipelineCreateFlags>(value); }
  PipelineCreateFlags getFlags() const { return std::bit_cast<PipelineCreateFlags>(this->flags); }
  // If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is nonzero, it specifies the handle of the base pipeline this is a derivative of
  void setBasePipelineHandle(Pipeline value) { this->basePipelineHandle = std::bit_cast<VkPipeline>(value); }
  Pipeline getBasePipelineHandle() const { return std::bit_cast<Pipeline>(this->basePipelineHandle); }

#if VK_NV_device_generated_commands_compute
  void attach(struct ComputePipelineIndirectBufferInfoNV&);
#endif // VK_NV_device_generated_commands_compute
#if VK_VERSION_1_4
  void attach(struct PipelineCreateFlags2CreateInfo&);
#endif // VK_VERSION_1_4
#if VK_KHR_pipeline_binary
  void attach(struct PipelineBinaryInfoKHR&);
#endif // VK_KHR_pipeline_binary
#if VK_VERSION_1_3
  void attach(struct PipelineCreationFeedbackCreateInfo&);
#endif // VK_VERSION_1_3
#if VK_HUAWEI_subpass_shading
  void attach(struct SubpassShadingPipelineCreateInfoHUAWEI&);
#endif // VK_HUAWEI_subpass_shading
#if VK_AMD_pipeline_compiler_control
  void attach(struct PipelineCompilerControlCreateInfoAMD&);
#endif // VK_AMD_pipeline_compiler_control
#if VK_VERSION_1_4
  void attach(struct PipelineRobustnessCreateInfo&);
#endif // VK_VERSION_1_4
};

struct PipelineColorBlendStateCreateInfo : VkPipelineColorBlendStateCreateInfo {
  PipelineColorBlendStateCreateInfo() noexcept : VkPipelineColorBlendStateCreateInfo{.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO} {}

  void setLogicOp(LogicOp value) { this->logicOp = std::bit_cast<VkLogicOp>(value); }
  LogicOp getLogicOp() const { return std::bit_cast<LogicOp>(this->logicOp); }
  void setBlendConstants(std::span<const float, 4> value) { std::memcpy(&this->blendConstants, value.data(), value.size_bytes()); }
  std::span<const float, 4> getBlendConstants() const { return this->blendConstants; }

  void setFlags(PipelineColorBlendStateCreateFlags value) { this->flags = std::bit_cast<VkPipelineColorBlendStateCreateFlags>(value); }
  PipelineColorBlendStateCreateFlags getFlags() const { return std::bit_cast<PipelineColorBlendStateCreateFlags>(this->flags); }
  void setLogicOpEnable(Bool32 value) { this->logicOpEnable = value; }
  Bool32 getLogicOpEnable() const { return this->logicOpEnable; }
  // # of pAttachments
  void setAttachmentCount(uint32_t value) { this->attachmentCount = value; }
  uint32_t getAttachmentCount() const { return this->attachmentCount; }
  void setAttachments(const PipelineColorBlendAttachmentState* value) { this->pAttachments = std::bit_cast<const VkPipelineColorBlendAttachmentState*>(value); }
  const PipelineColorBlendAttachmentState* getAttachments() const { return std::bit_cast<const PipelineColorBlendAttachmentState*>(this->pAttachments); }

#if VK_EXT_blend_operation_advanced
  void attach(struct PipelineColorBlendAdvancedStateCreateInfoEXT&);
#endif // VK_EXT_blend_operation_advanced
#if VK_EXT_color_write_enable
  void attach(struct PipelineColorWriteCreateInfoEXT&);
#endif // VK_EXT_color_write_enable
};
#endif // VK_VERSION_1_0

#if VK_VERSION_1_1
struct ExportFenceCreateInfo : VkExportFenceCreateInfo {
  ExportFenceCreateInfo() noexcept : VkExportFenceCreateInfo{.sType = VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO} {}

  void setHandleTypes(ExternalFenceHandleTypeFlags value) { this->handleTypes = std::bit_cast<VkExternalFenceHandleTypeFlags>(value); }
  ExternalFenceHandleTypeFlags getHandleTypes() const { return std::bit_cast<ExternalFenceHandleTypeFlags>(this->handleTypes); }
};
inline void FenceCreateInfo::attach(ExportFenceCreateInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_1

#if VK_KHR_external_fence_win32
struct ExportFenceWin32HandleInfoKHR : VkExportFenceWin32HandleInfoKHR {
  ExportFenceWin32HandleInfoKHR() noexcept : VkExportFenceWin32HandleInfoKHR{.sType = VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR} {}

  void setDwAccess(DWORD value) { this->dwAccess = value; }
  DWORD getDwAccess() const { return this->dwAccess; }
  void setName(LPCWSTR value) { this->name = value; }
  LPCWSTR getName() const { return this->name; }

  void setAttributes(const SECURITY_ATTRIBUTES* value) { this->pAttributes = value; }
  const SECURITY_ATTRIBUTES* getAttributes() const { return this->pAttributes; }
};
inline void FenceCreateInfo::attach(ExportFenceWin32HandleInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_external_fence_win32

#if VK_VERSION_1_1
struct FormatProperties2 : VkFormatProperties2 {
  FormatProperties2() noexcept : VkFormatProperties2{.sType = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2} {}

  const FormatProperties& getFormatProperties() const { return static_cast<const FormatProperties&>(this->formatProperties); }

#if VK_EXT_image_drm_format_modifier
  void attach(struct DrmFormatModifierPropertiesListEXT&);
#endif // VK_EXT_image_drm_format_modifier
#if VK_EXT_multisampled_render_to_single_sampled
  void attach(struct SubpassResolvePerformanceQueryEXT&);
#endif // VK_EXT_multisampled_render_to_single_sampled
#if VK_VERSION_1_3
  void attach(struct FormatProperties3&);
#endif // VK_VERSION_1_3
#if VK_ARM_tensors
  void attach(struct TensorFormatPropertiesARM&);
#endif // VK_ARM_tensors
};
#endif // VK_VERSION_1_1

#if VK_EXT_conditional_rendering
struct CommandBufferInheritanceConditionalRenderingInfoEXT : VkCommandBufferInheritanceConditionalRenderingInfoEXT {
  CommandBufferInheritanceConditionalRenderingInfoEXT() noexcept : VkCommandBufferInheritanceConditionalRenderingInfoEXT{.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT} {}

  // Whether this secondary command buffer may be executed during an active conditional rendering
  void setConditionalRenderingEnable(Bool32 value) { this->conditionalRenderingEnable = value; }
  Bool32 getConditionalRenderingEnable() const { return this->conditionalRenderingEnable; }
};
inline void CommandBufferInheritanceInfo::attach(CommandBufferInheritanceConditionalRenderingInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_conditional_rendering

#if VK_NV_inherited_viewport_scissor
struct CommandBufferInheritanceViewportScissorInfoNV : VkCommandBufferInheritanceViewportScissorInfoNV {
  CommandBufferInheritanceViewportScissorInfoNV() noexcept : VkCommandBufferInheritanceViewportScissorInfoNV{.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV} {}

  void setViewportDepthCount(uint32_t value) { this->viewportDepthCount = value; }
  uint32_t getViewportDepthCount() const { return this->viewportDepthCount; }
  void setViewportDepths(const Viewport* value) { this->pViewportDepths = std::bit_cast<const VkViewport*>(value); }
  const Viewport* getViewportDepths() const { return std::bit_cast<const Viewport*>(this->pViewportDepths); }

  void setViewportScissor2D(Bool32 value) { this->viewportScissor2D = value; }
  Bool32 getViewportScissor2D() const { return this->viewportScissor2D; }
};
inline void CommandBufferInheritanceInfo::attach(CommandBufferInheritanceViewportScissorInfoNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_inherited_viewport_scissor

#if VK_VERSION_1_3
struct CommandBufferInheritanceRenderingInfo : VkCommandBufferInheritanceRenderingInfo {
  CommandBufferInheritanceRenderingInfo() noexcept : VkCommandBufferInheritanceRenderingInfo{.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO} {}

  void setViewMask(uint32_t value) { this->viewMask = value; }
  uint32_t getViewMask() const { return this->viewMask; }
  void setDepthAttachmentFormat(Format value) { this->depthAttachmentFormat = std::bit_cast<VkFormat>(value); }
  Format getDepthAttachmentFormat() const { return std::bit_cast<Format>(this->depthAttachmentFormat); }
  void setStencilAttachmentFormat(Format value) { this->stencilAttachmentFormat = std::bit_cast<VkFormat>(value); }
  Format getStencilAttachmentFormat() const { return std::bit_cast<Format>(this->stencilAttachmentFormat); }

  void setFlags(RenderingFlags value) { this->flags = std::bit_cast<VkRenderingFlags>(value); }
  RenderingFlags getFlags() const { return std::bit_cast<RenderingFlags>(this->flags); }
  void setColorAttachmentCount(uint32_t value) { this->colorAttachmentCount = value; }
  uint32_t getColorAttachmentCount() const { return this->colorAttachmentCount; }
  void setColorAttachmentFormats(const Format* value) { this->pColorAttachmentFormats = std::bit_cast<const VkFormat*>(value); }
  const Format* getColorAttachmentFormats() const { return std::bit_cast<const Format*>(this->pColorAttachmentFormats); }
  void setRasterizationSamples(SampleCountFlagBits value) { this->rasterizationSamples = std::bit_cast<VkSampleCountFlagBits>(value); }
  SampleCountFlagBits getRasterizationSamples() const { return std::bit_cast<SampleCountFlagBits>(this->rasterizationSamples); }
};
inline void CommandBufferInheritanceInfo::attach(CommandBufferInheritanceRenderingInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_3

#if VK_VERSION_1_0
struct CommandBufferBeginInfo : VkCommandBufferBeginInfo {
  CommandBufferBeginInfo() noexcept : VkCommandBufferBeginInfo{.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO} {}

  // Command buffer usage flags
  void setFlags(CommandBufferUsageFlags value) { this->flags = std::bit_cast<VkCommandBufferUsageFlags>(value); }
  CommandBufferUsageFlags getFlags() const { return std::bit_cast<CommandBufferUsageFlags>(this->flags); }
  // Pointer to inheritance info for secondary command buffers
  void setInheritanceInfo(const CommandBufferInheritanceInfo* value) { this->pInheritanceInfo = std::bit_cast<const VkCommandBufferInheritanceInfo*>(value); }
  const CommandBufferInheritanceInfo* getInheritanceInfo() const { return std::bit_cast<const CommandBufferInheritanceInfo*>(this->pInheritanceInfo); }

#if VK_VERSION_1_1
  void attach(struct DeviceGroupCommandBufferBeginInfo&);
#endif // VK_VERSION_1_1
};
#endif // VK_VERSION_1_0

#if VK_QCOM_tile_memory_heap
struct TileMemoryBindInfoQCOM : VkTileMemoryBindInfoQCOM {
  TileMemoryBindInfoQCOM() noexcept : VkTileMemoryBindInfoQCOM{.sType = VK_STRUCTURE_TYPE_TILE_MEMORY_BIND_INFO_QCOM} {}

  void setMemory(DeviceMemory value) { this->memory = std::bit_cast<VkDeviceMemory>(value); }
  DeviceMemory getMemory() const { return std::bit_cast<DeviceMemory>(this->memory); }
};
inline void CommandBufferInheritanceInfo::attach(TileMemoryBindInfoQCOM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_QCOM_tile_memory_heap

#if VK_QCOM_render_pass_transform
struct CommandBufferInheritanceRenderPassTransformInfoQCOM : VkCommandBufferInheritanceRenderPassTransformInfoQCOM {
  CommandBufferInheritanceRenderPassTransformInfoQCOM() noexcept : VkCommandBufferInheritanceRenderPassTransformInfoQCOM{.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM} {}

  void setTransform(SurfaceTransformFlagBitsKHR value) { this->transform = std::bit_cast<VkSurfaceTransformFlagBitsKHR>(value); }
  SurfaceTransformFlagBitsKHR getTransform() const { return std::bit_cast<SurfaceTransformFlagBitsKHR>(this->transform); }
  void setRenderArea(const Rect2D& value) { this->renderArea = value; }
  const Rect2D& getRenderArea() const { return static_cast<const Rect2D&>(this->renderArea); }
};
inline void CommandBufferInheritanceInfo::attach(CommandBufferInheritanceRenderPassTransformInfoQCOM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_QCOM_render_pass_transform

#if VK_KHR_map_memory2
using MemoryMapInfoKHR = MemoryMapInfo;
#endif // VK_KHR_map_memory2

#if VK_EXT_map_memory_placed
struct MemoryMapPlacedInfoEXT : VkMemoryMapPlacedInfoEXT {
  MemoryMapPlacedInfoEXT() noexcept : VkMemoryMapPlacedInfoEXT{.sType = VK_STRUCTURE_TYPE_MEMORY_MAP_PLACED_INFO_EXT} {}

  void setPlacedAddress(void* value) { this->pPlacedAddress = value; }
  void* getPlacedAddress() const { return this->pPlacedAddress; }
};
inline void MemoryMapInfo::attach(MemoryMapPlacedInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_map_memory_placed

#if VK_KHR_create_renderpass2
using AttachmentReference2KHR = AttachmentReference2;
#endif // VK_KHR_create_renderpass2

#if VK_VERSION_1_2
struct AttachmentReferenceStencilLayout : VkAttachmentReferenceStencilLayout {
  AttachmentReferenceStencilLayout() noexcept : VkAttachmentReferenceStencilLayout{.sType = VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT} {}

  void setStencilLayout(ImageLayout value) { this->stencilLayout = std::bit_cast<VkImageLayout>(value); }
  ImageLayout getStencilLayout() const { return std::bit_cast<ImageLayout>(this->stencilLayout); }
};
inline void AttachmentReference2::attach(AttachmentReferenceStencilLayout& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }

struct SubpassDescription2 : VkSubpassDescription2 {
  SubpassDescription2() noexcept : VkSubpassDescription2{.sType = VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2} {}

  void setPipelineBindPoint(PipelineBindPoint value) { this->pipelineBindPoint = std::bit_cast<VkPipelineBindPoint>(value); }
  PipelineBindPoint getPipelineBindPoint() const { return std::bit_cast<PipelineBindPoint>(this->pipelineBindPoint); }
  void setViewMask(uint32_t value) { this->viewMask = value; }
  uint32_t getViewMask() const { return this->viewMask; }

  void setFlags(SubpassDescriptionFlags value) { this->flags = std::bit_cast<VkSubpassDescriptionFlags>(value); }
  SubpassDescriptionFlags getFlags() const { return std::bit_cast<SubpassDescriptionFlags>(this->flags); }
  void setInputAttachmentCount(uint32_t value) { this->inputAttachmentCount = value; }
  uint32_t getInputAttachmentCount() const { return this->inputAttachmentCount; }
  void setInputAttachments(const AttachmentReference2* value) { this->pInputAttachments = std::bit_cast<const VkAttachmentReference2*>(value); }
  const AttachmentReference2* getInputAttachments() const { return std::bit_cast<const AttachmentReference2*>(this->pInputAttachments); }
  void setColorAttachmentCount(uint32_t value) { this->colorAttachmentCount = value; }
  uint32_t getColorAttachmentCount() const { return this->colorAttachmentCount; }
  void setColorAttachments(const AttachmentReference2* value) { this->pColorAttachments = std::bit_cast<const VkAttachmentReference2*>(value); }
  const AttachmentReference2* getColorAttachments() const { return std::bit_cast<const AttachmentReference2*>(this->pColorAttachments); }
  void setResolveAttachments(const AttachmentReference2* value) { this->pResolveAttachments = std::bit_cast<const VkAttachmentReference2*>(value); }
  const AttachmentReference2* getResolveAttachments() const { return std::bit_cast<const AttachmentReference2*>(this->pResolveAttachments); }
  void setDepthStencilAttachment(const AttachmentReference2* value) { this->pDepthStencilAttachment = std::bit_cast<const VkAttachmentReference2*>(value); }
  const AttachmentReference2* getDepthStencilAttachment() const { return std::bit_cast<const AttachmentReference2*>(this->pDepthStencilAttachment); }
  void setPreserveAttachmentCount(uint32_t value) { this->preserveAttachmentCount = value; }
  uint32_t getPreserveAttachmentCount() const { return this->preserveAttachmentCount; }
  void setPreserveAttachments(const uint32_t* value) { this->pPreserveAttachments = value; }
  const uint32_t* getPreserveAttachments() const { return this->pPreserveAttachments; }

  void attach(struct SubpassDescriptionDepthStencilResolve&);
#if VK_KHR_fragment_shading_rate
  void attach(struct FragmentShadingRateAttachmentInfoKHR&);
#endif // VK_KHR_fragment_shading_rate
#if VK_EXT_multisampled_render_to_single_sampled
  void attach(struct MultisampledRenderToSingleSampledInfoEXT&);
#endif // VK_EXT_multisampled_render_to_single_sampled
#if VK_EXT_subpass_merge_feedback
  void attach(struct RenderPassCreationControlEXT&);
  void attach(struct RenderPassSubpassFeedbackCreateInfoEXT&);
#endif // VK_EXT_subpass_merge_feedback
};
#endif // VK_VERSION_1_2

#if VK_KHR_maintenance2
using InputAttachmentAspectReferenceKHR = InputAttachmentAspectReference;
#endif // VK_KHR_maintenance2

#if VK_VERSION_1_4
struct ImageSubresource2 : VkImageSubresource2 {
  ImageSubresource2() noexcept : VkImageSubresource2{.sType = VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2} {}

  void setImageSubresource(const ImageSubresource& value) { this->imageSubresource = value; }
  const ImageSubresource& getImageSubresource() const { return static_cast<const ImageSubresource&>(this->imageSubresource); }
};
#endif // VK_VERSION_1_4

#if VK_VERSION_1_0
struct SparseImageMemoryBind : VkSparseImageMemoryBind {
  SparseImageMemoryBind() noexcept : VkSparseImageMemoryBind{} {}

  void setSubresource(const ImageSubresource& value) { this->subresource = value; }
  const ImageSubresource& getSubresource() const { return static_cast<const ImageSubresource&>(this->subresource); }
  void setOffset(const Offset3D& value) { this->offset = value; }
  const Offset3D& getOffset() const { return static_cast<const Offset3D&>(this->offset); }
  void setExtent(const Extent3D& value) { this->extent = value; }
  const Extent3D& getExtent() const { return static_cast<const Extent3D&>(this->extent); }
  // Specified in bytes
  void setMemoryOffset(DeviceSize value) { this->memoryOffset = value; }
  DeviceSize getMemoryOffset() const { return this->memoryOffset; }

  void setMemory(DeviceMemory value) { this->memory = std::bit_cast<VkDeviceMemory>(value); }
  DeviceMemory getMemory() const { return std::bit_cast<DeviceMemory>(this->memory); }
  void setFlags(SparseMemoryBindFlags value) { this->flags = std::bit_cast<VkSparseMemoryBindFlags>(value); }
  SparseMemoryBindFlags getFlags() const { return std::bit_cast<SparseMemoryBindFlags>(this->flags); }
};
#endif // VK_VERSION_1_0

#if VK_VERSION_1_3
struct ImageBlit2 : VkImageBlit2 {
  ImageBlit2() noexcept : VkImageBlit2{.sType = VK_STRUCTURE_TYPE_IMAGE_BLIT_2} {}

  void setSrcSubresource(const ImageSubresourceLayers& value) { this->srcSubresource = value; }
  const ImageSubresourceLayers& getSrcSubresource() const { return static_cast<const ImageSubresourceLayers&>(this->srcSubresource); }
  // Specified in pixels for both compressed and uncompressed images
  void setSrcOffsets(std::span<const Offset3D, 2> value) { std::memcpy(&this->srcOffsets, value.data(), value.size_bytes()); }
  std::span<const Offset3D, 2> getSrcOffsets() const { return std::span<const Offset3D, 2>(std::bit_cast<const Offset3D*>(&this->srcOffsets), 2); }
  void setDstSubresource(const ImageSubresourceLayers& value) { this->dstSubresource = value; }
  const ImageSubresourceLayers& getDstSubresource() const { return static_cast<const ImageSubresourceLayers&>(this->dstSubresource); }
  // Specified in pixels for both compressed and uncompressed images
  void setDstOffsets(std::span<const Offset3D, 2> value) { std::memcpy(&this->dstOffsets, value.data(), value.size_bytes()); }
  std::span<const Offset3D, 2> getDstOffsets() const { return std::span<const Offset3D, 2>(std::bit_cast<const Offset3D*>(&this->dstOffsets), 2); }

#if VK_QCOM_rotated_copy_commands
  void attach(struct CopyCommandTransformInfoQCOM&);
#endif // VK_QCOM_rotated_copy_commands
};
#endif // VK_VERSION_1_3

#if VK_VERSION_1_4
struct MemoryToImageCopy : VkMemoryToImageCopy {
  MemoryToImageCopy() noexcept : VkMemoryToImageCopy{.sType = VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY} {}

  void setHostPointer(const void* value) { this->pHostPointer = value; }
  const void* getHostPointer() const { return this->pHostPointer; }
  // Specified in texels
  void setMemoryRowLength(uint32_t value) { this->memoryRowLength = value; }
  uint32_t getMemoryRowLength() const { return this->memoryRowLength; }
  void setMemoryImageHeight(uint32_t value) { this->memoryImageHeight = value; }
  uint32_t getMemoryImageHeight() const { return this->memoryImageHeight; }
  void setImageSubresource(const ImageSubresourceLayers& value) { this->imageSubresource = value; }
  const ImageSubresourceLayers& getImageSubresource() const { return static_cast<const ImageSubresourceLayers&>(this->imageSubresource); }
  void setImageOffset(const Offset3D& value) { this->imageOffset = value; }
  const Offset3D& getImageOffset() const { return static_cast<const Offset3D&>(this->imageOffset); }
  void setImageExtent(const Extent3D& value) { this->imageExtent = value; }
  const Extent3D& getImageExtent() const { return static_cast<const Extent3D&>(this->imageExtent); }
};

struct ImageToMemoryCopy : VkImageToMemoryCopy {
  ImageToMemoryCopy() noexcept : VkImageToMemoryCopy{.sType = VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY} {}

  void setHostPointer(void* value) { this->pHostPointer = value; }
  void* getHostPointer() const { return this->pHostPointer; }
  // Specified in texels
  void setMemoryRowLength(uint32_t value) { this->memoryRowLength = value; }
  uint32_t getMemoryRowLength() const { return this->memoryRowLength; }
  void setMemoryImageHeight(uint32_t value) { this->memoryImageHeight = value; }
  uint32_t getMemoryImageHeight() const { return this->memoryImageHeight; }
  void setImageSubresource(const ImageSubresourceLayers& value) { this->imageSubresource = value; }
  const ImageSubresourceLayers& getImageSubresource() const { return static_cast<const ImageSubresourceLayers&>(this->imageSubresource); }
  void setImageOffset(const Offset3D& value) { this->imageOffset = value; }
  const Offset3D& getImageOffset() const { return static_cast<const Offset3D&>(this->imageOffset); }
  void setImageExtent(const Extent3D& value) { this->imageExtent = value; }
  const Extent3D& getImageExtent() const { return static_cast<const Extent3D&>(this->imageExtent); }
};
#endif // VK_VERSION_1_4

#if VK_VERSION_1_3
struct BufferImageCopy2 : VkBufferImageCopy2 {
  BufferImageCopy2() noexcept : VkBufferImageCopy2{.sType = VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2} {}

  // Specified in bytes
  void setBufferOffset(DeviceSize value) { this->bufferOffset = value; }
  DeviceSize getBufferOffset() const { return this->bufferOffset; }
  // Specified in texels
  void setBufferRowLength(uint32_t value) { this->bufferRowLength = value; }
  uint32_t getBufferRowLength() const { return this->bufferRowLength; }
  void setBufferImageHeight(uint32_t value) { this->bufferImageHeight = value; }
  uint32_t getBufferImageHeight() const { return this->bufferImageHeight; }
  void setImageSubresource(const ImageSubresourceLayers& value) { this->imageSubresource = value; }
  const ImageSubresourceLayers& getImageSubresource() const { return static_cast<const ImageSubresourceLayers&>(this->imageSubresource); }
  // Specified in pixels for both compressed and uncompressed images
  void setImageOffset(const Offset3D& value) { this->imageOffset = value; }
  const Offset3D& getImageOffset() const { return static_cast<const Offset3D&>(this->imageOffset); }
  // Specified in pixels for both compressed and uncompressed images
  void setImageExtent(const Extent3D& value) { this->imageExtent = value; }
  const Extent3D& getImageExtent() const { return static_cast<const Extent3D&>(this->imageExtent); }

#if VK_QCOM_rotated_copy_commands
  void attach(struct CopyCommandTransformInfoQCOM&);
#endif // VK_QCOM_rotated_copy_commands
};

struct ImageCopy2 : VkImageCopy2 {
  ImageCopy2() noexcept : VkImageCopy2{.sType = VK_STRUCTURE_TYPE_IMAGE_COPY_2} {}

  void setSrcSubresource(const ImageSubresourceLayers& value) { this->srcSubresource = value; }
  const ImageSubresourceLayers& getSrcSubresource() const { return static_cast<const ImageSubresourceLayers&>(this->srcSubresource); }
  // Specified in pixels for both compressed and uncompressed images
  void setSrcOffset(const Offset3D& value) { this->srcOffset = value; }
  const Offset3D& getSrcOffset() const { return static_cast<const Offset3D&>(this->srcOffset); }
  void setDstSubresource(const ImageSubresourceLayers& value) { this->dstSubresource = value; }
  const ImageSubresourceLayers& getDstSubresource() const { return static_cast<const ImageSubresourceLayers&>(this->dstSubresource); }
  // Specified in pixels for both compressed and uncompressed images
  void setDstOffset(const Offset3D& value) { this->dstOffset = value; }
  const Offset3D& getDstOffset() const { return static_cast<const Offset3D&>(this->dstOffset); }
  // Specified in pixels for both compressed and uncompressed images
  void setExtent(const Extent3D& value) { this->extent = value; }
  const Extent3D& getExtent() const { return static_cast<const Extent3D&>(this->extent); }
};

struct ImageResolve2 : VkImageResolve2 {
  ImageResolve2() noexcept : VkImageResolve2{.sType = VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2} {}

  void setSrcSubresource(const ImageSubresourceLayers& value) { this->srcSubresource = value; }
  const ImageSubresourceLayers& getSrcSubresource() const { return static_cast<const ImageSubresourceLayers&>(this->srcSubresource); }
  void setSrcOffset(const Offset3D& value) { this->srcOffset = value; }
  const Offset3D& getSrcOffset() const { return static_cast<const Offset3D&>(this->srcOffset); }
  void setDstSubresource(const ImageSubresourceLayers& value) { this->dstSubresource = value; }
  const ImageSubresourceLayers& getDstSubresource() const { return static_cast<const ImageSubresourceLayers&>(this->dstSubresource); }
  void setDstOffset(const Offset3D& value) { this->dstOffset = value; }
  const Offset3D& getDstOffset() const { return static_cast<const Offset3D&>(this->dstOffset); }
  void setExtent(const Extent3D& value) { this->extent = value; }
  const Extent3D& getExtent() const { return static_cast<const Extent3D&>(this->extent); }
};
#endif // VK_VERSION_1_3

#if VK_VERSION_1_0
struct ImageCopy : VkImageCopy {
  ImageCopy() noexcept : VkImageCopy{} {}
  ImageCopy(const ImageSubresourceLayers& srcSubresource, const Offset3D& srcOffset, const ImageSubresourceLayers& dstSubresource, const Offset3D& dstOffset, const Extent3D& extent) noexcept : VkImageCopy{.srcSubresource = srcSubresource, .srcOffset = srcOffset, .dstSubresource = dstSubresource, .dstOffset = dstOffset, .extent = extent} {}

  void setSrcSubresource(const ImageSubresourceLayers& value) { this->srcSubresource = value; }
  const ImageSubresourceLayers& getSrcSubresource() const { return static_cast<const ImageSubresourceLayers&>(this->srcSubresource); }
  // Specified in pixels for both compressed and uncompressed images
  void setSrcOffset(const Offset3D& value) { this->srcOffset = value; }
  const Offset3D& getSrcOffset() const { return static_cast<const Offset3D&>(this->srcOffset); }
  void setDstSubresource(const ImageSubresourceLayers& value) { this->dstSubresource = value; }
  const ImageSubresourceLayers& getDstSubresource() const { return static_cast<const ImageSubresourceLayers&>(this->dstSubresource); }
  // Specified in pixels for both compressed and uncompressed images
  void setDstOffset(const Offset3D& value) { this->dstOffset = value; }
  const Offset3D& getDstOffset() const { return static_cast<const Offset3D&>(this->dstOffset); }
  // Specified in pixels for both compressed and uncompressed images
  void setExtent(const Extent3D& value) { this->extent = value; }
  const Extent3D& getExtent() const { return static_cast<const Extent3D&>(this->extent); }
};

struct ImageBlit : VkImageBlit {
  ImageBlit() noexcept : VkImageBlit{} {}
  ImageBlit(const ImageSubresourceLayers& srcSubresource, std::span<const Offset3D, 2> srcOffsets, const ImageSubresourceLayers& dstSubresource, std::span<const Offset3D, 2> dstOffsets) noexcept : VkImageBlit{.srcSubresource = srcSubresource, .dstSubresource = dstSubresource} { setSrcOffsets(srcOffsets); setDstOffsets(dstOffsets); }

  void setSrcSubresource(const ImageSubresourceLayers& value) { this->srcSubresource = value; }
  const ImageSubresourceLayers& getSrcSubresource() const { return static_cast<const ImageSubresourceLayers&>(this->srcSubresource); }
  // Specified in pixels for both compressed and uncompressed images
  void setSrcOffsets(std::span<const Offset3D, 2> value) { std::memcpy(&this->srcOffsets, value.data(), value.size_bytes()); }
  std::span<const Offset3D, 2> getSrcOffsets() const { return std::span<const Offset3D, 2>(std::bit_cast<const Offset3D*>(&this->srcOffsets), 2); }
  void setDstSubresource(const ImageSubresourceLayers& value) { this->dstSubresource = value; }
  const ImageSubresourceLayers& getDstSubresource() const { return static_cast<const ImageSubresourceLayers&>(this->dstSubresource); }
  // Specified in pixels for both compressed and uncompressed images
  void setDstOffsets(std::span<const Offset3D, 2> value) { std::memcpy(&this->dstOffsets, value.data(), value.size_bytes()); }
  std::span<const Offset3D, 2> getDstOffsets() const { return std::span<const Offset3D, 2>(std::bit_cast<const Offset3D*>(&this->dstOffsets), 2); }
};

struct BufferImageCopy : VkBufferImageCopy {
  BufferImageCopy() noexcept : VkBufferImageCopy{} {}
  BufferImageCopy(DeviceSize bufferOffset, uint32_t bufferRowLength, uint32_t bufferImageHeight, const ImageSubresourceLayers& imageSubresource, const Offset3D& imageOffset, const Extent3D& imageExtent) noexcept : VkBufferImageCopy{.bufferOffset = bufferOffset, .bufferRowLength = bufferRowLength, .bufferImageHeight = bufferImageHeight, .imageSubresource = imageSubresource, .imageOffset = imageOffset, .imageExtent = imageExtent} {}

  // Specified in bytes
  void setBufferOffset(DeviceSize value) { this->bufferOffset = value; }
  DeviceSize getBufferOffset() const { return this->bufferOffset; }
  // Specified in texels
  void setBufferRowLength(uint32_t value) { this->bufferRowLength = value; }
  uint32_t getBufferRowLength() const { return this->bufferRowLength; }
  void setBufferImageHeight(uint32_t value) { this->bufferImageHeight = value; }
  uint32_t getBufferImageHeight() const { return this->bufferImageHeight; }
  void setImageSubresource(const ImageSubresourceLayers& value) { this->imageSubresource = value; }
  const ImageSubresourceLayers& getImageSubresource() const { return static_cast<const ImageSubresourceLayers&>(this->imageSubresource); }
  // Specified in pixels for both compressed and uncompressed images
  void setImageOffset(const Offset3D& value) { this->imageOffset = value; }
  const Offset3D& getImageOffset() const { return static_cast<const Offset3D&>(this->imageOffset); }
  // Specified in pixels for both compressed and uncompressed images
  void setImageExtent(const Extent3D& value) { this->imageExtent = value; }
  const Extent3D& getImageExtent() const { return static_cast<const Extent3D&>(this->imageExtent); }
};
#endif // VK_VERSION_1_0

#if VK_NV_copy_memory_indirect
struct CopyMemoryToImageIndirectCommandNV : VkCopyMemoryToImageIndirectCommandNV {
  CopyMemoryToImageIndirectCommandNV() noexcept : VkCopyMemoryToImageIndirectCommandNV{} {}
  CopyMemoryToImageIndirectCommandNV(DeviceAddress srcAddress, uint32_t bufferRowLength, uint32_t bufferImageHeight, const ImageSubresourceLayers& imageSubresource, const Offset3D& imageOffset, const Extent3D& imageExtent) noexcept : VkCopyMemoryToImageIndirectCommandNV{.srcAddress = srcAddress, .bufferRowLength = bufferRowLength, .bufferImageHeight = bufferImageHeight, .imageSubresource = imageSubresource, .imageOffset = imageOffset, .imageExtent = imageExtent} {}

  void setSrcAddress(DeviceAddress value) { this->srcAddress = value; }
  DeviceAddress getSrcAddress() const { return this->srcAddress; }
  // Specified in texels
  void setBufferRowLength(uint32_t value) { this->bufferRowLength = value; }
  uint32_t getBufferRowLength() const { return this->bufferRowLength; }
  void setBufferImageHeight(uint32_t value) { this->bufferImageHeight = value; }
  uint32_t getBufferImageHeight() const { return this->bufferImageHeight; }
  void setImageSubresource(const ImageSubresourceLayers& value) { this->imageSubresource = value; }
  const ImageSubresourceLayers& getImageSubresource() const { return static_cast<const ImageSubresourceLayers&>(this->imageSubresource); }
  // Specified in pixels for both compressed and uncompressed images
  void setImageOffset(const Offset3D& value) { this->imageOffset = value; }
  const Offset3D& getImageOffset() const { return static_cast<const Offset3D&>(this->imageOffset); }
  // Specified in pixels for both compressed and uncompressed images
  void setImageExtent(const Extent3D& value) { this->imageExtent = value; }
  const Extent3D& getImageExtent() const { return static_cast<const Extent3D&>(this->imageExtent); }
};
#endif // VK_NV_copy_memory_indirect

#if VK_VERSION_1_0
struct ImageResolve : VkImageResolve {
  ImageResolve() noexcept : VkImageResolve{} {}
  ImageResolve(const ImageSubresourceLayers& srcSubresource, const Offset3D& srcOffset, const ImageSubresourceLayers& dstSubresource, const Offset3D& dstOffset, const Extent3D& extent) noexcept : VkImageResolve{.srcSubresource = srcSubresource, .srcOffset = srcOffset, .dstSubresource = dstSubresource, .dstOffset = dstOffset, .extent = extent} {}

  void setSrcSubresource(const ImageSubresourceLayers& value) { this->srcSubresource = value; }
  const ImageSubresourceLayers& getSrcSubresource() const { return static_cast<const ImageSubresourceLayers&>(this->srcSubresource); }
  void setSrcOffset(const Offset3D& value) { this->srcOffset = value; }
  const Offset3D& getSrcOffset() const { return static_cast<const Offset3D&>(this->srcOffset); }
  void setDstSubresource(const ImageSubresourceLayers& value) { this->dstSubresource = value; }
  const ImageSubresourceLayers& getDstSubresource() const { return static_cast<const ImageSubresourceLayers&>(this->dstSubresource); }
  void setDstOffset(const Offset3D& value) { this->dstOffset = value; }
  const Offset3D& getDstOffset() const { return static_cast<const Offset3D&>(this->dstOffset); }
  void setExtent(const Extent3D& value) { this->extent = value; }
  const Extent3D& getExtent() const { return static_cast<const Extent3D&>(this->extent); }
};
#endif // VK_VERSION_1_0

#if VK_VERSION_1_4
struct HostImageLayoutTransitionInfo : VkHostImageLayoutTransitionInfo {
  HostImageLayoutTransitionInfo() noexcept : VkHostImageLayoutTransitionInfo{.sType = VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO} {}

  void setImage(Image value) { this->image = std::bit_cast<VkImage>(value); }
  Image getImage() const { return std::bit_cast<Image>(this->image); }
  void setOldLayout(ImageLayout value) { this->oldLayout = std::bit_cast<VkImageLayout>(value); }
  ImageLayout getOldLayout() const { return std::bit_cast<ImageLayout>(this->oldLayout); }
  void setNewLayout(ImageLayout value) { this->newLayout = std::bit_cast<VkImageLayout>(value); }
  ImageLayout getNewLayout() const { return std::bit_cast<ImageLayout>(this->newLayout); }
  void setSubresourceRange(const ImageSubresourceRange& value) { this->subresourceRange = value; }
  const ImageSubresourceRange& getSubresourceRange() const { return static_cast<const ImageSubresourceRange&>(this->subresourceRange); }
};
#endif // VK_VERSION_1_4

#if VK_VERSION_1_3
struct ImageMemoryBarrier2 : VkImageMemoryBarrier2 {
  ImageMemoryBarrier2() noexcept : VkImageMemoryBarrier2{.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2} {}

  void setOldLayout(ImageLayout value) { this->oldLayout = std::bit_cast<VkImageLayout>(value); }
  ImageLayout getOldLayout() const { return std::bit_cast<ImageLayout>(this->oldLayout); }
  void setNewLayout(ImageLayout value) { this->newLayout = std::bit_cast<VkImageLayout>(value); }
  ImageLayout getNewLayout() const { return std::bit_cast<ImageLayout>(this->newLayout); }
  void setSrcQueueFamilyIndex(uint32_t value) { this->srcQueueFamilyIndex = value; }
  uint32_t getSrcQueueFamilyIndex() const { return this->srcQueueFamilyIndex; }
  void setDstQueueFamilyIndex(uint32_t value) { this->dstQueueFamilyIndex = value; }
  uint32_t getDstQueueFamilyIndex() const { return this->dstQueueFamilyIndex; }
  void setImage(Image value) { this->image = std::bit_cast<VkImage>(value); }
  Image getImage() const { return std::bit_cast<Image>(this->image); }
  void setSubresourceRange(const ImageSubresourceRange& value) { this->subresourceRange = value; }
  const ImageSubresourceRange& getSubresourceRange() const { return static_cast<const ImageSubresourceRange&>(this->subresourceRange); }

  void setSrcStageMask(PipelineStageFlags2 value) { this->srcStageMask = std::bit_cast<VkPipelineStageFlags2>(value); }
  PipelineStageFlags2 getSrcStageMask() const { return std::bit_cast<PipelineStageFlags2>(this->srcStageMask); }
  void setSrcAccessMask(AccessFlags2 value) { this->srcAccessMask = std::bit_cast<VkAccessFlags2>(value); }
  AccessFlags2 getSrcAccessMask() const { return std::bit_cast<AccessFlags2>(this->srcAccessMask); }
  void setDstStageMask(PipelineStageFlags2 value) { this->dstStageMask = std::bit_cast<VkPipelineStageFlags2>(value); }
  PipelineStageFlags2 getDstStageMask() const { return std::bit_cast<PipelineStageFlags2>(this->dstStageMask); }
  void setDstAccessMask(AccessFlags2 value) { this->dstAccessMask = std::bit_cast<VkAccessFlags2>(value); }
  AccessFlags2 getDstAccessMask() const { return std::bit_cast<AccessFlags2>(this->dstAccessMask); }

#if VK_EXT_sample_locations
  void attach(struct SampleLocationsInfoEXT&);
#endif // VK_EXT_sample_locations
#if VK_KHR_maintenance8
  void attach(struct MemoryBarrierAccessFlags3KHR&);
#endif // VK_KHR_maintenance8
#if VK_EXT_external_memory_acquire_unmodified
  void attach(struct ExternalMemoryAcquireUnmodifiedEXT&);
#endif // VK_EXT_external_memory_acquire_unmodified
};
#endif // VK_VERSION_1_3

#if VK_VERSION_1_0
struct ImageMemoryBarrier : VkImageMemoryBarrier {
  ImageMemoryBarrier() noexcept : VkImageMemoryBarrier{.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER} {}

  // Memory accesses from the source of the dependency to synchronize
  void setSrcAccessMask(AccessFlags value) { this->srcAccessMask = std::bit_cast<VkAccessFlags>(value); }
  AccessFlags getSrcAccessMask() const { return std::bit_cast<AccessFlags>(this->srcAccessMask); }
  // Memory accesses from the destination of the dependency to synchronize
  void setDstAccessMask(AccessFlags value) { this->dstAccessMask = std::bit_cast<VkAccessFlags>(value); }
  AccessFlags getDstAccessMask() const { return std::bit_cast<AccessFlags>(this->dstAccessMask); }
  // Current layout of the image
  void setOldLayout(ImageLayout value) { this->oldLayout = std::bit_cast<VkImageLayout>(value); }
  ImageLayout getOldLayout() const { return std::bit_cast<ImageLayout>(this->oldLayout); }
  // New layout to transition the image to
  void setNewLayout(ImageLayout value) { this->newLayout = std::bit_cast<VkImageLayout>(value); }
  ImageLayout getNewLayout() const { return std::bit_cast<ImageLayout>(this->newLayout); }
  // Queue family to transition ownership from
  void setSrcQueueFamilyIndex(uint32_t value) { this->srcQueueFamilyIndex = value; }
  uint32_t getSrcQueueFamilyIndex() const { return this->srcQueueFamilyIndex; }
  // Queue family to transition ownership to
  void setDstQueueFamilyIndex(uint32_t value) { this->dstQueueFamilyIndex = value; }
  uint32_t getDstQueueFamilyIndex() const { return this->dstQueueFamilyIndex; }
  // Image to sync
  void setImage(Image value) { this->image = std::bit_cast<VkImage>(value); }
  Image getImage() const { return std::bit_cast<Image>(this->image); }
  // Subresource range to sync
  void setSubresourceRange(const ImageSubresourceRange& value) { this->subresourceRange = value; }
  const ImageSubresourceRange& getSubresourceRange() const { return static_cast<const ImageSubresourceRange&>(this->subresourceRange); }

#if VK_EXT_sample_locations
  void attach(struct SampleLocationsInfoEXT&);
#endif // VK_EXT_sample_locations
#if VK_EXT_external_memory_acquire_unmodified
  void attach(struct ExternalMemoryAcquireUnmodifiedEXT&);
#endif // VK_EXT_external_memory_acquire_unmodified
};

struct ImageViewCreateInfo : VkImageViewCreateInfo {
  ImageViewCreateInfo() noexcept : VkImageViewCreateInfo{.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO} {}

  void setImage(Image value) { this->image = std::bit_cast<VkImage>(value); }
  Image getImage() const { return std::bit_cast<Image>(this->image); }
  void setViewType(ImageViewType value) { this->viewType = std::bit_cast<VkImageViewType>(value); }
  ImageViewType getViewType() const { return std::bit_cast<ImageViewType>(this->viewType); }
  void setFormat(Format value) { this->format = std::bit_cast<VkFormat>(value); }
  Format getFormat() const { return std::bit_cast<Format>(this->format); }
  void setComponents(const ComponentMapping& value) { this->components = value; }
  const ComponentMapping& getComponents() const { return static_cast<const ComponentMapping&>(this->components); }
  void setSubresourceRange(const ImageSubresourceRange& value) { this->subresourceRange = value; }
  const ImageSubresourceRange& getSubresourceRange() const { return static_cast<const ImageSubresourceRange&>(this->subresourceRange); }

  void setFlags(ImageViewCreateFlags value) { this->flags = std::bit_cast<VkImageViewCreateFlags>(value); }
  ImageViewCreateFlags getFlags() const { return std::bit_cast<ImageViewCreateFlags>(this->flags); }

#if VK_VERSION_1_1
  void attach(struct ImageViewUsageCreateInfo&);
#endif // VK_VERSION_1_1
#if VK_EXT_image_sliced_view_of_3d
  void attach(struct ImageViewSlicedCreateInfoEXT&);
#endif // VK_EXT_image_sliced_view_of_3d
#if VK_VERSION_1_1
  void attach(struct SamplerYcbcrConversionInfo&);
#endif // VK_VERSION_1_1
#if VK_EXT_astc_decode_mode
  void attach(struct ImageViewASTCDecodeModeEXT&);
#endif // VK_EXT_astc_decode_mode
#if VK_EXT_descriptor_buffer
  void attach(struct OpaqueCaptureDescriptorDataCreateInfoEXT&);
#endif // VK_EXT_descriptor_buffer
#if VK_EXT_image_view_min_lod
  void attach(struct ImageViewMinLodCreateInfoEXT&);
#endif // VK_EXT_image_view_min_lod
#if VK_EXT_metal_objects
  void attach(struct ExportMetalObjectCreateInfoEXT&);
#endif // VK_EXT_metal_objects
#if VK_QCOM_image_processing
  void attach(struct ImageViewSampleWeightCreateInfoQCOM&);
#endif // VK_QCOM_image_processing
};
#endif // VK_VERSION_1_0

#if VK_VERSION_1_1
struct SparseImageFormatProperties2 : VkSparseImageFormatProperties2 {
  SparseImageFormatProperties2() noexcept : VkSparseImageFormatProperties2{.sType = VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2} {}

  const SparseImageFormatProperties& getProperties() const { return static_cast<const SparseImageFormatProperties&>(this->properties); }
};
#endif // VK_VERSION_1_1

#if VK_VERSION_1_0
struct SparseImageMemoryRequirements : VkSparseImageMemoryRequirements {
  SparseImageMemoryRequirements() noexcept : VkSparseImageMemoryRequirements{} {}

  const SparseImageFormatProperties& getFormatProperties() const { return static_cast<const SparseImageFormatProperties&>(this->formatProperties); }
  uint32_t getImageMipTailFirstLod() const { return this->imageMipTailFirstLod; }
  // Specified in bytes, must be a multiple of sparse block size in bytes / alignment
  DeviceSize getImageMipTailSize() const { return this->imageMipTailSize; }
  // Specified in bytes, must be a multiple of sparse block size in bytes / alignment
  DeviceSize getImageMipTailOffset() const { return this->imageMipTailOffset; }
  // Specified in bytes, must be a multiple of sparse block size in bytes / alignment
  DeviceSize getImageMipTailStride() const { return this->imageMipTailStride; }
};

struct SparseBufferMemoryBindInfo : VkSparseBufferMemoryBindInfo {
  SparseBufferMemoryBindInfo() noexcept : VkSparseBufferMemoryBindInfo{} {}
  SparseBufferMemoryBindInfo(Buffer buffer, uint32_t bindCount, const SparseMemoryBind* pBinds) noexcept : VkSparseBufferMemoryBindInfo{.buffer = std::bit_cast<VkBuffer>(buffer), .bindCount = bindCount, .pBinds = std::bit_cast<const VkSparseMemoryBind*>(pBinds)} {}

  void setBuffer(Buffer value) { this->buffer = std::bit_cast<VkBuffer>(value); }
  Buffer getBuffer() const { return std::bit_cast<Buffer>(this->buffer); }
  void setBindCount(uint32_t value) { this->bindCount = value; }
  uint32_t getBindCount() const { return this->bindCount; }
  void setBinds(const SparseMemoryBind* value) { this->pBinds = std::bit_cast<const VkSparseMemoryBind*>(value); }
  const SparseMemoryBind* getBinds() const { return std::bit_cast<const SparseMemoryBind*>(this->pBinds); }
};

struct SparseImageOpaqueMemoryBindInfo : VkSparseImageOpaqueMemoryBindInfo {
  SparseImageOpaqueMemoryBindInfo() noexcept : VkSparseImageOpaqueMemoryBindInfo{} {}
  SparseImageOpaqueMemoryBindInfo(Image image, uint32_t bindCount, const SparseMemoryBind* pBinds) noexcept : VkSparseImageOpaqueMemoryBindInfo{.image = std::bit_cast<VkImage>(image), .bindCount = bindCount, .pBinds = std::bit_cast<const VkSparseMemoryBind*>(pBinds)} {}

  void setImage(Image value) { this->image = std::bit_cast<VkImage>(value); }
  Image getImage() const { return std::bit_cast<Image>(this->image); }
  void setBindCount(uint32_t value) { this->bindCount = value; }
  uint32_t getBindCount() const { return this->bindCount; }
  void setBinds(const SparseMemoryBind* value) { this->pBinds = std::bit_cast<const VkSparseMemoryBind*>(value); }
  const SparseMemoryBind* getBinds() const { return std::bit_cast<const SparseMemoryBind*>(this->pBinds); }
};
#endif // VK_VERSION_1_0

#if VK_VERSION_1_1
struct ImageFormatProperties2 : VkImageFormatProperties2 {
  ImageFormatProperties2() noexcept : VkImageFormatProperties2{.sType = VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2} {}

  const ImageFormatProperties& getImageFormatProperties() const { return static_cast<const ImageFormatProperties&>(this->imageFormatProperties); }

  void attach(struct ExternalImageFormatProperties&);
  void attach(struct SamplerYcbcrConversionImageFormatProperties&);
#if VK_AMD_texture_gather_bias_lod
  void attach(struct TextureLODGatherFormatPropertiesAMD&);
#endif // VK_AMD_texture_gather_bias_lod
#if VK_ANDROID_external_memory_android_hardware_buffer
  void attach(struct AndroidHardwareBufferUsageANDROID&);
#endif // VK_ANDROID_external_memory_android_hardware_buffer
#if VK_EXT_filter_cubic
  void attach(struct FilterCubicImageViewImageFormatPropertiesEXT&);
#endif // VK_EXT_filter_cubic
#if VK_VERSION_1_4
  void attach(struct HostImageCopyDevicePerformanceQuery&);
#endif // VK_VERSION_1_4
#if VK_EXT_image_compression_control
  void attach(struct ImageCompressionPropertiesEXT&);
#endif // VK_EXT_image_compression_control
};
#endif // VK_VERSION_1_1

#if VK_VERSION_1_0
struct PhysicalDeviceProperties : VkPhysicalDeviceProperties {
  PhysicalDeviceProperties() noexcept : VkPhysicalDeviceProperties{} {}

  uint32_t getApiVersion() const { return this->apiVersion; }
  uint32_t getDriverVersion() const { return this->driverVersion; }
  uint32_t getVendorID() const { return this->vendorID; }
  uint32_t getDeviceID() const { return this->deviceID; }
  PhysicalDeviceType getDeviceType() const { return std::bit_cast<PhysicalDeviceType>(this->deviceType); }
  std::string_view getDeviceName() const { return this->deviceName; }
  std::span<const uint8_t, VK_UUID_SIZE> getPipelineCacheUUID() const { return this->pipelineCacheUUID; }
  const PhysicalDeviceLimits& getLimits() const { return static_cast<const PhysicalDeviceLimits&>(this->limits); }
  const PhysicalDeviceSparseProperties& getSparseProperties() const { return static_cast<const PhysicalDeviceSparseProperties&>(this->sparseProperties); }
};
#endif // VK_VERSION_1_0

#if VK_VERSION_1_2
struct AttachmentDescriptionStencilLayout : VkAttachmentDescriptionStencilLayout {
  AttachmentDescriptionStencilLayout() noexcept : VkAttachmentDescriptionStencilLayout{.sType = VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT} {}

  void setStencilInitialLayout(ImageLayout value) { this->stencilInitialLayout = std::bit_cast<VkImageLayout>(value); }
  ImageLayout getStencilInitialLayout() const { return std::bit_cast<ImageLayout>(this->stencilInitialLayout); }
  void setStencilFinalLayout(ImageLayout value) { this->stencilFinalLayout = std::bit_cast<VkImageLayout>(value); }
  ImageLayout getStencilFinalLayout() const { return std::bit_cast<ImageLayout>(this->stencilFinalLayout); }
};
inline void AttachmentDescription2::attach(AttachmentDescriptionStencilLayout& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_2

#if VK_KHR_create_renderpass2
using AttachmentDescription2KHR = AttachmentDescription2;
#endif // VK_KHR_create_renderpass2

#if VK_VERSION_1_3
struct DescriptorPoolInlineUniformBlockCreateInfo : VkDescriptorPoolInlineUniformBlockCreateInfo {
  DescriptorPoolInlineUniformBlockCreateInfo() noexcept : VkDescriptorPoolInlineUniformBlockCreateInfo{.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO} {}

  void setMaxInlineUniformBlockBindings(uint32_t value) { this->maxInlineUniformBlockBindings = value; }
  uint32_t getMaxInlineUniformBlockBindings() const { return this->maxInlineUniformBlockBindings; }
};
inline void DescriptorPoolCreateInfo::attach(DescriptorPoolInlineUniformBlockCreateInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_3

#if VK_KHR_create_renderpass2
using SubpassDependency2KHR = SubpassDependency2;
#endif // VK_KHR_create_renderpass2

#if VK_VERSION_1_3
struct MemoryBarrier2 : VkMemoryBarrier2 {
  MemoryBarrier2() noexcept : VkMemoryBarrier2{.sType = VK_STRUCTURE_TYPE_MEMORY_BARRIER_2} {}

  void setSrcStageMask(PipelineStageFlags2 value) { this->srcStageMask = std::bit_cast<VkPipelineStageFlags2>(value); }
  PipelineStageFlags2 getSrcStageMask() const { return std::bit_cast<PipelineStageFlags2>(this->srcStageMask); }
  void setSrcAccessMask(AccessFlags2 value) { this->srcAccessMask = std::bit_cast<VkAccessFlags2>(value); }
  AccessFlags2 getSrcAccessMask() const { return std::bit_cast<AccessFlags2>(this->srcAccessMask); }
  void setDstStageMask(PipelineStageFlags2 value) { this->dstStageMask = std::bit_cast<VkPipelineStageFlags2>(value); }
  PipelineStageFlags2 getDstStageMask() const { return std::bit_cast<PipelineStageFlags2>(this->dstStageMask); }
  void setDstAccessMask(AccessFlags2 value) { this->dstAccessMask = std::bit_cast<VkAccessFlags2>(value); }
  AccessFlags2 getDstAccessMask() const { return std::bit_cast<AccessFlags2>(this->dstAccessMask); }
};
inline void SubpassDependency2::attach(MemoryBarrier2& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_3

#if VK_KHR_timeline_semaphore
using SemaphoreWaitInfoKHR = SemaphoreWaitInfo;
#endif // VK_KHR_timeline_semaphore

#if VK_KHR_get_display_properties2
struct DisplayPlaneCapabilities2KHR : VkDisplayPlaneCapabilities2KHR {
  DisplayPlaneCapabilities2KHR() noexcept : VkDisplayPlaneCapabilities2KHR{.sType = VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR} {}

  const DisplayPlaneCapabilitiesKHR& getCapabilities() const { return static_cast<const DisplayPlaneCapabilitiesKHR&>(this->capabilities); }
};

struct DisplayProperties2KHR : VkDisplayProperties2KHR {
  DisplayProperties2KHR() noexcept : VkDisplayProperties2KHR{.sType = VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR} {}

  const DisplayPropertiesKHR& getDisplayProperties() const { return static_cast<const DisplayPropertiesKHR&>(this->displayProperties); }
};
#endif // VK_KHR_get_display_properties2

#if VK_KHR_get_surface_capabilities2
struct SurfaceCapabilities2KHR : VkSurfaceCapabilities2KHR {
  SurfaceCapabilities2KHR() noexcept : VkSurfaceCapabilities2KHR{.sType = VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR} {}

  const SurfaceCapabilitiesKHR& getSurfaceCapabilities() const { return static_cast<const SurfaceCapabilitiesKHR&>(this->surfaceCapabilities); }

#if VK_AMD_display_native_hdr
  void attach(struct DisplayNativeHdrSurfaceCapabilitiesAMD&);
#endif // VK_AMD_display_native_hdr
  void attach(struct SharedPresentSurfaceCapabilitiesKHR&);
#if VK_KHR_surface_protected_capabilities
  void attach(struct SurfaceProtectedCapabilitiesKHR&);
#endif // VK_KHR_surface_protected_capabilities
#if VK_EXT_full_screen_exclusive
  void attach(struct SurfaceCapabilitiesFullScreenExclusiveEXT&);
#endif // VK_EXT_full_screen_exclusive
#if VK_NV_present_barrier
  void attach(struct SurfaceCapabilitiesPresentBarrierNV&);
#endif // VK_NV_present_barrier
#if VK_KHR_present_id2
  void attach(struct SurfaceCapabilitiesPresentId2KHR&);
#endif // VK_KHR_present_id2
#if VK_KHR_present_wait2
  void attach(struct SurfaceCapabilitiesPresentWait2KHR&);
#endif // VK_KHR_present_wait2
#if VK_KHR_surface_maintenance1
  void attach(struct SurfacePresentScalingCapabilitiesKHR&);
  void attach(struct SurfacePresentModeCompatibilityKHR&);
#endif // VK_KHR_surface_maintenance1
#if VK_NV_low_latency2
  void attach(struct LatencySurfaceCapabilitiesNV&);
#endif // VK_NV_low_latency2
};
#endif // VK_KHR_get_surface_capabilities2

#if VK_NV_device_generated_commands
struct IndirectCommandsLayoutCreateInfoNV : VkIndirectCommandsLayoutCreateInfoNV {
  IndirectCommandsLayoutCreateInfoNV() noexcept : VkIndirectCommandsLayoutCreateInfoNV{.sType = VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV} {}

  void setPipelineBindPoint(PipelineBindPoint value) { this->pipelineBindPoint = std::bit_cast<VkPipelineBindPoint>(value); }
  PipelineBindPoint getPipelineBindPoint() const { return std::bit_cast<PipelineBindPoint>(this->pipelineBindPoint); }
  void setTokenCount(uint32_t value) { this->tokenCount = value; }
  uint32_t getTokenCount() const { return this->tokenCount; }
  void setTokens(const IndirectCommandsLayoutTokenNV* value) { this->pTokens = std::bit_cast<const VkIndirectCommandsLayoutTokenNV*>(value); }
  const IndirectCommandsLayoutTokenNV* getTokens() const { return std::bit_cast<const IndirectCommandsLayoutTokenNV*>(this->pTokens); }
  void setStreamCount(uint32_t value) { this->streamCount = value; }
  uint32_t getStreamCount() const { return this->streamCount; }
  void setStreamStrides(const uint32_t* value) { this->pStreamStrides = value; }
  const uint32_t* getStreamStrides() const { return this->pStreamStrides; }

  void setFlags(IndirectCommandsLayoutUsageFlagsNV value) { this->flags = std::bit_cast<VkIndirectCommandsLayoutUsageFlagsNV>(value); }
  IndirectCommandsLayoutUsageFlagsNV getFlags() const { return std::bit_cast<IndirectCommandsLayoutUsageFlagsNV>(this->flags); }
};
#endif // VK_NV_device_generated_commands

#if VK_KHR_external_memory
using ExportMemoryAllocateInfoKHR = ExportMemoryAllocateInfo;
#endif // VK_KHR_external_memory

#if VK_ARM_tensors
struct ExternalTensorPropertiesARM : VkExternalTensorPropertiesARM {
  ExternalTensorPropertiesARM() noexcept : VkExternalTensorPropertiesARM{.sType = VK_STRUCTURE_TYPE_EXTERNAL_TENSOR_PROPERTIES_ARM} {}

  void setExternalMemoryProperties(const ExternalMemoryProperties& value) { this->externalMemoryProperties = value; }
  const ExternalMemoryProperties& getExternalMemoryProperties() const { return static_cast<const ExternalMemoryProperties&>(this->externalMemoryProperties); }
};
#endif // VK_ARM_tensors

#if VK_KHR_external_memory_capabilities
using ExternalMemoryPropertiesKHR = ExternalMemoryProperties;
#endif // VK_KHR_external_memory_capabilities

#if VK_VERSION_1_1
struct ExternalBufferProperties : VkExternalBufferProperties {
  ExternalBufferProperties() noexcept : VkExternalBufferProperties{.sType = VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES} {}

  const ExternalMemoryProperties& getExternalMemoryProperties() const { return static_cast<const ExternalMemoryProperties&>(this->externalMemoryProperties); }
};
#endif // VK_VERSION_1_1

#if VK_KHR_external_semaphore
using ExportSemaphoreCreateInfoKHR = ExportSemaphoreCreateInfo;
#endif // VK_KHR_external_semaphore
#if VK_KHR_timeline_semaphore
using SemaphoreTypeCreateInfoKHR = SemaphoreTypeCreateInfo;
#endif // VK_KHR_timeline_semaphore
#if VK_KHR_external_semaphore_capabilities
using ExternalSemaphorePropertiesKHR = ExternalSemaphoreProperties;
#endif // VK_KHR_external_semaphore_capabilities
#if VK_KHR_external_fence_capabilities
using ExternalFencePropertiesKHR = ExternalFenceProperties;
#endif // VK_KHR_external_fence_capabilities
#if VK_KHR_device_group
using MemoryAllocateFlagsInfoKHR = MemoryAllocateFlagsInfo;
#endif // VK_KHR_device_group

#if VK_EXT_full_screen_exclusive
struct SurfaceFullScreenExclusiveWin32InfoEXT : VkSurfaceFullScreenExclusiveWin32InfoEXT {
  SurfaceFullScreenExclusiveWin32InfoEXT() noexcept : VkSurfaceFullScreenExclusiveWin32InfoEXT{.sType = VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT} {}

  void setHmonitor(HMONITOR value) { this->hmonitor = value; }
  HMONITOR getHmonitor() const { return this->hmonitor; }
};
inline void PhysicalDeviceSurfaceInfo2KHR::attach(SurfaceFullScreenExclusiveWin32InfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void SwapchainCreateInfoKHR::attach(SurfaceFullScreenExclusiveWin32InfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_full_screen_exclusive

#if VK_EXT_image_compression_control
struct ImageCompressionControlEXT : VkImageCompressionControlEXT {
  ImageCompressionControlEXT() noexcept : VkImageCompressionControlEXT{.sType = VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT} {}

  void setFlags(ImageCompressionFlagsEXT value) { this->flags = std::bit_cast<VkImageCompressionFlagsEXT>(value); }
  ImageCompressionFlagsEXT getFlags() const { return std::bit_cast<ImageCompressionFlagsEXT>(this->flags); }

  void setCompressionControlPlaneCount(uint32_t value) { this->compressionControlPlaneCount = value; }
  uint32_t getCompressionControlPlaneCount() const { return this->compressionControlPlaneCount; }
  void setFixedRateFlags(ImageCompressionFixedRateFlagsEXT* value) { this->pFixedRateFlags = std::bit_cast<VkImageCompressionFixedRateFlagsEXT*>(value); }
  ImageCompressionFixedRateFlagsEXT* getFixedRateFlags() const { return std::bit_cast<ImageCompressionFixedRateFlagsEXT*>(this->pFixedRateFlags); }
};
inline void ImageCreateInfo::attach(ImageCompressionControlEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void SwapchainCreateInfoKHR::attach(ImageCompressionControlEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void PhysicalDeviceImageFormatInfo2::attach(ImageCompressionControlEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_image_compression_control

#if VK_KHR_swapchain_maintenance1
struct SwapchainPresentModesCreateInfoKHR : VkSwapchainPresentModesCreateInfoKHR {
  SwapchainPresentModesCreateInfoKHR() noexcept : VkSwapchainPresentModesCreateInfoKHR{.sType = VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_KHR} {}

  void setPresentModeCount(uint32_t value) { this->presentModeCount = value; }
  uint32_t getPresentModeCount() const { return this->presentModeCount; }
  void setPresentModes(const PresentModeKHR* value) { this->pPresentModes = std::bit_cast<const VkPresentModeKHR*>(value); }
  const PresentModeKHR* getPresentModes() const { return std::bit_cast<const PresentModeKHR*>(this->pPresentModes); }
};
inline void SwapchainCreateInfoKHR::attach(SwapchainPresentModesCreateInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }

struct SwapchainPresentScalingCreateInfoKHR : VkSwapchainPresentScalingCreateInfoKHR {
  SwapchainPresentScalingCreateInfoKHR() noexcept : VkSwapchainPresentScalingCreateInfoKHR{.sType = VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_KHR} {}

  void setScalingBehavior(PresentScalingFlagsKHR value) { this->scalingBehavior = std::bit_cast<VkPresentScalingFlagsKHR>(value); }
  PresentScalingFlagsKHR getScalingBehavior() const { return std::bit_cast<PresentScalingFlagsKHR>(this->scalingBehavior); }
  void setPresentGravityX(PresentGravityFlagsKHR value) { this->presentGravityX = std::bit_cast<VkPresentGravityFlagsKHR>(value); }
  PresentGravityFlagsKHR getPresentGravityX() const { return std::bit_cast<PresentGravityFlagsKHR>(this->presentGravityX); }
  void setPresentGravityY(PresentGravityFlagsKHR value) { this->presentGravityY = std::bit_cast<VkPresentGravityFlagsKHR>(value); }
  PresentGravityFlagsKHR getPresentGravityY() const { return std::bit_cast<PresentGravityFlagsKHR>(this->presentGravityY); }
};
inline void SwapchainCreateInfoKHR::attach(SwapchainPresentScalingCreateInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_swapchain_maintenance1

#if VK_EXT_full_screen_exclusive
struct SurfaceFullScreenExclusiveInfoEXT : VkSurfaceFullScreenExclusiveInfoEXT {
  SurfaceFullScreenExclusiveInfoEXT() noexcept : VkSurfaceFullScreenExclusiveInfoEXT{.sType = VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT} {}

  void setFullScreenExclusive(FullScreenExclusiveEXT value) { this->fullScreenExclusive = std::bit_cast<VkFullScreenExclusiveEXT>(value); }
  FullScreenExclusiveEXT getFullScreenExclusive() const { return std::bit_cast<FullScreenExclusiveEXT>(this->fullScreenExclusive); }
};
inline void PhysicalDeviceSurfaceInfo2KHR::attach(SurfaceFullScreenExclusiveInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void SwapchainCreateInfoKHR::attach(SurfaceFullScreenExclusiveInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_full_screen_exclusive

#if VK_NV_low_latency2
struct SwapchainLatencyCreateInfoNV : VkSwapchainLatencyCreateInfoNV {
  SwapchainLatencyCreateInfoNV() noexcept : VkSwapchainLatencyCreateInfoNV{.sType = VK_STRUCTURE_TYPE_SWAPCHAIN_LATENCY_CREATE_INFO_NV} {}

  void setLatencyModeEnable(Bool32 value) { this->latencyModeEnable = value; }
  Bool32 getLatencyModeEnable() const { return this->latencyModeEnable; }
};
inline void SwapchainCreateInfoKHR::attach(SwapchainLatencyCreateInfoNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_low_latency2

#if VK_AMD_display_native_hdr
struct SwapchainDisplayNativeHdrCreateInfoAMD : VkSwapchainDisplayNativeHdrCreateInfoAMD {
  SwapchainDisplayNativeHdrCreateInfoAMD() noexcept : VkSwapchainDisplayNativeHdrCreateInfoAMD{.sType = VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD} {}

  void setLocalDimmingEnable(Bool32 value) { this->localDimmingEnable = value; }
  Bool32 getLocalDimmingEnable() const { return this->localDimmingEnable; }
};
inline void SwapchainCreateInfoKHR::attach(SwapchainDisplayNativeHdrCreateInfoAMD& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_AMD_display_native_hdr

#if VK_NV_present_barrier
struct SwapchainPresentBarrierCreateInfoNV : VkSwapchainPresentBarrierCreateInfoNV {
  SwapchainPresentBarrierCreateInfoNV() noexcept : VkSwapchainPresentBarrierCreateInfoNV{.sType = VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV} {}

  void setPresentBarrierEnable(Bool32 value) { this->presentBarrierEnable = value; }
  Bool32 getPresentBarrierEnable() const { return this->presentBarrierEnable; }
};
inline void SwapchainCreateInfoKHR::attach(SwapchainPresentBarrierCreateInfoNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_present_barrier

#if VK_KHR_swapchain
struct DeviceGroupSwapchainCreateInfoKHR : VkDeviceGroupSwapchainCreateInfoKHR {
  DeviceGroupSwapchainCreateInfoKHR() noexcept : VkDeviceGroupSwapchainCreateInfoKHR{.sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR} {}

  void setModes(DeviceGroupPresentModeFlagsKHR value) { this->modes = std::bit_cast<VkDeviceGroupPresentModeFlagsKHR>(value); }
  DeviceGroupPresentModeFlagsKHR getModes() const { return std::bit_cast<DeviceGroupPresentModeFlagsKHR>(this->modes); }
};
inline void SwapchainCreateInfoKHR::attach(DeviceGroupSwapchainCreateInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_swapchain

#if VK_EXT_display_control
struct SwapchainCounterCreateInfoEXT : VkSwapchainCounterCreateInfoEXT {
  SwapchainCounterCreateInfoEXT() noexcept : VkSwapchainCounterCreateInfoEXT{.sType = VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT} {}

  void setSurfaceCounters(SurfaceCounterFlagsEXT value) { this->surfaceCounters = std::bit_cast<VkSurfaceCounterFlagsEXT>(value); }
  SurfaceCounterFlagsEXT getSurfaceCounters() const { return std::bit_cast<SurfaceCounterFlagsEXT>(this->surfaceCounters); }
};
inline void SwapchainCreateInfoKHR::attach(SwapchainCounterCreateInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_display_control

#if VK_VERSION_1_2
struct ImageFormatListCreateInfo : VkImageFormatListCreateInfo {
  ImageFormatListCreateInfo() noexcept : VkImageFormatListCreateInfo{.sType = VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO} {}

  void setViewFormatCount(uint32_t value) { this->viewFormatCount = value; }
  uint32_t getViewFormatCount() const { return this->viewFormatCount; }
  void setViewFormats(const Format* value) { this->pViewFormats = std::bit_cast<const VkFormat*>(value); }
  const Format* getViewFormats() const { return std::bit_cast<const Format*>(this->pViewFormats); }
};
inline void ImageCreateInfo::attach(ImageFormatListCreateInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#if VK_KHR_swapchain
inline void SwapchainCreateInfoKHR::attach(ImageFormatListCreateInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_swapchain
inline void PhysicalDeviceImageFormatInfo2::attach(ImageFormatListCreateInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_2

#if VK_VERSION_1_0
struct RenderPassCreateInfo : VkRenderPassCreateInfo {
  RenderPassCreateInfo() noexcept : VkRenderPassCreateInfo{.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO} {}

  void setSubpassCount(uint32_t value) { this->subpassCount = value; }
  uint32_t getSubpassCount() const { return this->subpassCount; }
  void setSubpasses(const SubpassDescription* value) { this->pSubpasses = std::bit_cast<const VkSubpassDescription*>(value); }
  const SubpassDescription* getSubpasses() const { return std::bit_cast<const SubpassDescription*>(this->pSubpasses); }

  void setFlags(RenderPassCreateFlags value) { this->flags = std::bit_cast<VkRenderPassCreateFlags>(value); }
  RenderPassCreateFlags getFlags() const { return std::bit_cast<RenderPassCreateFlags>(this->flags); }
  void setAttachmentCount(uint32_t value) { this->attachmentCount = value; }
  uint32_t getAttachmentCount() const { return this->attachmentCount; }
  void setAttachments(const AttachmentDescription* value) { this->pAttachments = std::bit_cast<const VkAttachmentDescription*>(value); }
  const AttachmentDescription* getAttachments() const { return std::bit_cast<const AttachmentDescription*>(this->pAttachments); }
  void setDependencyCount(uint32_t value) { this->dependencyCount = value; }
  uint32_t getDependencyCount() const { return this->dependencyCount; }
  void setDependencies(const SubpassDependency* value) { this->pDependencies = std::bit_cast<const VkSubpassDependency*>(value); }
  const SubpassDependency* getDependencies() const { return std::bit_cast<const SubpassDependency*>(this->pDependencies); }

#if VK_VERSION_1_1
  void attach(struct RenderPassMultiviewCreateInfo&);
  void attach(struct RenderPassInputAttachmentAspectCreateInfo&);
#endif // VK_VERSION_1_1
#if VK_EXT_fragment_density_map
  void attach(struct RenderPassFragmentDensityMapCreateInfoEXT&);
#endif // VK_EXT_fragment_density_map
#if VK_QCOM_tile_memory_heap
  void attach(struct TileMemorySizeInfoQCOM&);
#endif // VK_QCOM_tile_memory_heap
#if VK_QCOM_tile_shading
  void attach(struct RenderPassTileShadingCreateInfoQCOM&);
#endif // VK_QCOM_tile_shading
};
#endif // VK_VERSION_1_0

#if VK_NV_ray_tracing_linear_swept_spheres
struct AccelerationStructureGeometryLinearSweptSpheresDataNV : VkAccelerationStructureGeometryLinearSweptSpheresDataNV {
  AccelerationStructureGeometryLinearSweptSpheresDataNV() noexcept : VkAccelerationStructureGeometryLinearSweptSpheresDataNV{.sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_LINEAR_SWEPT_SPHERES_DATA_NV} {}

  void setVertexFormat(Format value) { this->vertexFormat = std::bit_cast<VkFormat>(value); }
  Format getVertexFormat() const { return std::bit_cast<Format>(this->vertexFormat); }
  void setVertexData(DeviceOrHostAddressConstKHR value) { this->vertexData = value; }
  DeviceOrHostAddressConstKHR getVertexData() const { return this->vertexData; }
  void setVertexStride(DeviceSize value) { this->vertexStride = value; }
  DeviceSize getVertexStride() const { return this->vertexStride; }
  void setRadiusFormat(Format value) { this->radiusFormat = std::bit_cast<VkFormat>(value); }
  Format getRadiusFormat() const { return std::bit_cast<Format>(this->radiusFormat); }
  void setRadiusData(DeviceOrHostAddressConstKHR value) { this->radiusData = value; }
  DeviceOrHostAddressConstKHR getRadiusData() const { return this->radiusData; }
  void setRadiusStride(DeviceSize value) { this->radiusStride = value; }
  DeviceSize getRadiusStride() const { return this->radiusStride; }
  void setIndexType(IndexType value) { this->indexType = std::bit_cast<VkIndexType>(value); }
  IndexType getIndexType() const { return std::bit_cast<IndexType>(this->indexType); }
  void setIndexData(DeviceOrHostAddressConstKHR value) { this->indexData = value; }
  DeviceOrHostAddressConstKHR getIndexData() const { return this->indexData; }
  void setIndexStride(DeviceSize value) { this->indexStride = value; }
  DeviceSize getIndexStride() const { return this->indexStride; }
  void setIndexingMode(RayTracingLssIndexingModeNV value) { this->indexingMode = std::bit_cast<VkRayTracingLssIndexingModeNV>(value); }
  RayTracingLssIndexingModeNV getIndexingMode() const { return std::bit_cast<RayTracingLssIndexingModeNV>(this->indexingMode); }
  void setEndCapsMode(RayTracingLssPrimitiveEndCapsModeNV value) { this->endCapsMode = std::bit_cast<VkRayTracingLssPrimitiveEndCapsModeNV>(value); }
  RayTracingLssPrimitiveEndCapsModeNV getEndCapsMode() const { return std::bit_cast<RayTracingLssPrimitiveEndCapsModeNV>(this->endCapsMode); }
};
inline void AccelerationStructureGeometryKHR::attach(AccelerationStructureGeometryLinearSweptSpheresDataNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_ray_tracing_linear_swept_spheres

#if VK_KHR_acceleration_structure
struct AccelerationStructureBuildGeometryInfoKHR : VkAccelerationStructureBuildGeometryInfoKHR {
  AccelerationStructureBuildGeometryInfoKHR() noexcept : VkAccelerationStructureBuildGeometryInfoKHR{.sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR} {}

  void setType(AccelerationStructureTypeKHR value) { this->type = std::bit_cast<VkAccelerationStructureTypeKHR>(value); }
  AccelerationStructureTypeKHR getType() const { return std::bit_cast<AccelerationStructureTypeKHR>(this->type); }
  void setMode(BuildAccelerationStructureModeKHR value) { this->mode = std::bit_cast<VkBuildAccelerationStructureModeKHR>(value); }
  BuildAccelerationStructureModeKHR getMode() const { return std::bit_cast<BuildAccelerationStructureModeKHR>(this->mode); }
  void setScratchData(DeviceOrHostAddressKHR value) { this->scratchData = value; }
  DeviceOrHostAddressKHR getScratchData() const { return this->scratchData; }

  void setFlags(BuildAccelerationStructureFlagsKHR value) { this->flags = std::bit_cast<VkBuildAccelerationStructureFlagsKHR>(value); }
  BuildAccelerationStructureFlagsKHR getFlags() const { return std::bit_cast<BuildAccelerationStructureFlagsKHR>(this->flags); }
  void setSrcAccelerationStructure(AccelerationStructureKHR value) { this->srcAccelerationStructure = std::bit_cast<VkAccelerationStructureKHR>(value); }
  AccelerationStructureKHR getSrcAccelerationStructure() const { return std::bit_cast<AccelerationStructureKHR>(this->srcAccelerationStructure); }
  void setDstAccelerationStructure(AccelerationStructureKHR value) { this->dstAccelerationStructure = std::bit_cast<VkAccelerationStructureKHR>(value); }
  AccelerationStructureKHR getDstAccelerationStructure() const { return std::bit_cast<AccelerationStructureKHR>(this->dstAccelerationStructure); }
  void setGeometryCount(uint32_t value) { this->geometryCount = value; }
  uint32_t getGeometryCount() const { return this->geometryCount; }
  void setGeometries(const AccelerationStructureGeometryKHR* value) { this->pGeometries = std::bit_cast<const VkAccelerationStructureGeometryKHR*>(value); }
  const AccelerationStructureGeometryKHR* getGeometries() const { return std::bit_cast<const AccelerationStructureGeometryKHR*>(this->pGeometries); }
};
#endif // VK_KHR_acceleration_structure

#if VK_NV_ray_tracing_linear_swept_spheres
struct AccelerationStructureGeometrySpheresDataNV : VkAccelerationStructureGeometrySpheresDataNV {
  AccelerationStructureGeometrySpheresDataNV() noexcept : VkAccelerationStructureGeometrySpheresDataNV{.sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_SPHERES_DATA_NV} {}

  void setVertexFormat(Format value) { this->vertexFormat = std::bit_cast<VkFormat>(value); }
  Format getVertexFormat() const { return std::bit_cast<Format>(this->vertexFormat); }
  void setVertexData(DeviceOrHostAddressConstKHR value) { this->vertexData = value; }
  DeviceOrHostAddressConstKHR getVertexData() const { return this->vertexData; }
  void setVertexStride(DeviceSize value) { this->vertexStride = value; }
  DeviceSize getVertexStride() const { return this->vertexStride; }
  void setRadiusFormat(Format value) { this->radiusFormat = std::bit_cast<VkFormat>(value); }
  Format getRadiusFormat() const { return std::bit_cast<Format>(this->radiusFormat); }
  void setRadiusData(DeviceOrHostAddressConstKHR value) { this->radiusData = value; }
  DeviceOrHostAddressConstKHR getRadiusData() const { return this->radiusData; }
  void setRadiusStride(DeviceSize value) { this->radiusStride = value; }
  DeviceSize getRadiusStride() const { return this->radiusStride; }
  void setIndexType(IndexType value) { this->indexType = std::bit_cast<VkIndexType>(value); }
  IndexType getIndexType() const { return std::bit_cast<IndexType>(this->indexType); }
  void setIndexData(DeviceOrHostAddressConstKHR value) { this->indexData = value; }
  DeviceOrHostAddressConstKHR getIndexData() const { return this->indexData; }
  void setIndexStride(DeviceSize value) { this->indexStride = value; }
  DeviceSize getIndexStride() const { return this->indexStride; }
};
inline void AccelerationStructureGeometryKHR::attach(AccelerationStructureGeometrySpheresDataNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_ray_tracing_linear_swept_spheres

#if VK_NV_partitioned_acceleration_structure
struct BuildPartitionedAccelerationStructureInfoNV : VkBuildPartitionedAccelerationStructureInfoNV {
  BuildPartitionedAccelerationStructureInfoNV() noexcept : VkBuildPartitionedAccelerationStructureInfoNV{.sType = VK_STRUCTURE_TYPE_BUILD_PARTITIONED_ACCELERATION_STRUCTURE_INFO_NV} {}

  void setInput(const PartitionedAccelerationStructureInstancesInputNV& value) { this->input = value; }
  const PartitionedAccelerationStructureInstancesInputNV& getInput() const { return static_cast<const PartitionedAccelerationStructureInstancesInputNV&>(this->input); }
  void setSrcAccelerationStructureData(DeviceAddress value) { this->srcAccelerationStructureData = value; }
  DeviceAddress getSrcAccelerationStructureData() const { return this->srcAccelerationStructureData; }
  void setDstAccelerationStructureData(DeviceAddress value) { this->dstAccelerationStructureData = value; }
  DeviceAddress getDstAccelerationStructureData() const { return this->dstAccelerationStructureData; }
  void setScratchData(DeviceAddress value) { this->scratchData = value; }
  DeviceAddress getScratchData() const { return this->scratchData; }
  void setSrcInfos(DeviceAddress value) { this->srcInfos = value; }
  DeviceAddress getSrcInfos() const { return this->srcInfos; }
  void setSrcInfosCount(DeviceAddress value) { this->srcInfosCount = value; }
  DeviceAddress getSrcInfosCount() const { return this->srcInfosCount; }
};

struct PartitionedAccelerationStructureFlagsNV : VkPartitionedAccelerationStructureFlagsNV {
  PartitionedAccelerationStructureFlagsNV() noexcept : VkPartitionedAccelerationStructureFlagsNV{.sType = VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_FLAGS_NV} {}

  void setEnablePartitionTranslation(Bool32 value) { this->enablePartitionTranslation = value; }
  Bool32 getEnablePartitionTranslation() const { return this->enablePartitionTranslation; }
};
inline void PartitionedAccelerationStructureInstancesInputNV::attach(PartitionedAccelerationStructureFlagsNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_partitioned_acceleration_structure

#if VK_NV_cluster_acceleration_structure
struct ClusterAccelerationStructureCommandsInfoNV : VkClusterAccelerationStructureCommandsInfoNV {
  ClusterAccelerationStructureCommandsInfoNV() noexcept : VkClusterAccelerationStructureCommandsInfoNV{.sType = VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_COMMANDS_INFO_NV} {}

  void setInput(const ClusterAccelerationStructureInputInfoNV& value) { this->input = value; }
  const ClusterAccelerationStructureInputInfoNV& getInput() const { return static_cast<const ClusterAccelerationStructureInputInfoNV&>(this->input); }
  void setDstImplicitData(DeviceAddress value) { this->dstImplicitData = value; }
  DeviceAddress getDstImplicitData() const { return this->dstImplicitData; }
  void setScratchData(DeviceAddress value) { this->scratchData = value; }
  DeviceAddress getScratchData() const { return this->scratchData; }
  void setDstAddressesArray(const StridedDeviceAddressRegionKHR& value) { this->dstAddressesArray = value; }
  const StridedDeviceAddressRegionKHR& getDstAddressesArray() const { return static_cast<const StridedDeviceAddressRegionKHR&>(this->dstAddressesArray); }
  void setDstSizesArray(const StridedDeviceAddressRegionKHR& value) { this->dstSizesArray = value; }
  const StridedDeviceAddressRegionKHR& getDstSizesArray() const { return static_cast<const StridedDeviceAddressRegionKHR&>(this->dstSizesArray); }
  void setSrcInfosArray(const StridedDeviceAddressRegionKHR& value) { this->srcInfosArray = value; }
  const StridedDeviceAddressRegionKHR& getSrcInfosArray() const { return static_cast<const StridedDeviceAddressRegionKHR&>(this->srcInfosArray); }
  void setSrcInfosCount(DeviceAddress value) { this->srcInfosCount = value; }
  DeviceAddress getSrcInfosCount() const { return this->srcInfosCount; }

  void setAddressResolutionFlags(ClusterAccelerationStructureAddressResolutionFlagsNV value) { this->addressResolutionFlags = std::bit_cast<VkClusterAccelerationStructureAddressResolutionFlagsNV>(value); }
  ClusterAccelerationStructureAddressResolutionFlagsNV getAddressResolutionFlags() const { return std::bit_cast<ClusterAccelerationStructureAddressResolutionFlagsNV>(this->addressResolutionFlags); }
};
#endif // VK_NV_cluster_acceleration_structure

#if VK_NV_ray_tracing_motion_blur
struct AccelerationStructureMotionInfoNV : VkAccelerationStructureMotionInfoNV {
  AccelerationStructureMotionInfoNV() noexcept : VkAccelerationStructureMotionInfoNV{.sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV} {}

  void setMaxInstances(uint32_t value) { this->maxInstances = value; }
  uint32_t getMaxInstances() const { return this->maxInstances; }

  void setFlags(AccelerationStructureMotionInfoFlagsNV value) { this->flags = std::bit_cast<VkAccelerationStructureMotionInfoFlagsNV>(value); }
  AccelerationStructureMotionInfoFlagsNV getFlags() const { return std::bit_cast<AccelerationStructureMotionInfoFlagsNV>(this->flags); }
};
inline void AccelerationStructureCreateInfoKHR::attach(AccelerationStructureMotionInfoNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_ray_tracing_motion_blur

#if VK_VERSION_1_2
struct FramebufferAttachmentsCreateInfo : VkFramebufferAttachmentsCreateInfo {
  FramebufferAttachmentsCreateInfo() noexcept : VkFramebufferAttachmentsCreateInfo{.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO} {}

  void setAttachmentImageInfoCount(uint32_t value) { this->attachmentImageInfoCount = value; }
  uint32_t getAttachmentImageInfoCount() const { return this->attachmentImageInfoCount; }
  void setAttachmentImageInfos(const FramebufferAttachmentImageInfo* value) { this->pAttachmentImageInfos = std::bit_cast<const VkFramebufferAttachmentImageInfo*>(value); }
  const FramebufferAttachmentImageInfo* getAttachmentImageInfos() const { return std::bit_cast<const FramebufferAttachmentImageInfo*>(this->pAttachmentImageInfos); }
};
inline void FramebufferCreateInfo::attach(FramebufferAttachmentsCreateInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_2

#if VK_KHR_video_encode_queue
struct QueryPoolVideoEncodeFeedbackCreateInfoKHR : VkQueryPoolVideoEncodeFeedbackCreateInfoKHR {
  QueryPoolVideoEncodeFeedbackCreateInfoKHR() noexcept : VkQueryPoolVideoEncodeFeedbackCreateInfoKHR{.sType = VK_STRUCTURE_TYPE_QUERY_POOL_VIDEO_ENCODE_FEEDBACK_CREATE_INFO_KHR} {}

  void setEncodeFeedbackFlags(VideoEncodeFeedbackFlagsKHR value) { this->encodeFeedbackFlags = std::bit_cast<VkVideoEncodeFeedbackFlagsKHR>(value); }
  VideoEncodeFeedbackFlagsKHR getEncodeFeedbackFlags() const { return std::bit_cast<VideoEncodeFeedbackFlagsKHR>(this->encodeFeedbackFlags); }
};
inline void QueryPoolCreateInfo::attach(QueryPoolVideoEncodeFeedbackCreateInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_encode_queue

#if VK_INTEL_performance_query
struct QueryPoolPerformanceQueryCreateInfoINTEL : VkQueryPoolPerformanceQueryCreateInfoINTEL {
  QueryPoolPerformanceQueryCreateInfoINTEL() noexcept : VkQueryPoolPerformanceQueryCreateInfoINTEL{.sType = VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL} {}

  void setPerformanceCountersSampling(QueryPoolSamplingModeINTEL value) { this->performanceCountersSampling = std::bit_cast<VkQueryPoolSamplingModeINTEL>(value); }
  QueryPoolSamplingModeINTEL getPerformanceCountersSampling() const { return std::bit_cast<QueryPoolSamplingModeINTEL>(this->performanceCountersSampling); }
};
inline void QueryPoolCreateInfo::attach(QueryPoolPerformanceQueryCreateInfoINTEL& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_INTEL_performance_query

#if VK_KHR_video_queue
struct VideoProfileInfoKHR : VkVideoProfileInfoKHR {
  VideoProfileInfoKHR() noexcept : VkVideoProfileInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR} {}

  void setVideoCodecOperation(VideoCodecOperationFlagBitsKHR value) { this->videoCodecOperation = std::bit_cast<VkVideoCodecOperationFlagBitsKHR>(value); }
  VideoCodecOperationFlagBitsKHR getVideoCodecOperation() const { return std::bit_cast<VideoCodecOperationFlagBitsKHR>(this->videoCodecOperation); }
  void setChromaSubsampling(VideoChromaSubsamplingFlagsKHR value) { this->chromaSubsampling = std::bit_cast<VkVideoChromaSubsamplingFlagsKHR>(value); }
  VideoChromaSubsamplingFlagsKHR getChromaSubsampling() const { return std::bit_cast<VideoChromaSubsamplingFlagsKHR>(this->chromaSubsampling); }
  void setLumaBitDepth(VideoComponentBitDepthFlagsKHR value) { this->lumaBitDepth = std::bit_cast<VkVideoComponentBitDepthFlagsKHR>(value); }
  VideoComponentBitDepthFlagsKHR getLumaBitDepth() const { return std::bit_cast<VideoComponentBitDepthFlagsKHR>(this->lumaBitDepth); }

  void setChromaBitDepth(VideoComponentBitDepthFlagsKHR value) { this->chromaBitDepth = std::bit_cast<VkVideoComponentBitDepthFlagsKHR>(value); }
  VideoComponentBitDepthFlagsKHR getChromaBitDepth() const { return std::bit_cast<VideoComponentBitDepthFlagsKHR>(this->chromaBitDepth); }

#if VK_KHR_video_decode_queue
  void attach(struct VideoDecodeUsageInfoKHR&);
#endif // VK_KHR_video_decode_queue
#if VK_KHR_video_decode_h264
  void attach(struct VideoDecodeH264ProfileInfoKHR&);
#endif // VK_KHR_video_decode_h264
#if VK_KHR_video_decode_h265
  void attach(struct VideoDecodeH265ProfileInfoKHR&);
#endif // VK_KHR_video_decode_h265
#if VK_KHR_video_decode_vp9
  void attach(struct VideoDecodeVP9ProfileInfoKHR&);
#endif // VK_KHR_video_decode_vp9
#if VK_KHR_video_decode_av1
  void attach(struct VideoDecodeAV1ProfileInfoKHR&);
#endif // VK_KHR_video_decode_av1
#if VK_KHR_video_encode_queue
  void attach(struct VideoEncodeUsageInfoKHR&);
#endif // VK_KHR_video_encode_queue
#if VK_KHR_video_encode_h264
  void attach(struct VideoEncodeH264ProfileInfoKHR&);
#endif // VK_KHR_video_encode_h264
#if VK_KHR_video_encode_h265
  void attach(struct VideoEncodeH265ProfileInfoKHR&);
#endif // VK_KHR_video_encode_h265
#if VK_KHR_video_encode_av1
  void attach(struct VideoEncodeAV1ProfileInfoKHR&);
#endif // VK_KHR_video_encode_av1
};
inline void QueryPoolCreateInfo::attachHead(VideoProfileInfoKHR& ext) { pNext = &ext; }
#endif // VK_KHR_video_queue

#if VK_KHR_performance_query
struct QueryPoolPerformanceCreateInfoKHR : VkQueryPoolPerformanceCreateInfoKHR {
  QueryPoolPerformanceCreateInfoKHR() noexcept : VkQueryPoolPerformanceCreateInfoKHR{.sType = VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR} {}

  void setQueueFamilyIndex(uint32_t value) { this->queueFamilyIndex = value; }
  uint32_t getQueueFamilyIndex() const { return this->queueFamilyIndex; }
  void setCounterIndexCount(uint32_t value) { this->counterIndexCount = value; }
  uint32_t getCounterIndexCount() const { return this->counterIndexCount; }
  void setCounterIndices(const uint32_t* value) { this->pCounterIndices = value; }
  const uint32_t* getCounterIndices() const { return this->pCounterIndices; }
};
inline void QueryPoolCreateInfo::attach(QueryPoolPerformanceCreateInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_performance_query

#if VK_EXT_pipeline_creation_feedback
using PipelineCreationFeedbackEXT = PipelineCreationFeedback;
#endif // VK_EXT_pipeline_creation_feedback

#if VK_EXT_tooling_info
using PhysicalDeviceToolPropertiesEXT = PhysicalDeviceToolProperties;
#endif // VK_EXT_tooling_info
#if VK_KHR_synchronization2
using BufferMemoryBarrier2KHR = BufferMemoryBarrier2;
using SemaphoreSubmitInfoKHR = SemaphoreSubmitInfo;
#endif // VK_KHR_synchronization2

#if VK_EXT_metal_objects
struct ImportMetalSharedEventInfoEXT : VkImportMetalSharedEventInfoEXT {
  ImportMetalSharedEventInfoEXT() noexcept : VkImportMetalSharedEventInfoEXT{.sType = VK_STRUCTURE_TYPE_IMPORT_METAL_SHARED_EVENT_INFO_EXT} {}

  void setMtlSharedEvent(MTLSharedEvent_id value) { this->mtlSharedEvent = value; }
  MTLSharedEvent_id getMtlSharedEvent() const { return this->mtlSharedEvent; }
};
inline void SemaphoreCreateInfo::attach(ImportMetalSharedEventInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void EventCreateInfo::attach(ImportMetalSharedEventInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_metal_objects

#if VK_KHR_video_encode_quantization_map
struct VideoEncodeH264QuantizationMapCapabilitiesKHR : VkVideoEncodeH264QuantizationMapCapabilitiesKHR {
  VideoEncodeH264QuantizationMapCapabilitiesKHR() noexcept : VkVideoEncodeH264QuantizationMapCapabilitiesKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUANTIZATION_MAP_CAPABILITIES_KHR} {}

  int32_t getMinQpDelta() const { return this->minQpDelta; }
  int32_t getMaxQpDelta() const { return this->maxQpDelta; }
};
inline void VideoCapabilitiesKHR::attach(VideoEncodeH264QuantizationMapCapabilitiesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_encode_quantization_map

#if VK_KHR_video_encode_queue
struct VideoEncodeCapabilitiesKHR : VkVideoEncodeCapabilitiesKHR {
  VideoEncodeCapabilitiesKHR() noexcept : VkVideoEncodeCapabilitiesKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR} {}

  VideoEncodeCapabilityFlagsKHR getFlags() const { return std::bit_cast<VideoEncodeCapabilityFlagsKHR>(this->flags); }
  VideoEncodeRateControlModeFlagsKHR getRateControlModes() const { return std::bit_cast<VideoEncodeRateControlModeFlagsKHR>(this->rateControlModes); }
  uint32_t getMaxRateControlLayers() const { return this->maxRateControlLayers; }
  uint64_t getMaxBitrate() const { return this->maxBitrate; }
  uint32_t getMaxQualityLevels() const { return this->maxQualityLevels; }
  const Extent2D& getEncodeInputPictureGranularity() const { return static_cast<const Extent2D&>(this->encodeInputPictureGranularity); }
  VideoEncodeFeedbackFlagsKHR getSupportedEncodeFeedbackFlags() const { return std::bit_cast<VideoEncodeFeedbackFlagsKHR>(this->supportedEncodeFeedbackFlags); }
};
inline void VideoCapabilitiesKHR::attach(VideoEncodeCapabilitiesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_encode_queue

#if VK_KHR_video_encode_h264
struct VideoEncodeH264CapabilitiesKHR : VkVideoEncodeH264CapabilitiesKHR {
  VideoEncodeH264CapabilitiesKHR() noexcept : VkVideoEncodeH264CapabilitiesKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_KHR} {}

  VideoEncodeH264CapabilityFlagsKHR getFlags() const { return std::bit_cast<VideoEncodeH264CapabilityFlagsKHR>(this->flags); }
  StdVideoH264LevelIdc getMaxLevelIdc() const { return this->maxLevelIdc; }
  uint32_t getMaxSliceCount() const { return this->maxSliceCount; }
  uint32_t getMaxPPictureL0ReferenceCount() const { return this->maxPPictureL0ReferenceCount; }
  uint32_t getMaxBPictureL0ReferenceCount() const { return this->maxBPictureL0ReferenceCount; }
  uint32_t getMaxL1ReferenceCount() const { return this->maxL1ReferenceCount; }
  uint32_t getMaxTemporalLayerCount() const { return this->maxTemporalLayerCount; }
  Bool32 getExpectDyadicTemporalLayerPattern() const { return this->expectDyadicTemporalLayerPattern; }
  int32_t getMinQp() const { return this->minQp; }
  int32_t getMaxQp() const { return this->maxQp; }
  Bool32 getPrefersGopRemainingFrames() const { return this->prefersGopRemainingFrames; }
  Bool32 getRequiresGopRemainingFrames() const { return this->requiresGopRemainingFrames; }
  VideoEncodeH264StdFlagsKHR getStdSyntaxFlags() const { return std::bit_cast<VideoEncodeH264StdFlagsKHR>(this->stdSyntaxFlags); }
};
inline void VideoCapabilitiesKHR::attach(VideoEncodeH264CapabilitiesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_encode_h264

#if VK_KHR_video_encode_h265
struct VideoEncodeH265CapabilitiesKHR : VkVideoEncodeH265CapabilitiesKHR {
  VideoEncodeH265CapabilitiesKHR() noexcept : VkVideoEncodeH265CapabilitiesKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_CAPABILITIES_KHR} {}

  VideoEncodeH265CapabilityFlagsKHR getFlags() const { return std::bit_cast<VideoEncodeH265CapabilityFlagsKHR>(this->flags); }
  StdVideoH265LevelIdc getMaxLevelIdc() const { return this->maxLevelIdc; }
  uint32_t getMaxSliceSegmentCount() const { return this->maxSliceSegmentCount; }
  const Extent2D& getMaxTiles() const { return static_cast<const Extent2D&>(this->maxTiles); }
  VideoEncodeH265CtbSizeFlagsKHR getCtbSizes() const { return std::bit_cast<VideoEncodeH265CtbSizeFlagsKHR>(this->ctbSizes); }
  VideoEncodeH265TransformBlockSizeFlagsKHR getTransformBlockSizes() const { return std::bit_cast<VideoEncodeH265TransformBlockSizeFlagsKHR>(this->transformBlockSizes); }
  uint32_t getMaxPPictureL0ReferenceCount() const { return this->maxPPictureL0ReferenceCount; }
  uint32_t getMaxBPictureL0ReferenceCount() const { return this->maxBPictureL0ReferenceCount; }
  uint32_t getMaxL1ReferenceCount() const { return this->maxL1ReferenceCount; }
  uint32_t getMaxSubLayerCount() const { return this->maxSubLayerCount; }
  Bool32 getExpectDyadicTemporalSubLayerPattern() const { return this->expectDyadicTemporalSubLayerPattern; }
  int32_t getMinQp() const { return this->minQp; }
  int32_t getMaxQp() const { return this->maxQp; }
  Bool32 getPrefersGopRemainingFrames() const { return this->prefersGopRemainingFrames; }
  Bool32 getRequiresGopRemainingFrames() const { return this->requiresGopRemainingFrames; }
  VideoEncodeH265StdFlagsKHR getStdSyntaxFlags() const { return std::bit_cast<VideoEncodeH265StdFlagsKHR>(this->stdSyntaxFlags); }
};
inline void VideoCapabilitiesKHR::attach(VideoEncodeH265CapabilitiesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_encode_h265

#if VK_KHR_video_encode_av1
struct VideoEncodeAV1CapabilitiesKHR : VkVideoEncodeAV1CapabilitiesKHR {
  VideoEncodeAV1CapabilitiesKHR() noexcept : VkVideoEncodeAV1CapabilitiesKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_CAPABILITIES_KHR} {}

  VideoEncodeAV1CapabilityFlagsKHR getFlags() const { return std::bit_cast<VideoEncodeAV1CapabilityFlagsKHR>(this->flags); }
  StdVideoAV1Level getMaxLevel() const { return this->maxLevel; }
  const Extent2D& getCodedPictureAlignment() const { return static_cast<const Extent2D&>(this->codedPictureAlignment); }
  const Extent2D& getMaxTiles() const { return static_cast<const Extent2D&>(this->maxTiles); }
  const Extent2D& getMinTileSize() const { return static_cast<const Extent2D&>(this->minTileSize); }
  const Extent2D& getMaxTileSize() const { return static_cast<const Extent2D&>(this->maxTileSize); }
  VideoEncodeAV1SuperblockSizeFlagsKHR getSuperblockSizes() const { return std::bit_cast<VideoEncodeAV1SuperblockSizeFlagsKHR>(this->superblockSizes); }
  uint32_t getMaxSingleReferenceCount() const { return this->maxSingleReferenceCount; }
  uint32_t getSingleReferenceNameMask() const { return this->singleReferenceNameMask; }
  uint32_t getMaxUnidirectionalCompoundReferenceCount() const { return this->maxUnidirectionalCompoundReferenceCount; }
  uint32_t getMaxUnidirectionalCompoundGroup1ReferenceCount() const { return this->maxUnidirectionalCompoundGroup1ReferenceCount; }
  uint32_t getUnidirectionalCompoundReferenceNameMask() const { return this->unidirectionalCompoundReferenceNameMask; }
  uint32_t getMaxBidirectionalCompoundReferenceCount() const { return this->maxBidirectionalCompoundReferenceCount; }
  uint32_t getMaxBidirectionalCompoundGroup1ReferenceCount() const { return this->maxBidirectionalCompoundGroup1ReferenceCount; }
  uint32_t getMaxBidirectionalCompoundGroup2ReferenceCount() const { return this->maxBidirectionalCompoundGroup2ReferenceCount; }
  uint32_t getBidirectionalCompoundReferenceNameMask() const { return this->bidirectionalCompoundReferenceNameMask; }
  uint32_t getMaxTemporalLayerCount() const { return this->maxTemporalLayerCount; }
  uint32_t getMaxSpatialLayerCount() const { return this->maxSpatialLayerCount; }
  uint32_t getMaxOperatingPoints() const { return this->maxOperatingPoints; }
  uint32_t getMinQIndex() const { return this->minQIndex; }
  uint32_t getMaxQIndex() const { return this->maxQIndex; }
  Bool32 getPrefersGopRemainingFrames() const { return this->prefersGopRemainingFrames; }
  Bool32 getRequiresGopRemainingFrames() const { return this->requiresGopRemainingFrames; }
  VideoEncodeAV1StdFlagsKHR getStdSyntaxFlags() const { return std::bit_cast<VideoEncodeAV1StdFlagsKHR>(this->stdSyntaxFlags); }
};
inline void VideoCapabilitiesKHR::attach(VideoEncodeAV1CapabilitiesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_encode_av1

#if VK_KHR_video_encode_intra_refresh
struct VideoEncodeIntraRefreshCapabilitiesKHR : VkVideoEncodeIntraRefreshCapabilitiesKHR {
  VideoEncodeIntraRefreshCapabilitiesKHR() noexcept : VkVideoEncodeIntraRefreshCapabilitiesKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_CAPABILITIES_KHR} {}

  uint32_t getMaxIntraRefreshCycleDuration() const { return this->maxIntraRefreshCycleDuration; }
  uint32_t getMaxIntraRefreshActiveReferencePictures() const { return this->maxIntraRefreshActiveReferencePictures; }
  Bool32 getPartitionIndependentIntraRefreshRegions() const { return this->partitionIndependentIntraRefreshRegions; }
  Bool32 getNonRectangularIntraRefreshRegions() const { return this->nonRectangularIntraRefreshRegions; }

  VideoEncodeIntraRefreshModeFlagsKHR getIntraRefreshModes() const { return std::bit_cast<VideoEncodeIntraRefreshModeFlagsKHR>(this->intraRefreshModes); }
};
inline void VideoCapabilitiesKHR::attach(VideoEncodeIntraRefreshCapabilitiesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_encode_intra_refresh

#if VK_KHR_video_decode_queue
struct VideoDecodeCapabilitiesKHR : VkVideoDecodeCapabilitiesKHR {
  VideoDecodeCapabilitiesKHR() noexcept : VkVideoDecodeCapabilitiesKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR} {}

  VideoDecodeCapabilityFlagsKHR getFlags() const { return std::bit_cast<VideoDecodeCapabilityFlagsKHR>(this->flags); }
};
inline void VideoCapabilitiesKHR::attach(VideoDecodeCapabilitiesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_decode_queue

#if VK_KHR_video_decode_h264
struct VideoDecodeH264CapabilitiesKHR : VkVideoDecodeH264CapabilitiesKHR {
  VideoDecodeH264CapabilitiesKHR() noexcept : VkVideoDecodeH264CapabilitiesKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_KHR} {}

  StdVideoH264LevelIdc getMaxLevelIdc() const { return this->maxLevelIdc; }
  const Offset2D& getFieldOffsetGranularity() const { return static_cast<const Offset2D&>(this->fieldOffsetGranularity); }
};
inline void VideoCapabilitiesKHR::attach(VideoDecodeH264CapabilitiesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_decode_h264

#if VK_KHR_video_encode_quantization_map
struct VideoEncodeH265QuantizationMapCapabilitiesKHR : VkVideoEncodeH265QuantizationMapCapabilitiesKHR {
  VideoEncodeH265QuantizationMapCapabilitiesKHR() noexcept : VkVideoEncodeH265QuantizationMapCapabilitiesKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUANTIZATION_MAP_CAPABILITIES_KHR} {}

  int32_t getMinQpDelta() const { return this->minQpDelta; }
  int32_t getMaxQpDelta() const { return this->maxQpDelta; }
};
inline void VideoCapabilitiesKHR::attach(VideoEncodeH265QuantizationMapCapabilitiesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }

struct VideoEncodeAV1QuantizationMapCapabilitiesKHR : VkVideoEncodeAV1QuantizationMapCapabilitiesKHR {
  VideoEncodeAV1QuantizationMapCapabilitiesKHR() noexcept : VkVideoEncodeAV1QuantizationMapCapabilitiesKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUANTIZATION_MAP_CAPABILITIES_KHR} {}

  int32_t getMinQIndexDelta() const { return this->minQIndexDelta; }
  int32_t getMaxQIndexDelta() const { return this->maxQIndexDelta; }
};
inline void VideoCapabilitiesKHR::attach(VideoEncodeAV1QuantizationMapCapabilitiesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_encode_quantization_map

#if VK_KHR_video_decode_vp9
struct VideoDecodeVP9CapabilitiesKHR : VkVideoDecodeVP9CapabilitiesKHR {
  VideoDecodeVP9CapabilitiesKHR() noexcept : VkVideoDecodeVP9CapabilitiesKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_CAPABILITIES_KHR} {}

  StdVideoVP9Level getMaxLevel() const { return this->maxLevel; }
};
inline void VideoCapabilitiesKHR::attach(VideoDecodeVP9CapabilitiesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_decode_vp9

#if VK_KHR_video_decode_h265
struct VideoDecodeH265CapabilitiesKHR : VkVideoDecodeH265CapabilitiesKHR {
  VideoDecodeH265CapabilitiesKHR() noexcept : VkVideoDecodeH265CapabilitiesKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_CAPABILITIES_KHR} {}

  StdVideoH265LevelIdc getMaxLevelIdc() const { return this->maxLevelIdc; }
};
inline void VideoCapabilitiesKHR::attach(VideoDecodeH265CapabilitiesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_decode_h265

#if VK_KHR_video_encode_quantization_map
struct VideoEncodeQuantizationMapCapabilitiesKHR : VkVideoEncodeQuantizationMapCapabilitiesKHR {
  VideoEncodeQuantizationMapCapabilitiesKHR() noexcept : VkVideoEncodeQuantizationMapCapabilitiesKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_CAPABILITIES_KHR} {}

  const Extent2D& getMaxQuantizationMapExtent() const { return static_cast<const Extent2D&>(this->maxQuantizationMapExtent); }
};
inline void VideoCapabilitiesKHR::attach(VideoEncodeQuantizationMapCapabilitiesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_encode_quantization_map

#if VK_KHR_video_decode_av1
struct VideoDecodeAV1CapabilitiesKHR : VkVideoDecodeAV1CapabilitiesKHR {
  VideoDecodeAV1CapabilitiesKHR() noexcept : VkVideoDecodeAV1CapabilitiesKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_CAPABILITIES_KHR} {}

  StdVideoAV1Level getMaxLevel() const { return this->maxLevel; }
};
inline void VideoCapabilitiesKHR::attach(VideoDecodeAV1CapabilitiesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_decode_av1

#if VK_KHR_video_encode_h264
struct VideoEncodeH264SessionParametersCreateInfoKHR : VkVideoEncodeH264SessionParametersCreateInfoKHR {
  VideoEncodeH264SessionParametersCreateInfoKHR() noexcept : VkVideoEncodeH264SessionParametersCreateInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR} {}

  void setMaxStdSPSCount(uint32_t value) { this->maxStdSPSCount = value; }
  uint32_t getMaxStdSPSCount() const { return this->maxStdSPSCount; }
  void setMaxStdPPSCount(uint32_t value) { this->maxStdPPSCount = value; }
  uint32_t getMaxStdPPSCount() const { return this->maxStdPPSCount; }

  void setParametersAddInfo(const VideoEncodeH264SessionParametersAddInfoKHR* value) { this->pParametersAddInfo = std::bit_cast<const VkVideoEncodeH264SessionParametersAddInfoKHR*>(value); }
  const VideoEncodeH264SessionParametersAddInfoKHR* getParametersAddInfo() const { return std::bit_cast<const VideoEncodeH264SessionParametersAddInfoKHR*>(this->pParametersAddInfo); }
};
inline void VideoSessionParametersCreateInfoKHR::attach(VideoEncodeH264SessionParametersCreateInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_encode_h264

#if VK_KHR_video_encode_h265
struct VideoEncodeH265SessionParametersCreateInfoKHR : VkVideoEncodeH265SessionParametersCreateInfoKHR {
  VideoEncodeH265SessionParametersCreateInfoKHR() noexcept : VkVideoEncodeH265SessionParametersCreateInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR} {}

  void setMaxStdVPSCount(uint32_t value) { this->maxStdVPSCount = value; }
  uint32_t getMaxStdVPSCount() const { return this->maxStdVPSCount; }
  void setMaxStdSPSCount(uint32_t value) { this->maxStdSPSCount = value; }
  uint32_t getMaxStdSPSCount() const { return this->maxStdSPSCount; }
  void setMaxStdPPSCount(uint32_t value) { this->maxStdPPSCount = value; }
  uint32_t getMaxStdPPSCount() const { return this->maxStdPPSCount; }

  void setParametersAddInfo(const VideoEncodeH265SessionParametersAddInfoKHR* value) { this->pParametersAddInfo = std::bit_cast<const VkVideoEncodeH265SessionParametersAddInfoKHR*>(value); }
  const VideoEncodeH265SessionParametersAddInfoKHR* getParametersAddInfo() const { return std::bit_cast<const VideoEncodeH265SessionParametersAddInfoKHR*>(this->pParametersAddInfo); }
};
inline void VideoSessionParametersCreateInfoKHR::attach(VideoEncodeH265SessionParametersCreateInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_encode_h265

#if VK_KHR_video_encode_av1
struct VideoEncodeAV1SessionParametersCreateInfoKHR : VkVideoEncodeAV1SessionParametersCreateInfoKHR {
  VideoEncodeAV1SessionParametersCreateInfoKHR() noexcept : VkVideoEncodeAV1SessionParametersCreateInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR} {}

  void setStdSequenceHeader(const StdVideoAV1SequenceHeader* value) { this->pStdSequenceHeader = value; }
  const StdVideoAV1SequenceHeader* getStdSequenceHeader() const { return this->pStdSequenceHeader; }

  void setStdDecoderModelInfo(const StdVideoEncodeAV1DecoderModelInfo* value) { this->pStdDecoderModelInfo = value; }
  const StdVideoEncodeAV1DecoderModelInfo* getStdDecoderModelInfo() const { return this->pStdDecoderModelInfo; }
  void setStdOperatingPointCount(uint32_t value) { this->stdOperatingPointCount = value; }
  uint32_t getStdOperatingPointCount() const { return this->stdOperatingPointCount; }
  void setStdOperatingPoints(const StdVideoEncodeAV1OperatingPointInfo* value) { this->pStdOperatingPoints = value; }
  const StdVideoEncodeAV1OperatingPointInfo* getStdOperatingPoints() const { return this->pStdOperatingPoints; }
};
inline void VideoSessionParametersCreateInfoKHR::attach(VideoEncodeAV1SessionParametersCreateInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_encode_av1

#if VK_KHR_video_encode_quantization_map
struct VideoEncodeQuantizationMapSessionParametersCreateInfoKHR : VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR {
  VideoEncodeQuantizationMapSessionParametersCreateInfoKHR() noexcept : VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_SESSION_PARAMETERS_CREATE_INFO_KHR} {}

  void setQuantizationMapTexelSize(const Extent2D& value) { this->quantizationMapTexelSize = value; }
  const Extent2D& getQuantizationMapTexelSize() const { return static_cast<const Extent2D&>(this->quantizationMapTexelSize); }
};
inline void VideoSessionParametersCreateInfoKHR::attach(VideoEncodeQuantizationMapSessionParametersCreateInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_encode_quantization_map

#if VK_KHR_video_decode_h265
struct VideoDecodeH265SessionParametersCreateInfoKHR : VkVideoDecodeH265SessionParametersCreateInfoKHR {
  VideoDecodeH265SessionParametersCreateInfoKHR() noexcept : VkVideoDecodeH265SessionParametersCreateInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR} {}

  void setMaxStdVPSCount(uint32_t value) { this->maxStdVPSCount = value; }
  uint32_t getMaxStdVPSCount() const { return this->maxStdVPSCount; }
  void setMaxStdSPSCount(uint32_t value) { this->maxStdSPSCount = value; }
  uint32_t getMaxStdSPSCount() const { return this->maxStdSPSCount; }
  void setMaxStdPPSCount(uint32_t value) { this->maxStdPPSCount = value; }
  uint32_t getMaxStdPPSCount() const { return this->maxStdPPSCount; }

  void setParametersAddInfo(const VideoDecodeH265SessionParametersAddInfoKHR* value) { this->pParametersAddInfo = std::bit_cast<const VkVideoDecodeH265SessionParametersAddInfoKHR*>(value); }
  const VideoDecodeH265SessionParametersAddInfoKHR* getParametersAddInfo() const { return std::bit_cast<const VideoDecodeH265SessionParametersAddInfoKHR*>(this->pParametersAddInfo); }
};
inline void VideoSessionParametersCreateInfoKHR::attach(VideoDecodeH265SessionParametersCreateInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_decode_h265

#if VK_KHR_video_decode_av1
struct VideoDecodeAV1SessionParametersCreateInfoKHR : VkVideoDecodeAV1SessionParametersCreateInfoKHR {
  VideoDecodeAV1SessionParametersCreateInfoKHR() noexcept : VkVideoDecodeAV1SessionParametersCreateInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR} {}

  void setStdSequenceHeader(const StdVideoAV1SequenceHeader* value) { this->pStdSequenceHeader = value; }
  const StdVideoAV1SequenceHeader* getStdSequenceHeader() const { return this->pStdSequenceHeader; }
};
inline void VideoSessionParametersCreateInfoKHR::attach(VideoDecodeAV1SessionParametersCreateInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_decode_av1

#if VK_KHR_video_decode_h264
struct VideoDecodeH264SessionParametersCreateInfoKHR : VkVideoDecodeH264SessionParametersCreateInfoKHR {
  VideoDecodeH264SessionParametersCreateInfoKHR() noexcept : VkVideoDecodeH264SessionParametersCreateInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR} {}

  void setMaxStdSPSCount(uint32_t value) { this->maxStdSPSCount = value; }
  uint32_t getMaxStdSPSCount() const { return this->maxStdSPSCount; }
  void setMaxStdPPSCount(uint32_t value) { this->maxStdPPSCount = value; }
  uint32_t getMaxStdPPSCount() const { return this->maxStdPPSCount; }

  void setParametersAddInfo(const VideoDecodeH264SessionParametersAddInfoKHR* value) { this->pParametersAddInfo = std::bit_cast<const VkVideoDecodeH264SessionParametersAddInfoKHR*>(value); }
  const VideoDecodeH264SessionParametersAddInfoKHR* getParametersAddInfo() const { return std::bit_cast<const VideoDecodeH264SessionParametersAddInfoKHR*>(this->pParametersAddInfo); }
};
inline void VideoSessionParametersCreateInfoKHR::attach(VideoDecodeH264SessionParametersCreateInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_decode_h264

#if VK_KHR_video_encode_queue
struct VideoEncodeQualityLevelInfoKHR : VkVideoEncodeQualityLevelInfoKHR {
  VideoEncodeQualityLevelInfoKHR() noexcept : VkVideoEncodeQualityLevelInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR} {}

  void setQualityLevel(uint32_t value) { this->qualityLevel = value; }
  uint32_t getQualityLevel() const { return this->qualityLevel; }
};
inline void VideoCodingControlInfoKHR::attach(VideoEncodeQualityLevelInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void VideoSessionParametersCreateInfoKHR::attach(VideoEncodeQualityLevelInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_encode_queue

#if VK_LUNARG_direct_driver_loading
struct DirectDriverLoadingListLUNARG : VkDirectDriverLoadingListLUNARG {
  DirectDriverLoadingListLUNARG() noexcept : VkDirectDriverLoadingListLUNARG{.sType = VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_LIST_LUNARG} {}

  void setMode(DirectDriverLoadingModeLUNARG value) { this->mode = std::bit_cast<VkDirectDriverLoadingModeLUNARG>(value); }
  DirectDriverLoadingModeLUNARG getMode() const { return std::bit_cast<DirectDriverLoadingModeLUNARG>(this->mode); }
  void setDriverCount(uint32_t value) { this->driverCount = value; }
  uint32_t getDriverCount() const { return this->driverCount; }
  void setDrivers(const DirectDriverLoadingInfoLUNARG* value) { this->pDrivers = std::bit_cast<const VkDirectDriverLoadingInfoLUNARG*>(value); }
  const DirectDriverLoadingInfoLUNARG* getDrivers() const { return std::bit_cast<const DirectDriverLoadingInfoLUNARG*>(this->pDrivers); }
};
inline void InstanceCreateInfo::attach(DirectDriverLoadingListLUNARG& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_LUNARG_direct_driver_loading

#if VK_EXT_debug_utils
struct DebugUtilsMessengerCreateInfoEXT : VkDebugUtilsMessengerCreateInfoEXT {
  DebugUtilsMessengerCreateInfoEXT() noexcept : VkDebugUtilsMessengerCreateInfoEXT{.sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT} {}

  void setMessageSeverity(DebugUtilsMessageSeverityFlagsEXT value) { this->messageSeverity = std::bit_cast<VkDebugUtilsMessageSeverityFlagsEXT>(value); }
  DebugUtilsMessageSeverityFlagsEXT getMessageSeverity() const { return std::bit_cast<DebugUtilsMessageSeverityFlagsEXT>(this->messageSeverity); }
  void setMessageType(DebugUtilsMessageTypeFlagsEXT value) { this->messageType = std::bit_cast<VkDebugUtilsMessageTypeFlagsEXT>(value); }
  DebugUtilsMessageTypeFlagsEXT getMessageType() const { return std::bit_cast<DebugUtilsMessageTypeFlagsEXT>(this->messageType); }
  void setPfnUserCallback(PFN_vkDebugUtilsMessengerCallbackEXT value) { this->pfnUserCallback = value; }
  PFN_vkDebugUtilsMessengerCallbackEXT getPfnUserCallback() const { return this->pfnUserCallback; }

  void setFlags(DebugUtilsMessengerCreateFlagsEXT value) { this->flags = std::bit_cast<VkDebugUtilsMessengerCreateFlagsEXT>(value); }
  DebugUtilsMessengerCreateFlagsEXT getFlags() const { return std::bit_cast<DebugUtilsMessengerCreateFlagsEXT>(this->flags); }
  void setUserData(void* value) { this->pUserData = value; }
  void* getUserData() const { return this->pUserData; }
};
inline void InstanceCreateInfo::attach(DebugUtilsMessengerCreateInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_debug_utils

#if VK_EXT_layer_settings
struct LayerSettingsCreateInfoEXT : VkLayerSettingsCreateInfoEXT {
  LayerSettingsCreateInfoEXT() noexcept : VkLayerSettingsCreateInfoEXT{.sType = VK_STRUCTURE_TYPE_LAYER_SETTINGS_CREATE_INFO_EXT} {}

  // Number of settings to configure
  void setSettingCount(uint32_t value) { this->settingCount = value; }
  uint32_t getSettingCount() const { return this->settingCount; }
  // Validation features to enable
  void setSettings(const LayerSettingEXT* value) { this->pSettings = std::bit_cast<const VkLayerSettingEXT*>(value); }
  const LayerSettingEXT* getSettings() const { return std::bit_cast<const LayerSettingEXT*>(this->pSettings); }
};
inline void InstanceCreateInfo::attach(LayerSettingsCreateInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_layer_settings

#if VK_NV_optical_flow
struct OpticalFlowSessionCreatePrivateDataInfoNV : VkOpticalFlowSessionCreatePrivateDataInfoNV {
  OpticalFlowSessionCreatePrivateDataInfoNV() noexcept : VkOpticalFlowSessionCreatePrivateDataInfoNV{.sType = VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV} {}

  void setId(uint32_t value) { this->id = value; }
  uint32_t getId() const { return this->id; }
  void setSize(uint32_t value) { this->size = value; }
  uint32_t getSize() const { return this->size; }
  void setPrivateData(const void* value) { this->pPrivateData = value; }
  const void* getPrivateData() const { return this->pPrivateData; }
};
inline void OpticalFlowSessionCreateInfoNV::attach(OpticalFlowSessionCreatePrivateDataInfoNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_optical_flow

#if VK_KHR_map_memory2
using MemoryUnmapInfoKHR = MemoryUnmapInfo;
#endif // VK_KHR_map_memory2

#if VK_ARM_tensors
struct TensorCreateInfoARM : VkTensorCreateInfoARM {
  TensorCreateInfoARM() noexcept : VkTensorCreateInfoARM{.sType = VK_STRUCTURE_TYPE_TENSOR_CREATE_INFO_ARM} {}

  void setDescription(const TensorDescriptionARM* value) { this->pDescription = std::bit_cast<const VkTensorDescriptionARM*>(value); }
  const TensorDescriptionARM* getDescription() const { return std::bit_cast<const TensorDescriptionARM*>(this->pDescription); }
  void setSharingMode(SharingMode value) { this->sharingMode = std::bit_cast<VkSharingMode>(value); }
  SharingMode getSharingMode() const { return std::bit_cast<SharingMode>(this->sharingMode); }

  void setFlags(TensorCreateFlagsARM value) { this->flags = std::bit_cast<VkTensorCreateFlagsARM>(value); }
  TensorCreateFlagsARM getFlags() const { return std::bit_cast<TensorCreateFlagsARM>(this->flags); }
  void setQueueFamilyIndexCount(uint32_t value) { this->queueFamilyIndexCount = value; }
  uint32_t getQueueFamilyIndexCount() const { return this->queueFamilyIndexCount; }
  void setQueueFamilyIndices(const uint32_t* value) { this->pQueueFamilyIndices = value; }
  const uint32_t* getQueueFamilyIndices() const { return this->pQueueFamilyIndices; }

  void attach(struct OpaqueCaptureDescriptorDataCreateInfoEXT&);
  void attach(struct ExternalMemoryTensorCreateInfoARM&);
};

struct PhysicalDeviceExternalTensorInfoARM : VkPhysicalDeviceExternalTensorInfoARM {
  PhysicalDeviceExternalTensorInfoARM() noexcept : VkPhysicalDeviceExternalTensorInfoARM{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_TENSOR_INFO_ARM} {}

  void setDescription(const TensorDescriptionARM* value) { this->pDescription = std::bit_cast<const VkTensorDescriptionARM*>(value); }
  const TensorDescriptionARM* getDescription() const { return std::bit_cast<const TensorDescriptionARM*>(this->pDescription); }
  void setHandleType(ExternalMemoryHandleTypeFlagBits value) { this->handleType = std::bit_cast<VkExternalMemoryHandleTypeFlagBits>(value); }
  ExternalMemoryHandleTypeFlagBits getHandleType() const { return std::bit_cast<ExternalMemoryHandleTypeFlagBits>(this->handleType); }

  void setFlags(TensorCreateFlagsARM value) { this->flags = std::bit_cast<VkTensorCreateFlagsARM>(value); }
  TensorCreateFlagsARM getFlags() const { return std::bit_cast<TensorCreateFlagsARM>(this->flags); }
};
#endif // VK_ARM_tensors

#if VK_KHR_dedicated_allocation
using MemoryDedicatedRequirementsKHR = MemoryDedicatedRequirements;
#endif // VK_KHR_dedicated_allocation
#if VK_EXT_host_image_copy
using SubresourceHostMemcpySizeEXT = SubresourceHostMemcpySize;
#endif // VK_EXT_host_image_copy
#if VK_EXT_vertex_attribute_divisor
using PipelineVertexInputDivisorStateCreateInfoEXT = PipelineVertexInputDivisorStateCreateInfo;
#endif // VK_EXT_vertex_attribute_divisor
#if VK_KHR_vertex_attribute_divisor
using PipelineVertexInputDivisorStateCreateInfoKHR = PipelineVertexInputDivisorStateCreateInfo;
#endif // VK_KHR_vertex_attribute_divisor

#if VK_KHR_maintenance6
using BindMemoryStatusKHR = BindMemoryStatus;
#endif // VK_KHR_maintenance6
#if VK_KHR_sampler_ycbcr_conversion
using BindImagePlaneMemoryInfoKHR = BindImagePlaneMemoryInfo;
using ImagePlaneMemoryRequirementsInfoKHR = ImagePlaneMemoryRequirementsInfo;
#endif // VK_KHR_sampler_ycbcr_conversion

#if VK_KHR_video_encode_h265
struct VideoEncodeH265DpbSlotInfoKHR : VkVideoEncodeH265DpbSlotInfoKHR {
  VideoEncodeH265DpbSlotInfoKHR() noexcept : VkVideoEncodeH265DpbSlotInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_KHR} {}

  void setStdReferenceInfo(const StdVideoEncodeH265ReferenceInfo* value) { this->pStdReferenceInfo = value; }
  const StdVideoEncodeH265ReferenceInfo* getStdReferenceInfo() const { return this->pStdReferenceInfo; }
};
inline void VideoReferenceSlotInfoKHR::attach(VideoEncodeH265DpbSlotInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_encode_h265

#if VK_KHR_video_encode_av1
struct VideoEncodeAV1DpbSlotInfoKHR : VkVideoEncodeAV1DpbSlotInfoKHR {
  VideoEncodeAV1DpbSlotInfoKHR() noexcept : VkVideoEncodeAV1DpbSlotInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_DPB_SLOT_INFO_KHR} {}

  void setStdReferenceInfo(const StdVideoEncodeAV1ReferenceInfo* value) { this->pStdReferenceInfo = value; }
  const StdVideoEncodeAV1ReferenceInfo* getStdReferenceInfo() const { return this->pStdReferenceInfo; }
};
inline void VideoReferenceSlotInfoKHR::attach(VideoEncodeAV1DpbSlotInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_encode_av1

#if VK_KHR_video_encode_intra_refresh
struct VideoReferenceIntraRefreshInfoKHR : VkVideoReferenceIntraRefreshInfoKHR {
  VideoReferenceIntraRefreshInfoKHR() noexcept : VkVideoReferenceIntraRefreshInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_REFERENCE_INTRA_REFRESH_INFO_KHR} {}

  void setDirtyIntraRefreshRegions(uint32_t value) { this->dirtyIntraRefreshRegions = value; }
  uint32_t getDirtyIntraRefreshRegions() const { return this->dirtyIntraRefreshRegions; }
};
inline void VideoReferenceSlotInfoKHR::attach(VideoReferenceIntraRefreshInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_encode_intra_refresh

#if VK_KHR_video_decode_h265
struct VideoDecodeH265DpbSlotInfoKHR : VkVideoDecodeH265DpbSlotInfoKHR {
  VideoDecodeH265DpbSlotInfoKHR() noexcept : VkVideoDecodeH265DpbSlotInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR} {}

  void setStdReferenceInfo(const StdVideoDecodeH265ReferenceInfo* value) { this->pStdReferenceInfo = value; }
  const StdVideoDecodeH265ReferenceInfo* getStdReferenceInfo() const { return this->pStdReferenceInfo; }
};
inline void VideoReferenceSlotInfoKHR::attach(VideoDecodeH265DpbSlotInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_decode_h265

#if VK_KHR_video_queue
struct VideoBeginCodingInfoKHR : VkVideoBeginCodingInfoKHR {
  VideoBeginCodingInfoKHR() noexcept : VkVideoBeginCodingInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR} {}

  void setVideoSession(VideoSessionKHR value) { this->videoSession = std::bit_cast<VkVideoSessionKHR>(value); }
  VideoSessionKHR getVideoSession() const { return std::bit_cast<VideoSessionKHR>(this->videoSession); }

  void setFlags(VideoBeginCodingFlagsKHR value) { this->flags = std::bit_cast<VkVideoBeginCodingFlagsKHR>(value); }
  VideoBeginCodingFlagsKHR getFlags() const { return std::bit_cast<VideoBeginCodingFlagsKHR>(this->flags); }
  void setVideoSessionParameters(VideoSessionParametersKHR value) { this->videoSessionParameters = std::bit_cast<VkVideoSessionParametersKHR>(value); }
  VideoSessionParametersKHR getVideoSessionParameters() const { return std::bit_cast<VideoSessionParametersKHR>(this->videoSessionParameters); }
  void setReferenceSlotCount(uint32_t value) { this->referenceSlotCount = value; }
  uint32_t getReferenceSlotCount() const { return this->referenceSlotCount; }
  void setReferenceSlots(const VideoReferenceSlotInfoKHR* value) { this->pReferenceSlots = std::bit_cast<const VkVideoReferenceSlotInfoKHR*>(value); }
  const VideoReferenceSlotInfoKHR* getReferenceSlots() const { return std::bit_cast<const VideoReferenceSlotInfoKHR*>(this->pReferenceSlots); }

#if VK_KHR_video_encode_queue
  void attach(struct VideoEncodeRateControlInfoKHR&);
#endif // VK_KHR_video_encode_queue
#if VK_KHR_video_encode_h264
  void attach(struct VideoEncodeH264RateControlInfoKHR&);
  void attach(struct VideoEncodeH264GopRemainingFrameInfoKHR&);
#endif // VK_KHR_video_encode_h264
#if VK_KHR_video_encode_h265
  void attach(struct VideoEncodeH265RateControlInfoKHR&);
  void attach(struct VideoEncodeH265GopRemainingFrameInfoKHR&);
#endif // VK_KHR_video_encode_h265
#if VK_KHR_video_encode_av1
  void attach(struct VideoEncodeAV1RateControlInfoKHR&);
  void attach(struct VideoEncodeAV1GopRemainingFrameInfoKHR&);
#endif // VK_KHR_video_encode_av1
};
#endif // VK_KHR_video_queue

#if VK_KHR_video_encode_h264
struct VideoEncodeH264DpbSlotInfoKHR : VkVideoEncodeH264DpbSlotInfoKHR {
  VideoEncodeH264DpbSlotInfoKHR() noexcept : VkVideoEncodeH264DpbSlotInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_KHR} {}

  void setStdReferenceInfo(const StdVideoEncodeH264ReferenceInfo* value) { this->pStdReferenceInfo = value; }
  const StdVideoEncodeH264ReferenceInfo* getStdReferenceInfo() const { return this->pStdReferenceInfo; }
};
inline void VideoReferenceSlotInfoKHR::attach(VideoEncodeH264DpbSlotInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_encode_h264

#if VK_KHR_video_encode_queue
struct VideoEncodeInfoKHR : VkVideoEncodeInfoKHR {
  VideoEncodeInfoKHR() noexcept : VkVideoEncodeInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR} {}

  void setDstBuffer(Buffer value) { this->dstBuffer = std::bit_cast<VkBuffer>(value); }
  Buffer getDstBuffer() const { return std::bit_cast<Buffer>(this->dstBuffer); }
  void setDstBufferOffset(DeviceSize value) { this->dstBufferOffset = value; }
  DeviceSize getDstBufferOffset() const { return this->dstBufferOffset; }
  void setDstBufferRange(DeviceSize value) { this->dstBufferRange = value; }
  DeviceSize getDstBufferRange() const { return this->dstBufferRange; }
  void setSrcPictureResource(const VideoPictureResourceInfoKHR& value) { this->srcPictureResource = value; }
  const VideoPictureResourceInfoKHR& getSrcPictureResource() const { return static_cast<const VideoPictureResourceInfoKHR&>(this->srcPictureResource); }
  void setPrecedingExternallyEncodedBytes(uint32_t value) { this->precedingExternallyEncodedBytes = value; }
  uint32_t getPrecedingExternallyEncodedBytes() const { return this->precedingExternallyEncodedBytes; }

  void setFlags(VideoEncodeFlagsKHR value) { this->flags = std::bit_cast<VkVideoEncodeFlagsKHR>(value); }
  VideoEncodeFlagsKHR getFlags() const { return std::bit_cast<VideoEncodeFlagsKHR>(this->flags); }
  void setSetupReferenceSlot(const VideoReferenceSlotInfoKHR* value) { this->pSetupReferenceSlot = std::bit_cast<const VkVideoReferenceSlotInfoKHR*>(value); }
  const VideoReferenceSlotInfoKHR* getSetupReferenceSlot() const { return std::bit_cast<const VideoReferenceSlotInfoKHR*>(this->pSetupReferenceSlot); }
  void setReferenceSlotCount(uint32_t value) { this->referenceSlotCount = value; }
  uint32_t getReferenceSlotCount() const { return this->referenceSlotCount; }
  void setReferenceSlots(const VideoReferenceSlotInfoKHR* value) { this->pReferenceSlots = std::bit_cast<const VkVideoReferenceSlotInfoKHR*>(value); }
  const VideoReferenceSlotInfoKHR* getReferenceSlots() const { return std::bit_cast<const VideoReferenceSlotInfoKHR*>(this->pReferenceSlots); }

#if VK_KHR_video_maintenance1
  void attach(struct VideoInlineQueryInfoKHR&);
#endif // VK_KHR_video_maintenance1
#if VK_KHR_video_encode_quantization_map
  void attach(struct VideoEncodeQuantizationMapInfoKHR&);
#endif // VK_KHR_video_encode_quantization_map
  void attach(struct VideoEncodeH264PictureInfoKHR&);
  void attach(struct VideoEncodeH265PictureInfoKHR&);
#if VK_KHR_video_encode_av1
  void attach(struct VideoEncodeAV1PictureInfoKHR&);
#endif // VK_KHR_video_encode_av1
#if VK_KHR_video_encode_intra_refresh
  void attach(struct VideoEncodeIntraRefreshInfoKHR&);
#endif // VK_KHR_video_encode_intra_refresh
};
#endif // VK_KHR_video_encode_queue

#if VK_KHR_video_decode_h264
struct VideoDecodeH264DpbSlotInfoKHR : VkVideoDecodeH264DpbSlotInfoKHR {
  VideoDecodeH264DpbSlotInfoKHR() noexcept : VkVideoDecodeH264DpbSlotInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR} {}

  void setStdReferenceInfo(const StdVideoDecodeH264ReferenceInfo* value) { this->pStdReferenceInfo = value; }
  const StdVideoDecodeH264ReferenceInfo* getStdReferenceInfo() const { return this->pStdReferenceInfo; }
};
inline void VideoReferenceSlotInfoKHR::attach(VideoDecodeH264DpbSlotInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_decode_h264

#if VK_KHR_video_decode_queue
struct VideoDecodeInfoKHR : VkVideoDecodeInfoKHR {
  VideoDecodeInfoKHR() noexcept : VkVideoDecodeInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR} {}

  void setSrcBuffer(Buffer value) { this->srcBuffer = std::bit_cast<VkBuffer>(value); }
  Buffer getSrcBuffer() const { return std::bit_cast<Buffer>(this->srcBuffer); }
  void setSrcBufferOffset(DeviceSize value) { this->srcBufferOffset = value; }
  DeviceSize getSrcBufferOffset() const { return this->srcBufferOffset; }
  void setSrcBufferRange(DeviceSize value) { this->srcBufferRange = value; }
  DeviceSize getSrcBufferRange() const { return this->srcBufferRange; }
  void setDstPictureResource(const VideoPictureResourceInfoKHR& value) { this->dstPictureResource = value; }
  const VideoPictureResourceInfoKHR& getDstPictureResource() const { return static_cast<const VideoPictureResourceInfoKHR&>(this->dstPictureResource); }

  void setFlags(VideoDecodeFlagsKHR value) { this->flags = std::bit_cast<VkVideoDecodeFlagsKHR>(value); }
  VideoDecodeFlagsKHR getFlags() const { return std::bit_cast<VideoDecodeFlagsKHR>(this->flags); }
  void setSetupReferenceSlot(const VideoReferenceSlotInfoKHR* value) { this->pSetupReferenceSlot = std::bit_cast<const VkVideoReferenceSlotInfoKHR*>(value); }
  const VideoReferenceSlotInfoKHR* getSetupReferenceSlot() const { return std::bit_cast<const VideoReferenceSlotInfoKHR*>(this->pSetupReferenceSlot); }
  void setReferenceSlotCount(uint32_t value) { this->referenceSlotCount = value; }
  uint32_t getReferenceSlotCount() const { return this->referenceSlotCount; }
  void setReferenceSlots(const VideoReferenceSlotInfoKHR* value) { this->pReferenceSlots = std::bit_cast<const VkVideoReferenceSlotInfoKHR*>(value); }
  const VideoReferenceSlotInfoKHR* getReferenceSlots() const { return std::bit_cast<const VideoReferenceSlotInfoKHR*>(this->pReferenceSlots); }

#if VK_KHR_video_maintenance1
  void attach(struct VideoInlineQueryInfoKHR&);
#endif // VK_KHR_video_maintenance1
#if VK_KHR_video_maintenance2
  void attach(struct VideoDecodeH264InlineSessionParametersInfoKHR&);
#endif // VK_KHR_video_maintenance2
#if VK_KHR_video_decode_h264
  void attach(struct VideoDecodeH264PictureInfoKHR&);
#endif // VK_KHR_video_decode_h264
#if VK_KHR_video_maintenance2
  void attach(struct VideoDecodeH265InlineSessionParametersInfoKHR&);
#endif // VK_KHR_video_maintenance2
#if VK_KHR_video_decode_h265
  void attach(struct VideoDecodeH265PictureInfoKHR&);
#endif // VK_KHR_video_decode_h265
#if VK_KHR_video_decode_vp9
  void attach(struct VideoDecodeVP9PictureInfoKHR&);
#endif // VK_KHR_video_decode_vp9
#if VK_KHR_video_maintenance2
  void attach(struct VideoDecodeAV1InlineSessionParametersInfoKHR&);
#endif // VK_KHR_video_maintenance2
#if VK_KHR_video_decode_av1
  void attach(struct VideoDecodeAV1PictureInfoKHR&);
#endif // VK_KHR_video_decode_av1
};
#endif // VK_KHR_video_decode_queue

#if VK_KHR_video_decode_av1
struct VideoDecodeAV1DpbSlotInfoKHR : VkVideoDecodeAV1DpbSlotInfoKHR {
  VideoDecodeAV1DpbSlotInfoKHR() noexcept : VkVideoDecodeAV1DpbSlotInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_DPB_SLOT_INFO_KHR} {}

  void setStdReferenceInfo(const StdVideoDecodeAV1ReferenceInfo* value) { this->pStdReferenceInfo = value; }
  const StdVideoDecodeAV1ReferenceInfo* getStdReferenceInfo() const { return this->pStdReferenceInfo; }
};
inline void VideoReferenceSlotInfoKHR::attach(VideoDecodeAV1DpbSlotInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_decode_av1

#if VK_KHR_dynamic_rendering
using RenderingInfoKHR = RenderingInfo;
#endif // VK_KHR_dynamic_rendering

#if VK_KHR_fragment_shading_rate
struct RenderingFragmentShadingRateAttachmentInfoKHR : VkRenderingFragmentShadingRateAttachmentInfoKHR {
  RenderingFragmentShadingRateAttachmentInfoKHR() noexcept : VkRenderingFragmentShadingRateAttachmentInfoKHR{.sType = VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR} {}

  void setImageLayout(ImageLayout value) { this->imageLayout = std::bit_cast<VkImageLayout>(value); }
  ImageLayout getImageLayout() const { return std::bit_cast<ImageLayout>(this->imageLayout); }
  void setShadingRateAttachmentTexelSize(const Extent2D& value) { this->shadingRateAttachmentTexelSize = value; }
  const Extent2D& getShadingRateAttachmentTexelSize() const { return static_cast<const Extent2D&>(this->shadingRateAttachmentTexelSize); }

  void setImageView(ImageView value) { this->imageView = std::bit_cast<VkImageView>(value); }
  ImageView getImageView() const { return std::bit_cast<ImageView>(this->imageView); }
};
inline void RenderingInfo::attach(RenderingFragmentShadingRateAttachmentInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_fragment_shading_rate

#if VK_EXT_fragment_density_map
struct RenderingFragmentDensityMapAttachmentInfoEXT : VkRenderingFragmentDensityMapAttachmentInfoEXT {
  RenderingFragmentDensityMapAttachmentInfoEXT() noexcept : VkRenderingFragmentDensityMapAttachmentInfoEXT{.sType = VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT} {}

  void setImageView(ImageView value) { this->imageView = std::bit_cast<VkImageView>(value); }
  ImageView getImageView() const { return std::bit_cast<ImageView>(this->imageView); }
  void setImageLayout(ImageLayout value) { this->imageLayout = std::bit_cast<VkImageLayout>(value); }
  ImageLayout getImageLayout() const { return std::bit_cast<ImageLayout>(this->imageLayout); }
};
inline void RenderingInfo::attach(RenderingFragmentDensityMapAttachmentInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_fragment_density_map

#if VK_QCOM_multiview_per_view_render_areas
struct MultiviewPerViewRenderAreasRenderPassBeginInfoQCOM : VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM {
  MultiviewPerViewRenderAreasRenderPassBeginInfoQCOM() noexcept : VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM{.sType = VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM} {}

  void setPerViewRenderAreaCount(uint32_t value) { this->perViewRenderAreaCount = value; }
  uint32_t getPerViewRenderAreaCount() const { return this->perViewRenderAreaCount; }
  void setPerViewRenderAreas(const Rect2D* value) { this->pPerViewRenderAreas = std::bit_cast<const VkRect2D*>(value); }
  const Rect2D* getPerViewRenderAreas() const { return std::bit_cast<const Rect2D*>(this->pPerViewRenderAreas); }
};
inline void RenderPassBeginInfo::attach(MultiviewPerViewRenderAreasRenderPassBeginInfoQCOM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void RenderingInfo::attach(MultiviewPerViewRenderAreasRenderPassBeginInfoQCOM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_QCOM_multiview_per_view_render_areas

#if VK_ARM_render_pass_striped
struct RenderPassStripeBeginInfoARM : VkRenderPassStripeBeginInfoARM {
  RenderPassStripeBeginInfoARM() noexcept : VkRenderPassStripeBeginInfoARM{.sType = VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_BEGIN_INFO_ARM} {}

  void setStripeInfoCount(uint32_t value) { this->stripeInfoCount = value; }
  uint32_t getStripeInfoCount() const { return this->stripeInfoCount; }
  void setStripeInfos(const RenderPassStripeInfoARM* value) { this->pStripeInfos = std::bit_cast<const VkRenderPassStripeInfoARM*>(value); }
  const RenderPassStripeInfoARM* getStripeInfos() const { return std::bit_cast<const RenderPassStripeInfoARM*>(this->pStripeInfos); }
};
inline void RenderingInfo::attach(RenderPassStripeBeginInfoARM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void RenderPassBeginInfo::attach(RenderPassStripeBeginInfoARM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_ARM_render_pass_striped

#if VK_VERSION_1_1
struct DeviceGroupRenderPassBeginInfo : VkDeviceGroupRenderPassBeginInfo {
  DeviceGroupRenderPassBeginInfo() noexcept : VkDeviceGroupRenderPassBeginInfo{.sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO} {}

  void setDeviceMask(uint32_t value) { this->deviceMask = value; }
  uint32_t getDeviceMask() const { return this->deviceMask; }

  void setDeviceRenderAreaCount(uint32_t value) { this->deviceRenderAreaCount = value; }
  uint32_t getDeviceRenderAreaCount() const { return this->deviceRenderAreaCount; }
  void setDeviceRenderAreas(const Rect2D* value) { this->pDeviceRenderAreas = std::bit_cast<const VkRect2D*>(value); }
  const Rect2D* getDeviceRenderAreas() const { return std::bit_cast<const Rect2D*>(this->pDeviceRenderAreas); }
};
inline void RenderPassBeginInfo::attach(DeviceGroupRenderPassBeginInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#if VK_VERSION_1_3
inline void RenderingInfo::attach(DeviceGroupRenderPassBeginInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_3
#endif // VK_VERSION_1_1

#if VK_KHR_acceleration_structure
struct WriteDescriptorSetAccelerationStructureKHR : VkWriteDescriptorSetAccelerationStructureKHR {
  WriteDescriptorSetAccelerationStructureKHR() noexcept : VkWriteDescriptorSetAccelerationStructureKHR{.sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR} {}

  void setAccelerationStructureCount(uint32_t value) { this->accelerationStructureCount = value; }
  uint32_t getAccelerationStructureCount() const { return this->accelerationStructureCount; }

  void setAccelerationStructures(const AccelerationStructureKHR* value) { this->pAccelerationStructures = std::bit_cast<const VkAccelerationStructureKHR*>(value); }
  const AccelerationStructureKHR* getAccelerationStructures() const { return std::bit_cast<const AccelerationStructureKHR*>(this->pAccelerationStructures); }
};
inline void WriteDescriptorSet::attach(WriteDescriptorSetAccelerationStructureKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_acceleration_structure

#if VK_VERSION_1_4
struct PushDescriptorSetInfo : VkPushDescriptorSetInfo {
  PushDescriptorSetInfo() noexcept : VkPushDescriptorSetInfo{.sType = VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_INFO} {}

  void setStageFlags(ShaderStageFlags value) { this->stageFlags = std::bit_cast<VkShaderStageFlags>(value); }
  ShaderStageFlags getStageFlags() const { return std::bit_cast<ShaderStageFlags>(this->stageFlags); }
  void setDescriptorWriteCount(uint32_t value) { this->descriptorWriteCount = value; }
  uint32_t getDescriptorWriteCount() const { return this->descriptorWriteCount; }
  void setDescriptorWrites(const WriteDescriptorSet* value) { this->pDescriptorWrites = std::bit_cast<const VkWriteDescriptorSet*>(value); }
  const WriteDescriptorSet* getDescriptorWrites() const { return std::bit_cast<const WriteDescriptorSet*>(this->pDescriptorWrites); }

  void setLayout(PipelineLayout value) { this->layout = std::bit_cast<VkPipelineLayout>(value); }
  PipelineLayout getLayout() const { return std::bit_cast<PipelineLayout>(this->layout); }
  void setSet(uint32_t value) { this->set = value; }
  uint32_t getSet() const { return this->set; }

  void attach(struct PipelineLayoutCreateInfo&);
};
#endif // VK_VERSION_1_4

#if VK_ARM_tensors
struct WriteDescriptorSetTensorARM : VkWriteDescriptorSetTensorARM {
  WriteDescriptorSetTensorARM() noexcept : VkWriteDescriptorSetTensorARM{.sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_TENSOR_ARM} {}

  void setTensorViewCount(uint32_t value) { this->tensorViewCount = value; }
  uint32_t getTensorViewCount() const { return this->tensorViewCount; }
  void setTensorViews(const TensorViewARM* value) { this->pTensorViews = std::bit_cast<const VkTensorViewARM*>(value); }
  const TensorViewARM* getTensorViews() const { return std::bit_cast<const TensorViewARM*>(this->pTensorViews); }
};
inline void WriteDescriptorSet::attach(WriteDescriptorSetTensorARM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_ARM_tensors

#if VK_NV_partitioned_acceleration_structure
struct WriteDescriptorSetPartitionedAccelerationStructureNV : VkWriteDescriptorSetPartitionedAccelerationStructureNV {
  WriteDescriptorSetPartitionedAccelerationStructureNV() noexcept : VkWriteDescriptorSetPartitionedAccelerationStructureNV{.sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_PARTITIONED_ACCELERATION_STRUCTURE_NV} {}

  void setAccelerationStructureCount(uint32_t value) { this->accelerationStructureCount = value; }
  uint32_t getAccelerationStructureCount() const { return this->accelerationStructureCount; }

  void setAccelerationStructures(const DeviceAddress* value) { this->pAccelerationStructures = value; }
  const DeviceAddress* getAccelerationStructures() const { return this->pAccelerationStructures; }
};
inline void WriteDescriptorSet::attach(WriteDescriptorSetPartitionedAccelerationStructureNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_partitioned_acceleration_structure

#if VK_VERSION_1_3
struct WriteDescriptorSetInlineUniformBlock : VkWriteDescriptorSetInlineUniformBlock {
  WriteDescriptorSetInlineUniformBlock() noexcept : VkWriteDescriptorSetInlineUniformBlock{.sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK} {}

  void setDataSize(uint32_t value) { this->dataSize = value; }
  uint32_t getDataSize() const { return this->dataSize; }
  void setData(const void* value) { this->pData = value; }
  const void* getData() const { return this->pData; }
};
inline void WriteDescriptorSet::attach(WriteDescriptorSetInlineUniformBlock& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_3

#if VK_EXT_descriptor_indexing
using DescriptorSetVariableDescriptorCountAllocateInfoEXT = DescriptorSetVariableDescriptorCountAllocateInfo;
#endif // VK_EXT_descriptor_indexing
#if VK_KHR_imageless_framebuffer
using RenderPassAttachmentBeginInfoKHR = RenderPassAttachmentBeginInfo;
#endif // VK_KHR_imageless_framebuffer

#if VK_NV_display_stereo
struct DisplayModeStereoPropertiesNV : VkDisplayModeStereoPropertiesNV {
  DisplayModeStereoPropertiesNV() noexcept : VkDisplayModeStereoPropertiesNV{.sType = VK_STRUCTURE_TYPE_DISPLAY_MODE_STEREO_PROPERTIES_NV} {}

  // Whether this mode supports HDMI 3D stereo rendering.
  Bool32 getHdmi3DSupported() const { return this->hdmi3DSupported; }
};
inline void DisplayModeProperties2KHR::attach(DisplayModeStereoPropertiesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_display_stereo

#if VK_EXT_surface_maintenance1
using SurfacePresentModeEXT = SurfacePresentModeKHR;
#endif // VK_EXT_surface_maintenance1
#if VK_EXT_swapchain_maintenance1
using SwapchainPresentFenceInfoEXT = SwapchainPresentFenceInfoKHR;
using SwapchainPresentModeInfoEXT = SwapchainPresentModeInfoKHR;
#endif // VK_EXT_swapchain_maintenance1

#if VK_NV_device_diagnostic_checkpoints
struct QueueFamilyCheckpointPropertiesNV : VkQueueFamilyCheckpointPropertiesNV {
  QueueFamilyCheckpointPropertiesNV() noexcept : VkQueueFamilyCheckpointPropertiesNV{.sType = VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV} {}

  PipelineStageFlags getCheckpointExecutionStageMask() const { return std::bit_cast<PipelineStageFlags>(this->checkpointExecutionStageMask); }
};
inline void QueueFamilyProperties2::attach(QueueFamilyCheckpointPropertiesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_device_diagnostic_checkpoints

#if VK_KHR_get_physical_device_properties2
using QueueFamilyProperties2KHR = QueueFamilyProperties2;
#endif // VK_KHR_get_physical_device_properties2

#if VK_VERSION_1_4
struct QueueFamilyGlobalPriorityProperties : VkQueueFamilyGlobalPriorityProperties {
  QueueFamilyGlobalPriorityProperties() noexcept : VkQueueFamilyGlobalPriorityProperties{.sType = VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES} {}

  uint32_t getPriorityCount() const { return this->priorityCount; }
  std::span<const QueueGlobalPriority, VK_MAX_GLOBAL_PRIORITY_SIZE> getPriorities() const { return std::span<const QueueGlobalPriority, VK_MAX_GLOBAL_PRIORITY_SIZE>(std::bit_cast<const QueueGlobalPriority*>(&this->priorities), VK_MAX_GLOBAL_PRIORITY_SIZE); }
};
inline void QueueFamilyProperties2::attach(QueueFamilyGlobalPriorityProperties& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_4

#if VK_KHR_maintenance9
struct QueueFamilyOwnershipTransferPropertiesKHR : VkQueueFamilyOwnershipTransferPropertiesKHR {
  QueueFamilyOwnershipTransferPropertiesKHR() noexcept : VkQueueFamilyOwnershipTransferPropertiesKHR{.sType = VK_STRUCTURE_TYPE_QUEUE_FAMILY_OWNERSHIP_TRANSFER_PROPERTIES_KHR} {}

  uint32_t getOptimalImageTransferToQueueFamilies() const { return this->optimalImageTransferToQueueFamilies; }
};
inline void QueueFamilyProperties2::attach(QueueFamilyOwnershipTransferPropertiesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_maintenance9

#if VK_KHR_video_queue
struct QueueFamilyQueryResultStatusPropertiesKHR : VkQueueFamilyQueryResultStatusPropertiesKHR {
  QueueFamilyQueryResultStatusPropertiesKHR() noexcept : VkQueueFamilyQueryResultStatusPropertiesKHR{.sType = VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR} {}

  Bool32 getQueryResultStatusSupport() const { return this->queryResultStatusSupport; }
};
inline void QueueFamilyProperties2::attach(QueueFamilyQueryResultStatusPropertiesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }

struct QueueFamilyVideoPropertiesKHR : VkQueueFamilyVideoPropertiesKHR {
  QueueFamilyVideoPropertiesKHR() noexcept : VkQueueFamilyVideoPropertiesKHR{.sType = VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR} {}

  VideoCodecOperationFlagsKHR getVideoCodecOperations() const { return std::bit_cast<VideoCodecOperationFlagsKHR>(this->videoCodecOperations); }
};
inline void QueueFamilyProperties2::attach(QueueFamilyVideoPropertiesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_queue

#if VK_KHR_line_rasterization
using PipelineRasterizationLineStateCreateInfoKHR = PipelineRasterizationLineStateCreateInfo;
#endif // VK_KHR_line_rasterization
#if VK_EXT_line_rasterization
using PipelineRasterizationLineStateCreateInfoEXT = PipelineRasterizationLineStateCreateInfo;
#endif // VK_EXT_line_rasterization
#if VK_KHR_global_priority
using DeviceQueueGlobalPriorityCreateInfoKHR = DeviceQueueGlobalPriorityCreateInfo;
#endif // VK_KHR_global_priority
#if VK_EXT_global_priority
using DeviceQueueGlobalPriorityCreateInfoEXT = DeviceQueueGlobalPriorityCreateInfo;
#endif // VK_EXT_global_priority

#if VK_KHR_pipeline_binary
struct DevicePipelineBinaryInternalCacheControlKHR : VkDevicePipelineBinaryInternalCacheControlKHR {
  DevicePipelineBinaryInternalCacheControlKHR() noexcept : VkDevicePipelineBinaryInternalCacheControlKHR{.sType = VK_STRUCTURE_TYPE_DEVICE_PIPELINE_BINARY_INTERNAL_CACHE_CONTROL_KHR} {}

  void setDisableInternalCache(Bool32 value) { this->disableInternalCache = value; }
  Bool32 getDisableInternalCache() const { return this->disableInternalCache; }
};
inline void DeviceCreateInfo::attach(DevicePipelineBinaryInternalCacheControlKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_pipeline_binary

#if VK_AMD_memory_overallocation_behavior
struct DeviceMemoryOverallocationCreateInfoAMD : VkDeviceMemoryOverallocationCreateInfoAMD {
  DeviceMemoryOverallocationCreateInfoAMD() noexcept : VkDeviceMemoryOverallocationCreateInfoAMD{.sType = VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD} {}

  void setOverallocationBehavior(MemoryOverallocationBehaviorAMD value) { this->overallocationBehavior = std::bit_cast<VkMemoryOverallocationBehaviorAMD>(value); }
  MemoryOverallocationBehaviorAMD getOverallocationBehavior() const { return std::bit_cast<MemoryOverallocationBehaviorAMD>(this->overallocationBehavior); }
};
inline void DeviceCreateInfo::attach(DeviceMemoryOverallocationCreateInfoAMD& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_AMD_memory_overallocation_behavior

#if VK_ARM_scheduling_controls
struct DeviceQueueShaderCoreControlCreateInfoARM : VkDeviceQueueShaderCoreControlCreateInfoARM {
  DeviceQueueShaderCoreControlCreateInfoARM() noexcept : VkDeviceQueueShaderCoreControlCreateInfoARM{.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_SHADER_CORE_CONTROL_CREATE_INFO_ARM} {}

  void setShaderCoreCount(uint32_t value) { this->shaderCoreCount = value; }
  uint32_t getShaderCoreCount() const { return this->shaderCoreCount; }
};
inline void DeviceQueueCreateInfo::attach(DeviceQueueShaderCoreControlCreateInfoARM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(DeviceQueueShaderCoreControlCreateInfoARM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_ARM_scheduling_controls

#if VK_NV_external_compute_queue
struct ExternalComputeQueueDeviceCreateInfoNV : VkExternalComputeQueueDeviceCreateInfoNV {
  ExternalComputeQueueDeviceCreateInfoNV() noexcept : VkExternalComputeQueueDeviceCreateInfoNV{.sType = VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_DEVICE_CREATE_INFO_NV} {}

  void setReservedExternalQueues(uint32_t value) { this->reservedExternalQueues = value; }
  uint32_t getReservedExternalQueues() const { return this->reservedExternalQueues; }
};
inline void DeviceCreateInfo::attach(ExternalComputeQueueDeviceCreateInfoNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_external_compute_queue

#if VK_VERSION_1_3
struct DevicePrivateDataCreateInfo : VkDevicePrivateDataCreateInfo {
  DevicePrivateDataCreateInfo() noexcept : VkDevicePrivateDataCreateInfo{.sType = VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO} {}

  void setPrivateDataSlotRequestCount(uint32_t value) { this->privateDataSlotRequestCount = value; }
  uint32_t getPrivateDataSlotRequestCount() const { return this->privateDataSlotRequestCount; }
};
inline void DeviceCreateInfo::attach(DevicePrivateDataCreateInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_3

#if VK_VERSION_1_1
struct PhysicalDeviceFeatures2 : VkPhysicalDeviceFeatures2 {
  PhysicalDeviceFeatures2() noexcept : VkPhysicalDeviceFeatures2{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2} {}

  void setFeatures(const PhysicalDeviceFeatures& value) { this->features = value; }
  const PhysicalDeviceFeatures& getFeatures() const { return static_cast<const PhysicalDeviceFeatures&>(this->features); }

#if VK_NV_device_generated_commands
  void attach(struct PhysicalDeviceDeviceGeneratedCommandsFeaturesNV&);
#endif // VK_NV_device_generated_commands
#if VK_NV_device_generated_commands_compute
  void attach(struct PhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV&);
#endif // VK_NV_device_generated_commands_compute
#if VK_VERSION_1_3
  void attach(struct PhysicalDevicePrivateDataFeatures&);
#endif // VK_VERSION_1_3
#if VK_NV_cluster_acceleration_structure
  void attach(struct PhysicalDeviceClusterAccelerationStructureFeaturesNV&);
#endif // VK_NV_cluster_acceleration_structure
  void attach(struct PhysicalDeviceVariablePointersFeatures&);
  void attach(struct PhysicalDeviceMultiviewFeatures&);
#if VK_KHR_present_id
  void attach(struct PhysicalDevicePresentIdFeaturesKHR&);
#endif // VK_KHR_present_id
#if VK_KHR_present_id2
  void attach(struct PhysicalDevicePresentId2FeaturesKHR&);
#endif // VK_KHR_present_id2
#if VK_KHR_present_wait
  void attach(struct PhysicalDevicePresentWaitFeaturesKHR&);
#endif // VK_KHR_present_wait
#if VK_KHR_present_wait2
  void attach(struct PhysicalDevicePresentWait2FeaturesKHR&);
#endif // VK_KHR_present_wait2
  void attach(struct PhysicalDevice16BitStorageFeatures&);
#if VK_VERSION_1_2
  void attach(struct PhysicalDeviceShaderSubgroupExtendedTypesFeatures&);
#endif // VK_VERSION_1_2
  void attach(struct PhysicalDeviceSamplerYcbcrConversionFeatures&);
  void attach(struct PhysicalDeviceProtectedMemoryFeatures&);
#if VK_EXT_blend_operation_advanced
  void attach(struct PhysicalDeviceBlendOperationAdvancedFeaturesEXT&);
#endif // VK_EXT_blend_operation_advanced
#if VK_EXT_multi_draw
  void attach(struct PhysicalDeviceMultiDrawFeaturesEXT&);
#endif // VK_EXT_multi_draw
#if VK_VERSION_1_3
  void attach(struct PhysicalDeviceInlineUniformBlockFeatures&);
  void attach(struct PhysicalDeviceMaintenance4Features&);
#endif // VK_VERSION_1_3
#if VK_VERSION_1_4
  void attach(struct PhysicalDeviceMaintenance5Features&);
  void attach(struct PhysicalDeviceMaintenance6Features&);
#endif // VK_VERSION_1_4
#if VK_KHR_maintenance7
  void attach(struct PhysicalDeviceMaintenance7FeaturesKHR&);
#endif // VK_KHR_maintenance7
#if VK_KHR_maintenance8
  void attach(struct PhysicalDeviceMaintenance8FeaturesKHR&);
#endif // VK_KHR_maintenance8
#if VK_KHR_maintenance9
  void attach(struct PhysicalDeviceMaintenance9FeaturesKHR&);
#endif // VK_KHR_maintenance9
  void attach(struct PhysicalDeviceShaderDrawParametersFeatures&);
#if VK_VERSION_1_2
  void attach(struct PhysicalDeviceShaderFloat16Int8Features&);
  void attach(struct PhysicalDeviceHostQueryResetFeatures&);
#endif // VK_VERSION_1_2
#if VK_VERSION_1_4
  void attach(struct PhysicalDeviceGlobalPriorityQueryFeatures&);
#endif // VK_VERSION_1_4
#if VK_EXT_device_memory_report
  void attach(struct PhysicalDeviceDeviceMemoryReportFeaturesEXT&);
#endif // VK_EXT_device_memory_report
#if VK_VERSION_1_2
  void attach(struct PhysicalDeviceDescriptorIndexingFeatures&);
  void attach(struct PhysicalDeviceTimelineSemaphoreFeatures&);
  void attach(struct PhysicalDevice8BitStorageFeatures&);
#endif // VK_VERSION_1_2
#if VK_EXT_conditional_rendering
  void attach(struct PhysicalDeviceConditionalRenderingFeaturesEXT&);
#endif // VK_EXT_conditional_rendering
#if VK_VERSION_1_2
  void attach(struct PhysicalDeviceVulkanMemoryModelFeatures&);
  void attach(struct PhysicalDeviceShaderAtomicInt64Features&);
#endif // VK_VERSION_1_2
#if VK_EXT_shader_atomic_float
  void attach(struct PhysicalDeviceShaderAtomicFloatFeaturesEXT&);
#endif // VK_EXT_shader_atomic_float
#if VK_EXT_shader_atomic_float2
  void attach(struct PhysicalDeviceShaderAtomicFloat2FeaturesEXT&);
#endif // VK_EXT_shader_atomic_float2
#if VK_VERSION_1_4
  void attach(struct PhysicalDeviceVertexAttributeDivisorFeatures&);
#endif // VK_VERSION_1_4
#if VK_EXT_astc_decode_mode
  void attach(struct PhysicalDeviceASTCDecodeFeaturesEXT&);
#endif // VK_EXT_astc_decode_mode
#if VK_EXT_transform_feedback
  void attach(struct PhysicalDeviceTransformFeedbackFeaturesEXT&);
#endif // VK_EXT_transform_feedback
#if VK_NV_representative_fragment_test
  void attach(struct PhysicalDeviceRepresentativeFragmentTestFeaturesNV&);
#endif // VK_NV_representative_fragment_test
#if VK_NV_scissor_exclusive
  void attach(struct PhysicalDeviceExclusiveScissorFeaturesNV&);
#endif // VK_NV_scissor_exclusive
#if VK_NV_corner_sampled_image
  void attach(struct PhysicalDeviceCornerSampledImageFeaturesNV&);
#endif // VK_NV_corner_sampled_image
#if VK_KHR_compute_shader_derivatives
  void attach(struct PhysicalDeviceComputeShaderDerivativesFeaturesKHR&);
#endif // VK_KHR_compute_shader_derivatives
#if VK_NV_shader_image_footprint
  void attach(struct PhysicalDeviceShaderImageFootprintFeaturesNV&);
#endif // VK_NV_shader_image_footprint
#if VK_NV_dedicated_allocation_image_aliasing
  void attach(struct PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV&);
#endif // VK_NV_dedicated_allocation_image_aliasing
#if VK_NV_copy_memory_indirect
  void attach(struct PhysicalDeviceCopyMemoryIndirectFeaturesNV&);
#endif // VK_NV_copy_memory_indirect
#if VK_NV_memory_decompression
  void attach(struct PhysicalDeviceMemoryDecompressionFeaturesNV&);
#endif // VK_NV_memory_decompression
#if VK_NV_shading_rate_image
  void attach(struct PhysicalDeviceShadingRateImageFeaturesNV&);
#endif // VK_NV_shading_rate_image
#if VK_HUAWEI_invocation_mask
  void attach(struct PhysicalDeviceInvocationMaskFeaturesHUAWEI&);
#endif // VK_HUAWEI_invocation_mask
#if VK_NV_mesh_shader
  void attach(struct PhysicalDeviceMeshShaderFeaturesNV&);
#endif // VK_NV_mesh_shader
#if VK_EXT_mesh_shader
  void attach(struct PhysicalDeviceMeshShaderFeaturesEXT&);
#endif // VK_EXT_mesh_shader
#if VK_KHR_acceleration_structure
  void attach(struct PhysicalDeviceAccelerationStructureFeaturesKHR&);
#endif // VK_KHR_acceleration_structure
#if VK_KHR_ray_tracing_pipeline
  void attach(struct PhysicalDeviceRayTracingPipelineFeaturesKHR&);
#endif // VK_KHR_ray_tracing_pipeline
#if VK_KHR_ray_query
  void attach(struct PhysicalDeviceRayQueryFeaturesKHR&);
#endif // VK_KHR_ray_query
#if VK_KHR_ray_tracing_maintenance1
  void attach(struct PhysicalDeviceRayTracingMaintenance1FeaturesKHR&);
#endif // VK_KHR_ray_tracing_maintenance1
#if VK_EXT_fragment_density_map
  void attach(struct PhysicalDeviceFragmentDensityMapFeaturesEXT&);
#endif // VK_EXT_fragment_density_map
#if VK_EXT_fragment_density_map2
  void attach(struct PhysicalDeviceFragmentDensityMap2FeaturesEXT&);
#endif // VK_EXT_fragment_density_map2
#if VK_EXT_fragment_density_map_offset
  void attach(struct PhysicalDeviceFragmentDensityMapOffsetFeaturesEXT&);
#endif // VK_EXT_fragment_density_map_offset
#if VK_VERSION_1_2
  void attach(struct PhysicalDeviceScalarBlockLayoutFeatures&);
  void attach(struct PhysicalDeviceUniformBufferStandardLayoutFeatures&);
#endif // VK_VERSION_1_2
#if VK_EXT_depth_clip_enable
  void attach(struct PhysicalDeviceDepthClipEnableFeaturesEXT&);
#endif // VK_EXT_depth_clip_enable
#if VK_EXT_memory_priority
  void attach(struct PhysicalDeviceMemoryPriorityFeaturesEXT&);
#endif // VK_EXT_memory_priority
#if VK_EXT_pageable_device_local_memory
  void attach(struct PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT&);
#endif // VK_EXT_pageable_device_local_memory
#if VK_VERSION_1_2
  void attach(struct PhysicalDeviceBufferDeviceAddressFeatures&);
  void attach(struct PhysicalDeviceImagelessFramebufferFeatures&);
#endif // VK_VERSION_1_2
#if VK_VERSION_1_3
  void attach(struct PhysicalDeviceTextureCompressionASTCHDRFeatures&);
#endif // VK_VERSION_1_3
#if VK_NV_cooperative_matrix
  void attach(struct PhysicalDeviceCooperativeMatrixFeaturesNV&);
#endif // VK_NV_cooperative_matrix
#if VK_EXT_ycbcr_image_arrays
  void attach(struct PhysicalDeviceYcbcrImageArraysFeaturesEXT&);
#endif // VK_EXT_ycbcr_image_arrays
#if VK_NV_present_barrier
  void attach(struct PhysicalDevicePresentBarrierFeaturesNV&);
#endif // VK_NV_present_barrier
#if VK_KHR_performance_query
  void attach(struct PhysicalDevicePerformanceQueryFeaturesKHR&);
#endif // VK_KHR_performance_query
#if VK_NV_coverage_reduction_mode
  void attach(struct PhysicalDeviceCoverageReductionModeFeaturesNV&);
#endif // VK_NV_coverage_reduction_mode
#if VK_INTEL_shader_integer_functions2
  void attach(struct PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL&);
#endif // VK_INTEL_shader_integer_functions2
#if VK_KHR_shader_clock
  void attach(struct PhysicalDeviceShaderClockFeaturesKHR&);
#endif // VK_KHR_shader_clock
#if VK_VERSION_1_4
  void attach(struct PhysicalDeviceIndexTypeUint8Features&);
#endif // VK_VERSION_1_4
#if VK_NV_shader_sm_builtins
  void attach(struct PhysicalDeviceShaderSMBuiltinsFeaturesNV&);
#endif // VK_NV_shader_sm_builtins
#if VK_EXT_fragment_shader_interlock
  void attach(struct PhysicalDeviceFragmentShaderInterlockFeaturesEXT&);
#endif // VK_EXT_fragment_shader_interlock
#if VK_VERSION_1_2
  void attach(struct PhysicalDeviceSeparateDepthStencilLayoutsFeatures&);
#endif // VK_VERSION_1_2
#if VK_EXT_primitive_topology_list_restart
  void attach(struct PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT&);
#endif // VK_EXT_primitive_topology_list_restart
#if VK_KHR_pipeline_executable_properties
  void attach(struct PhysicalDevicePipelineExecutablePropertiesFeaturesKHR&);
#endif // VK_KHR_pipeline_executable_properties
#if VK_VERSION_1_3
  void attach(struct PhysicalDeviceShaderDemoteToHelperInvocationFeatures&);
#endif // VK_VERSION_1_3
#if VK_EXT_texel_buffer_alignment
  void attach(struct PhysicalDeviceTexelBufferAlignmentFeaturesEXT&);
#endif // VK_EXT_texel_buffer_alignment
#if VK_VERSION_1_3
  void attach(struct PhysicalDeviceSubgroupSizeControlFeatures&);
#endif // VK_VERSION_1_3
#if VK_VERSION_1_4
  void attach(struct PhysicalDeviceLineRasterizationFeatures&);
#endif // VK_VERSION_1_4
#if VK_VERSION_1_3
  void attach(struct PhysicalDevicePipelineCreationCacheControlFeatures&);
#endif // VK_VERSION_1_3
#if VK_VERSION_1_2
  void attach(struct PhysicalDeviceVulkan11Features&);
  void attach(struct PhysicalDeviceVulkan12Features&);
#endif // VK_VERSION_1_2
#if VK_VERSION_1_3
  void attach(struct PhysicalDeviceVulkan13Features&);
#endif // VK_VERSION_1_3
#if VK_VERSION_1_4
  void attach(struct PhysicalDeviceVulkan14Features&);
#endif // VK_VERSION_1_4
#if VK_AMD_device_coherent_memory
  void attach(struct PhysicalDeviceCoherentMemoryFeaturesAMD&);
#endif // VK_AMD_device_coherent_memory
#if VK_EXT_custom_border_color
  void attach(struct PhysicalDeviceCustomBorderColorFeaturesEXT&);
#endif // VK_EXT_custom_border_color
#if VK_EXT_border_color_swizzle
  void attach(struct PhysicalDeviceBorderColorSwizzleFeaturesEXT&);
#endif // VK_EXT_border_color_swizzle
#if VK_EXT_extended_dynamic_state
  void attach(struct PhysicalDeviceExtendedDynamicStateFeaturesEXT&);
#endif // VK_EXT_extended_dynamic_state
#if VK_EXT_extended_dynamic_state2
  void attach(struct PhysicalDeviceExtendedDynamicState2FeaturesEXT&);
#endif // VK_EXT_extended_dynamic_state2
#if VK_EXT_extended_dynamic_state3
  void attach(struct PhysicalDeviceExtendedDynamicState3FeaturesEXT&);
#endif // VK_EXT_extended_dynamic_state3
#if VK_NV_partitioned_acceleration_structure
  void attach(struct PhysicalDevicePartitionedAccelerationStructureFeaturesNV&);
#endif // VK_NV_partitioned_acceleration_structure
#if VK_NV_device_diagnostics_config
  void attach(struct PhysicalDeviceDiagnosticsConfigFeaturesNV&);
#endif // VK_NV_device_diagnostics_config
#if VK_VERSION_1_3
  void attach(struct PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures&);
#endif // VK_VERSION_1_3
#if VK_KHR_shader_subgroup_uniform_control_flow
  void attach(struct PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR&);
#endif // VK_KHR_shader_subgroup_uniform_control_flow
#if VK_KHR_robustness2
  void attach(struct PhysicalDeviceRobustness2FeaturesKHR&);
#endif // VK_KHR_robustness2
#if VK_VERSION_1_3
  void attach(struct PhysicalDeviceImageRobustnessFeatures&);
#endif // VK_VERSION_1_3
#if VK_KHR_workgroup_memory_explicit_layout
  void attach(struct PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR&);
#endif // VK_KHR_workgroup_memory_explicit_layout
#if VK_EXT_4444_formats
  void attach(struct PhysicalDevice4444FormatsFeaturesEXT&);
#endif // VK_EXT_4444_formats
#if VK_HUAWEI_subpass_shading
  void attach(struct PhysicalDeviceSubpassShadingFeaturesHUAWEI&);
#endif // VK_HUAWEI_subpass_shading
#if VK_HUAWEI_cluster_culling_shader
  void attachHead(struct PhysicalDeviceClusterCullingShaderFeaturesHUAWEI&);
#endif // VK_HUAWEI_cluster_culling_shader
#if VK_EXT_shader_image_atomic_int64
  void attach(struct PhysicalDeviceShaderImageAtomicInt64FeaturesEXT&);
#endif // VK_EXT_shader_image_atomic_int64
#if VK_KHR_fragment_shading_rate
  void attach(struct PhysicalDeviceFragmentShadingRateFeaturesKHR&);
#endif // VK_KHR_fragment_shading_rate
#if VK_VERSION_1_3
  void attach(struct PhysicalDeviceShaderTerminateInvocationFeatures&);
#endif // VK_VERSION_1_3
#if VK_NV_fragment_shading_rate_enums
  void attach(struct PhysicalDeviceFragmentShadingRateEnumsFeaturesNV&);
#endif // VK_NV_fragment_shading_rate_enums
#if VK_EXT_image_2d_view_of_3d
  void attach(struct PhysicalDeviceImage2DViewOf3DFeaturesEXT&);
#endif // VK_EXT_image_2d_view_of_3d
#if VK_EXT_image_sliced_view_of_3d
  void attach(struct PhysicalDeviceImageSlicedViewOf3DFeaturesEXT&);
#endif // VK_EXT_image_sliced_view_of_3d
#if VK_EXT_attachment_feedback_loop_dynamic_state
  void attach(struct PhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT&);
#endif // VK_EXT_attachment_feedback_loop_dynamic_state
#if VK_EXT_legacy_vertex_attributes
  void attach(struct PhysicalDeviceLegacyVertexAttributesFeaturesEXT&);
#endif // VK_EXT_legacy_vertex_attributes
#if VK_EXT_mutable_descriptor_type
  void attach(struct PhysicalDeviceMutableDescriptorTypeFeaturesEXT&);
#endif // VK_EXT_mutable_descriptor_type
#if VK_EXT_depth_clip_control
  void attach(struct PhysicalDeviceDepthClipControlFeaturesEXT&);
#endif // VK_EXT_depth_clip_control
#if VK_EXT_zero_initialize_device_memory
  void attach(struct PhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT&);
#endif // VK_EXT_zero_initialize_device_memory
#if VK_EXT_device_generated_commands
  void attach(struct PhysicalDeviceDeviceGeneratedCommandsFeaturesEXT&);
#endif // VK_EXT_device_generated_commands
#if VK_EXT_depth_clamp_control
  void attach(struct PhysicalDeviceDepthClampControlFeaturesEXT&);
#endif // VK_EXT_depth_clamp_control
#if VK_EXT_vertex_input_dynamic_state
  void attach(struct PhysicalDeviceVertexInputDynamicStateFeaturesEXT&);
#endif // VK_EXT_vertex_input_dynamic_state
#if VK_NV_external_memory_rdma
  void attach(struct PhysicalDeviceExternalMemoryRDMAFeaturesNV&);
#endif // VK_NV_external_memory_rdma
#if VK_KHR_shader_relaxed_extended_instruction
  void attach(struct PhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR&);
#endif // VK_KHR_shader_relaxed_extended_instruction
#if VK_EXT_color_write_enable
  void attach(struct PhysicalDeviceColorWriteEnableFeaturesEXT&);
#endif // VK_EXT_color_write_enable
#if VK_VERSION_1_3
  void attach(struct PhysicalDeviceSynchronization2Features&);
#endif // VK_VERSION_1_3
#if VK_KHR_unified_image_layouts
  void attach(struct PhysicalDeviceUnifiedImageLayoutsFeaturesKHR&);
#endif // VK_KHR_unified_image_layouts
#if VK_VERSION_1_4
  void attach(struct PhysicalDeviceHostImageCopyFeatures&);
#endif // VK_VERSION_1_4
#if VK_EXT_primitives_generated_query
  void attach(struct PhysicalDevicePrimitivesGeneratedQueryFeaturesEXT&);
#endif // VK_EXT_primitives_generated_query
#if VK_EXT_legacy_dithering
  void attach(struct PhysicalDeviceLegacyDitheringFeaturesEXT&);
#endif // VK_EXT_legacy_dithering
#if VK_EXT_multisampled_render_to_single_sampled
  void attach(struct PhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT&);
#endif // VK_EXT_multisampled_render_to_single_sampled
#if VK_VERSION_1_4
  void attach(struct PhysicalDevicePipelineProtectedAccessFeatures&);
#endif // VK_VERSION_1_4
#if VK_KHR_video_maintenance1
  void attach(struct PhysicalDeviceVideoMaintenance1FeaturesKHR&);
#endif // VK_KHR_video_maintenance1
#if VK_KHR_video_maintenance2
  void attach(struct PhysicalDeviceVideoMaintenance2FeaturesKHR&);
#endif // VK_KHR_video_maintenance2
#if VK_KHR_video_decode_vp9
  void attach(struct PhysicalDeviceVideoDecodeVP9FeaturesKHR&);
#endif // VK_KHR_video_decode_vp9
#if VK_KHR_video_encode_quantization_map
  void attach(struct PhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR&);
#endif // VK_KHR_video_encode_quantization_map
#if VK_KHR_video_encode_av1
  void attach(struct PhysicalDeviceVideoEncodeAV1FeaturesKHR&);
#endif // VK_KHR_video_encode_av1
#if VK_NV_inherited_viewport_scissor
  void attach(struct PhysicalDeviceInheritedViewportScissorFeaturesNV&);
#endif // VK_NV_inherited_viewport_scissor
#if VK_EXT_ycbcr_2plane_444_formats
  void attach(struct PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT&);
#endif // VK_EXT_ycbcr_2plane_444_formats
#if VK_EXT_provoking_vertex
  void attach(struct PhysicalDeviceProvokingVertexFeaturesEXT&);
#endif // VK_EXT_provoking_vertex
#if VK_KHR_video_encode_intra_refresh
  void attach(struct PhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR&);
#endif // VK_KHR_video_encode_intra_refresh
#if VK_EXT_descriptor_buffer
  void attach(struct PhysicalDeviceDescriptorBufferFeaturesEXT&);
#endif // VK_EXT_descriptor_buffer
#if VK_VERSION_1_3
  void attach(struct PhysicalDeviceShaderIntegerDotProductFeatures&);
#endif // VK_VERSION_1_3
#if VK_KHR_fragment_shader_barycentric
  void attach(struct PhysicalDeviceFragmentShaderBarycentricFeaturesKHR&);
#endif // VK_KHR_fragment_shader_barycentric
#if VK_NV_ray_tracing_motion_blur
  void attach(struct PhysicalDeviceRayTracingMotionBlurFeaturesNV&);
#endif // VK_NV_ray_tracing_motion_blur
#if VK_NV_ray_tracing_validation
  void attach(struct PhysicalDeviceRayTracingValidationFeaturesNV&);
#endif // VK_NV_ray_tracing_validation
#if VK_NV_ray_tracing_linear_swept_spheres
  void attach(struct PhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV&);
#endif // VK_NV_ray_tracing_linear_swept_spheres
#if VK_EXT_rgba10x6_formats
  void attach(struct PhysicalDeviceRGBA10X6FormatsFeaturesEXT&);
#endif // VK_EXT_rgba10x6_formats
#if VK_VERSION_1_3
  void attach(struct PhysicalDeviceDynamicRenderingFeatures&);
#endif // VK_VERSION_1_3
#if VK_EXT_image_view_min_lod
  void attach(struct PhysicalDeviceImageViewMinLodFeaturesEXT&);
#endif // VK_EXT_image_view_min_lod
#if VK_EXT_rasterization_order_attachment_access
  void attach(struct PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT&);
#endif // VK_EXT_rasterization_order_attachment_access
#if VK_NV_linear_color_attachment
  void attach(struct PhysicalDeviceLinearColorAttachmentFeaturesNV&);
#endif // VK_NV_linear_color_attachment
#if VK_EXT_graphics_pipeline_library
  void attach(struct PhysicalDeviceGraphicsPipelineLibraryFeaturesEXT&);
#endif // VK_EXT_graphics_pipeline_library
#if VK_KHR_pipeline_binary
  void attach(struct PhysicalDevicePipelineBinaryFeaturesKHR&);
#endif // VK_KHR_pipeline_binary
#if VK_VALVE_descriptor_set_host_mapping
  void attach(struct PhysicalDeviceDescriptorSetHostMappingFeaturesVALVE&);
#endif // VK_VALVE_descriptor_set_host_mapping
#if VK_EXT_nested_command_buffer
  void attach(struct PhysicalDeviceNestedCommandBufferFeaturesEXT&);
#endif // VK_EXT_nested_command_buffer
#if VK_EXT_shader_module_identifier
  void attach(struct PhysicalDeviceShaderModuleIdentifierFeaturesEXT&);
#endif // VK_EXT_shader_module_identifier
#if VK_EXT_image_compression_control
  void attach(struct PhysicalDeviceImageCompressionControlFeaturesEXT&);
#endif // VK_EXT_image_compression_control
#if VK_EXT_image_compression_control_swapchain
  void attach(struct PhysicalDeviceImageCompressionControlSwapchainFeaturesEXT&);
#endif // VK_EXT_image_compression_control_swapchain
#if VK_EXT_subpass_merge_feedback
  void attach(struct PhysicalDeviceSubpassMergeFeedbackFeaturesEXT&);
#endif // VK_EXT_subpass_merge_feedback
#if VK_EXT_opacity_micromap
  void attach(struct PhysicalDeviceOpacityMicromapFeaturesEXT&);
#endif // VK_EXT_opacity_micromap
#if VK_EXT_pipeline_properties
  void attach(struct PhysicalDevicePipelinePropertiesFeaturesEXT&);
#endif // VK_EXT_pipeline_properties
#if VK_AMD_shader_early_and_late_fragment_tests
  void attach(struct PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD&);
#endif // VK_AMD_shader_early_and_late_fragment_tests
#if VK_EXT_non_seamless_cube_map
  void attach(struct PhysicalDeviceNonSeamlessCubeMapFeaturesEXT&);
#endif // VK_EXT_non_seamless_cube_map
#if VK_VERSION_1_4
  void attach(struct PhysicalDevicePipelineRobustnessFeatures&);
#endif // VK_VERSION_1_4
#if VK_QCOM_image_processing
  void attach(struct PhysicalDeviceImageProcessingFeaturesQCOM&);
#endif // VK_QCOM_image_processing
#if VK_QCOM_tile_properties
  void attach(struct PhysicalDeviceTilePropertiesFeaturesQCOM&);
#endif // VK_QCOM_tile_properties
#if VK_SEC_amigo_profiling
  void attach(struct PhysicalDeviceAmigoProfilingFeaturesSEC&);
#endif // VK_SEC_amigo_profiling
#if VK_EXT_attachment_feedback_loop_layout
  void attach(struct PhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT&);
#endif // VK_EXT_attachment_feedback_loop_layout
#if VK_EXT_device_address_binding_report
  void attach(struct PhysicalDeviceAddressBindingReportFeaturesEXT&);
#endif // VK_EXT_device_address_binding_report
#if VK_NV_optical_flow
  void attach(struct PhysicalDeviceOpticalFlowFeaturesNV&);
#endif // VK_NV_optical_flow
#if VK_EXT_device_fault
  void attach(struct PhysicalDeviceFaultFeaturesEXT&);
#endif // VK_EXT_device_fault
#if VK_EXT_pipeline_library_group_handles
  void attach(struct PhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT&);
#endif // VK_EXT_pipeline_library_group_handles
#if VK_ARM_shader_core_builtins
  void attach(struct PhysicalDeviceShaderCoreBuiltinsFeaturesARM&);
#endif // VK_ARM_shader_core_builtins
#if VK_EXT_frame_boundary
  void attach(struct PhysicalDeviceFrameBoundaryFeaturesEXT&);
#endif // VK_EXT_frame_boundary
#if VK_EXT_dynamic_rendering_unused_attachments
  void attach(struct PhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT&);
#endif // VK_EXT_dynamic_rendering_unused_attachments
#if VK_KHR_swapchain_maintenance1
  void attach(struct PhysicalDeviceSwapchainMaintenance1FeaturesKHR&);
#endif // VK_KHR_swapchain_maintenance1
#if VK_EXT_depth_bias_control
  void attach(struct PhysicalDeviceDepthBiasControlFeaturesEXT&);
#endif // VK_EXT_depth_bias_control
#if VK_NV_ray_tracing_invocation_reorder
  void attach(struct PhysicalDeviceRayTracingInvocationReorderFeaturesNV&);
#endif // VK_NV_ray_tracing_invocation_reorder
#if VK_NV_extended_sparse_address_space
  void attach(struct PhysicalDeviceExtendedSparseAddressSpaceFeaturesNV&);
#endif // VK_NV_extended_sparse_address_space
#if VK_QCOM_multiview_per_view_viewports
  void attach(struct PhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM&);
#endif // VK_QCOM_multiview_per_view_viewports
#if VK_KHR_ray_tracing_position_fetch
  void attach(struct PhysicalDeviceRayTracingPositionFetchFeaturesKHR&);
#endif // VK_KHR_ray_tracing_position_fetch
#if VK_QCOM_multiview_per_view_render_areas
  void attach(struct PhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM&);
#endif // VK_QCOM_multiview_per_view_render_areas
#if VK_EXT_shader_object
  void attach(struct PhysicalDeviceShaderObjectFeaturesEXT&);
#endif // VK_EXT_shader_object
#if VK_EXT_shader_tile_image
  void attach(struct PhysicalDeviceShaderTileImageFeaturesEXT&);
#endif // VK_EXT_shader_tile_image
#if VK_QNX_external_memory_screen_buffer
  void attach(struct PhysicalDeviceExternalMemoryScreenBufferFeaturesQNX&);
#endif // VK_QNX_external_memory_screen_buffer
#if VK_KHR_cooperative_matrix
  void attach(struct PhysicalDeviceCooperativeMatrixFeaturesKHR&);
#endif // VK_KHR_cooperative_matrix
#if VK_AMD_anti_lag
  void attach(struct PhysicalDeviceAntiLagFeaturesAMD&);
#endif // VK_AMD_anti_lag
#if VK_QCOM_tile_memory_heap
  void attach(struct PhysicalDeviceTileMemoryHeapFeaturesQCOM&);
#endif // VK_QCOM_tile_memory_heap
#if VK_QCOM_filter_cubic_clamp
  void attach(struct PhysicalDeviceCubicClampFeaturesQCOM&);
#endif // VK_QCOM_filter_cubic_clamp
#if VK_QCOM_ycbcr_degamma
  void attach(struct PhysicalDeviceYcbcrDegammaFeaturesQCOM&);
#endif // VK_QCOM_ycbcr_degamma
#if VK_QCOM_filter_cubic_weights
  void attach(struct PhysicalDeviceCubicWeightsFeaturesQCOM&);
#endif // VK_QCOM_filter_cubic_weights
#if VK_QCOM_image_processing2
  void attach(struct PhysicalDeviceImageProcessing2FeaturesQCOM&);
#endif // VK_QCOM_image_processing2
#if VK_NV_descriptor_pool_overallocation
  void attach(struct PhysicalDeviceDescriptorPoolOverallocationFeaturesNV&);
#endif // VK_NV_descriptor_pool_overallocation
#if VK_NV_per_stage_descriptor_set
  void attach(struct PhysicalDevicePerStageDescriptorSetFeaturesNV&);
#endif // VK_NV_per_stage_descriptor_set
#if VK_ANDROID_external_format_resolve
  void attach(struct PhysicalDeviceExternalFormatResolveFeaturesANDROID&);
#endif // VK_ANDROID_external_format_resolve
#if VK_ARM_scheduling_controls
  void attach(struct PhysicalDeviceSchedulingControlsFeaturesARM&);
#endif // VK_ARM_scheduling_controls
#if VK_IMG_relaxed_line_rasterization
  void attach(struct PhysicalDeviceRelaxedLineRasterizationFeaturesIMG&);
#endif // VK_IMG_relaxed_line_rasterization
#if VK_ARM_render_pass_striped
  void attach(struct PhysicalDeviceRenderPassStripedFeaturesARM&);
#endif // VK_ARM_render_pass_striped
#if VK_ARM_pipeline_opacity_micromap
  void attach(struct PhysicalDevicePipelineOpacityMicromapFeaturesARM&);
#endif // VK_ARM_pipeline_opacity_micromap
#if VK_KHR_shader_maximal_reconvergence
  void attach(struct PhysicalDeviceShaderMaximalReconvergenceFeaturesKHR&);
#endif // VK_KHR_shader_maximal_reconvergence
#if VK_VERSION_1_4
  void attach(struct PhysicalDeviceShaderSubgroupRotateFeatures&);
  void attach(struct PhysicalDeviceShaderExpectAssumeFeatures&);
  void attach(struct PhysicalDeviceShaderFloatControls2Features&);
  void attach(struct PhysicalDeviceDynamicRenderingLocalReadFeatures&);
#endif // VK_VERSION_1_4
#if VK_KHR_shader_quad_control
  void attach(struct PhysicalDeviceShaderQuadControlFeaturesKHR&);
#endif // VK_KHR_shader_quad_control
#if VK_NV_shader_atomic_float16_vector
  void attach(struct PhysicalDeviceShaderAtomicFloat16VectorFeaturesNV&);
#endif // VK_NV_shader_atomic_float16_vector
#if VK_EXT_map_memory_placed
  void attach(struct PhysicalDeviceMapMemoryPlacedFeaturesEXT&);
#endif // VK_EXT_map_memory_placed
#if VK_KHR_shader_bfloat16
  void attach(struct PhysicalDeviceShaderBfloat16FeaturesKHR&);
#endif // VK_KHR_shader_bfloat16
#if VK_NV_raw_access_chains
  void attach(struct PhysicalDeviceRawAccessChainsFeaturesNV&);
#endif // VK_NV_raw_access_chains
#if VK_NV_command_buffer_inheritance
  void attach(struct PhysicalDeviceCommandBufferInheritanceFeaturesNV&);
#endif // VK_NV_command_buffer_inheritance
#if VK_MESA_image_alignment_control
  void attach(struct PhysicalDeviceImageAlignmentControlFeaturesMESA&);
#endif // VK_MESA_image_alignment_control
#if VK_EXT_shader_replicated_composites
  void attach(struct PhysicalDeviceShaderReplicatedCompositesFeaturesEXT&);
#endif // VK_EXT_shader_replicated_composites
#if VK_KHR_present_mode_fifo_latest_ready
  void attach(struct PhysicalDevicePresentModeFifoLatestReadyFeaturesKHR&);
#endif // VK_KHR_present_mode_fifo_latest_ready
#if VK_NV_cooperative_matrix2
  void attach(struct PhysicalDeviceCooperativeMatrix2FeaturesNV&);
#endif // VK_NV_cooperative_matrix2
#if VK_HUAWEI_hdr_vivid
  void attach(struct PhysicalDeviceHdrVividFeaturesHUAWEI&);
#endif // VK_HUAWEI_hdr_vivid
#if VK_EXT_vertex_attribute_robustness
  void attach(struct PhysicalDeviceVertexAttributeRobustnessFeaturesEXT&);
#endif // VK_EXT_vertex_attribute_robustness
#if VK_KHR_depth_clamp_zero_one
  void attach(struct PhysicalDeviceDepthClampZeroOneFeaturesKHR&);
#endif // VK_KHR_depth_clamp_zero_one
#if VK_NV_cooperative_vector
  void attach(struct PhysicalDeviceCooperativeVectorFeaturesNV&);
#endif // VK_NV_cooperative_vector
#if VK_QCOM_tile_shading
  void attach(struct PhysicalDeviceTileShadingFeaturesQCOM&);
#endif // VK_QCOM_tile_shading
#if VK_VALVE_fragment_density_map_layered
  void attach(struct PhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE&);
#endif // VK_VALVE_fragment_density_map_layered
#if VK_ARM_format_pack
  void attach(struct PhysicalDeviceFormatPackFeaturesARM&);
#endif // VK_ARM_format_pack
#if VK_ARM_tensors
  void attach(struct PhysicalDeviceTensorFeaturesARM&);
  void attach(struct PhysicalDeviceDescriptorBufferTensorFeaturesARM&);
#endif // VK_ARM_tensors
#if VK_EXT_shader_float8
  void attach(struct PhysicalDeviceShaderFloat8FeaturesEXT&);
#endif // VK_EXT_shader_float8
#if VK_ARM_data_graph
  void attach(struct PhysicalDeviceDataGraphFeaturesARM&);
#endif // VK_ARM_data_graph
#if VK_SEC_pipeline_cache_incremental_mode
  void attach(struct PhysicalDevicePipelineCacheIncrementalModeFeaturesSEC&);
#endif // VK_SEC_pipeline_cache_incremental_mode
};
inline void DeviceCreateInfo::attachHead(PhysicalDeviceFeatures2& ext) { pNext = &ext; }
#endif // VK_VERSION_1_1

#if VK_NV_device_diagnostics_config
struct DeviceDiagnosticsConfigCreateInfoNV : VkDeviceDiagnosticsConfigCreateInfoNV {
  DeviceDiagnosticsConfigCreateInfoNV() noexcept : VkDeviceDiagnosticsConfigCreateInfoNV{.sType = VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV} {}

  void setFlags(DeviceDiagnosticsConfigFlagsNV value) { this->flags = std::bit_cast<VkDeviceDiagnosticsConfigFlagsNV>(value); }
  DeviceDiagnosticsConfigFlagsNV getFlags() const { return std::bit_cast<DeviceDiagnosticsConfigFlagsNV>(this->flags); }
};
inline void DeviceCreateInfo::attach(DeviceDiagnosticsConfigCreateInfoNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_device_diagnostics_config

#if VK_EXT_device_memory_report
struct DeviceDeviceMemoryReportCreateInfoEXT : VkDeviceDeviceMemoryReportCreateInfoEXT {
  DeviceDeviceMemoryReportCreateInfoEXT() noexcept : VkDeviceDeviceMemoryReportCreateInfoEXT{.sType = VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT} {}

  void setFlags(DeviceMemoryReportFlagsEXT value) { this->flags = std::bit_cast<VkDeviceMemoryReportFlagsEXT>(value); }
  DeviceMemoryReportFlagsEXT getFlags() const { return std::bit_cast<DeviceMemoryReportFlagsEXT>(this->flags); }
  void setPfnUserCallback(PFN_vkDeviceMemoryReportCallbackEXT value) { this->pfnUserCallback = value; }
  PFN_vkDeviceMemoryReportCallbackEXT getPfnUserCallback() const { return this->pfnUserCallback; }
  void setUserData(void* value) { this->pUserData = value; }
  void* getUserData() const { return this->pUserData; }
};
inline void DeviceCreateInfo::attach(DeviceDeviceMemoryReportCreateInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_device_memory_report

#if VK_VERSION_1_1
struct PhysicalDeviceMemoryProperties2 : VkPhysicalDeviceMemoryProperties2 {
  PhysicalDeviceMemoryProperties2() noexcept : VkPhysicalDeviceMemoryProperties2{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2} {}

  const PhysicalDeviceMemoryProperties& getMemoryProperties() const { return static_cast<const PhysicalDeviceMemoryProperties&>(this->memoryProperties); }

#if VK_EXT_memory_budget
  void attach(struct PhysicalDeviceMemoryBudgetPropertiesEXT&);
#endif // VK_EXT_memory_budget
};
#endif // VK_VERSION_1_1

#if VK_KHR_external_memory
using ExternalMemoryBufferCreateInfoKHR = ExternalMemoryBufferCreateInfo;
#endif // VK_KHR_external_memory
#if VK_KHR_maintenance4
using DeviceBufferMemoryRequirementsKHR = DeviceBufferMemoryRequirements;
#endif // VK_KHR_maintenance4
#if VK_KHR_maintenance5
using BufferUsageFlags2CreateInfoKHR = BufferUsageFlags2CreateInfo;
#endif // VK_KHR_maintenance5
#if VK_KHR_buffer_device_address
using BufferOpaqueCaptureAddressCreateInfoKHR = BufferOpaqueCaptureAddressCreateInfo;
#endif // VK_KHR_buffer_device_address

#if VK_VERSION_1_3
struct PipelineShaderStageRequiredSubgroupSizeCreateInfo : VkPipelineShaderStageRequiredSubgroupSizeCreateInfo {
  PipelineShaderStageRequiredSubgroupSizeCreateInfo() noexcept : VkPipelineShaderStageRequiredSubgroupSizeCreateInfo{.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO} {}

  uint32_t getRequiredSubgroupSize() const { return this->requiredSubgroupSize; }
};
inline void PipelineShaderStageCreateInfo::attach(PipelineShaderStageRequiredSubgroupSizeCreateInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#if VK_EXT_shader_object
inline void ShaderCreateInfoEXT::attach(PipelineShaderStageRequiredSubgroupSizeCreateInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_shader_object
#endif // VK_VERSION_1_3

#if VK_EXT_mutable_descriptor_type
struct MutableDescriptorTypeCreateInfoEXT : VkMutableDescriptorTypeCreateInfoEXT {
  MutableDescriptorTypeCreateInfoEXT() noexcept : VkMutableDescriptorTypeCreateInfoEXT{.sType = VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT} {}

  void setMutableDescriptorTypeListCount(uint32_t value) { this->mutableDescriptorTypeListCount = value; }
  uint32_t getMutableDescriptorTypeListCount() const { return this->mutableDescriptorTypeListCount; }
  void setMutableDescriptorTypeLists(const MutableDescriptorTypeListEXT* value) { this->pMutableDescriptorTypeLists = std::bit_cast<const VkMutableDescriptorTypeListEXT*>(value); }
  const MutableDescriptorTypeListEXT* getMutableDescriptorTypeLists() const { return std::bit_cast<const MutableDescriptorTypeListEXT*>(this->pMutableDescriptorTypeLists); }
};
inline void DescriptorSetLayoutCreateInfo::attach(MutableDescriptorTypeCreateInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DescriptorPoolCreateInfo::attach(MutableDescriptorTypeCreateInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_mutable_descriptor_type

#if VK_VERSION_1_2
struct DescriptorSetLayoutBindingFlagsCreateInfo : VkDescriptorSetLayoutBindingFlagsCreateInfo {
  DescriptorSetLayoutBindingFlagsCreateInfo() noexcept : VkDescriptorSetLayoutBindingFlagsCreateInfo{.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO} {}

  void setBindingCount(uint32_t value) { this->bindingCount = value; }
  uint32_t getBindingCount() const { return this->bindingCount; }
  void setBindingFlags(const DescriptorBindingFlags* value) { this->pBindingFlags = std::bit_cast<const VkDescriptorBindingFlags*>(value); }
  const DescriptorBindingFlags* getBindingFlags() const { return std::bit_cast<const DescriptorBindingFlags*>(this->pBindingFlags); }
};
inline void DescriptorSetLayoutCreateInfo::attach(DescriptorSetLayoutBindingFlagsCreateInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_2

#if VK_KHR_external_memory_capabilities
using PhysicalDeviceExternalImageFormatInfoKHR = PhysicalDeviceExternalImageFormatInfo;
#endif // VK_KHR_external_memory_capabilities

#if VK_FUCHSIA_buffer_collection
struct ImageConstraintsInfoFUCHSIA : VkImageConstraintsInfoFUCHSIA {
  ImageConstraintsInfoFUCHSIA() noexcept : VkImageConstraintsInfoFUCHSIA{.sType = VK_STRUCTURE_TYPE_IMAGE_CONSTRAINTS_INFO_FUCHSIA} {}

  void setFormatConstraintsCount(uint32_t value) { this->formatConstraintsCount = value; }
  uint32_t getFormatConstraintsCount() const { return this->formatConstraintsCount; }
  void setFormatConstraints(const ImageFormatConstraintsInfoFUCHSIA* value) { this->pFormatConstraints = std::bit_cast<const VkImageFormatConstraintsInfoFUCHSIA*>(value); }
  const ImageFormatConstraintsInfoFUCHSIA* getFormatConstraints() const { return std::bit_cast<const ImageFormatConstraintsInfoFUCHSIA*>(this->pFormatConstraints); }
  void setBufferCollectionConstraints(const BufferCollectionConstraintsInfoFUCHSIA& value) { this->bufferCollectionConstraints = value; }
  const BufferCollectionConstraintsInfoFUCHSIA& getBufferCollectionConstraints() const { return static_cast<const BufferCollectionConstraintsInfoFUCHSIA&>(this->bufferCollectionConstraints); }

  void setFlags(ImageConstraintsInfoFlagsFUCHSIA value) { this->flags = std::bit_cast<VkImageConstraintsInfoFlagsFUCHSIA>(value); }
  ImageConstraintsInfoFlagsFUCHSIA getFlags() const { return std::bit_cast<ImageConstraintsInfoFlagsFUCHSIA>(this->flags); }
};
#endif // VK_FUCHSIA_buffer_collection

#if VK_KHR_maintenance4
using DeviceImageMemoryRequirementsKHR = DeviceImageMemoryRequirements;
#endif // VK_KHR_maintenance4
#if VK_EXT_separate_stencil_usage
using ImageStencilUsageCreateInfoEXT = ImageStencilUsageCreateInfo;
#endif // VK_EXT_separate_stencil_usage
#if VK_KHR_external_memory
using ExternalMemoryImageCreateInfoKHR = ExternalMemoryImageCreateInfo;
#endif // VK_KHR_external_memory
#if VK_EXT_sampler_filter_minmax
using SamplerReductionModeCreateInfoEXT = SamplerReductionModeCreateInfo;
#endif // VK_EXT_sampler_filter_minmax

#if VK_ARM_data_graph
struct DataGraphPipelineCompilerControlCreateInfoARM : VkDataGraphPipelineCompilerControlCreateInfoARM {
  DataGraphPipelineCompilerControlCreateInfoARM() noexcept : VkDataGraphPipelineCompilerControlCreateInfoARM{.sType = VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_COMPILER_CONTROL_CREATE_INFO_ARM} {}

  void setVendorOptions(const char* value) { this->pVendorOptions = value; }
  const char* getVendorOptions() const { return this->pVendorOptions; }
};
inline void DataGraphPipelineCreateInfoARM::attach(DataGraphPipelineCompilerControlCreateInfoARM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }

struct DataGraphPipelineShaderModuleCreateInfoARM : VkDataGraphPipelineShaderModuleCreateInfoARM {
  DataGraphPipelineShaderModuleCreateInfoARM() noexcept : VkDataGraphPipelineShaderModuleCreateInfoARM{.sType = VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SHADER_MODULE_CREATE_INFO_ARM} {}

  void setName(const char* value) { this->pName = value; }
  const char* getName() const { return this->pName; }

  void setModule(ShaderModule value) { this->module = std::bit_cast<VkShaderModule>(value); }
  ShaderModule getModule() const { return std::bit_cast<ShaderModule>(this->module); }
  void setSpecializationInfo(const SpecializationInfo* value) { this->pSpecializationInfo = std::bit_cast<const VkSpecializationInfo*>(value); }
  const SpecializationInfo* getSpecializationInfo() const { return std::bit_cast<const SpecializationInfo*>(this->pSpecializationInfo); }
  void setConstantCount(uint32_t value) { this->constantCount = value; }
  uint32_t getConstantCount() const { return this->constantCount; }
  void setConstants(const DataGraphPipelineConstantARM* value) { this->pConstants = std::bit_cast<const VkDataGraphPipelineConstantARM*>(value); }
  const DataGraphPipelineConstantARM* getConstants() const { return std::bit_cast<const DataGraphPipelineConstantARM*>(this->pConstants); }

  void attachHead(struct ShaderModuleCreateInfo&);
};
inline void DataGraphPipelineCreateInfoARM::attachHead(DataGraphPipelineShaderModuleCreateInfoARM& ext) { pNext = &ext; }

struct DataGraphPipelineIdentifierCreateInfoARM : VkDataGraphPipelineIdentifierCreateInfoARM {
  DataGraphPipelineIdentifierCreateInfoARM() noexcept : VkDataGraphPipelineIdentifierCreateInfoARM{.sType = VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_IDENTIFIER_CREATE_INFO_ARM} {}

  void setIdentifierSize(uint32_t value) { this->identifierSize = value; }
  uint32_t getIdentifierSize() const { return this->identifierSize; }
  void setIdentifier(const uint8_t* value) { this->pIdentifier = value; }
  const uint8_t* getIdentifier() const { return this->pIdentifier; }
};
inline void DataGraphPipelineCreateInfoARM::attach(DataGraphPipelineIdentifierCreateInfoARM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }

struct DataGraphProcessingEngineCreateInfoARM : VkDataGraphProcessingEngineCreateInfoARM {
  DataGraphProcessingEngineCreateInfoARM() noexcept : VkDataGraphProcessingEngineCreateInfoARM{.sType = VK_STRUCTURE_TYPE_DATA_GRAPH_PROCESSING_ENGINE_CREATE_INFO_ARM} {}

  void setProcessingEngineCount(uint32_t value) { this->processingEngineCount = value; }
  uint32_t getProcessingEngineCount() const { return this->processingEngineCount; }
  void setProcessingEngines(PhysicalDeviceDataGraphProcessingEngineARM* value) { this->pProcessingEngines = std::bit_cast<VkPhysicalDeviceDataGraphProcessingEngineARM*>(value); }
  PhysicalDeviceDataGraphProcessingEngineARM* getProcessingEngines() const { return std::bit_cast<PhysicalDeviceDataGraphProcessingEngineARM*>(this->pProcessingEngines); }
};
inline void DataGraphPipelineCreateInfoARM::attach(DataGraphProcessingEngineCreateInfoARM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DescriptorPoolCreateInfo::attach(DataGraphProcessingEngineCreateInfoARM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void CommandPoolCreateInfo::attach(DataGraphProcessingEngineCreateInfoARM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_ARM_data_graph

#if VK_EXT_debug_utils
struct DebugUtilsMessengerCallbackDataEXT : VkDebugUtilsMessengerCallbackDataEXT {
  DebugUtilsMessengerCallbackDataEXT() noexcept : VkDebugUtilsMessengerCallbackDataEXT{.sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT} {}

  void setMessageIdNumber(int32_t value) { this->messageIdNumber = value; }
  int32_t getMessageIdNumber() const { return this->messageIdNumber; }

  void setFlags(DebugUtilsMessengerCallbackDataFlagsEXT value) { this->flags = std::bit_cast<VkDebugUtilsMessengerCallbackDataFlagsEXT>(value); }
  DebugUtilsMessengerCallbackDataFlagsEXT getFlags() const { return std::bit_cast<DebugUtilsMessengerCallbackDataFlagsEXT>(this->flags); }
  void setMessageIdName(const char* value) { this->pMessageIdName = value; }
  const char* getMessageIdName() const { return this->pMessageIdName; }
  void setMessage(const char* value) { this->pMessage = value; }
  const char* getMessage() const { return this->pMessage; }
  void setQueueLabelCount(uint32_t value) { this->queueLabelCount = value; }
  uint32_t getQueueLabelCount() const { return this->queueLabelCount; }
  void setQueueLabels(const DebugUtilsLabelEXT* value) { this->pQueueLabels = std::bit_cast<const VkDebugUtilsLabelEXT*>(value); }
  const DebugUtilsLabelEXT* getQueueLabels() const { return std::bit_cast<const DebugUtilsLabelEXT*>(this->pQueueLabels); }
  void setCmdBufLabelCount(uint32_t value) { this->cmdBufLabelCount = value; }
  uint32_t getCmdBufLabelCount() const { return this->cmdBufLabelCount; }
  void setCmdBufLabels(const DebugUtilsLabelEXT* value) { this->pCmdBufLabels = std::bit_cast<const VkDebugUtilsLabelEXT*>(value); }
  const DebugUtilsLabelEXT* getCmdBufLabels() const { return std::bit_cast<const DebugUtilsLabelEXT*>(this->pCmdBufLabels); }
  void setObjectCount(uint32_t value) { this->objectCount = value; }
  uint32_t getObjectCount() const { return this->objectCount; }
  void setObjects(const DebugUtilsObjectNameInfoEXT* value) { this->pObjects = std::bit_cast<const VkDebugUtilsObjectNameInfoEXT*>(value); }
  const DebugUtilsObjectNameInfoEXT* getObjects() const { return std::bit_cast<const DebugUtilsObjectNameInfoEXT*>(this->pObjects); }

#if VK_EXT_device_address_binding_report
  void attach(struct DeviceAddressBindingCallbackDataEXT&);
#endif // VK_EXT_device_address_binding_report
};
#endif // VK_EXT_debug_utils

#if VK_HUAWEI_subpass_shading
struct SubpassShadingPipelineCreateInfoHUAWEI : VkSubpassShadingPipelineCreateInfoHUAWEI {
  SubpassShadingPipelineCreateInfoHUAWEI() noexcept : VkSubpassShadingPipelineCreateInfoHUAWEI{.sType = VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI} {}

  void setRenderPass(RenderPass value) { this->renderPass = std::bit_cast<VkRenderPass>(value); }
  RenderPass getRenderPass() const { return std::bit_cast<RenderPass>(this->renderPass); }
  void setSubpass(uint32_t value) { this->subpass = value; }
  uint32_t getSubpass() const { return this->subpass; }
};
inline void ComputePipelineCreateInfo::attach(SubpassShadingPipelineCreateInfoHUAWEI& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_HUAWEI_subpass_shading

#if VK_NV_device_generated_commands_compute
struct ComputePipelineIndirectBufferInfoNV : VkComputePipelineIndirectBufferInfoNV {
  ComputePipelineIndirectBufferInfoNV() noexcept : VkComputePipelineIndirectBufferInfoNV{.sType = VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_INDIRECT_BUFFER_INFO_NV} {}

  void setDeviceAddress(DeviceAddress value) { this->deviceAddress = value; }
  DeviceAddress getDeviceAddress() const { return this->deviceAddress; }
  void setSize(DeviceSize value) { this->size = value; }
  DeviceSize getSize() const { return this->size; }
  void setPipelineDeviceAddressCaptureReplay(DeviceAddress value) { this->pipelineDeviceAddressCaptureReplay = value; }
  DeviceAddress getPipelineDeviceAddressCaptureReplay() const { return this->pipelineDeviceAddressCaptureReplay; }
};
inline void ComputePipelineCreateInfo::attach(ComputePipelineIndirectBufferInfoNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_device_generated_commands_compute

#if VK_EXT_color_write_enable
struct PipelineColorWriteCreateInfoEXT : VkPipelineColorWriteCreateInfoEXT {
  PipelineColorWriteCreateInfoEXT() noexcept : VkPipelineColorWriteCreateInfoEXT{.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT} {}

  // # of pAttachments
  void setAttachmentCount(uint32_t value) { this->attachmentCount = value; }
  uint32_t getAttachmentCount() const { return this->attachmentCount; }
  void setColorWriteEnables(const Bool32* value) { this->pColorWriteEnables = value; }
  const Bool32* getColorWriteEnables() const { return this->pColorWriteEnables; }
};
inline void PipelineColorBlendStateCreateInfo::attach(PipelineColorWriteCreateInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_color_write_enable

#if VK_EXT_blend_operation_advanced
struct PipelineColorBlendAdvancedStateCreateInfoEXT : VkPipelineColorBlendAdvancedStateCreateInfoEXT {
  PipelineColorBlendAdvancedStateCreateInfoEXT() noexcept : VkPipelineColorBlendAdvancedStateCreateInfoEXT{.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT} {}

  void setBlendOverlap(BlendOverlapEXT value) { this->blendOverlap = std::bit_cast<VkBlendOverlapEXT>(value); }
  BlendOverlapEXT getBlendOverlap() const { return std::bit_cast<BlendOverlapEXT>(this->blendOverlap); }

  void setSrcPremultiplied(Bool32 value) { this->srcPremultiplied = value; }
  Bool32 getSrcPremultiplied() const { return this->srcPremultiplied; }
  void setDstPremultiplied(Bool32 value) { this->dstPremultiplied = value; }
  Bool32 getDstPremultiplied() const { return this->dstPremultiplied; }
};
inline void PipelineColorBlendStateCreateInfo::attach(PipelineColorBlendAdvancedStateCreateInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_blend_operation_advanced

#if VK_VERSION_1_0
struct GraphicsPipelineCreateInfo : VkGraphicsPipelineCreateInfo {
  GraphicsPipelineCreateInfo() noexcept : VkGraphicsPipelineCreateInfo{.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO} {}

  void setSubpass(uint32_t value) { this->subpass = value; }
  uint32_t getSubpass() const { return this->subpass; }
  // If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is not -1, it specifies an index into pCreateInfos of the base pipeline this is a derivative of
  void setBasePipelineIndex(int32_t value) { this->basePipelineIndex = value; }
  int32_t getBasePipelineIndex() const { return this->basePipelineIndex; }

  // Pipeline creation flags
  void setFlags(PipelineCreateFlags value) { this->flags = std::bit_cast<VkPipelineCreateFlags>(value); }
  PipelineCreateFlags getFlags() const { return std::bit_cast<PipelineCreateFlags>(this->flags); }
  void setStageCount(uint32_t value) { this->stageCount = value; }
  uint32_t getStageCount() const { return this->stageCount; }
  // One entry for each active shader stage
  void setStages(const PipelineShaderStageCreateInfo* value) { this->pStages = std::bit_cast<const VkPipelineShaderStageCreateInfo*>(value); }
  const PipelineShaderStageCreateInfo* getStages() const { return std::bit_cast<const PipelineShaderStageCreateInfo*>(this->pStages); }
  void setVertexInputState(const PipelineVertexInputStateCreateInfo* value) { this->pVertexInputState = std::bit_cast<const VkPipelineVertexInputStateCreateInfo*>(value); }
  const PipelineVertexInputStateCreateInfo* getVertexInputState() const { return std::bit_cast<const PipelineVertexInputStateCreateInfo*>(this->pVertexInputState); }
  void setInputAssemblyState(const PipelineInputAssemblyStateCreateInfo* value) { this->pInputAssemblyState = std::bit_cast<const VkPipelineInputAssemblyStateCreateInfo*>(value); }
  const PipelineInputAssemblyStateCreateInfo* getInputAssemblyState() const { return std::bit_cast<const PipelineInputAssemblyStateCreateInfo*>(this->pInputAssemblyState); }
  void setTessellationState(const PipelineTessellationStateCreateInfo* value) { this->pTessellationState = std::bit_cast<const VkPipelineTessellationStateCreateInfo*>(value); }
  const PipelineTessellationStateCreateInfo* getTessellationState() const { return std::bit_cast<const PipelineTessellationStateCreateInfo*>(this->pTessellationState); }
  void setViewportState(const PipelineViewportStateCreateInfo* value) { this->pViewportState = std::bit_cast<const VkPipelineViewportStateCreateInfo*>(value); }
  const PipelineViewportStateCreateInfo* getViewportState() const { return std::bit_cast<const PipelineViewportStateCreateInfo*>(this->pViewportState); }
  void setRasterizationState(const PipelineRasterizationStateCreateInfo* value) { this->pRasterizationState = std::bit_cast<const VkPipelineRasterizationStateCreateInfo*>(value); }
  const PipelineRasterizationStateCreateInfo* getRasterizationState() const { return std::bit_cast<const PipelineRasterizationStateCreateInfo*>(this->pRasterizationState); }
  void setMultisampleState(const PipelineMultisampleStateCreateInfo* value) { this->pMultisampleState = std::bit_cast<const VkPipelineMultisampleStateCreateInfo*>(value); }
  const PipelineMultisampleStateCreateInfo* getMultisampleState() const { return std::bit_cast<const PipelineMultisampleStateCreateInfo*>(this->pMultisampleState); }
  void setDepthStencilState(const PipelineDepthStencilStateCreateInfo* value) { this->pDepthStencilState = std::bit_cast<const VkPipelineDepthStencilStateCreateInfo*>(value); }
  const PipelineDepthStencilStateCreateInfo* getDepthStencilState() const { return std::bit_cast<const PipelineDepthStencilStateCreateInfo*>(this->pDepthStencilState); }
  void setColorBlendState(const PipelineColorBlendStateCreateInfo* value) { this->pColorBlendState = std::bit_cast<const VkPipelineColorBlendStateCreateInfo*>(value); }
  const PipelineColorBlendStateCreateInfo* getColorBlendState() const { return std::bit_cast<const PipelineColorBlendStateCreateInfo*>(this->pColorBlendState); }
  void setDynamicState(const PipelineDynamicStateCreateInfo* value) { this->pDynamicState = std::bit_cast<const VkPipelineDynamicStateCreateInfo*>(value); }
  const PipelineDynamicStateCreateInfo* getDynamicState() const { return std::bit_cast<const PipelineDynamicStateCreateInfo*>(this->pDynamicState); }
  // Interface layout of the pipeline
  void setLayout(PipelineLayout value) { this->layout = std::bit_cast<VkPipelineLayout>(value); }
  PipelineLayout getLayout() const { return std::bit_cast<PipelineLayout>(this->layout); }
  void setRenderPass(RenderPass value) { this->renderPass = std::bit_cast<VkRenderPass>(value); }
  RenderPass getRenderPass() const { return std::bit_cast<RenderPass>(this->renderPass); }
  // If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is nonzero, it specifies the handle of the base pipeline this is a derivative of
  void setBasePipelineHandle(Pipeline value) { this->basePipelineHandle = std::bit_cast<VkPipeline>(value); }
  Pipeline getBasePipelineHandle() const { return std::bit_cast<Pipeline>(this->basePipelineHandle); }

#if VK_VERSION_1_4
  void attach(struct PipelineCreateFlags2CreateInfo&);
#endif // VK_VERSION_1_4
#if VK_KHR_pipeline_binary
  void attach(struct PipelineBinaryInfoKHR&);
#endif // VK_KHR_pipeline_binary
#if VK_NV_device_generated_commands
  void attach(struct GraphicsPipelineShaderGroupsCreateInfoNV&);
#endif // VK_NV_device_generated_commands
#if VK_EXT_discard_rectangles
  void attach(struct PipelineDiscardRectangleStateCreateInfoEXT&);
#endif // VK_EXT_discard_rectangles
#if VK_ANDROID_external_memory_android_hardware_buffer
  void attach(struct ExternalFormatANDROID&);
#endif // VK_ANDROID_external_memory_android_hardware_buffer
#if VK_NV_representative_fragment_test
  void attach(struct PipelineRepresentativeFragmentTestStateCreateInfoNV&);
#endif // VK_NV_representative_fragment_test
#if VK_VERSION_1_3
  void attach(struct PipelineCreationFeedbackCreateInfo&);
#endif // VK_VERSION_1_3
#if VK_AMD_pipeline_compiler_control
  void attach(struct PipelineCompilerControlCreateInfoAMD&);
#endif // VK_AMD_pipeline_compiler_control
#if VK_KHR_pipeline_library
  void attach(struct PipelineLibraryCreateInfoKHR&);
#endif // VK_KHR_pipeline_library
#if VK_KHR_fragment_shading_rate
  void attach(struct PipelineFragmentShadingRateStateCreateInfoKHR&);
#endif // VK_KHR_fragment_shading_rate
#if VK_NV_fragment_shading_rate_enums
  void attach(struct PipelineFragmentShadingRateEnumStateCreateInfoNV&);
#endif // VK_NV_fragment_shading_rate_enums
#if VK_VERSION_1_3
  void attach(struct PipelineRenderingCreateInfo&);
#endif // VK_VERSION_1_3
#if VK_AMD_mixed_attachment_samples
  void attach(struct AttachmentSampleCountInfoAMD&);
#endif // VK_AMD_mixed_attachment_samples
#if VK_NVX_multiview_per_view_attributes
  void attach(struct MultiviewPerViewAttributesInfoNVX&);
#endif // VK_NVX_multiview_per_view_attributes
#if VK_EXT_graphics_pipeline_library
  void attach(struct GraphicsPipelineLibraryCreateInfoEXT&);
#endif // VK_EXT_graphics_pipeline_library
#if VK_VERSION_1_4
  void attach(struct PipelineRobustnessCreateInfo&);
  void attach(struct RenderingAttachmentLocationInfo&);
  void attach(struct RenderingInputAttachmentIndexInfo&);
#endif // VK_VERSION_1_4
#if VK_VALVE_fragment_density_map_layered
  void attach(struct PipelineFragmentDensityMapLayeredCreateInfoVALVE&);
#endif // VK_VALVE_fragment_density_map_layered
};
#endif // VK_VERSION_1_0

#if VK_KHR_external_fence
using ExportFenceCreateInfoKHR = ExportFenceCreateInfo;
#endif // VK_KHR_external_fence

#if VK_VERSION_1_3
struct FormatProperties3 : VkFormatProperties3 {
  FormatProperties3() noexcept : VkFormatProperties3{.sType = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3} {}

  FormatFeatureFlags2 getLinearTilingFeatures() const { return std::bit_cast<FormatFeatureFlags2>(this->linearTilingFeatures); }
  FormatFeatureFlags2 getOptimalTilingFeatures() const { return std::bit_cast<FormatFeatureFlags2>(this->optimalTilingFeatures); }
  FormatFeatureFlags2 getBufferFeatures() const { return std::bit_cast<FormatFeatureFlags2>(this->bufferFeatures); }
};
inline void FormatProperties2::attach(FormatProperties3& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_3

#if VK_ARM_tensors
struct TensorFormatPropertiesARM : VkTensorFormatPropertiesARM {
  TensorFormatPropertiesARM() noexcept : VkTensorFormatPropertiesARM{.sType = VK_STRUCTURE_TYPE_TENSOR_FORMAT_PROPERTIES_ARM} {}

  FormatFeatureFlags2 getOptimalTilingTensorFeatures() const { return std::bit_cast<FormatFeatureFlags2>(this->optimalTilingTensorFeatures); }
  FormatFeatureFlags2 getLinearTilingTensorFeatures() const { return std::bit_cast<FormatFeatureFlags2>(this->linearTilingTensorFeatures); }
};
inline void FormatProperties2::attach(TensorFormatPropertiesARM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_ARM_tensors

#if VK_EXT_image_drm_format_modifier
struct DrmFormatModifierPropertiesListEXT : VkDrmFormatModifierPropertiesListEXT {
  DrmFormatModifierPropertiesListEXT() noexcept : VkDrmFormatModifierPropertiesListEXT{.sType = VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT} {}

  uint32_t getDrmFormatModifierCount() const { return this->drmFormatModifierCount; }
  DrmFormatModifierPropertiesEXT* getDrmFormatModifierProperties() const { return std::bit_cast<DrmFormatModifierPropertiesEXT*>(this->pDrmFormatModifierProperties); }
};
inline void FormatProperties2::attach(DrmFormatModifierPropertiesListEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_image_drm_format_modifier

#if VK_EXT_multisampled_render_to_single_sampled
struct SubpassResolvePerformanceQueryEXT : VkSubpassResolvePerformanceQueryEXT {
  SubpassResolvePerformanceQueryEXT() noexcept : VkSubpassResolvePerformanceQueryEXT{.sType = VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT} {}

  Bool32 getOptimal() const { return this->optimal; }
};
inline void FormatProperties2::attach(SubpassResolvePerformanceQueryEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_multisampled_render_to_single_sampled

#if VK_KHR_get_physical_device_properties2
using FormatProperties2KHR = FormatProperties2;
#endif // VK_KHR_get_physical_device_properties2
#if VK_KHR_dynamic_rendering
using CommandBufferInheritanceRenderingInfoKHR = CommandBufferInheritanceRenderingInfo;
#endif // VK_KHR_dynamic_rendering

#if VK_VERSION_1_1
struct DeviceGroupCommandBufferBeginInfo : VkDeviceGroupCommandBufferBeginInfo {
  DeviceGroupCommandBufferBeginInfo() noexcept : VkDeviceGroupCommandBufferBeginInfo{.sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO} {}

  void setDeviceMask(uint32_t value) { this->deviceMask = value; }
  uint32_t getDeviceMask() const { return this->deviceMask; }
};
inline void CommandBufferBeginInfo::attach(DeviceGroupCommandBufferBeginInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_1

#if VK_KHR_separate_depth_stencil_layouts
using AttachmentReferenceStencilLayoutKHR = AttachmentReferenceStencilLayout;
#endif // VK_KHR_separate_depth_stencil_layouts

#if VK_EXT_subpass_merge_feedback
struct RenderPassSubpassFeedbackCreateInfoEXT : VkRenderPassSubpassFeedbackCreateInfoEXT {
  RenderPassSubpassFeedbackCreateInfoEXT() noexcept : VkRenderPassSubpassFeedbackCreateInfoEXT{.sType = VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT} {}

  void setSubpassFeedback(RenderPassSubpassFeedbackInfoEXT* value) { this->pSubpassFeedback = std::bit_cast<VkRenderPassSubpassFeedbackInfoEXT*>(value); }
  RenderPassSubpassFeedbackInfoEXT* getSubpassFeedback() const { return std::bit_cast<RenderPassSubpassFeedbackInfoEXT*>(this->pSubpassFeedback); }
};
inline void SubpassDescription2::attach(RenderPassSubpassFeedbackCreateInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_subpass_merge_feedback

#if VK_VERSION_1_2
struct RenderPassCreateInfo2 : VkRenderPassCreateInfo2 {
  RenderPassCreateInfo2() noexcept : VkRenderPassCreateInfo2{.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2} {}

  void setSubpassCount(uint32_t value) { this->subpassCount = value; }
  uint32_t getSubpassCount() const { return this->subpassCount; }
  void setSubpasses(const SubpassDescription2* value) { this->pSubpasses = std::bit_cast<const VkSubpassDescription2*>(value); }
  const SubpassDescription2* getSubpasses() const { return std::bit_cast<const SubpassDescription2*>(this->pSubpasses); }

  void setFlags(RenderPassCreateFlags value) { this->flags = std::bit_cast<VkRenderPassCreateFlags>(value); }
  RenderPassCreateFlags getFlags() const { return std::bit_cast<RenderPassCreateFlags>(this->flags); }
  void setAttachmentCount(uint32_t value) { this->attachmentCount = value; }
  uint32_t getAttachmentCount() const { return this->attachmentCount; }
  void setAttachments(const AttachmentDescription2* value) { this->pAttachments = std::bit_cast<const VkAttachmentDescription2*>(value); }
  const AttachmentDescription2* getAttachments() const { return std::bit_cast<const AttachmentDescription2*>(this->pAttachments); }
  void setDependencyCount(uint32_t value) { this->dependencyCount = value; }
  uint32_t getDependencyCount() const { return this->dependencyCount; }
  void setDependencies(const SubpassDependency2* value) { this->pDependencies = std::bit_cast<const VkSubpassDependency2*>(value); }
  const SubpassDependency2* getDependencies() const { return std::bit_cast<const SubpassDependency2*>(this->pDependencies); }
  void setCorrelatedViewMaskCount(uint32_t value) { this->correlatedViewMaskCount = value; }
  uint32_t getCorrelatedViewMaskCount() const { return this->correlatedViewMaskCount; }
  void setCorrelatedViewMasks(const uint32_t* value) { this->pCorrelatedViewMasks = value; }
  const uint32_t* getCorrelatedViewMasks() const { return this->pCorrelatedViewMasks; }

#if VK_EXT_fragment_density_map
  void attach(struct RenderPassFragmentDensityMapCreateInfoEXT&);
#endif // VK_EXT_fragment_density_map
#if VK_EXT_subpass_merge_feedback
  void attach(struct RenderPassCreationControlEXT&);
  void attach(struct RenderPassCreationFeedbackCreateInfoEXT&);
#endif // VK_EXT_subpass_merge_feedback
#if VK_QCOM_tile_memory_heap
  void attach(struct TileMemorySizeInfoQCOM&);
#endif // VK_QCOM_tile_memory_heap
#if VK_QCOM_tile_shading
  void attach(struct RenderPassTileShadingCreateInfoQCOM&);
#endif // VK_QCOM_tile_shading
};
#endif // VK_VERSION_1_2

#if VK_KHR_fragment_shading_rate
struct FragmentShadingRateAttachmentInfoKHR : VkFragmentShadingRateAttachmentInfoKHR {
  FragmentShadingRateAttachmentInfoKHR() noexcept : VkFragmentShadingRateAttachmentInfoKHR{.sType = VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR} {}

  void setShadingRateAttachmentTexelSize(const Extent2D& value) { this->shadingRateAttachmentTexelSize = value; }
  const Extent2D& getShadingRateAttachmentTexelSize() const { return static_cast<const Extent2D&>(this->shadingRateAttachmentTexelSize); }

  void setFragmentShadingRateAttachment(const AttachmentReference2* value) { this->pFragmentShadingRateAttachment = std::bit_cast<const VkAttachmentReference2*>(value); }
  const AttachmentReference2* getFragmentShadingRateAttachment() const { return std::bit_cast<const AttachmentReference2*>(this->pFragmentShadingRateAttachment); }
};
inline void SubpassDescription2::attach(FragmentShadingRateAttachmentInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_fragment_shading_rate

#if VK_KHR_create_renderpass2
using SubpassDescription2KHR = SubpassDescription2;
#endif // VK_KHR_create_renderpass2

#if VK_EXT_multisampled_render_to_single_sampled
struct MultisampledRenderToSingleSampledInfoEXT : VkMultisampledRenderToSingleSampledInfoEXT {
  MultisampledRenderToSingleSampledInfoEXT() noexcept : VkMultisampledRenderToSingleSampledInfoEXT{.sType = VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT} {}

  void setRasterizationSamples(SampleCountFlagBits value) { this->rasterizationSamples = std::bit_cast<VkSampleCountFlagBits>(value); }
  SampleCountFlagBits getRasterizationSamples() const { return std::bit_cast<SampleCountFlagBits>(this->rasterizationSamples); }

  void setMultisampledRenderToSingleSampledEnable(Bool32 value) { this->multisampledRenderToSingleSampledEnable = value; }
  Bool32 getMultisampledRenderToSingleSampledEnable() const { return this->multisampledRenderToSingleSampledEnable; }
};
inline void SubpassDescription2::attach(MultisampledRenderToSingleSampledInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void RenderingInfo::attach(MultisampledRenderToSingleSampledInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_multisampled_render_to_single_sampled

#if VK_VERSION_1_2
struct SubpassDescriptionDepthStencilResolve : VkSubpassDescriptionDepthStencilResolve {
  SubpassDescriptionDepthStencilResolve() noexcept : VkSubpassDescriptionDepthStencilResolve{.sType = VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE} {}

  // depth resolve mode
  void setDepthResolveMode(ResolveModeFlagBits value) { this->depthResolveMode = std::bit_cast<VkResolveModeFlagBits>(value); }
  ResolveModeFlagBits getDepthResolveMode() const { return std::bit_cast<ResolveModeFlagBits>(this->depthResolveMode); }
  // stencil resolve mode
  void setStencilResolveMode(ResolveModeFlagBits value) { this->stencilResolveMode = std::bit_cast<VkResolveModeFlagBits>(value); }
  ResolveModeFlagBits getStencilResolveMode() const { return std::bit_cast<ResolveModeFlagBits>(this->stencilResolveMode); }

  // depth/stencil resolve attachment
  void setDepthStencilResolveAttachment(const AttachmentReference2* value) { this->pDepthStencilResolveAttachment = std::bit_cast<const VkAttachmentReference2*>(value); }
  const AttachmentReference2* getDepthStencilResolveAttachment() const { return std::bit_cast<const AttachmentReference2*>(this->pDepthStencilResolveAttachment); }
};
inline void SubpassDescription2::attach(SubpassDescriptionDepthStencilResolve& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_2

#if VK_KHR_maintenance5
using ImageSubresource2KHR = ImageSubresource2;
#endif // VK_KHR_maintenance5
#if VK_EXT_host_image_copy
using ImageSubresource2EXT = ImageSubresource2;
#endif // VK_EXT_host_image_copy

#if VK_VERSION_1_4
struct DeviceImageSubresourceInfo : VkDeviceImageSubresourceInfo {
  DeviceImageSubresourceInfo() noexcept : VkDeviceImageSubresourceInfo{.sType = VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO} {}

  void setCreateInfo(const ImageCreateInfo* value) { this->pCreateInfo = std::bit_cast<const VkImageCreateInfo*>(value); }
  const ImageCreateInfo* getCreateInfo() const { return std::bit_cast<const ImageCreateInfo*>(this->pCreateInfo); }
  void setSubresource(const ImageSubresource2* value) { this->pSubresource = std::bit_cast<const VkImageSubresource2*>(value); }
  const ImageSubresource2* getSubresource() const { return std::bit_cast<const ImageSubresource2*>(this->pSubresource); }
};
#endif // VK_VERSION_1_4

#if VK_VERSION_1_0
struct SparseImageMemoryBindInfo : VkSparseImageMemoryBindInfo {
  SparseImageMemoryBindInfo() noexcept : VkSparseImageMemoryBindInfo{} {}
  SparseImageMemoryBindInfo(Image image, uint32_t bindCount, const SparseImageMemoryBind* pBinds) noexcept : VkSparseImageMemoryBindInfo{.image = std::bit_cast<VkImage>(image), .bindCount = bindCount, .pBinds = std::bit_cast<const VkSparseImageMemoryBind*>(pBinds)} {}

  void setImage(Image value) { this->image = std::bit_cast<VkImage>(value); }
  Image getImage() const { return std::bit_cast<Image>(this->image); }
  void setBindCount(uint32_t value) { this->bindCount = value; }
  uint32_t getBindCount() const { return this->bindCount; }
  void setBinds(const SparseImageMemoryBind* value) { this->pBinds = std::bit_cast<const VkSparseImageMemoryBind*>(value); }
  const SparseImageMemoryBind* getBinds() const { return std::bit_cast<const SparseImageMemoryBind*>(this->pBinds); }
};
#endif // VK_VERSION_1_0

#if VK_KHR_copy_commands2
using ImageBlit2KHR = ImageBlit2;
#endif // VK_KHR_copy_commands2

#if VK_VERSION_1_3
struct BlitImageInfo2 : VkBlitImageInfo2 {
  BlitImageInfo2() noexcept : VkBlitImageInfo2{.sType = VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2} {}

  void setSrcImage(Image value) { this->srcImage = std::bit_cast<VkImage>(value); }
  Image getSrcImage() const { return std::bit_cast<Image>(this->srcImage); }
  void setSrcImageLayout(ImageLayout value) { this->srcImageLayout = std::bit_cast<VkImageLayout>(value); }
  ImageLayout getSrcImageLayout() const { return std::bit_cast<ImageLayout>(this->srcImageLayout); }
  void setDstImage(Image value) { this->dstImage = std::bit_cast<VkImage>(value); }
  Image getDstImage() const { return std::bit_cast<Image>(this->dstImage); }
  void setDstImageLayout(ImageLayout value) { this->dstImageLayout = std::bit_cast<VkImageLayout>(value); }
  ImageLayout getDstImageLayout() const { return std::bit_cast<ImageLayout>(this->dstImageLayout); }
  void setRegionCount(uint32_t value) { this->regionCount = value; }
  uint32_t getRegionCount() const { return this->regionCount; }
  void setRegions(const ImageBlit2* value) { this->pRegions = std::bit_cast<const VkImageBlit2*>(value); }
  const ImageBlit2* getRegions() const { return std::bit_cast<const ImageBlit2*>(this->pRegions); }
  void setFilter(Filter value) { this->filter = std::bit_cast<VkFilter>(value); }
  Filter getFilter() const { return std::bit_cast<Filter>(this->filter); }

#if VK_QCOM_filter_cubic_weights
  void attach(struct BlitImageCubicWeightsInfoQCOM&);
#endif // VK_QCOM_filter_cubic_weights
};
#endif // VK_VERSION_1_3

#if VK_EXT_host_image_copy
using MemoryToImageCopyEXT = MemoryToImageCopy;
#endif // VK_EXT_host_image_copy

#if VK_VERSION_1_4
struct CopyMemoryToImageInfo : VkCopyMemoryToImageInfo {
  CopyMemoryToImageInfo() noexcept : VkCopyMemoryToImageInfo{.sType = VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO} {}

  void setDstImage(Image value) { this->dstImage = std::bit_cast<VkImage>(value); }
  Image getDstImage() const { return std::bit_cast<Image>(this->dstImage); }
  void setDstImageLayout(ImageLayout value) { this->dstImageLayout = std::bit_cast<VkImageLayout>(value); }
  ImageLayout getDstImageLayout() const { return std::bit_cast<ImageLayout>(this->dstImageLayout); }
  void setRegionCount(uint32_t value) { this->regionCount = value; }
  uint32_t getRegionCount() const { return this->regionCount; }
  void setRegions(const MemoryToImageCopy* value) { this->pRegions = std::bit_cast<const VkMemoryToImageCopy*>(value); }
  const MemoryToImageCopy* getRegions() const { return std::bit_cast<const MemoryToImageCopy*>(this->pRegions); }

  void setFlags(HostImageCopyFlags value) { this->flags = std::bit_cast<VkHostImageCopyFlags>(value); }
  HostImageCopyFlags getFlags() const { return std::bit_cast<HostImageCopyFlags>(this->flags); }
};

struct CopyImageToMemoryInfo : VkCopyImageToMemoryInfo {
  CopyImageToMemoryInfo() noexcept : VkCopyImageToMemoryInfo{.sType = VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO} {}

  void setSrcImage(Image value) { this->srcImage = std::bit_cast<VkImage>(value); }
  Image getSrcImage() const { return std::bit_cast<Image>(this->srcImage); }
  void setSrcImageLayout(ImageLayout value) { this->srcImageLayout = std::bit_cast<VkImageLayout>(value); }
  ImageLayout getSrcImageLayout() const { return std::bit_cast<ImageLayout>(this->srcImageLayout); }
  void setRegionCount(uint32_t value) { this->regionCount = value; }
  uint32_t getRegionCount() const { return this->regionCount; }
  void setRegions(const ImageToMemoryCopy* value) { this->pRegions = std::bit_cast<const VkImageToMemoryCopy*>(value); }
  const ImageToMemoryCopy* getRegions() const { return std::bit_cast<const ImageToMemoryCopy*>(this->pRegions); }

  void setFlags(HostImageCopyFlags value) { this->flags = std::bit_cast<VkHostImageCopyFlags>(value); }
  HostImageCopyFlags getFlags() const { return std::bit_cast<HostImageCopyFlags>(this->flags); }
};
#endif // VK_VERSION_1_4

#if VK_EXT_host_image_copy
using ImageToMemoryCopyEXT = ImageToMemoryCopy;
#endif // VK_EXT_host_image_copy

#if VK_QCOM_rotated_copy_commands
struct CopyCommandTransformInfoQCOM : VkCopyCommandTransformInfoQCOM {
  CopyCommandTransformInfoQCOM() noexcept : VkCopyCommandTransformInfoQCOM{.sType = VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM} {}

  void setTransform(SurfaceTransformFlagBitsKHR value) { this->transform = std::bit_cast<VkSurfaceTransformFlagBitsKHR>(value); }
  SurfaceTransformFlagBitsKHR getTransform() const { return std::bit_cast<SurfaceTransformFlagBitsKHR>(this->transform); }
};
inline void BufferImageCopy2::attach(CopyCommandTransformInfoQCOM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void ImageBlit2::attach(CopyCommandTransformInfoQCOM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_QCOM_rotated_copy_commands

#if VK_VERSION_1_3
struct CopyImageToBufferInfo2 : VkCopyImageToBufferInfo2 {
  CopyImageToBufferInfo2() noexcept : VkCopyImageToBufferInfo2{.sType = VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2} {}

  void setSrcImage(Image value) { this->srcImage = std::bit_cast<VkImage>(value); }
  Image getSrcImage() const { return std::bit_cast<Image>(this->srcImage); }
  void setSrcImageLayout(ImageLayout value) { this->srcImageLayout = std::bit_cast<VkImageLayout>(value); }
  ImageLayout getSrcImageLayout() const { return std::bit_cast<ImageLayout>(this->srcImageLayout); }
  void setDstBuffer(Buffer value) { this->dstBuffer = std::bit_cast<VkBuffer>(value); }
  Buffer getDstBuffer() const { return std::bit_cast<Buffer>(this->dstBuffer); }
  void setRegionCount(uint32_t value) { this->regionCount = value; }
  uint32_t getRegionCount() const { return this->regionCount; }
  void setRegions(const BufferImageCopy2* value) { this->pRegions = std::bit_cast<const VkBufferImageCopy2*>(value); }
  const BufferImageCopy2* getRegions() const { return std::bit_cast<const BufferImageCopy2*>(this->pRegions); }
};
#endif // VK_VERSION_1_3

#if VK_KHR_copy_commands2
using BufferImageCopy2KHR = BufferImageCopy2;
#endif // VK_KHR_copy_commands2

#if VK_VERSION_1_3
struct CopyBufferToImageInfo2 : VkCopyBufferToImageInfo2 {
  CopyBufferToImageInfo2() noexcept : VkCopyBufferToImageInfo2{.sType = VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2} {}

  void setSrcBuffer(Buffer value) { this->srcBuffer = std::bit_cast<VkBuffer>(value); }
  Buffer getSrcBuffer() const { return std::bit_cast<Buffer>(this->srcBuffer); }
  void setDstImage(Image value) { this->dstImage = std::bit_cast<VkImage>(value); }
  Image getDstImage() const { return std::bit_cast<Image>(this->dstImage); }
  void setDstImageLayout(ImageLayout value) { this->dstImageLayout = std::bit_cast<VkImageLayout>(value); }
  ImageLayout getDstImageLayout() const { return std::bit_cast<ImageLayout>(this->dstImageLayout); }
  void setRegionCount(uint32_t value) { this->regionCount = value; }
  uint32_t getRegionCount() const { return this->regionCount; }
  void setRegions(const BufferImageCopy2* value) { this->pRegions = std::bit_cast<const VkBufferImageCopy2*>(value); }
  const BufferImageCopy2* getRegions() const { return std::bit_cast<const BufferImageCopy2*>(this->pRegions); }
};

struct CopyImageInfo2 : VkCopyImageInfo2 {
  CopyImageInfo2() noexcept : VkCopyImageInfo2{.sType = VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2} {}

  void setSrcImage(Image value) { this->srcImage = std::bit_cast<VkImage>(value); }
  Image getSrcImage() const { return std::bit_cast<Image>(this->srcImage); }
  void setSrcImageLayout(ImageLayout value) { this->srcImageLayout = std::bit_cast<VkImageLayout>(value); }
  ImageLayout getSrcImageLayout() const { return std::bit_cast<ImageLayout>(this->srcImageLayout); }
  void setDstImage(Image value) { this->dstImage = std::bit_cast<VkImage>(value); }
  Image getDstImage() const { return std::bit_cast<Image>(this->dstImage); }
  void setDstImageLayout(ImageLayout value) { this->dstImageLayout = std::bit_cast<VkImageLayout>(value); }
  ImageLayout getDstImageLayout() const { return std::bit_cast<ImageLayout>(this->dstImageLayout); }
  void setRegionCount(uint32_t value) { this->regionCount = value; }
  uint32_t getRegionCount() const { return this->regionCount; }
  void setRegions(const ImageCopy2* value) { this->pRegions = std::bit_cast<const VkImageCopy2*>(value); }
  const ImageCopy2* getRegions() const { return std::bit_cast<const ImageCopy2*>(this->pRegions); }
};
#endif // VK_VERSION_1_3

#if VK_VERSION_1_4
struct CopyImageToImageInfo : VkCopyImageToImageInfo {
  CopyImageToImageInfo() noexcept : VkCopyImageToImageInfo{.sType = VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO} {}

  void setSrcImage(Image value) { this->srcImage = std::bit_cast<VkImage>(value); }
  Image getSrcImage() const { return std::bit_cast<Image>(this->srcImage); }
  void setSrcImageLayout(ImageLayout value) { this->srcImageLayout = std::bit_cast<VkImageLayout>(value); }
  ImageLayout getSrcImageLayout() const { return std::bit_cast<ImageLayout>(this->srcImageLayout); }
  void setDstImage(Image value) { this->dstImage = std::bit_cast<VkImage>(value); }
  Image getDstImage() const { return std::bit_cast<Image>(this->dstImage); }
  void setDstImageLayout(ImageLayout value) { this->dstImageLayout = std::bit_cast<VkImageLayout>(value); }
  ImageLayout getDstImageLayout() const { return std::bit_cast<ImageLayout>(this->dstImageLayout); }
  void setRegionCount(uint32_t value) { this->regionCount = value; }
  uint32_t getRegionCount() const { return this->regionCount; }
  void setRegions(const ImageCopy2* value) { this->pRegions = std::bit_cast<const VkImageCopy2*>(value); }
  const ImageCopy2* getRegions() const { return std::bit_cast<const ImageCopy2*>(this->pRegions); }

  void setFlags(HostImageCopyFlags value) { this->flags = std::bit_cast<VkHostImageCopyFlags>(value); }
  HostImageCopyFlags getFlags() const { return std::bit_cast<HostImageCopyFlags>(this->flags); }
};
#endif // VK_VERSION_1_4

#if VK_KHR_copy_commands2
using ImageCopy2KHR = ImageCopy2;
#endif // VK_KHR_copy_commands2

#if VK_VERSION_1_3
struct ResolveImageInfo2 : VkResolveImageInfo2 {
  ResolveImageInfo2() noexcept : VkResolveImageInfo2{.sType = VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2} {}

  void setSrcImage(Image value) { this->srcImage = std::bit_cast<VkImage>(value); }
  Image getSrcImage() const { return std::bit_cast<Image>(this->srcImage); }
  void setSrcImageLayout(ImageLayout value) { this->srcImageLayout = std::bit_cast<VkImageLayout>(value); }
  ImageLayout getSrcImageLayout() const { return std::bit_cast<ImageLayout>(this->srcImageLayout); }
  void setDstImage(Image value) { this->dstImage = std::bit_cast<VkImage>(value); }
  Image getDstImage() const { return std::bit_cast<Image>(this->dstImage); }
  void setDstImageLayout(ImageLayout value) { this->dstImageLayout = std::bit_cast<VkImageLayout>(value); }
  ImageLayout getDstImageLayout() const { return std::bit_cast<ImageLayout>(this->dstImageLayout); }
  void setRegionCount(uint32_t value) { this->regionCount = value; }
  uint32_t getRegionCount() const { return this->regionCount; }
  void setRegions(const ImageResolve2* value) { this->pRegions = std::bit_cast<const VkImageResolve2*>(value); }
  const ImageResolve2* getRegions() const { return std::bit_cast<const ImageResolve2*>(this->pRegions); }
};
#endif // VK_VERSION_1_3

#if VK_KHR_copy_commands2
using ImageResolve2KHR = ImageResolve2;
#endif // VK_KHR_copy_commands2
#if VK_EXT_host_image_copy
using HostImageLayoutTransitionInfoEXT = HostImageLayoutTransitionInfo;
#endif // VK_EXT_host_image_copy

#if VK_KHR_maintenance8
struct MemoryBarrierAccessFlags3KHR : VkMemoryBarrierAccessFlags3KHR {
  MemoryBarrierAccessFlags3KHR() noexcept : VkMemoryBarrierAccessFlags3KHR{.sType = VK_STRUCTURE_TYPE_MEMORY_BARRIER_ACCESS_FLAGS_3_KHR} {}

  void setSrcAccessMask3(AccessFlags3KHR value) { this->srcAccessMask3 = std::bit_cast<VkAccessFlags3KHR>(value); }
  AccessFlags3KHR getSrcAccessMask3() const { return std::bit_cast<AccessFlags3KHR>(this->srcAccessMask3); }
  void setDstAccessMask3(AccessFlags3KHR value) { this->dstAccessMask3 = std::bit_cast<VkAccessFlags3KHR>(value); }
  AccessFlags3KHR getDstAccessMask3() const { return std::bit_cast<AccessFlags3KHR>(this->dstAccessMask3); }
};
inline void SubpassDependency2::attach(MemoryBarrierAccessFlags3KHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void BufferMemoryBarrier2::attach(MemoryBarrierAccessFlags3KHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void ImageMemoryBarrier2::attach(MemoryBarrierAccessFlags3KHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_maintenance8

#if VK_KHR_synchronization2
using ImageMemoryBarrier2KHR = ImageMemoryBarrier2;
#endif // VK_KHR_synchronization2

#if VK_EXT_external_memory_acquire_unmodified
struct ExternalMemoryAcquireUnmodifiedEXT : VkExternalMemoryAcquireUnmodifiedEXT {
  ExternalMemoryAcquireUnmodifiedEXT() noexcept : VkExternalMemoryAcquireUnmodifiedEXT{.sType = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT} {}

  void setAcquireUnmodifiedMemory(Bool32 value) { this->acquireUnmodifiedMemory = value; }
  Bool32 getAcquireUnmodifiedMemory() const { return this->acquireUnmodifiedMemory; }
};
inline void BufferMemoryBarrier::attach(ExternalMemoryAcquireUnmodifiedEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void BufferMemoryBarrier2::attach(ExternalMemoryAcquireUnmodifiedEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void ImageMemoryBarrier::attach(ExternalMemoryAcquireUnmodifiedEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void ImageMemoryBarrier2::attach(ExternalMemoryAcquireUnmodifiedEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_external_memory_acquire_unmodified

#if VK_EXT_sample_locations
struct SampleLocationsInfoEXT : VkSampleLocationsInfoEXT {
  SampleLocationsInfoEXT() noexcept : VkSampleLocationsInfoEXT{.sType = VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT} {}

  void setSampleLocationsPerPixel(SampleCountFlagBits value) { this->sampleLocationsPerPixel = std::bit_cast<VkSampleCountFlagBits>(value); }
  SampleCountFlagBits getSampleLocationsPerPixel() const { return std::bit_cast<SampleCountFlagBits>(this->sampleLocationsPerPixel); }
  void setSampleLocationGridSize(const Extent2D& value) { this->sampleLocationGridSize = value; }
  const Extent2D& getSampleLocationGridSize() const { return static_cast<const Extent2D&>(this->sampleLocationGridSize); }

  void setSampleLocationsCount(uint32_t value) { this->sampleLocationsCount = value; }
  uint32_t getSampleLocationsCount() const { return this->sampleLocationsCount; }
  void setSampleLocations(const SampleLocationEXT* value) { this->pSampleLocations = std::bit_cast<const VkSampleLocationEXT*>(value); }
  const SampleLocationEXT* getSampleLocations() const { return std::bit_cast<const SampleLocationEXT*>(this->pSampleLocations); }
};
inline void ImageMemoryBarrier::attach(SampleLocationsInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void ImageMemoryBarrier2::attach(SampleLocationsInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_sample_locations

#if VK_EXT_metal_objects
struct ExportMetalObjectCreateInfoEXT : VkExportMetalObjectCreateInfoEXT {
  ExportMetalObjectCreateInfoEXT() noexcept : VkExportMetalObjectCreateInfoEXT{.sType = VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT} {}

  void setExportObjectType(ExportMetalObjectTypeFlagBitsEXT value) { this->exportObjectType = std::bit_cast<VkExportMetalObjectTypeFlagBitsEXT>(value); }
  ExportMetalObjectTypeFlagBitsEXT getExportObjectType() const { return std::bit_cast<ExportMetalObjectTypeFlagBitsEXT>(this->exportObjectType); }
};
inline void InstanceCreateInfo::attach(ExportMetalObjectCreateInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void MemoryAllocateInfo::attach(ExportMetalObjectCreateInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void ImageCreateInfo::attach(ExportMetalObjectCreateInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void ImageViewCreateInfo::attach(ExportMetalObjectCreateInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void BufferViewCreateInfo::attach(ExportMetalObjectCreateInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void SemaphoreCreateInfo::attach(ExportMetalObjectCreateInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void EventCreateInfo::attach(ExportMetalObjectCreateInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_metal_objects

#if VK_QCOM_image_processing
struct ImageViewSampleWeightCreateInfoQCOM : VkImageViewSampleWeightCreateInfoQCOM {
  ImageViewSampleWeightCreateInfoQCOM() noexcept : VkImageViewSampleWeightCreateInfoQCOM{.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM} {}

  void setFilterCenter(const Offset2D& value) { this->filterCenter = value; }
  const Offset2D& getFilterCenter() const { return static_cast<const Offset2D&>(this->filterCenter); }
  void setFilterSize(const Extent2D& value) { this->filterSize = value; }
  const Extent2D& getFilterSize() const { return static_cast<const Extent2D&>(this->filterSize); }
  void setNumPhases(uint32_t value) { this->numPhases = value; }
  uint32_t getNumPhases() const { return this->numPhases; }
};
inline void ImageViewCreateInfo::attach(ImageViewSampleWeightCreateInfoQCOM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_QCOM_image_processing

#if VK_EXT_image_view_min_lod
struct ImageViewMinLodCreateInfoEXT : VkImageViewMinLodCreateInfoEXT {
  ImageViewMinLodCreateInfoEXT() noexcept : VkImageViewMinLodCreateInfoEXT{.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT} {}

  void setMinLod(float value) { this->minLod = value; }
  float getMinLod() const { return this->minLod; }
};
inline void ImageViewCreateInfo::attach(ImageViewMinLodCreateInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_image_view_min_lod

#if VK_EXT_image_sliced_view_of_3d
struct ImageViewSlicedCreateInfoEXT : VkImageViewSlicedCreateInfoEXT {
  ImageViewSlicedCreateInfoEXT() noexcept : VkImageViewSlicedCreateInfoEXT{.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_SLICED_CREATE_INFO_EXT} {}

  void setSliceOffset(uint32_t value) { this->sliceOffset = value; }
  uint32_t getSliceOffset() const { return this->sliceOffset; }
  void setSliceCount(uint32_t value) { this->sliceCount = value; }
  uint32_t getSliceCount() const { return this->sliceCount; }
};
inline void ImageViewCreateInfo::attach(ImageViewSlicedCreateInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_image_sliced_view_of_3d

#if VK_EXT_astc_decode_mode
struct ImageViewASTCDecodeModeEXT : VkImageViewASTCDecodeModeEXT {
  ImageViewASTCDecodeModeEXT() noexcept : VkImageViewASTCDecodeModeEXT{.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT} {}

  void setDecodeMode(Format value) { this->decodeMode = std::bit_cast<VkFormat>(value); }
  Format getDecodeMode() const { return std::bit_cast<Format>(this->decodeMode); }
};
inline void ImageViewCreateInfo::attach(ImageViewASTCDecodeModeEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_astc_decode_mode

#if VK_VERSION_1_1
struct ImageViewUsageCreateInfo : VkImageViewUsageCreateInfo {
  ImageViewUsageCreateInfo() noexcept : VkImageViewUsageCreateInfo{.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO} {}

  void setUsage(ImageUsageFlags value) { this->usage = std::bit_cast<VkImageUsageFlags>(value); }
  ImageUsageFlags getUsage() const { return std::bit_cast<ImageUsageFlags>(this->usage); }
};
inline void ImageViewCreateInfo::attach(ImageViewUsageCreateInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }

struct SamplerYcbcrConversionInfo : VkSamplerYcbcrConversionInfo {
  SamplerYcbcrConversionInfo() noexcept : VkSamplerYcbcrConversionInfo{.sType = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO} {}

  void setConversion(SamplerYcbcrConversion value) { this->conversion = std::bit_cast<VkSamplerYcbcrConversion>(value); }
  SamplerYcbcrConversion getConversion() const { return std::bit_cast<SamplerYcbcrConversion>(this->conversion); }
};
inline void SamplerCreateInfo::attach(SamplerYcbcrConversionInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void ImageViewCreateInfo::attach(SamplerYcbcrConversionInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_1

#if VK_KHR_get_physical_device_properties2
using SparseImageFormatProperties2KHR = SparseImageFormatProperties2;
#endif // VK_KHR_get_physical_device_properties2

#if VK_VERSION_1_1
struct SparseImageMemoryRequirements2 : VkSparseImageMemoryRequirements2 {
  SparseImageMemoryRequirements2() noexcept : VkSparseImageMemoryRequirements2{.sType = VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2} {}

  const SparseImageMemoryRequirements& getMemoryRequirements() const { return static_cast<const SparseImageMemoryRequirements&>(this->memoryRequirements); }
};
#endif // VK_VERSION_1_1

#if VK_EXT_image_compression_control
struct ImageCompressionPropertiesEXT : VkImageCompressionPropertiesEXT {
  ImageCompressionPropertiesEXT() noexcept : VkImageCompressionPropertiesEXT{.sType = VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT} {}

  ImageCompressionFlagsEXT getImageCompressionFlags() const { return std::bit_cast<ImageCompressionFlagsEXT>(this->imageCompressionFlags); }
  ImageCompressionFixedRateFlagsEXT getImageCompressionFixedRateFlags() const { return std::bit_cast<ImageCompressionFixedRateFlagsEXT>(this->imageCompressionFixedRateFlags); }
};
inline void ImageFormatProperties2::attach(ImageCompressionPropertiesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void SurfaceFormat2KHR::attach(ImageCompressionPropertiesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void SubresourceLayout2::attach(ImageCompressionPropertiesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_image_compression_control

#if VK_VERSION_1_4
struct HostImageCopyDevicePerformanceQuery : VkHostImageCopyDevicePerformanceQuery {
  HostImageCopyDevicePerformanceQuery() noexcept : VkHostImageCopyDevicePerformanceQuery{.sType = VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY} {}

  // Specifies if device access is optimal
  Bool32 getOptimalDeviceAccess() const { return this->optimalDeviceAccess; }
  // Specifies if memory layout is identical
  Bool32 getIdenticalMemoryLayout() const { return this->identicalMemoryLayout; }
};
inline void ImageFormatProperties2::attach(HostImageCopyDevicePerformanceQuery& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_4

#if VK_AMD_texture_gather_bias_lod
struct TextureLODGatherFormatPropertiesAMD : VkTextureLODGatherFormatPropertiesAMD {
  TextureLODGatherFormatPropertiesAMD() noexcept : VkTextureLODGatherFormatPropertiesAMD{.sType = VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD} {}

  Bool32 getSupportsTextureGatherLODBiasAMD() const { return this->supportsTextureGatherLODBiasAMD; }
};
inline void ImageFormatProperties2::attach(TextureLODGatherFormatPropertiesAMD& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_AMD_texture_gather_bias_lod

#if VK_VERSION_1_1
struct SamplerYcbcrConversionImageFormatProperties : VkSamplerYcbcrConversionImageFormatProperties {
  SamplerYcbcrConversionImageFormatProperties() noexcept : VkSamplerYcbcrConversionImageFormatProperties{.sType = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES} {}

  uint32_t getCombinedImageSamplerDescriptorCount() const { return this->combinedImageSamplerDescriptorCount; }
};
inline void ImageFormatProperties2::attach(SamplerYcbcrConversionImageFormatProperties& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }

struct ExternalImageFormatProperties : VkExternalImageFormatProperties {
  ExternalImageFormatProperties() noexcept : VkExternalImageFormatProperties{.sType = VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES} {}

  const ExternalMemoryProperties& getExternalMemoryProperties() const { return static_cast<const ExternalMemoryProperties&>(this->externalMemoryProperties); }
};
inline void ImageFormatProperties2::attach(ExternalImageFormatProperties& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_1

#if VK_ANDROID_external_memory_android_hardware_buffer
struct AndroidHardwareBufferUsageANDROID : VkAndroidHardwareBufferUsageANDROID {
  AndroidHardwareBufferUsageANDROID() noexcept : VkAndroidHardwareBufferUsageANDROID{.sType = VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID} {}

  uint64_t getAndroidHardwareBufferUsage() const { return this->androidHardwareBufferUsage; }
};
inline void ImageFormatProperties2::attach(AndroidHardwareBufferUsageANDROID& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_ANDROID_external_memory_android_hardware_buffer

#if VK_EXT_filter_cubic
struct FilterCubicImageViewImageFormatPropertiesEXT : VkFilterCubicImageViewImageFormatPropertiesEXT {
  FilterCubicImageViewImageFormatPropertiesEXT() noexcept : VkFilterCubicImageViewImageFormatPropertiesEXT{.sType = VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT} {}

  // The combinations of format, image type (and image view type if provided) can be filtered with VK_FILTER_CUBIC_EXT
  Bool32 getFilterCubic() const { return this->filterCubic; }
  // The combination of format, image type (and image view type if provided) can be filtered with VK_FILTER_CUBIC_EXT and ReductionMode of Min or Max
  Bool32 getFilterCubicMinmax() const { return this->filterCubicMinmax; }
};
inline void ImageFormatProperties2::attach(FilterCubicImageViewImageFormatPropertiesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_filter_cubic

#if VK_KHR_get_physical_device_properties2
using ImageFormatProperties2KHR = ImageFormatProperties2;
#endif // VK_KHR_get_physical_device_properties2

#if VK_VERSION_1_1
struct PhysicalDeviceProperties2 : VkPhysicalDeviceProperties2 {
  PhysicalDeviceProperties2() noexcept : VkPhysicalDeviceProperties2{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2} {}

  const PhysicalDeviceProperties& getProperties() const { return static_cast<const PhysicalDeviceProperties&>(this->properties); }

#if VK_NV_device_generated_commands
  void attach(struct PhysicalDeviceDeviceGeneratedCommandsPropertiesNV&);
#endif // VK_NV_device_generated_commands
#if VK_NV_cluster_acceleration_structure
  void attach(struct PhysicalDeviceClusterAccelerationStructurePropertiesNV&);
#endif // VK_NV_cluster_acceleration_structure
#if VK_EXT_multi_draw
  void attach(struct PhysicalDeviceMultiDrawPropertiesEXT&);
#endif // VK_EXT_multi_draw
#if VK_VERSION_1_4
  void attach(struct PhysicalDevicePushDescriptorProperties&);
#endif // VK_VERSION_1_4
#if VK_VERSION_1_2
  void attach(struct PhysicalDeviceDriverProperties&);
#endif // VK_VERSION_1_2
  void attach(struct PhysicalDeviceIDProperties&);
  void attach(struct PhysicalDeviceMultiviewProperties&);
#if VK_EXT_discard_rectangles
  void attach(struct PhysicalDeviceDiscardRectanglePropertiesEXT&);
#endif // VK_EXT_discard_rectangles
#if VK_NVX_multiview_per_view_attributes
  void attach(struct PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX&);
#endif // VK_NVX_multiview_per_view_attributes
  void attach(struct PhysicalDeviceSubgroupProperties&);
  void attach(struct PhysicalDevicePointClippingProperties&);
  void attach(struct PhysicalDeviceProtectedMemoryProperties&);
#if VK_VERSION_1_2
  void attach(struct PhysicalDeviceSamplerFilterMinmaxProperties&);
#endif // VK_VERSION_1_2
#if VK_EXT_sample_locations
  void attach(struct PhysicalDeviceSampleLocationsPropertiesEXT&);
#endif // VK_EXT_sample_locations
#if VK_EXT_blend_operation_advanced
  void attach(struct PhysicalDeviceBlendOperationAdvancedPropertiesEXT&);
#endif // VK_EXT_blend_operation_advanced
#if VK_VERSION_1_3
  void attach(struct PhysicalDeviceInlineUniformBlockProperties&);
#endif // VK_VERSION_1_3
  void attach(struct PhysicalDeviceMaintenance3Properties&);
#if VK_VERSION_1_3
  void attach(struct PhysicalDeviceMaintenance4Properties&);
#endif // VK_VERSION_1_3
#if VK_VERSION_1_4
  void attach(struct PhysicalDeviceMaintenance5Properties&);
  void attach(struct PhysicalDeviceMaintenance6Properties&);
#endif // VK_VERSION_1_4
#if VK_KHR_maintenance7
  void attach(struct PhysicalDeviceMaintenance7PropertiesKHR&);
  void attach(struct PhysicalDeviceLayeredApiPropertiesListKHR&);
#endif // VK_KHR_maintenance7
#if VK_KHR_maintenance9
  void attach(struct PhysicalDeviceMaintenance9PropertiesKHR&);
#endif // VK_KHR_maintenance9
#if VK_VERSION_1_2
  void attach(struct PhysicalDeviceFloatControlsProperties&);
#endif // VK_VERSION_1_2
#if VK_EXT_external_memory_host
  void attach(struct PhysicalDeviceExternalMemoryHostPropertiesEXT&);
#endif // VK_EXT_external_memory_host
#if VK_EXT_conservative_rasterization
  void attach(struct PhysicalDeviceConservativeRasterizationPropertiesEXT&);
#endif // VK_EXT_conservative_rasterization
#if VK_AMD_shader_core_properties
  void attach(struct PhysicalDeviceShaderCorePropertiesAMD&);
#endif // VK_AMD_shader_core_properties
#if VK_AMD_shader_core_properties2
  void attach(struct PhysicalDeviceShaderCoreProperties2AMD&);
#endif // VK_AMD_shader_core_properties2
#if VK_VERSION_1_2
  void attach(struct PhysicalDeviceDescriptorIndexingProperties&);
  void attach(struct PhysicalDeviceTimelineSemaphoreProperties&);
#endif // VK_VERSION_1_2
#if VK_EXT_vertex_attribute_divisor
  void attach(struct PhysicalDeviceVertexAttributeDivisorPropertiesEXT&);
#endif // VK_EXT_vertex_attribute_divisor
#if VK_VERSION_1_4
  void attach(struct PhysicalDeviceVertexAttributeDivisorProperties&);
#endif // VK_VERSION_1_4
#if VK_EXT_pci_bus_info
  void attach(struct PhysicalDevicePCIBusInfoPropertiesEXT&);
#endif // VK_EXT_pci_bus_info
#if VK_VERSION_1_2
  void attach(struct PhysicalDeviceDepthStencilResolveProperties&);
#endif // VK_VERSION_1_2
#if VK_EXT_transform_feedback
  void attach(struct PhysicalDeviceTransformFeedbackPropertiesEXT&);
#endif // VK_EXT_transform_feedback
#if VK_KHR_compute_shader_derivatives
  void attach(struct PhysicalDeviceComputeShaderDerivativesPropertiesKHR&);
#endif // VK_KHR_compute_shader_derivatives
#if VK_NV_copy_memory_indirect
  void attach(struct PhysicalDeviceCopyMemoryIndirectPropertiesNV&);
#endif // VK_NV_copy_memory_indirect
#if VK_NV_memory_decompression
  void attach(struct PhysicalDeviceMemoryDecompressionPropertiesNV&);
#endif // VK_NV_memory_decompression
#if VK_NV_shading_rate_image
  void attach(struct PhysicalDeviceShadingRateImagePropertiesNV&);
#endif // VK_NV_shading_rate_image
#if VK_NV_mesh_shader
  void attach(struct PhysicalDeviceMeshShaderPropertiesNV&);
#endif // VK_NV_mesh_shader
#if VK_EXT_mesh_shader
  void attach(struct PhysicalDeviceMeshShaderPropertiesEXT&);
#endif // VK_EXT_mesh_shader
#if VK_KHR_acceleration_structure
  void attach(struct PhysicalDeviceAccelerationStructurePropertiesKHR&);
#endif // VK_KHR_acceleration_structure
#if VK_KHR_ray_tracing_pipeline
  void attach(struct PhysicalDeviceRayTracingPipelinePropertiesKHR&);
#endif // VK_KHR_ray_tracing_pipeline
#if VK_EXT_fragment_density_map
  void attach(struct PhysicalDeviceFragmentDensityMapPropertiesEXT&);
#endif // VK_EXT_fragment_density_map
#if VK_EXT_fragment_density_map2
  void attach(struct PhysicalDeviceFragmentDensityMap2PropertiesEXT&);
#endif // VK_EXT_fragment_density_map2
#if VK_EXT_fragment_density_map_offset
  void attach(struct PhysicalDeviceFragmentDensityMapOffsetPropertiesEXT&);
#endif // VK_EXT_fragment_density_map_offset
#if VK_NV_cooperative_matrix
  void attach(struct PhysicalDeviceCooperativeMatrixPropertiesNV&);
#endif // VK_NV_cooperative_matrix
#if VK_KHR_performance_query
  void attach(struct PhysicalDevicePerformanceQueryPropertiesKHR&);
#endif // VK_KHR_performance_query
#if VK_NV_shader_sm_builtins
  void attach(struct PhysicalDeviceShaderSMBuiltinsPropertiesNV&);
#endif // VK_NV_shader_sm_builtins
#if VK_VERSION_1_3
  void attach(struct PhysicalDeviceTexelBufferAlignmentProperties&);
  void attach(struct PhysicalDeviceSubgroupSizeControlProperties&);
#endif // VK_VERSION_1_3
#if VK_HUAWEI_subpass_shading
  void attach(struct PhysicalDeviceSubpassShadingPropertiesHUAWEI&);
#endif // VK_HUAWEI_subpass_shading
#if VK_HUAWEI_cluster_culling_shader
  void attach(struct PhysicalDeviceClusterCullingShaderPropertiesHUAWEI&);
#endif // VK_HUAWEI_cluster_culling_shader
#if VK_VERSION_1_4
  void attach(struct PhysicalDeviceLineRasterizationProperties&);
#endif // VK_VERSION_1_4
#if VK_VERSION_1_2
  void attach(struct PhysicalDeviceVulkan11Properties&);
  void attach(struct PhysicalDeviceVulkan12Properties&);
#endif // VK_VERSION_1_2
#if VK_VERSION_1_3
  void attach(struct PhysicalDeviceVulkan13Properties&);
#endif // VK_VERSION_1_3
#if VK_VERSION_1_4
  void attach(struct PhysicalDeviceVulkan14Properties&);
#endif // VK_VERSION_1_4
#if VK_EXT_custom_border_color
  void attach(struct PhysicalDeviceCustomBorderColorPropertiesEXT&);
#endif // VK_EXT_custom_border_color
#if VK_EXT_extended_dynamic_state3
  void attach(struct PhysicalDeviceExtendedDynamicState3PropertiesEXT&);
#endif // VK_EXT_extended_dynamic_state3
#if VK_NV_partitioned_acceleration_structure
  void attach(struct PhysicalDevicePartitionedAccelerationStructurePropertiesNV&);
#endif // VK_NV_partitioned_acceleration_structure
#if VK_KHR_robustness2
  void attach(struct PhysicalDeviceRobustness2PropertiesKHR&);
#endif // VK_KHR_robustness2
#if VK_KHR_fragment_shading_rate
  void attach(struct PhysicalDeviceFragmentShadingRatePropertiesKHR&);
#endif // VK_KHR_fragment_shading_rate
#if VK_NV_fragment_shading_rate_enums
  void attach(struct PhysicalDeviceFragmentShadingRateEnumsPropertiesNV&);
#endif // VK_NV_fragment_shading_rate_enums
#if VK_EXT_legacy_vertex_attributes
  void attach(struct PhysicalDeviceLegacyVertexAttributesPropertiesEXT&);
#endif // VK_EXT_legacy_vertex_attributes
#if VK_EXT_device_generated_commands
  void attach(struct PhysicalDeviceDeviceGeneratedCommandsPropertiesEXT&);
#endif // VK_EXT_device_generated_commands
#if VK_VERSION_1_4
  void attach(struct PhysicalDeviceHostImageCopyProperties&);
#endif // VK_VERSION_1_4
#if VK_EXT_provoking_vertex
  void attach(struct PhysicalDeviceProvokingVertexPropertiesEXT&);
#endif // VK_EXT_provoking_vertex
#if VK_EXT_descriptor_buffer
  void attach(struct PhysicalDeviceDescriptorBufferPropertiesEXT&);
  void attach(struct PhysicalDeviceDescriptorBufferDensityMapPropertiesEXT&);
#endif // VK_EXT_descriptor_buffer
#if VK_VERSION_1_3
  void attach(struct PhysicalDeviceShaderIntegerDotProductProperties&);
#endif // VK_VERSION_1_3
#if VK_EXT_physical_device_drm
  void attach(struct PhysicalDeviceDrmPropertiesEXT&);
#endif // VK_EXT_physical_device_drm
#if VK_KHR_fragment_shader_barycentric
  void attach(struct PhysicalDeviceFragmentShaderBarycentricPropertiesKHR&);
#endif // VK_KHR_fragment_shader_barycentric
#if VK_KHR_pipeline_binary
  void attach(struct PhysicalDevicePipelineBinaryPropertiesKHR&);
#endif // VK_KHR_pipeline_binary
#if VK_EXT_graphics_pipeline_library
  void attach(struct PhysicalDeviceGraphicsPipelineLibraryPropertiesEXT&);
#endif // VK_EXT_graphics_pipeline_library
#if VK_EXT_nested_command_buffer
  void attach(struct PhysicalDeviceNestedCommandBufferPropertiesEXT&);
#endif // VK_EXT_nested_command_buffer
#if VK_EXT_shader_module_identifier
  void attach(struct PhysicalDeviceShaderModuleIdentifierPropertiesEXT&);
#endif // VK_EXT_shader_module_identifier
#if VK_EXT_opacity_micromap
  void attach(struct PhysicalDeviceOpacityMicromapPropertiesEXT&);
#endif // VK_EXT_opacity_micromap
#if VK_VERSION_1_4
  void attach(struct PhysicalDevicePipelineRobustnessProperties&);
#endif // VK_VERSION_1_4
#if VK_QCOM_image_processing
  void attach(struct PhysicalDeviceImageProcessingPropertiesQCOM&);
#endif // VK_QCOM_image_processing
#if VK_NV_optical_flow
  void attach(struct PhysicalDeviceOpticalFlowPropertiesNV&);
#endif // VK_NV_optical_flow
#if VK_ARM_shader_core_builtins
  void attach(struct PhysicalDeviceShaderCoreBuiltinsPropertiesARM&);
#endif // VK_ARM_shader_core_builtins
#if VK_NV_ray_tracing_invocation_reorder
  void attach(struct PhysicalDeviceRayTracingInvocationReorderPropertiesNV&);
#endif // VK_NV_ray_tracing_invocation_reorder
#if VK_NV_extended_sparse_address_space
  void attach(struct PhysicalDeviceExtendedSparseAddressSpacePropertiesNV&);
#endif // VK_NV_extended_sparse_address_space
#if VK_ARM_shader_core_properties
  void attach(struct PhysicalDeviceShaderCorePropertiesARM&);
#endif // VK_ARM_shader_core_properties
#if VK_EXT_shader_object
  void attach(struct PhysicalDeviceShaderObjectPropertiesEXT&);
#endif // VK_EXT_shader_object
#if VK_EXT_shader_tile_image
  void attach(struct PhysicalDeviceShaderTileImagePropertiesEXT&);
#endif // VK_EXT_shader_tile_image
#if VK_KHR_cooperative_matrix
  void attach(struct PhysicalDeviceCooperativeMatrixPropertiesKHR&);
#endif // VK_KHR_cooperative_matrix
#if VK_QCOM_tile_memory_heap
  void attach(struct PhysicalDeviceTileMemoryHeapPropertiesQCOM&);
#endif // VK_QCOM_tile_memory_heap
#if VK_QCOM_image_processing2
  void attach(struct PhysicalDeviceImageProcessing2PropertiesQCOM&);
#endif // VK_QCOM_image_processing2
#if VK_MSFT_layered_driver
  void attach(struct PhysicalDeviceLayeredDriverPropertiesMSFT&);
#endif // VK_MSFT_layered_driver
#if VK_ANDROID_external_format_resolve
  void attach(struct PhysicalDeviceExternalFormatResolvePropertiesANDROID&);
#endif // VK_ANDROID_external_format_resolve
#if VK_ARM_scheduling_controls
  void attach(struct PhysicalDeviceSchedulingControlsPropertiesARM&);
#endif // VK_ARM_scheduling_controls
#if VK_ARM_render_pass_striped
  void attach(struct PhysicalDeviceRenderPassStripedPropertiesARM&);
#endif // VK_ARM_render_pass_striped
#if VK_EXT_map_memory_placed
  void attach(struct PhysicalDeviceMapMemoryPlacedPropertiesEXT&);
#endif // VK_EXT_map_memory_placed
#if VK_MESA_image_alignment_control
  void attach(struct PhysicalDeviceImageAlignmentControlPropertiesMESA&);
#endif // VK_MESA_image_alignment_control
#if VK_NV_cooperative_matrix2
  void attach(struct PhysicalDeviceCooperativeMatrix2PropertiesNV&);
#endif // VK_NV_cooperative_matrix2
#if VK_NV_cooperative_vector
  void attach(struct PhysicalDeviceCooperativeVectorPropertiesNV&);
#endif // VK_NV_cooperative_vector
#if VK_QCOM_tile_shading
  void attach(struct PhysicalDeviceTileShadingPropertiesQCOM&);
#endif // VK_QCOM_tile_shading
#if VK_VALVE_fragment_density_map_layered
  void attach(struct PhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE&);
#endif // VK_VALVE_fragment_density_map_layered
#if VK_NV_external_compute_queue
  void attach(struct PhysicalDeviceExternalComputeQueuePropertiesNV&);
#endif // VK_NV_external_compute_queue
#if VK_ARM_tensors
  void attach(struct PhysicalDeviceTensorPropertiesARM&);
  void attach(struct PhysicalDeviceDescriptorBufferTensorPropertiesARM&);
#endif // VK_ARM_tensors
};
#endif // VK_VERSION_1_1

#if VK_KHR_separate_depth_stencil_layouts
using AttachmentDescriptionStencilLayoutKHR = AttachmentDescriptionStencilLayout;
#endif // VK_KHR_separate_depth_stencil_layouts
#if VK_EXT_inline_uniform_block
using DescriptorPoolInlineUniformBlockCreateInfoEXT = DescriptorPoolInlineUniformBlockCreateInfo;
#endif // VK_EXT_inline_uniform_block

#if VK_VERSION_1_3
struct DependencyInfo : VkDependencyInfo {
  DependencyInfo() noexcept : VkDependencyInfo{.sType = VK_STRUCTURE_TYPE_DEPENDENCY_INFO} {}

  void setDependencyFlags(DependencyFlags value) { this->dependencyFlags = std::bit_cast<VkDependencyFlags>(value); }
  DependencyFlags getDependencyFlags() const { return std::bit_cast<DependencyFlags>(this->dependencyFlags); }
  void setMemoryBarrierCount(uint32_t value) { this->memoryBarrierCount = value; }
  uint32_t getMemoryBarrierCount() const { return this->memoryBarrierCount; }
  void setMemoryBarriers(const MemoryBarrier2* value) { this->pMemoryBarriers = std::bit_cast<const VkMemoryBarrier2*>(value); }
  const MemoryBarrier2* getMemoryBarriers() const { return std::bit_cast<const MemoryBarrier2*>(this->pMemoryBarriers); }
  void setBufferMemoryBarrierCount(uint32_t value) { this->bufferMemoryBarrierCount = value; }
  uint32_t getBufferMemoryBarrierCount() const { return this->bufferMemoryBarrierCount; }
  void setBufferMemoryBarriers(const BufferMemoryBarrier2* value) { this->pBufferMemoryBarriers = std::bit_cast<const VkBufferMemoryBarrier2*>(value); }
  const BufferMemoryBarrier2* getBufferMemoryBarriers() const { return std::bit_cast<const BufferMemoryBarrier2*>(this->pBufferMemoryBarriers); }
  void setImageMemoryBarrierCount(uint32_t value) { this->imageMemoryBarrierCount = value; }
  uint32_t getImageMemoryBarrierCount() const { return this->imageMemoryBarrierCount; }
  void setImageMemoryBarriers(const ImageMemoryBarrier2* value) { this->pImageMemoryBarriers = std::bit_cast<const VkImageMemoryBarrier2*>(value); }
  const ImageMemoryBarrier2* getImageMemoryBarriers() const { return std::bit_cast<const ImageMemoryBarrier2*>(this->pImageMemoryBarriers); }

#if VK_ARM_tensors
  void attach(struct TensorMemoryBarrierARM&);
  void attach(struct TensorDependencyInfoARM&);
#endif // VK_ARM_tensors
};
#endif // VK_VERSION_1_3

#if VK_KHR_synchronization2
using MemoryBarrier2KHR = MemoryBarrier2;
#endif // VK_KHR_synchronization2

#if VK_KHR_surface_maintenance1
struct SurfacePresentScalingCapabilitiesKHR : VkSurfacePresentScalingCapabilitiesKHR {
  SurfacePresentScalingCapabilitiesKHR() noexcept : VkSurfacePresentScalingCapabilitiesKHR{.sType = VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_KHR} {}

  void setSupportedPresentScaling(PresentScalingFlagsKHR value) { this->supportedPresentScaling = std::bit_cast<VkPresentScalingFlagsKHR>(value); }
  PresentScalingFlagsKHR getSupportedPresentScaling() const { return std::bit_cast<PresentScalingFlagsKHR>(this->supportedPresentScaling); }
  void setSupportedPresentGravityX(PresentGravityFlagsKHR value) { this->supportedPresentGravityX = std::bit_cast<VkPresentGravityFlagsKHR>(value); }
  PresentGravityFlagsKHR getSupportedPresentGravityX() const { return std::bit_cast<PresentGravityFlagsKHR>(this->supportedPresentGravityX); }
  void setSupportedPresentGravityY(PresentGravityFlagsKHR value) { this->supportedPresentGravityY = std::bit_cast<VkPresentGravityFlagsKHR>(value); }
  PresentGravityFlagsKHR getSupportedPresentGravityY() const { return std::bit_cast<PresentGravityFlagsKHR>(this->supportedPresentGravityY); }
  // Supported minimum image width and height for the surface when scaling is used
  void setMinScaledImageExtent(const Extent2D& value) { this->minScaledImageExtent = value; }
  const Extent2D& getMinScaledImageExtent() const { return static_cast<const Extent2D&>(this->minScaledImageExtent); }
  // Supported maximum image width and height for the surface when scaling is used
  void setMaxScaledImageExtent(const Extent2D& value) { this->maxScaledImageExtent = value; }
  const Extent2D& getMaxScaledImageExtent() const { return static_cast<const Extent2D&>(this->maxScaledImageExtent); }
};
inline void SurfaceCapabilities2KHR::attach(SurfacePresentScalingCapabilitiesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }

struct SurfacePresentModeCompatibilityKHR : VkSurfacePresentModeCompatibilityKHR {
  SurfacePresentModeCompatibilityKHR() noexcept : VkSurfacePresentModeCompatibilityKHR{.sType = VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_KHR} {}

  void setPresentModeCount(uint32_t value) { this->presentModeCount = value; }
  uint32_t getPresentModeCount() const { return this->presentModeCount; }
  // Output list of present modes compatible with the one specified in VkSurfacePresentModeKHR
  void setPresentModes(PresentModeKHR* value) { this->pPresentModes = std::bit_cast<VkPresentModeKHR*>(value); }
  PresentModeKHR* getPresentModes() const { return std::bit_cast<PresentModeKHR*>(this->pPresentModes); }
};
inline void SurfaceCapabilities2KHR::attach(SurfacePresentModeCompatibilityKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_surface_maintenance1

#if VK_EXT_full_screen_exclusive
struct SurfaceCapabilitiesFullScreenExclusiveEXT : VkSurfaceCapabilitiesFullScreenExclusiveEXT {
  SurfaceCapabilitiesFullScreenExclusiveEXT() noexcept : VkSurfaceCapabilitiesFullScreenExclusiveEXT{.sType = VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT} {}

  Bool32 getFullScreenExclusiveSupported() const { return this->fullScreenExclusiveSupported; }
};
inline void SurfaceCapabilities2KHR::attach(SurfaceCapabilitiesFullScreenExclusiveEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_full_screen_exclusive

#if VK_NV_low_latency2
struct LatencySurfaceCapabilitiesNV : VkLatencySurfaceCapabilitiesNV {
  LatencySurfaceCapabilitiesNV() noexcept : VkLatencySurfaceCapabilitiesNV{.sType = VK_STRUCTURE_TYPE_LATENCY_SURFACE_CAPABILITIES_NV} {}

  void setPresentModeCount(uint32_t value) { this->presentModeCount = value; }
  uint32_t getPresentModeCount() const { return this->presentModeCount; }
  void setPresentModes(PresentModeKHR* value) { this->pPresentModes = std::bit_cast<VkPresentModeKHR*>(value); }
  PresentModeKHR* getPresentModes() const { return std::bit_cast<PresentModeKHR*>(this->pPresentModes); }
};
inline void SurfaceCapabilities2KHR::attach(LatencySurfaceCapabilitiesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_low_latency2

#if VK_KHR_surface_protected_capabilities
struct SurfaceProtectedCapabilitiesKHR : VkSurfaceProtectedCapabilitiesKHR {
  SurfaceProtectedCapabilitiesKHR() noexcept : VkSurfaceProtectedCapabilitiesKHR{.sType = VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR} {}

  // Represents if surface can be protected
  Bool32 getSupportsProtected() const { return this->supportsProtected; }
};
inline void SurfaceCapabilities2KHR::attach(SurfaceProtectedCapabilitiesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_surface_protected_capabilities

#if VK_AMD_display_native_hdr
struct DisplayNativeHdrSurfaceCapabilitiesAMD : VkDisplayNativeHdrSurfaceCapabilitiesAMD {
  DisplayNativeHdrSurfaceCapabilitiesAMD() noexcept : VkDisplayNativeHdrSurfaceCapabilitiesAMD{.sType = VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD} {}

  Bool32 getLocalDimmingSupport() const { return this->localDimmingSupport; }
};
inline void SurfaceCapabilities2KHR::attach(DisplayNativeHdrSurfaceCapabilitiesAMD& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_AMD_display_native_hdr

#if VK_NV_present_barrier
struct SurfaceCapabilitiesPresentBarrierNV : VkSurfaceCapabilitiesPresentBarrierNV {
  SurfaceCapabilitiesPresentBarrierNV() noexcept : VkSurfaceCapabilitiesPresentBarrierNV{.sType = VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV} {}

  Bool32 getPresentBarrierSupported() const { return this->presentBarrierSupported; }
};
inline void SurfaceCapabilities2KHR::attach(SurfaceCapabilitiesPresentBarrierNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_present_barrier

#if VK_KHR_shared_presentable_image
struct SharedPresentSurfaceCapabilitiesKHR : VkSharedPresentSurfaceCapabilitiesKHR {
  SharedPresentSurfaceCapabilitiesKHR() noexcept : VkSharedPresentSurfaceCapabilitiesKHR{.sType = VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR} {}

  // Supported image usage flags if swapchain created using a shared present mode
  ImageUsageFlags getSharedPresentSupportedUsageFlags() const { return std::bit_cast<ImageUsageFlags>(this->sharedPresentSupportedUsageFlags); }
};
#if VK_KHR_get_surface_capabilities2
inline void SurfaceCapabilities2KHR::attach(SharedPresentSurfaceCapabilitiesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_get_surface_capabilities2
#endif // VK_KHR_shared_presentable_image

#if VK_KHR_present_id2
struct SurfaceCapabilitiesPresentId2KHR : VkSurfaceCapabilitiesPresentId2KHR {
  SurfaceCapabilitiesPresentId2KHR() noexcept : VkSurfaceCapabilitiesPresentId2KHR{.sType = VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_ID_2_KHR} {}

  void setPresentId2Supported(Bool32 value) { this->presentId2Supported = value; }
  Bool32 getPresentId2Supported() const { return this->presentId2Supported; }
};
inline void SurfaceCapabilities2KHR::attach(SurfaceCapabilitiesPresentId2KHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_present_id2

#if VK_KHR_present_wait2
struct SurfaceCapabilitiesPresentWait2KHR : VkSurfaceCapabilitiesPresentWait2KHR {
  SurfaceCapabilitiesPresentWait2KHR() noexcept : VkSurfaceCapabilitiesPresentWait2KHR{.sType = VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_WAIT_2_KHR} {}

  void setPresentWait2Supported(Bool32 value) { this->presentWait2Supported = value; }
  Bool32 getPresentWait2Supported() const { return this->presentWait2Supported; }
};
inline void SurfaceCapabilities2KHR::attach(SurfaceCapabilitiesPresentWait2KHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_present_wait2

#if VK_KHR_external_memory_capabilities
using ExternalBufferPropertiesKHR = ExternalBufferProperties;
#endif // VK_KHR_external_memory_capabilities
#if VK_EXT_swapchain_maintenance1
using SwapchainPresentModesCreateInfoEXT = SwapchainPresentModesCreateInfoKHR;
using SwapchainPresentScalingCreateInfoEXT = SwapchainPresentScalingCreateInfoKHR;
#endif // VK_EXT_swapchain_maintenance1
#if VK_KHR_image_format_list
using ImageFormatListCreateInfoKHR = ImageFormatListCreateInfo;
#endif // VK_KHR_image_format_list

#if VK_VERSION_1_1
struct RenderPassInputAttachmentAspectCreateInfo : VkRenderPassInputAttachmentAspectCreateInfo {
  RenderPassInputAttachmentAspectCreateInfo() noexcept : VkRenderPassInputAttachmentAspectCreateInfo{.sType = VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO} {}

  void setAspectReferenceCount(uint32_t value) { this->aspectReferenceCount = value; }
  uint32_t getAspectReferenceCount() const { return this->aspectReferenceCount; }
  void setAspectReferences(const InputAttachmentAspectReference* value) { this->pAspectReferences = std::bit_cast<const VkInputAttachmentAspectReference*>(value); }
  const InputAttachmentAspectReference* getAspectReferences() const { return std::bit_cast<const InputAttachmentAspectReference*>(this->pAspectReferences); }
};
inline void RenderPassCreateInfo::attach(RenderPassInputAttachmentAspectCreateInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }

struct RenderPassMultiviewCreateInfo : VkRenderPassMultiviewCreateInfo {
  RenderPassMultiviewCreateInfo() noexcept : VkRenderPassMultiviewCreateInfo{.sType = VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO} {}

  void setSubpassCount(uint32_t value) { this->subpassCount = value; }
  uint32_t getSubpassCount() const { return this->subpassCount; }
  void setViewMasks(const uint32_t* value) { this->pViewMasks = value; }
  const uint32_t* getViewMasks() const { return this->pViewMasks; }
  void setDependencyCount(uint32_t value) { this->dependencyCount = value; }
  uint32_t getDependencyCount() const { return this->dependencyCount; }
  void setViewOffsets(const int32_t* value) { this->pViewOffsets = value; }
  const int32_t* getViewOffsets() const { return this->pViewOffsets; }
  void setCorrelationMaskCount(uint32_t value) { this->correlationMaskCount = value; }
  uint32_t getCorrelationMaskCount() const { return this->correlationMaskCount; }
  void setCorrelationMasks(const uint32_t* value) { this->pCorrelationMasks = value; }
  const uint32_t* getCorrelationMasks() const { return this->pCorrelationMasks; }
};
inline void RenderPassCreateInfo::attach(RenderPassMultiviewCreateInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_1

#if VK_KHR_imageless_framebuffer
using FramebufferAttachmentsCreateInfoKHR = FramebufferAttachmentsCreateInfo;
#endif // VK_KHR_imageless_framebuffer
#if VK_INTEL_performance_query
using QueryPoolCreateInfoINTEL = QueryPoolPerformanceQueryCreateInfoINTEL;
#endif // VK_INTEL_performance_query

#if VK_KHR_video_encode_queue
struct VideoEncodeUsageInfoKHR : VkVideoEncodeUsageInfoKHR {
  VideoEncodeUsageInfoKHR() noexcept : VkVideoEncodeUsageInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR} {}

  void setVideoUsageHints(VideoEncodeUsageFlagsKHR value) { this->videoUsageHints = std::bit_cast<VkVideoEncodeUsageFlagsKHR>(value); }
  VideoEncodeUsageFlagsKHR getVideoUsageHints() const { return std::bit_cast<VideoEncodeUsageFlagsKHR>(this->videoUsageHints); }
  void setVideoContentHints(VideoEncodeContentFlagsKHR value) { this->videoContentHints = std::bit_cast<VkVideoEncodeContentFlagsKHR>(value); }
  VideoEncodeContentFlagsKHR getVideoContentHints() const { return std::bit_cast<VideoEncodeContentFlagsKHR>(this->videoContentHints); }
  void setTuningMode(VideoEncodeTuningModeKHR value) { this->tuningMode = std::bit_cast<VkVideoEncodeTuningModeKHR>(value); }
  VideoEncodeTuningModeKHR getTuningMode() const { return std::bit_cast<VideoEncodeTuningModeKHR>(this->tuningMode); }
};
inline void VideoProfileInfoKHR::attach(VideoEncodeUsageInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void QueryPoolCreateInfo::attach(VideoEncodeUsageInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_encode_queue

#if VK_KHR_video_encode_h264
struct VideoEncodeH264ProfileInfoKHR : VkVideoEncodeH264ProfileInfoKHR {
  VideoEncodeH264ProfileInfoKHR() noexcept : VkVideoEncodeH264ProfileInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_KHR} {}

  void setStdProfileIdc(StdVideoH264ProfileIdc value) { this->stdProfileIdc = value; }
  StdVideoH264ProfileIdc getStdProfileIdc() const { return this->stdProfileIdc; }
};
inline void VideoProfileInfoKHR::attach(VideoEncodeH264ProfileInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void QueryPoolCreateInfo::attach(VideoEncodeH264ProfileInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_encode_h264

#if VK_KHR_video_encode_queue
struct PhysicalDeviceVideoEncodeQualityLevelInfoKHR : VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR {
  PhysicalDeviceVideoEncodeQualityLevelInfoKHR() noexcept : VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR} {}

  void setVideoProfile(const VideoProfileInfoKHR* value) { this->pVideoProfile = std::bit_cast<const VkVideoProfileInfoKHR*>(value); }
  const VideoProfileInfoKHR* getVideoProfile() const { return std::bit_cast<const VideoProfileInfoKHR*>(this->pVideoProfile); }
  void setQualityLevel(uint32_t value) { this->qualityLevel = value; }
  uint32_t getQualityLevel() const { return this->qualityLevel; }
};
#endif // VK_KHR_video_encode_queue

#if VK_KHR_video_encode_h265
struct VideoEncodeH265ProfileInfoKHR : VkVideoEncodeH265ProfileInfoKHR {
  VideoEncodeH265ProfileInfoKHR() noexcept : VkVideoEncodeH265ProfileInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_INFO_KHR} {}

  void setStdProfileIdc(StdVideoH265ProfileIdc value) { this->stdProfileIdc = value; }
  StdVideoH265ProfileIdc getStdProfileIdc() const { return this->stdProfileIdc; }
};
inline void VideoProfileInfoKHR::attach(VideoEncodeH265ProfileInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void QueryPoolCreateInfo::attach(VideoEncodeH265ProfileInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_encode_h265

#if VK_KHR_video_decode_queue
struct VideoDecodeUsageInfoKHR : VkVideoDecodeUsageInfoKHR {
  VideoDecodeUsageInfoKHR() noexcept : VkVideoDecodeUsageInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR} {}

  void setVideoUsageHints(VideoDecodeUsageFlagsKHR value) { this->videoUsageHints = std::bit_cast<VkVideoDecodeUsageFlagsKHR>(value); }
  VideoDecodeUsageFlagsKHR getVideoUsageHints() const { return std::bit_cast<VideoDecodeUsageFlagsKHR>(this->videoUsageHints); }
};
inline void VideoProfileInfoKHR::attach(VideoDecodeUsageInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void QueryPoolCreateInfo::attach(VideoDecodeUsageInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_decode_queue

#if VK_KHR_video_decode_h265
struct VideoDecodeH265ProfileInfoKHR : VkVideoDecodeH265ProfileInfoKHR {
  VideoDecodeH265ProfileInfoKHR() noexcept : VkVideoDecodeH265ProfileInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_KHR} {}

  void setStdProfileIdc(StdVideoH265ProfileIdc value) { this->stdProfileIdc = value; }
  StdVideoH265ProfileIdc getStdProfileIdc() const { return this->stdProfileIdc; }
};
inline void VideoProfileInfoKHR::attach(VideoDecodeH265ProfileInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void QueryPoolCreateInfo::attach(VideoDecodeH265ProfileInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_decode_h265

#if VK_KHR_video_decode_av1
struct VideoDecodeAV1ProfileInfoKHR : VkVideoDecodeAV1ProfileInfoKHR {
  VideoDecodeAV1ProfileInfoKHR() noexcept : VkVideoDecodeAV1ProfileInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PROFILE_INFO_KHR} {}

  void setStdProfile(StdVideoAV1Profile value) { this->stdProfile = value; }
  StdVideoAV1Profile getStdProfile() const { return this->stdProfile; }

  void setFilmGrainSupport(Bool32 value) { this->filmGrainSupport = value; }
  Bool32 getFilmGrainSupport() const { return this->filmGrainSupport; }
};
inline void VideoProfileInfoKHR::attach(VideoDecodeAV1ProfileInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void QueryPoolCreateInfo::attach(VideoDecodeAV1ProfileInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_decode_av1

#if VK_KHR_video_decode_h264
struct VideoDecodeH264ProfileInfoKHR : VkVideoDecodeH264ProfileInfoKHR {
  VideoDecodeH264ProfileInfoKHR() noexcept : VkVideoDecodeH264ProfileInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR} {}

  void setStdProfileIdc(StdVideoH264ProfileIdc value) { this->stdProfileIdc = value; }
  StdVideoH264ProfileIdc getStdProfileIdc() const { return this->stdProfileIdc; }

  void setPictureLayout(VideoDecodeH264PictureLayoutFlagBitsKHR value) { this->pictureLayout = std::bit_cast<VkVideoDecodeH264PictureLayoutFlagBitsKHR>(value); }
  VideoDecodeH264PictureLayoutFlagBitsKHR getPictureLayout() const { return std::bit_cast<VideoDecodeH264PictureLayoutFlagBitsKHR>(this->pictureLayout); }
};
inline void VideoProfileInfoKHR::attach(VideoDecodeH264ProfileInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void QueryPoolCreateInfo::attach(VideoDecodeH264ProfileInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_decode_h264

#if VK_KHR_video_decode_vp9
struct VideoDecodeVP9ProfileInfoKHR : VkVideoDecodeVP9ProfileInfoKHR {
  VideoDecodeVP9ProfileInfoKHR() noexcept : VkVideoDecodeVP9ProfileInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_PROFILE_INFO_KHR} {}

  void setStdProfile(StdVideoVP9Profile value) { this->stdProfile = value; }
  StdVideoVP9Profile getStdProfile() const { return this->stdProfile; }
};
inline void VideoProfileInfoKHR::attach(VideoDecodeVP9ProfileInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void QueryPoolCreateInfo::attach(VideoDecodeVP9ProfileInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_decode_vp9

#if VK_KHR_video_encode_av1
struct VideoEncodeAV1ProfileInfoKHR : VkVideoEncodeAV1ProfileInfoKHR {
  VideoEncodeAV1ProfileInfoKHR() noexcept : VkVideoEncodeAV1ProfileInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PROFILE_INFO_KHR} {}

  void setStdProfile(StdVideoAV1Profile value) { this->stdProfile = value; }
  StdVideoAV1Profile getStdProfile() const { return this->stdProfile; }
};
inline void VideoProfileInfoKHR::attach(VideoEncodeAV1ProfileInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void QueryPoolCreateInfo::attach(VideoEncodeAV1ProfileInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_encode_av1

#if VK_KHR_video_queue
struct VideoSessionCreateInfoKHR : VkVideoSessionCreateInfoKHR {
  VideoSessionCreateInfoKHR() noexcept : VkVideoSessionCreateInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR} {}

  void setQueueFamilyIndex(uint32_t value) { this->queueFamilyIndex = value; }
  uint32_t getQueueFamilyIndex() const { return this->queueFamilyIndex; }
  void setVideoProfile(const VideoProfileInfoKHR* value) { this->pVideoProfile = std::bit_cast<const VkVideoProfileInfoKHR*>(value); }
  const VideoProfileInfoKHR* getVideoProfile() const { return std::bit_cast<const VideoProfileInfoKHR*>(this->pVideoProfile); }
  void setPictureFormat(Format value) { this->pictureFormat = std::bit_cast<VkFormat>(value); }
  Format getPictureFormat() const { return std::bit_cast<Format>(this->pictureFormat); }
  void setMaxCodedExtent(const Extent2D& value) { this->maxCodedExtent = value; }
  const Extent2D& getMaxCodedExtent() const { return static_cast<const Extent2D&>(this->maxCodedExtent); }
  void setReferencePictureFormat(Format value) { this->referencePictureFormat = std::bit_cast<VkFormat>(value); }
  Format getReferencePictureFormat() const { return std::bit_cast<Format>(this->referencePictureFormat); }
  void setMaxDpbSlots(uint32_t value) { this->maxDpbSlots = value; }
  uint32_t getMaxDpbSlots() const { return this->maxDpbSlots; }
  void setMaxActiveReferencePictures(uint32_t value) { this->maxActiveReferencePictures = value; }
  uint32_t getMaxActiveReferencePictures() const { return this->maxActiveReferencePictures; }
  void setStdHeaderVersion(const ExtensionProperties* value) { this->pStdHeaderVersion = std::bit_cast<const VkExtensionProperties*>(value); }
  const ExtensionProperties* getStdHeaderVersion() const { return std::bit_cast<const ExtensionProperties*>(this->pStdHeaderVersion); }

  void setFlags(VideoSessionCreateFlagsKHR value) { this->flags = std::bit_cast<VkVideoSessionCreateFlagsKHR>(value); }
  VideoSessionCreateFlagsKHR getFlags() const { return std::bit_cast<VideoSessionCreateFlagsKHR>(this->flags); }

#if VK_KHR_video_encode_h264
  void attach(struct VideoEncodeH264SessionCreateInfoKHR&);
#endif // VK_KHR_video_encode_h264
#if VK_KHR_video_encode_h265
  void attach(struct VideoEncodeH265SessionCreateInfoKHR&);
#endif // VK_KHR_video_encode_h265
#if VK_KHR_video_encode_av1
  void attach(struct VideoEncodeAV1SessionCreateInfoKHR&);
#endif // VK_KHR_video_encode_av1
#if VK_KHR_video_encode_intra_refresh
  void attach(struct VideoEncodeSessionIntraRefreshCreateInfoKHR&);
#endif // VK_KHR_video_encode_intra_refresh
};

struct VideoProfileListInfoKHR : VkVideoProfileListInfoKHR {
  VideoProfileListInfoKHR() noexcept : VkVideoProfileListInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR} {}

  void setProfileCount(uint32_t value) { this->profileCount = value; }
  uint32_t getProfileCount() const { return this->profileCount; }
  void setProfiles(const VideoProfileInfoKHR* value) { this->pProfiles = std::bit_cast<const VkVideoProfileInfoKHR*>(value); }
  const VideoProfileInfoKHR* getProfiles() const { return std::bit_cast<const VideoProfileInfoKHR*>(this->pProfiles); }
};
inline void PhysicalDeviceImageFormatInfo2::attach(VideoProfileListInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void PhysicalDeviceVideoFormatInfoKHR::attach(VideoProfileListInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void ImageCreateInfo::attach(VideoProfileListInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void BufferCreateInfo::attach(VideoProfileListInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_queue

#if VK_ARM_tensors
struct DeviceTensorMemoryRequirementsARM : VkDeviceTensorMemoryRequirementsARM {
  DeviceTensorMemoryRequirementsARM() noexcept : VkDeviceTensorMemoryRequirementsARM{.sType = VK_STRUCTURE_TYPE_DEVICE_TENSOR_MEMORY_REQUIREMENTS_ARM} {}

  void setCreateInfo(const TensorCreateInfoARM* value) { this->pCreateInfo = std::bit_cast<const VkTensorCreateInfoARM*>(value); }
  const TensorCreateInfoARM* getCreateInfo() const { return std::bit_cast<const TensorCreateInfoARM*>(this->pCreateInfo); }
};

struct ExternalMemoryTensorCreateInfoARM : VkExternalMemoryTensorCreateInfoARM {
  ExternalMemoryTensorCreateInfoARM() noexcept : VkExternalMemoryTensorCreateInfoARM{.sType = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_TENSOR_CREATE_INFO_ARM} {}

  void setHandleTypes(ExternalMemoryHandleTypeFlags value) { this->handleTypes = std::bit_cast<VkExternalMemoryHandleTypeFlags>(value); }
  ExternalMemoryHandleTypeFlags getHandleTypes() const { return std::bit_cast<ExternalMemoryHandleTypeFlags>(this->handleTypes); }
};
inline void TensorCreateInfoARM::attach(ExternalMemoryTensorCreateInfoARM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_ARM_tensors

#if VK_KHR_video_encode_av1
struct VideoEncodeAV1RateControlInfoKHR : VkVideoEncodeAV1RateControlInfoKHR {
  VideoEncodeAV1RateControlInfoKHR() noexcept : VkVideoEncodeAV1RateControlInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_INFO_KHR} {}

  void setGopFrameCount(uint32_t value) { this->gopFrameCount = value; }
  uint32_t getGopFrameCount() const { return this->gopFrameCount; }
  void setKeyFramePeriod(uint32_t value) { this->keyFramePeriod = value; }
  uint32_t getKeyFramePeriod() const { return this->keyFramePeriod; }
  void setConsecutiveBipredictiveFrameCount(uint32_t value) { this->consecutiveBipredictiveFrameCount = value; }
  uint32_t getConsecutiveBipredictiveFrameCount() const { return this->consecutiveBipredictiveFrameCount; }
  void setTemporalLayerCount(uint32_t value) { this->temporalLayerCount = value; }
  uint32_t getTemporalLayerCount() const { return this->temporalLayerCount; }

  void setFlags(VideoEncodeAV1RateControlFlagsKHR value) { this->flags = std::bit_cast<VkVideoEncodeAV1RateControlFlagsKHR>(value); }
  VideoEncodeAV1RateControlFlagsKHR getFlags() const { return std::bit_cast<VideoEncodeAV1RateControlFlagsKHR>(this->flags); }
};
inline void VideoCodingControlInfoKHR::attach(VideoEncodeAV1RateControlInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void VideoBeginCodingInfoKHR::attach(VideoEncodeAV1RateControlInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_encode_av1

#if VK_KHR_video_encode_h264
struct VideoEncodeH264GopRemainingFrameInfoKHR : VkVideoEncodeH264GopRemainingFrameInfoKHR {
  VideoEncodeH264GopRemainingFrameInfoKHR() noexcept : VkVideoEncodeH264GopRemainingFrameInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_GOP_REMAINING_FRAME_INFO_KHR} {}

  void setGopRemainingI(uint32_t value) { this->gopRemainingI = value; }
  uint32_t getGopRemainingI() const { return this->gopRemainingI; }
  void setGopRemainingP(uint32_t value) { this->gopRemainingP = value; }
  uint32_t getGopRemainingP() const { return this->gopRemainingP; }
  void setGopRemainingB(uint32_t value) { this->gopRemainingB = value; }
  uint32_t getGopRemainingB() const { return this->gopRemainingB; }

  void setUseGopRemainingFrames(Bool32 value) { this->useGopRemainingFrames = value; }
  Bool32 getUseGopRemainingFrames() const { return this->useGopRemainingFrames; }
};
inline void VideoBeginCodingInfoKHR::attach(VideoEncodeH264GopRemainingFrameInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_encode_h264

#if VK_KHR_video_encode_h265
struct VideoEncodeH265RateControlInfoKHR : VkVideoEncodeH265RateControlInfoKHR {
  VideoEncodeH265RateControlInfoKHR() noexcept : VkVideoEncodeH265RateControlInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_INFO_KHR} {}

  void setGopFrameCount(uint32_t value) { this->gopFrameCount = value; }
  uint32_t getGopFrameCount() const { return this->gopFrameCount; }
  void setIdrPeriod(uint32_t value) { this->idrPeriod = value; }
  uint32_t getIdrPeriod() const { return this->idrPeriod; }
  void setConsecutiveBFrameCount(uint32_t value) { this->consecutiveBFrameCount = value; }
  uint32_t getConsecutiveBFrameCount() const { return this->consecutiveBFrameCount; }
  void setSubLayerCount(uint32_t value) { this->subLayerCount = value; }
  uint32_t getSubLayerCount() const { return this->subLayerCount; }

  void setFlags(VideoEncodeH265RateControlFlagsKHR value) { this->flags = std::bit_cast<VkVideoEncodeH265RateControlFlagsKHR>(value); }
  VideoEncodeH265RateControlFlagsKHR getFlags() const { return std::bit_cast<VideoEncodeH265RateControlFlagsKHR>(this->flags); }
};
inline void VideoCodingControlInfoKHR::attach(VideoEncodeH265RateControlInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void VideoBeginCodingInfoKHR::attach(VideoEncodeH265RateControlInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_encode_h265

#if VK_KHR_video_encode_h264
struct VideoEncodeH264RateControlInfoKHR : VkVideoEncodeH264RateControlInfoKHR {
  VideoEncodeH264RateControlInfoKHR() noexcept : VkVideoEncodeH264RateControlInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_KHR} {}

  void setGopFrameCount(uint32_t value) { this->gopFrameCount = value; }
  uint32_t getGopFrameCount() const { return this->gopFrameCount; }
  void setIdrPeriod(uint32_t value) { this->idrPeriod = value; }
  uint32_t getIdrPeriod() const { return this->idrPeriod; }
  void setConsecutiveBFrameCount(uint32_t value) { this->consecutiveBFrameCount = value; }
  uint32_t getConsecutiveBFrameCount() const { return this->consecutiveBFrameCount; }
  void setTemporalLayerCount(uint32_t value) { this->temporalLayerCount = value; }
  uint32_t getTemporalLayerCount() const { return this->temporalLayerCount; }

  void setFlags(VideoEncodeH264RateControlFlagsKHR value) { this->flags = std::bit_cast<VkVideoEncodeH264RateControlFlagsKHR>(value); }
  VideoEncodeH264RateControlFlagsKHR getFlags() const { return std::bit_cast<VideoEncodeH264RateControlFlagsKHR>(this->flags); }
};
inline void VideoCodingControlInfoKHR::attach(VideoEncodeH264RateControlInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void VideoBeginCodingInfoKHR::attach(VideoEncodeH264RateControlInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_encode_h264

#if VK_KHR_video_encode_queue
struct VideoEncodeRateControlInfoKHR : VkVideoEncodeRateControlInfoKHR {
  VideoEncodeRateControlInfoKHR() noexcept : VkVideoEncodeRateControlInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR} {}

  void setVirtualBufferSizeInMs(uint32_t value) { this->virtualBufferSizeInMs = value; }
  uint32_t getVirtualBufferSizeInMs() const { return this->virtualBufferSizeInMs; }
  void setInitialVirtualBufferSizeInMs(uint32_t value) { this->initialVirtualBufferSizeInMs = value; }
  uint32_t getInitialVirtualBufferSizeInMs() const { return this->initialVirtualBufferSizeInMs; }

  void setFlags(VideoEncodeRateControlFlagsKHR value) { this->flags = std::bit_cast<VkVideoEncodeRateControlFlagsKHR>(value); }
  VideoEncodeRateControlFlagsKHR getFlags() const { return std::bit_cast<VideoEncodeRateControlFlagsKHR>(this->flags); }
  void setRateControlMode(VideoEncodeRateControlModeFlagBitsKHR value) { this->rateControlMode = std::bit_cast<VkVideoEncodeRateControlModeFlagBitsKHR>(value); }
  VideoEncodeRateControlModeFlagBitsKHR getRateControlMode() const { return std::bit_cast<VideoEncodeRateControlModeFlagBitsKHR>(this->rateControlMode); }
  void setLayerCount(uint32_t value) { this->layerCount = value; }
  uint32_t getLayerCount() const { return this->layerCount; }
  void setLayers(const VideoEncodeRateControlLayerInfoKHR* value) { this->pLayers = std::bit_cast<const VkVideoEncodeRateControlLayerInfoKHR*>(value); }
  const VideoEncodeRateControlLayerInfoKHR* getLayers() const { return std::bit_cast<const VideoEncodeRateControlLayerInfoKHR*>(this->pLayers); }
};
inline void VideoCodingControlInfoKHR::attach(VideoEncodeRateControlInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void VideoBeginCodingInfoKHR::attach(VideoEncodeRateControlInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_encode_queue

#if VK_KHR_video_encode_av1
struct VideoEncodeAV1GopRemainingFrameInfoKHR : VkVideoEncodeAV1GopRemainingFrameInfoKHR {
  VideoEncodeAV1GopRemainingFrameInfoKHR() noexcept : VkVideoEncodeAV1GopRemainingFrameInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_GOP_REMAINING_FRAME_INFO_KHR} {}

  void setGopRemainingIntra(uint32_t value) { this->gopRemainingIntra = value; }
  uint32_t getGopRemainingIntra() const { return this->gopRemainingIntra; }
  void setGopRemainingPredictive(uint32_t value) { this->gopRemainingPredictive = value; }
  uint32_t getGopRemainingPredictive() const { return this->gopRemainingPredictive; }
  void setGopRemainingBipredictive(uint32_t value) { this->gopRemainingBipredictive = value; }
  uint32_t getGopRemainingBipredictive() const { return this->gopRemainingBipredictive; }

  void setUseGopRemainingFrames(Bool32 value) { this->useGopRemainingFrames = value; }
  Bool32 getUseGopRemainingFrames() const { return this->useGopRemainingFrames; }
};
inline void VideoBeginCodingInfoKHR::attach(VideoEncodeAV1GopRemainingFrameInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_encode_av1

#if VK_KHR_video_encode_h265
struct VideoEncodeH265GopRemainingFrameInfoKHR : VkVideoEncodeH265GopRemainingFrameInfoKHR {
  VideoEncodeH265GopRemainingFrameInfoKHR() noexcept : VkVideoEncodeH265GopRemainingFrameInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_GOP_REMAINING_FRAME_INFO_KHR} {}

  void setGopRemainingI(uint32_t value) { this->gopRemainingI = value; }
  uint32_t getGopRemainingI() const { return this->gopRemainingI; }
  void setGopRemainingP(uint32_t value) { this->gopRemainingP = value; }
  uint32_t getGopRemainingP() const { return this->gopRemainingP; }
  void setGopRemainingB(uint32_t value) { this->gopRemainingB = value; }
  uint32_t getGopRemainingB() const { return this->gopRemainingB; }

  void setUseGopRemainingFrames(Bool32 value) { this->useGopRemainingFrames = value; }
  Bool32 getUseGopRemainingFrames() const { return this->useGopRemainingFrames; }
};
inline void VideoBeginCodingInfoKHR::attach(VideoEncodeH265GopRemainingFrameInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_encode_h265

#if VK_KHR_video_encode_intra_refresh
struct VideoEncodeIntraRefreshInfoKHR : VkVideoEncodeIntraRefreshInfoKHR {
  VideoEncodeIntraRefreshInfoKHR() noexcept : VkVideoEncodeIntraRefreshInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_INFO_KHR} {}

  void setIntraRefreshCycleDuration(uint32_t value) { this->intraRefreshCycleDuration = value; }
  uint32_t getIntraRefreshCycleDuration() const { return this->intraRefreshCycleDuration; }
  void setIntraRefreshIndex(uint32_t value) { this->intraRefreshIndex = value; }
  uint32_t getIntraRefreshIndex() const { return this->intraRefreshIndex; }
};
inline void VideoEncodeInfoKHR::attach(VideoEncodeIntraRefreshInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_encode_intra_refresh

#if VK_KHR_video_encode_av1
struct VideoEncodeAV1PictureInfoKHR : VkVideoEncodeAV1PictureInfoKHR {
  VideoEncodeAV1PictureInfoKHR() noexcept : VkVideoEncodeAV1PictureInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PICTURE_INFO_KHR} {}

  void setPredictionMode(VideoEncodeAV1PredictionModeKHR value) { this->predictionMode = std::bit_cast<VkVideoEncodeAV1PredictionModeKHR>(value); }
  VideoEncodeAV1PredictionModeKHR getPredictionMode() const { return std::bit_cast<VideoEncodeAV1PredictionModeKHR>(this->predictionMode); }
  void setRateControlGroup(VideoEncodeAV1RateControlGroupKHR value) { this->rateControlGroup = std::bit_cast<VkVideoEncodeAV1RateControlGroupKHR>(value); }
  VideoEncodeAV1RateControlGroupKHR getRateControlGroup() const { return std::bit_cast<VideoEncodeAV1RateControlGroupKHR>(this->rateControlGroup); }
  void setConstantQIndex(uint32_t value) { this->constantQIndex = value; }
  uint32_t getConstantQIndex() const { return this->constantQIndex; }
  void setStdPictureInfo(const StdVideoEncodeAV1PictureInfo* value) { this->pStdPictureInfo = value; }
  const StdVideoEncodeAV1PictureInfo* getStdPictureInfo() const { return this->pStdPictureInfo; }
  void setReferenceNameSlotIndices(std::span<const int32_t, VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR> value) { std::memcpy(&this->referenceNameSlotIndices, value.data(), value.size_bytes()); }
  std::span<const int32_t, VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR> getReferenceNameSlotIndices() const { return this->referenceNameSlotIndices; }

  void setPrimaryReferenceCdfOnly(Bool32 value) { this->primaryReferenceCdfOnly = value; }
  Bool32 getPrimaryReferenceCdfOnly() const { return this->primaryReferenceCdfOnly; }
  void setGenerateObuExtensionHeader(Bool32 value) { this->generateObuExtensionHeader = value; }
  Bool32 getGenerateObuExtensionHeader() const { return this->generateObuExtensionHeader; }
};
inline void VideoEncodeInfoKHR::attach(VideoEncodeAV1PictureInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_encode_av1

#if VK_KHR_video_encode_quantization_map
struct VideoEncodeQuantizationMapInfoKHR : VkVideoEncodeQuantizationMapInfoKHR {
  VideoEncodeQuantizationMapInfoKHR() noexcept : VkVideoEncodeQuantizationMapInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_INFO_KHR} {}

  void setQuantizationMapExtent(const Extent2D& value) { this->quantizationMapExtent = value; }
  const Extent2D& getQuantizationMapExtent() const { return static_cast<const Extent2D&>(this->quantizationMapExtent); }

  void setQuantizationMap(ImageView value) { this->quantizationMap = std::bit_cast<VkImageView>(value); }
  ImageView getQuantizationMap() const { return std::bit_cast<ImageView>(this->quantizationMap); }
};
inline void VideoEncodeInfoKHR::attach(VideoEncodeQuantizationMapInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_encode_quantization_map

#if VK_KHR_video_encode_h265
struct VideoEncodeH265PictureInfoKHR : VkVideoEncodeH265PictureInfoKHR {
  VideoEncodeH265PictureInfoKHR() noexcept : VkVideoEncodeH265PictureInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PICTURE_INFO_KHR} {}

  void setNaluSliceSegmentEntryCount(uint32_t value) { this->naluSliceSegmentEntryCount = value; }
  uint32_t getNaluSliceSegmentEntryCount() const { return this->naluSliceSegmentEntryCount; }
  void setNaluSliceSegmentEntries(const VideoEncodeH265NaluSliceSegmentInfoKHR* value) { this->pNaluSliceSegmentEntries = std::bit_cast<const VkVideoEncodeH265NaluSliceSegmentInfoKHR*>(value); }
  const VideoEncodeH265NaluSliceSegmentInfoKHR* getNaluSliceSegmentEntries() const { return std::bit_cast<const VideoEncodeH265NaluSliceSegmentInfoKHR*>(this->pNaluSliceSegmentEntries); }
  void setStdPictureInfo(const StdVideoEncodeH265PictureInfo* value) { this->pStdPictureInfo = value; }
  const StdVideoEncodeH265PictureInfo* getStdPictureInfo() const { return this->pStdPictureInfo; }
};
#if VK_KHR_video_encode_queue
inline void VideoEncodeInfoKHR::attach(VideoEncodeH265PictureInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_encode_queue
#endif // VK_KHR_video_encode_h265

#if VK_KHR_video_encode_h264
struct VideoEncodeH264PictureInfoKHR : VkVideoEncodeH264PictureInfoKHR {
  VideoEncodeH264PictureInfoKHR() noexcept : VkVideoEncodeH264PictureInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PICTURE_INFO_KHR} {}

  void setNaluSliceEntryCount(uint32_t value) { this->naluSliceEntryCount = value; }
  uint32_t getNaluSliceEntryCount() const { return this->naluSliceEntryCount; }
  void setNaluSliceEntries(const VideoEncodeH264NaluSliceInfoKHR* value) { this->pNaluSliceEntries = std::bit_cast<const VkVideoEncodeH264NaluSliceInfoKHR*>(value); }
  const VideoEncodeH264NaluSliceInfoKHR* getNaluSliceEntries() const { return std::bit_cast<const VideoEncodeH264NaluSliceInfoKHR*>(this->pNaluSliceEntries); }
  void setStdPictureInfo(const StdVideoEncodeH264PictureInfo* value) { this->pStdPictureInfo = value; }
  const StdVideoEncodeH264PictureInfo* getStdPictureInfo() const { return this->pStdPictureInfo; }

  void setGeneratePrefixNalu(Bool32 value) { this->generatePrefixNalu = value; }
  Bool32 getGeneratePrefixNalu() const { return this->generatePrefixNalu; }
};
#if VK_KHR_video_encode_queue
inline void VideoEncodeInfoKHR::attach(VideoEncodeH264PictureInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_encode_queue
#endif // VK_KHR_video_encode_h264

#if VK_KHR_video_maintenance2
struct VideoDecodeH265InlineSessionParametersInfoKHR : VkVideoDecodeH265InlineSessionParametersInfoKHR {
  VideoDecodeH265InlineSessionParametersInfoKHR() noexcept : VkVideoDecodeH265InlineSessionParametersInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_INLINE_SESSION_PARAMETERS_INFO_KHR} {}

  void setStdVPS(const StdVideoH265VideoParameterSet* value) { this->pStdVPS = value; }
  const StdVideoH265VideoParameterSet* getStdVPS() const { return this->pStdVPS; }
  void setStdSPS(const StdVideoH265SequenceParameterSet* value) { this->pStdSPS = value; }
  const StdVideoH265SequenceParameterSet* getStdSPS() const { return this->pStdSPS; }
  void setStdPPS(const StdVideoH265PictureParameterSet* value) { this->pStdPPS = value; }
  const StdVideoH265PictureParameterSet* getStdPPS() const { return this->pStdPPS; }
};
inline void VideoDecodeInfoKHR::attach(VideoDecodeH265InlineSessionParametersInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }

struct VideoDecodeH264InlineSessionParametersInfoKHR : VkVideoDecodeH264InlineSessionParametersInfoKHR {
  VideoDecodeH264InlineSessionParametersInfoKHR() noexcept : VkVideoDecodeH264InlineSessionParametersInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_INLINE_SESSION_PARAMETERS_INFO_KHR} {}

  void setStdSPS(const StdVideoH264SequenceParameterSet* value) { this->pStdSPS = value; }
  const StdVideoH264SequenceParameterSet* getStdSPS() const { return this->pStdSPS; }
  void setStdPPS(const StdVideoH264PictureParameterSet* value) { this->pStdPPS = value; }
  const StdVideoH264PictureParameterSet* getStdPPS() const { return this->pStdPPS; }
};
inline void VideoDecodeInfoKHR::attach(VideoDecodeH264InlineSessionParametersInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }

struct VideoDecodeAV1InlineSessionParametersInfoKHR : VkVideoDecodeAV1InlineSessionParametersInfoKHR {
  VideoDecodeAV1InlineSessionParametersInfoKHR() noexcept : VkVideoDecodeAV1InlineSessionParametersInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_INLINE_SESSION_PARAMETERS_INFO_KHR} {}

  void setStdSequenceHeader(const StdVideoAV1SequenceHeader* value) { this->pStdSequenceHeader = value; }
  const StdVideoAV1SequenceHeader* getStdSequenceHeader() const { return this->pStdSequenceHeader; }
};
inline void VideoDecodeInfoKHR::attach(VideoDecodeAV1InlineSessionParametersInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_maintenance2

#if VK_KHR_video_decode_vp9
struct VideoDecodeVP9PictureInfoKHR : VkVideoDecodeVP9PictureInfoKHR {
  VideoDecodeVP9PictureInfoKHR() noexcept : VkVideoDecodeVP9PictureInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_PICTURE_INFO_KHR} {}

  void setStdPictureInfo(const StdVideoDecodeVP9PictureInfo* value) { this->pStdPictureInfo = value; }
  const StdVideoDecodeVP9PictureInfo* getStdPictureInfo() const { return this->pStdPictureInfo; }
  void setReferenceNameSlotIndices(std::span<const int32_t, VK_MAX_VIDEO_VP9_REFERENCES_PER_FRAME_KHR> value) { std::memcpy(&this->referenceNameSlotIndices, value.data(), value.size_bytes()); }
  std::span<const int32_t, VK_MAX_VIDEO_VP9_REFERENCES_PER_FRAME_KHR> getReferenceNameSlotIndices() const { return this->referenceNameSlotIndices; }
  void setUncompressedHeaderOffset(uint32_t value) { this->uncompressedHeaderOffset = value; }
  uint32_t getUncompressedHeaderOffset() const { return this->uncompressedHeaderOffset; }
  void setCompressedHeaderOffset(uint32_t value) { this->compressedHeaderOffset = value; }
  uint32_t getCompressedHeaderOffset() const { return this->compressedHeaderOffset; }
  void setTilesOffset(uint32_t value) { this->tilesOffset = value; }
  uint32_t getTilesOffset() const { return this->tilesOffset; }
};
inline void VideoDecodeInfoKHR::attach(VideoDecodeVP9PictureInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_decode_vp9

#if VK_KHR_video_decode_h264
struct VideoDecodeH264PictureInfoKHR : VkVideoDecodeH264PictureInfoKHR {
  VideoDecodeH264PictureInfoKHR() noexcept : VkVideoDecodeH264PictureInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_KHR} {}

  void setStdPictureInfo(const StdVideoDecodeH264PictureInfo* value) { this->pStdPictureInfo = value; }
  const StdVideoDecodeH264PictureInfo* getStdPictureInfo() const { return this->pStdPictureInfo; }
  void setSliceCount(uint32_t value) { this->sliceCount = value; }
  uint32_t getSliceCount() const { return this->sliceCount; }
  void setSliceOffsets(const uint32_t* value) { this->pSliceOffsets = value; }
  const uint32_t* getSliceOffsets() const { return this->pSliceOffsets; }
};
inline void VideoDecodeInfoKHR::attach(VideoDecodeH264PictureInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_decode_h264

#if VK_KHR_video_decode_h265
struct VideoDecodeH265PictureInfoKHR : VkVideoDecodeH265PictureInfoKHR {
  VideoDecodeH265PictureInfoKHR() noexcept : VkVideoDecodeH265PictureInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_KHR} {}

  void setStdPictureInfo(const StdVideoDecodeH265PictureInfo* value) { this->pStdPictureInfo = value; }
  const StdVideoDecodeH265PictureInfo* getStdPictureInfo() const { return this->pStdPictureInfo; }
  void setSliceSegmentCount(uint32_t value) { this->sliceSegmentCount = value; }
  uint32_t getSliceSegmentCount() const { return this->sliceSegmentCount; }
  void setSliceSegmentOffsets(const uint32_t* value) { this->pSliceSegmentOffsets = value; }
  const uint32_t* getSliceSegmentOffsets() const { return this->pSliceSegmentOffsets; }
};
inline void VideoDecodeInfoKHR::attach(VideoDecodeH265PictureInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_decode_h265

#if VK_KHR_video_maintenance1
struct VideoInlineQueryInfoKHR : VkVideoInlineQueryInfoKHR {
  VideoInlineQueryInfoKHR() noexcept : VkVideoInlineQueryInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_INLINE_QUERY_INFO_KHR} {}

  void setFirstQuery(uint32_t value) { this->firstQuery = value; }
  uint32_t getFirstQuery() const { return this->firstQuery; }
  void setQueryCount(uint32_t value) { this->queryCount = value; }
  uint32_t getQueryCount() const { return this->queryCount; }

  void setQueryPool(QueryPool value) { this->queryPool = std::bit_cast<VkQueryPool>(value); }
  QueryPool getQueryPool() const { return std::bit_cast<QueryPool>(this->queryPool); }
};
inline void VideoDecodeInfoKHR::attach(VideoInlineQueryInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void VideoEncodeInfoKHR::attach(VideoInlineQueryInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_maintenance1

#if VK_KHR_video_decode_av1
struct VideoDecodeAV1PictureInfoKHR : VkVideoDecodeAV1PictureInfoKHR {
  VideoDecodeAV1PictureInfoKHR() noexcept : VkVideoDecodeAV1PictureInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PICTURE_INFO_KHR} {}

  void setStdPictureInfo(const StdVideoDecodeAV1PictureInfo* value) { this->pStdPictureInfo = value; }
  const StdVideoDecodeAV1PictureInfo* getStdPictureInfo() const { return this->pStdPictureInfo; }
  void setReferenceNameSlotIndices(std::span<const int32_t, VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR> value) { std::memcpy(&this->referenceNameSlotIndices, value.data(), value.size_bytes()); }
  std::span<const int32_t, VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR> getReferenceNameSlotIndices() const { return this->referenceNameSlotIndices; }
  void setFrameHeaderOffset(uint32_t value) { this->frameHeaderOffset = value; }
  uint32_t getFrameHeaderOffset() const { return this->frameHeaderOffset; }
  void setTileCount(uint32_t value) { this->tileCount = value; }
  uint32_t getTileCount() const { return this->tileCount; }
  void setTileOffsets(const uint32_t* value) { this->pTileOffsets = value; }
  const uint32_t* getTileOffsets() const { return this->pTileOffsets; }
  void setTileSizes(const uint32_t* value) { this->pTileSizes = value; }
  const uint32_t* getTileSizes() const { return this->pTileSizes; }
};
inline void VideoDecodeInfoKHR::attach(VideoDecodeAV1PictureInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_decode_av1

#if VK_KHR_device_group
using DeviceGroupRenderPassBeginInfoKHR = DeviceGroupRenderPassBeginInfo;
#endif // VK_KHR_device_group
#if VK_KHR_maintenance6
using PushDescriptorSetInfoKHR = PushDescriptorSetInfo;
#endif // VK_KHR_maintenance6

#if VK_VERSION_1_0
struct PipelineLayoutCreateInfo : VkPipelineLayoutCreateInfo {
  PipelineLayoutCreateInfo() noexcept : VkPipelineLayoutCreateInfo{.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO} {}

  void setFlags(PipelineLayoutCreateFlags value) { this->flags = std::bit_cast<VkPipelineLayoutCreateFlags>(value); }
  PipelineLayoutCreateFlags getFlags() const { return std::bit_cast<PipelineLayoutCreateFlags>(this->flags); }
  // Number of descriptor sets interfaced by the pipeline
  void setSetLayoutCount(uint32_t value) { this->setLayoutCount = value; }
  uint32_t getSetLayoutCount() const { return this->setLayoutCount; }
  // Array of setCount number of descriptor set layout objects defining the layout of the
  void setSetLayouts(const DescriptorSetLayout* value) { this->pSetLayouts = std::bit_cast<const VkDescriptorSetLayout*>(value); }
  const DescriptorSetLayout* getSetLayouts() const { return std::bit_cast<const DescriptorSetLayout*>(this->pSetLayouts); }
  // Number of push-constant ranges used by the pipeline
  void setPushConstantRangeCount(uint32_t value) { this->pushConstantRangeCount = value; }
  uint32_t getPushConstantRangeCount() const { return this->pushConstantRangeCount; }
  // Array of pushConstantRangeCount number of ranges used by various shader stages
  void setPushConstantRanges(const PushConstantRange* value) { this->pPushConstantRanges = std::bit_cast<const VkPushConstantRange*>(value); }
  const PushConstantRange* getPushConstantRanges() const { return std::bit_cast<const PushConstantRange*>(this->pPushConstantRanges); }
};
#if VK_VERSION_1_4
inline void BindDescriptorSetsInfo::attach(PipelineLayoutCreateInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void PushConstantsInfo::attach(PipelineLayoutCreateInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void PushDescriptorSetInfo::attach(PipelineLayoutCreateInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void PushDescriptorSetWithTemplateInfo::attach(PipelineLayoutCreateInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_4
#if VK_KHR_maintenance6
inline void SetDescriptorBufferOffsetsInfoEXT::attach(PipelineLayoutCreateInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void BindDescriptorBufferEmbeddedSamplersInfoEXT::attach(PipelineLayoutCreateInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_maintenance6
#if VK_EXT_device_generated_commands
inline void IndirectCommandsLayoutCreateInfoEXT::attach(PipelineLayoutCreateInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_device_generated_commands
#endif // VK_VERSION_1_0

#if VK_EXT_inline_uniform_block
using WriteDescriptorSetInlineUniformBlockEXT = WriteDescriptorSetInlineUniformBlock;
#endif // VK_EXT_inline_uniform_block
#if VK_KHR_global_priority
using QueueFamilyGlobalPriorityPropertiesKHR = QueueFamilyGlobalPriorityProperties;
#endif // VK_KHR_global_priority
#if VK_EXT_global_priority_query
using QueueFamilyGlobalPriorityPropertiesEXT = QueueFamilyGlobalPriorityProperties;
#endif // VK_EXT_global_priority_query
#if VK_EXT_private_data
using DevicePrivateDataCreateInfoEXT = DevicePrivateDataCreateInfo;
#endif // VK_EXT_private_data

#if VK_KHR_video_encode_quantization_map
struct PhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR : VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR {
  PhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR() noexcept : VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUANTIZATION_MAP_FEATURES_KHR} {}

  void setVideoEncodeQuantizationMap(Bool32 value) { this->videoEncodeQuantizationMap = value; }
  Bool32 getVideoEncodeQuantizationMap() const { return this->videoEncodeQuantizationMap; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_encode_quantization_map

#if VK_KHR_video_encode_intra_refresh
struct PhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR : VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR {
  PhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR() noexcept : VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_INTRA_REFRESH_FEATURES_KHR} {}

  void setVideoEncodeIntraRefresh(Bool32 value) { this->videoEncodeIntraRefresh = value; }
  Bool32 getVideoEncodeIntraRefresh() const { return this->videoEncodeIntraRefresh; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_encode_intra_refresh

#if VK_VERSION_1_2
struct PhysicalDeviceShaderFloat16Int8Features : VkPhysicalDeviceShaderFloat16Int8Features {
  PhysicalDeviceShaderFloat16Int8Features() noexcept : VkPhysicalDeviceShaderFloat16Int8Features{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES} {}

  // 16-bit floats (halfs) in shaders
  void setShaderFloat16(Bool32 value) { this->shaderFloat16 = value; }
  Bool32 getShaderFloat16() const { return this->shaderFloat16; }
  // 8-bit integers in shaders
  void setShaderInt8(Bool32 value) { this->shaderInt8 = value; }
  Bool32 getShaderInt8() const { return this->shaderInt8; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceShaderFloat16Int8Features& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceShaderFloat16Int8Features& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_2

#if VK_EXT_pipeline_library_group_handles
struct PhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT : VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT {
  PhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT() noexcept : VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT} {}

  void setPipelineLibraryGroupHandles(Bool32 value) { this->pipelineLibraryGroupHandles = value; }
  Bool32 getPipelineLibraryGroupHandles() const { return this->pipelineLibraryGroupHandles; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_pipeline_library_group_handles

#if VK_VERSION_1_2
struct PhysicalDeviceVulkan12Features : VkPhysicalDeviceVulkan12Features {
  PhysicalDeviceVulkan12Features() noexcept : VkPhysicalDeviceVulkan12Features{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES} {}

  void setSamplerMirrorClampToEdge(Bool32 value) { this->samplerMirrorClampToEdge = value; }
  Bool32 getSamplerMirrorClampToEdge() const { return this->samplerMirrorClampToEdge; }
  void setDrawIndirectCount(Bool32 value) { this->drawIndirectCount = value; }
  Bool32 getDrawIndirectCount() const { return this->drawIndirectCount; }
  // 8-bit integer variables supported in StorageBuffer
  void setStorageBuffer8BitAccess(Bool32 value) { this->storageBuffer8BitAccess = value; }
  Bool32 getStorageBuffer8BitAccess() const { return this->storageBuffer8BitAccess; }
  // 8-bit integer variables supported in StorageBuffer and Uniform
  void setUniformAndStorageBuffer8BitAccess(Bool32 value) { this->uniformAndStorageBuffer8BitAccess = value; }
  Bool32 getUniformAndStorageBuffer8BitAccess() const { return this->uniformAndStorageBuffer8BitAccess; }
  // 8-bit integer variables supported in PushConstant
  void setStoragePushConstant8(Bool32 value) { this->storagePushConstant8 = value; }
  Bool32 getStoragePushConstant8() const { return this->storagePushConstant8; }
  void setShaderBufferInt64Atomics(Bool32 value) { this->shaderBufferInt64Atomics = value; }
  Bool32 getShaderBufferInt64Atomics() const { return this->shaderBufferInt64Atomics; }
  void setShaderSharedInt64Atomics(Bool32 value) { this->shaderSharedInt64Atomics = value; }
  Bool32 getShaderSharedInt64Atomics() const { return this->shaderSharedInt64Atomics; }
  // 16-bit floats (halfs) in shaders
  void setShaderFloat16(Bool32 value) { this->shaderFloat16 = value; }
  Bool32 getShaderFloat16() const { return this->shaderFloat16; }
  // 8-bit integers in shaders
  void setShaderInt8(Bool32 value) { this->shaderInt8 = value; }
  Bool32 getShaderInt8() const { return this->shaderInt8; }
  void setDescriptorIndexing(Bool32 value) { this->descriptorIndexing = value; }
  Bool32 getDescriptorIndexing() const { return this->descriptorIndexing; }
  void setShaderInputAttachmentArrayDynamicIndexing(Bool32 value) { this->shaderInputAttachmentArrayDynamicIndexing = value; }
  Bool32 getShaderInputAttachmentArrayDynamicIndexing() const { return this->shaderInputAttachmentArrayDynamicIndexing; }
  void setShaderUniformTexelBufferArrayDynamicIndexing(Bool32 value) { this->shaderUniformTexelBufferArrayDynamicIndexing = value; }
  Bool32 getShaderUniformTexelBufferArrayDynamicIndexing() const { return this->shaderUniformTexelBufferArrayDynamicIndexing; }
  void setShaderStorageTexelBufferArrayDynamicIndexing(Bool32 value) { this->shaderStorageTexelBufferArrayDynamicIndexing = value; }
  Bool32 getShaderStorageTexelBufferArrayDynamicIndexing() const { return this->shaderStorageTexelBufferArrayDynamicIndexing; }
  void setShaderUniformBufferArrayNonUniformIndexing(Bool32 value) { this->shaderUniformBufferArrayNonUniformIndexing = value; }
  Bool32 getShaderUniformBufferArrayNonUniformIndexing() const { return this->shaderUniformBufferArrayNonUniformIndexing; }
  void setShaderSampledImageArrayNonUniformIndexing(Bool32 value) { this->shaderSampledImageArrayNonUniformIndexing = value; }
  Bool32 getShaderSampledImageArrayNonUniformIndexing() const { return this->shaderSampledImageArrayNonUniformIndexing; }
  void setShaderStorageBufferArrayNonUniformIndexing(Bool32 value) { this->shaderStorageBufferArrayNonUniformIndexing = value; }
  Bool32 getShaderStorageBufferArrayNonUniformIndexing() const { return this->shaderStorageBufferArrayNonUniformIndexing; }
  void setShaderStorageImageArrayNonUniformIndexing(Bool32 value) { this->shaderStorageImageArrayNonUniformIndexing = value; }
  Bool32 getShaderStorageImageArrayNonUniformIndexing() const { return this->shaderStorageImageArrayNonUniformIndexing; }
  void setShaderInputAttachmentArrayNonUniformIndexing(Bool32 value) { this->shaderInputAttachmentArrayNonUniformIndexing = value; }
  Bool32 getShaderInputAttachmentArrayNonUniformIndexing() const { return this->shaderInputAttachmentArrayNonUniformIndexing; }
  void setShaderUniformTexelBufferArrayNonUniformIndexing(Bool32 value) { this->shaderUniformTexelBufferArrayNonUniformIndexing = value; }
  Bool32 getShaderUniformTexelBufferArrayNonUniformIndexing() const { return this->shaderUniformTexelBufferArrayNonUniformIndexing; }
  void setShaderStorageTexelBufferArrayNonUniformIndexing(Bool32 value) { this->shaderStorageTexelBufferArrayNonUniformIndexing = value; }
  Bool32 getShaderStorageTexelBufferArrayNonUniformIndexing() const { return this->shaderStorageTexelBufferArrayNonUniformIndexing; }
  void setDescriptorBindingUniformBufferUpdateAfterBind(Bool32 value) { this->descriptorBindingUniformBufferUpdateAfterBind = value; }
  Bool32 getDescriptorBindingUniformBufferUpdateAfterBind() const { return this->descriptorBindingUniformBufferUpdateAfterBind; }
  void setDescriptorBindingSampledImageUpdateAfterBind(Bool32 value) { this->descriptorBindingSampledImageUpdateAfterBind = value; }
  Bool32 getDescriptorBindingSampledImageUpdateAfterBind() const { return this->descriptorBindingSampledImageUpdateAfterBind; }
  void setDescriptorBindingStorageImageUpdateAfterBind(Bool32 value) { this->descriptorBindingStorageImageUpdateAfterBind = value; }
  Bool32 getDescriptorBindingStorageImageUpdateAfterBind() const { return this->descriptorBindingStorageImageUpdateAfterBind; }
  void setDescriptorBindingStorageBufferUpdateAfterBind(Bool32 value) { this->descriptorBindingStorageBufferUpdateAfterBind = value; }
  Bool32 getDescriptorBindingStorageBufferUpdateAfterBind() const { return this->descriptorBindingStorageBufferUpdateAfterBind; }
  void setDescriptorBindingUniformTexelBufferUpdateAfterBind(Bool32 value) { this->descriptorBindingUniformTexelBufferUpdateAfterBind = value; }
  Bool32 getDescriptorBindingUniformTexelBufferUpdateAfterBind() const { return this->descriptorBindingUniformTexelBufferUpdateAfterBind; }
  void setDescriptorBindingStorageTexelBufferUpdateAfterBind(Bool32 value) { this->descriptorBindingStorageTexelBufferUpdateAfterBind = value; }
  Bool32 getDescriptorBindingStorageTexelBufferUpdateAfterBind() const { return this->descriptorBindingStorageTexelBufferUpdateAfterBind; }
  void setDescriptorBindingUpdateUnusedWhilePending(Bool32 value) { this->descriptorBindingUpdateUnusedWhilePending = value; }
  Bool32 getDescriptorBindingUpdateUnusedWhilePending() const { return this->descriptorBindingUpdateUnusedWhilePending; }
  void setDescriptorBindingPartiallyBound(Bool32 value) { this->descriptorBindingPartiallyBound = value; }
  Bool32 getDescriptorBindingPartiallyBound() const { return this->descriptorBindingPartiallyBound; }
  void setDescriptorBindingVariableDescriptorCount(Bool32 value) { this->descriptorBindingVariableDescriptorCount = value; }
  Bool32 getDescriptorBindingVariableDescriptorCount() const { return this->descriptorBindingVariableDescriptorCount; }
  void setRuntimeDescriptorArray(Bool32 value) { this->runtimeDescriptorArray = value; }
  Bool32 getRuntimeDescriptorArray() const { return this->runtimeDescriptorArray; }
  void setSamplerFilterMinmax(Bool32 value) { this->samplerFilterMinmax = value; }
  Bool32 getSamplerFilterMinmax() const { return this->samplerFilterMinmax; }
  void setScalarBlockLayout(Bool32 value) { this->scalarBlockLayout = value; }
  Bool32 getScalarBlockLayout() const { return this->scalarBlockLayout; }
  void setImagelessFramebuffer(Bool32 value) { this->imagelessFramebuffer = value; }
  Bool32 getImagelessFramebuffer() const { return this->imagelessFramebuffer; }
  void setUniformBufferStandardLayout(Bool32 value) { this->uniformBufferStandardLayout = value; }
  Bool32 getUniformBufferStandardLayout() const { return this->uniformBufferStandardLayout; }
  void setShaderSubgroupExtendedTypes(Bool32 value) { this->shaderSubgroupExtendedTypes = value; }
  Bool32 getShaderSubgroupExtendedTypes() const { return this->shaderSubgroupExtendedTypes; }
  void setSeparateDepthStencilLayouts(Bool32 value) { this->separateDepthStencilLayouts = value; }
  Bool32 getSeparateDepthStencilLayouts() const { return this->separateDepthStencilLayouts; }
  void setHostQueryReset(Bool32 value) { this->hostQueryReset = value; }
  Bool32 getHostQueryReset() const { return this->hostQueryReset; }
  void setTimelineSemaphore(Bool32 value) { this->timelineSemaphore = value; }
  Bool32 getTimelineSemaphore() const { return this->timelineSemaphore; }
  void setBufferDeviceAddress(Bool32 value) { this->bufferDeviceAddress = value; }
  Bool32 getBufferDeviceAddress() const { return this->bufferDeviceAddress; }
  void setBufferDeviceAddressCaptureReplay(Bool32 value) { this->bufferDeviceAddressCaptureReplay = value; }
  Bool32 getBufferDeviceAddressCaptureReplay() const { return this->bufferDeviceAddressCaptureReplay; }
  void setBufferDeviceAddressMultiDevice(Bool32 value) { this->bufferDeviceAddressMultiDevice = value; }
  Bool32 getBufferDeviceAddressMultiDevice() const { return this->bufferDeviceAddressMultiDevice; }
  void setVulkanMemoryModel(Bool32 value) { this->vulkanMemoryModel = value; }
  Bool32 getVulkanMemoryModel() const { return this->vulkanMemoryModel; }
  void setVulkanMemoryModelDeviceScope(Bool32 value) { this->vulkanMemoryModelDeviceScope = value; }
  Bool32 getVulkanMemoryModelDeviceScope() const { return this->vulkanMemoryModelDeviceScope; }
  void setVulkanMemoryModelAvailabilityVisibilityChains(Bool32 value) { this->vulkanMemoryModelAvailabilityVisibilityChains = value; }
  Bool32 getVulkanMemoryModelAvailabilityVisibilityChains() const { return this->vulkanMemoryModelAvailabilityVisibilityChains; }
  void setShaderOutputViewportIndex(Bool32 value) { this->shaderOutputViewportIndex = value; }
  Bool32 getShaderOutputViewportIndex() const { return this->shaderOutputViewportIndex; }
  void setShaderOutputLayer(Bool32 value) { this->shaderOutputLayer = value; }
  Bool32 getShaderOutputLayer() const { return this->shaderOutputLayer; }
  void setSubgroupBroadcastDynamicId(Bool32 value) { this->subgroupBroadcastDynamicId = value; }
  Bool32 getSubgroupBroadcastDynamicId() const { return this->subgroupBroadcastDynamicId; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceVulkan12Features& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceVulkan12Features& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_2

#if VK_EXT_image_2d_view_of_3d
struct PhysicalDeviceImage2DViewOf3DFeaturesEXT : VkPhysicalDeviceImage2DViewOf3DFeaturesEXT {
  PhysicalDeviceImage2DViewOf3DFeaturesEXT() noexcept : VkPhysicalDeviceImage2DViewOf3DFeaturesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT} {}

  void setImage2DViewOf3D(Bool32 value) { this->image2DViewOf3D = value; }
  Bool32 getImage2DViewOf3D() const { return this->image2DViewOf3D; }
  void setSampler2DViewOf3D(Bool32 value) { this->sampler2DViewOf3D = value; }
  Bool32 getSampler2DViewOf3D() const { return this->sampler2DViewOf3D; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceImage2DViewOf3DFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceImage2DViewOf3DFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_image_2d_view_of_3d

#if VK_VERSION_1_4
struct PhysicalDeviceVulkan14Features : VkPhysicalDeviceVulkan14Features {
  PhysicalDeviceVulkan14Features() noexcept : VkPhysicalDeviceVulkan14Features{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_FEATURES} {}

  void setGlobalPriorityQuery(Bool32 value) { this->globalPriorityQuery = value; }
  Bool32 getGlobalPriorityQuery() const { return this->globalPriorityQuery; }
  void setShaderSubgroupRotate(Bool32 value) { this->shaderSubgroupRotate = value; }
  Bool32 getShaderSubgroupRotate() const { return this->shaderSubgroupRotate; }
  void setShaderSubgroupRotateClustered(Bool32 value) { this->shaderSubgroupRotateClustered = value; }
  Bool32 getShaderSubgroupRotateClustered() const { return this->shaderSubgroupRotateClustered; }
  void setShaderFloatControls2(Bool32 value) { this->shaderFloatControls2 = value; }
  Bool32 getShaderFloatControls2() const { return this->shaderFloatControls2; }
  void setShaderExpectAssume(Bool32 value) { this->shaderExpectAssume = value; }
  Bool32 getShaderExpectAssume() const { return this->shaderExpectAssume; }
  void setRectangularLines(Bool32 value) { this->rectangularLines = value; }
  Bool32 getRectangularLines() const { return this->rectangularLines; }
  void setBresenhamLines(Bool32 value) { this->bresenhamLines = value; }
  Bool32 getBresenhamLines() const { return this->bresenhamLines; }
  void setSmoothLines(Bool32 value) { this->smoothLines = value; }
  Bool32 getSmoothLines() const { return this->smoothLines; }
  void setStippledRectangularLines(Bool32 value) { this->stippledRectangularLines = value; }
  Bool32 getStippledRectangularLines() const { return this->stippledRectangularLines; }
  void setStippledBresenhamLines(Bool32 value) { this->stippledBresenhamLines = value; }
  Bool32 getStippledBresenhamLines() const { return this->stippledBresenhamLines; }
  void setStippledSmoothLines(Bool32 value) { this->stippledSmoothLines = value; }
  Bool32 getStippledSmoothLines() const { return this->stippledSmoothLines; }
  void setVertexAttributeInstanceRateDivisor(Bool32 value) { this->vertexAttributeInstanceRateDivisor = value; }
  Bool32 getVertexAttributeInstanceRateDivisor() const { return this->vertexAttributeInstanceRateDivisor; }
  void setVertexAttributeInstanceRateZeroDivisor(Bool32 value) { this->vertexAttributeInstanceRateZeroDivisor = value; }
  Bool32 getVertexAttributeInstanceRateZeroDivisor() const { return this->vertexAttributeInstanceRateZeroDivisor; }
  void setIndexTypeUint8(Bool32 value) { this->indexTypeUint8 = value; }
  Bool32 getIndexTypeUint8() const { return this->indexTypeUint8; }
  void setDynamicRenderingLocalRead(Bool32 value) { this->dynamicRenderingLocalRead = value; }
  Bool32 getDynamicRenderingLocalRead() const { return this->dynamicRenderingLocalRead; }
  void setMaintenance5(Bool32 value) { this->maintenance5 = value; }
  Bool32 getMaintenance5() const { return this->maintenance5; }
  void setMaintenance6(Bool32 value) { this->maintenance6 = value; }
  Bool32 getMaintenance6() const { return this->maintenance6; }
  void setPipelineProtectedAccess(Bool32 value) { this->pipelineProtectedAccess = value; }
  Bool32 getPipelineProtectedAccess() const { return this->pipelineProtectedAccess; }
  void setPipelineRobustness(Bool32 value) { this->pipelineRobustness = value; }
  Bool32 getPipelineRobustness() const { return this->pipelineRobustness; }
  void setHostImageCopy(Bool32 value) { this->hostImageCopy = value; }
  Bool32 getHostImageCopy() const { return this->hostImageCopy; }
  void setPushDescriptor(Bool32 value) { this->pushDescriptor = value; }
  Bool32 getPushDescriptor() const { return this->pushDescriptor; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceVulkan14Features& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceVulkan14Features& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_4

#if VK_ARM_shader_core_builtins
struct PhysicalDeviceShaderCoreBuiltinsFeaturesARM : VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM {
  PhysicalDeviceShaderCoreBuiltinsFeaturesARM() noexcept : VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM} {}

  void setShaderCoreBuiltins(Bool32 value) { this->shaderCoreBuiltins = value; }
  Bool32 getShaderCoreBuiltins() const { return this->shaderCoreBuiltins; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceShaderCoreBuiltinsFeaturesARM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceShaderCoreBuiltinsFeaturesARM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_ARM_shader_core_builtins

#if VK_EXT_frame_boundary
struct PhysicalDeviceFrameBoundaryFeaturesEXT : VkPhysicalDeviceFrameBoundaryFeaturesEXT {
  PhysicalDeviceFrameBoundaryFeaturesEXT() noexcept : VkPhysicalDeviceFrameBoundaryFeaturesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT} {}

  void setFrameBoundary(Bool32 value) { this->frameBoundary = value; }
  Bool32 getFrameBoundary() const { return this->frameBoundary; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceFrameBoundaryFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceFrameBoundaryFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_frame_boundary

#if VK_EXT_dynamic_rendering_unused_attachments
struct PhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT : VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT {
  PhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT() noexcept : VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT} {}

  void setDynamicRenderingUnusedAttachments(Bool32 value) { this->dynamicRenderingUnusedAttachments = value; }
  Bool32 getDynamicRenderingUnusedAttachments() const { return this->dynamicRenderingUnusedAttachments; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_dynamic_rendering_unused_attachments

#if VK_EXT_image_view_min_lod
struct PhysicalDeviceImageViewMinLodFeaturesEXT : VkPhysicalDeviceImageViewMinLodFeaturesEXT {
  PhysicalDeviceImageViewMinLodFeaturesEXT() noexcept : VkPhysicalDeviceImageViewMinLodFeaturesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT} {}

  void setMinLod(Bool32 value) { this->minLod = value; }
  Bool32 getMinLod() const { return this->minLod; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceImageViewMinLodFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceImageViewMinLodFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_image_view_min_lod

#if VK_EXT_subpass_merge_feedback
struct PhysicalDeviceSubpassMergeFeedbackFeaturesEXT : VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT {
  PhysicalDeviceSubpassMergeFeedbackFeaturesEXT() noexcept : VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT} {}

  void setSubpassMergeFeedback(Bool32 value) { this->subpassMergeFeedback = value; }
  Bool32 getSubpassMergeFeedback() const { return this->subpassMergeFeedback; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceSubpassMergeFeedbackFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceSubpassMergeFeedbackFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_subpass_merge_feedback

#if VK_SEC_amigo_profiling
struct PhysicalDeviceAmigoProfilingFeaturesSEC : VkPhysicalDeviceAmigoProfilingFeaturesSEC {
  PhysicalDeviceAmigoProfilingFeaturesSEC() noexcept : VkPhysicalDeviceAmigoProfilingFeaturesSEC{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC} {}

  void setAmigoProfiling(Bool32 value) { this->amigoProfiling = value; }
  Bool32 getAmigoProfiling() const { return this->amigoProfiling; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceAmigoProfilingFeaturesSEC& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceAmigoProfilingFeaturesSEC& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_SEC_amigo_profiling

#if VK_KHR_swapchain_maintenance1
struct PhysicalDeviceSwapchainMaintenance1FeaturesKHR : VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR {
  PhysicalDeviceSwapchainMaintenance1FeaturesKHR() noexcept : VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_KHR} {}

  void setSwapchainMaintenance1(Bool32 value) { this->swapchainMaintenance1 = value; }
  Bool32 getSwapchainMaintenance1() const { return this->swapchainMaintenance1; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceSwapchainMaintenance1FeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceSwapchainMaintenance1FeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_swapchain_maintenance1

#if VK_KHR_pipeline_binary
struct PhysicalDevicePipelineBinaryFeaturesKHR : VkPhysicalDevicePipelineBinaryFeaturesKHR {
  PhysicalDevicePipelineBinaryFeaturesKHR() noexcept : VkPhysicalDevicePipelineBinaryFeaturesKHR{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_FEATURES_KHR} {}

  void setPipelineBinaries(Bool32 value) { this->pipelineBinaries = value; }
  Bool32 getPipelineBinaries() const { return this->pipelineBinaries; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDevicePipelineBinaryFeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDevicePipelineBinaryFeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_pipeline_binary

#if VK_QCOM_image_processing
struct PhysicalDeviceImageProcessingFeaturesQCOM : VkPhysicalDeviceImageProcessingFeaturesQCOM {
  PhysicalDeviceImageProcessingFeaturesQCOM() noexcept : VkPhysicalDeviceImageProcessingFeaturesQCOM{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM} {}

  void setTextureSampleWeighted(Bool32 value) { this->textureSampleWeighted = value; }
  Bool32 getTextureSampleWeighted() const { return this->textureSampleWeighted; }
  void setTextureBoxFilter(Bool32 value) { this->textureBoxFilter = value; }
  Bool32 getTextureBoxFilter() const { return this->textureBoxFilter; }
  void setTextureBlockMatch(Bool32 value) { this->textureBlockMatch = value; }
  Bool32 getTextureBlockMatch() const { return this->textureBlockMatch; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceImageProcessingFeaturesQCOM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceImageProcessingFeaturesQCOM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_QCOM_image_processing

#if VK_NV_fragment_shading_rate_enums
struct PhysicalDeviceFragmentShadingRateEnumsFeaturesNV : VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV {
  PhysicalDeviceFragmentShadingRateEnumsFeaturesNV() noexcept : VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV} {}

  void setFragmentShadingRateEnums(Bool32 value) { this->fragmentShadingRateEnums = value; }
  Bool32 getFragmentShadingRateEnums() const { return this->fragmentShadingRateEnums; }
  void setSupersampleFragmentShadingRates(Bool32 value) { this->supersampleFragmentShadingRates = value; }
  Bool32 getSupersampleFragmentShadingRates() const { return this->supersampleFragmentShadingRates; }
  void setNoInvocationFragmentShadingRates(Bool32 value) { this->noInvocationFragmentShadingRates = value; }
  Bool32 getNoInvocationFragmentShadingRates() const { return this->noInvocationFragmentShadingRates; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceFragmentShadingRateEnumsFeaturesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceFragmentShadingRateEnumsFeaturesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_fragment_shading_rate_enums

#if VK_EXT_ycbcr_image_arrays
struct PhysicalDeviceYcbcrImageArraysFeaturesEXT : VkPhysicalDeviceYcbcrImageArraysFeaturesEXT {
  PhysicalDeviceYcbcrImageArraysFeaturesEXT() noexcept : VkPhysicalDeviceYcbcrImageArraysFeaturesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT} {}

  void setYcbcrImageArrays(Bool32 value) { this->ycbcrImageArrays = value; }
  Bool32 getYcbcrImageArrays() const { return this->ycbcrImageArrays; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceYcbcrImageArraysFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceYcbcrImageArraysFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_ycbcr_image_arrays

#if VK_VERSION_1_1
struct PhysicalDeviceProtectedMemoryFeatures : VkPhysicalDeviceProtectedMemoryFeatures {
  PhysicalDeviceProtectedMemoryFeatures() noexcept : VkPhysicalDeviceProtectedMemoryFeatures{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES} {}

  void setProtectedMemory(Bool32 value) { this->protectedMemory = value; }
  Bool32 getProtectedMemory() const { return this->protectedMemory; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceProtectedMemoryFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceProtectedMemoryFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_1

#if VK_EXT_depth_clip_enable
struct PhysicalDeviceDepthClipEnableFeaturesEXT : VkPhysicalDeviceDepthClipEnableFeaturesEXT {
  PhysicalDeviceDepthClipEnableFeaturesEXT() noexcept : VkPhysicalDeviceDepthClipEnableFeaturesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT} {}

  void setDepthClipEnable(Bool32 value) { this->depthClipEnable = value; }
  Bool32 getDepthClipEnable() const { return this->depthClipEnable; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceDepthClipEnableFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceDepthClipEnableFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_depth_clip_enable

#if VK_EXT_depth_bias_control
struct PhysicalDeviceDepthBiasControlFeaturesEXT : VkPhysicalDeviceDepthBiasControlFeaturesEXT {
  PhysicalDeviceDepthBiasControlFeaturesEXT() noexcept : VkPhysicalDeviceDepthBiasControlFeaturesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT} {}

  void setDepthBiasControl(Bool32 value) { this->depthBiasControl = value; }
  Bool32 getDepthBiasControl() const { return this->depthBiasControl; }
  void setLeastRepresentableValueForceUnormRepresentation(Bool32 value) { this->leastRepresentableValueForceUnormRepresentation = value; }
  Bool32 getLeastRepresentableValueForceUnormRepresentation() const { return this->leastRepresentableValueForceUnormRepresentation; }
  void setFloatRepresentation(Bool32 value) { this->floatRepresentation = value; }
  Bool32 getFloatRepresentation() const { return this->floatRepresentation; }
  void setDepthBiasExact(Bool32 value) { this->depthBiasExact = value; }
  Bool32 getDepthBiasExact() const { return this->depthBiasExact; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceDepthBiasControlFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceDepthBiasControlFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_depth_bias_control

#if VK_NV_ray_tracing_invocation_reorder
struct PhysicalDeviceRayTracingInvocationReorderFeaturesNV : VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV {
  PhysicalDeviceRayTracingInvocationReorderFeaturesNV() noexcept : VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV} {}

  void setRayTracingInvocationReorder(Bool32 value) { this->rayTracingInvocationReorder = value; }
  Bool32 getRayTracingInvocationReorder() const { return this->rayTracingInvocationReorder; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceRayTracingInvocationReorderFeaturesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceRayTracingInvocationReorderFeaturesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_ray_tracing_invocation_reorder

#if VK_NV_extended_sparse_address_space
struct PhysicalDeviceExtendedSparseAddressSpaceFeaturesNV : VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV {
  PhysicalDeviceExtendedSparseAddressSpaceFeaturesNV() noexcept : VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_FEATURES_NV} {}

  void setExtendedSparseAddressSpace(Bool32 value) { this->extendedSparseAddressSpace = value; }
  Bool32 getExtendedSparseAddressSpace() const { return this->extendedSparseAddressSpace; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceExtendedSparseAddressSpaceFeaturesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceExtendedSparseAddressSpaceFeaturesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_extended_sparse_address_space

#if VK_VALVE_descriptor_set_host_mapping
struct PhysicalDeviceDescriptorSetHostMappingFeaturesVALVE : VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE {
  PhysicalDeviceDescriptorSetHostMappingFeaturesVALVE() noexcept : VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE} {}

  void setDescriptorSetHostMapping(Bool32 value) { this->descriptorSetHostMapping = value; }
  Bool32 getDescriptorSetHostMapping() const { return this->descriptorSetHostMapping; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceDescriptorSetHostMappingFeaturesVALVE& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceDescriptorSetHostMappingFeaturesVALVE& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VALVE_descriptor_set_host_mapping

#if VK_QCOM_multiview_per_view_viewports
struct PhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM : VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM {
  PhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM() noexcept : VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM} {}

  void setMultiviewPerViewViewports(Bool32 value) { this->multiviewPerViewViewports = value; }
  Bool32 getMultiviewPerViewViewports() const { return this->multiviewPerViewViewports; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_QCOM_multiview_per_view_viewports

#if VK_KHR_ray_tracing_position_fetch
struct PhysicalDeviceRayTracingPositionFetchFeaturesKHR : VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR {
  PhysicalDeviceRayTracingPositionFetchFeaturesKHR() noexcept : VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR} {}

  void setRayTracingPositionFetch(Bool32 value) { this->rayTracingPositionFetch = value; }
  Bool32 getRayTracingPositionFetch() const { return this->rayTracingPositionFetch; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceRayTracingPositionFetchFeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceRayTracingPositionFetchFeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_ray_tracing_position_fetch

#if VK_QCOM_multiview_per_view_render_areas
struct PhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM : VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM {
  PhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM() noexcept : VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM} {}

  void setMultiviewPerViewRenderAreas(Bool32 value) { this->multiviewPerViewRenderAreas = value; }
  Bool32 getMultiviewPerViewRenderAreas() const { return this->multiviewPerViewRenderAreas; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_QCOM_multiview_per_view_render_areas

#if VK_VERSION_1_4
struct PhysicalDevicePipelineRobustnessFeatures : VkPhysicalDevicePipelineRobustnessFeatures {
  PhysicalDevicePipelineRobustnessFeatures() noexcept : VkPhysicalDevicePipelineRobustnessFeatures{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES} {}

  void setPipelineRobustness(Bool32 value) { this->pipelineRobustness = value; }
  Bool32 getPipelineRobustness() const { return this->pipelineRobustness; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDevicePipelineRobustnessFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDevicePipelineRobustnessFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_4

#if VK_QCOM_tile_properties
struct PhysicalDeviceTilePropertiesFeaturesQCOM : VkPhysicalDeviceTilePropertiesFeaturesQCOM {
  PhysicalDeviceTilePropertiesFeaturesQCOM() noexcept : VkPhysicalDeviceTilePropertiesFeaturesQCOM{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM} {}

  void setTileProperties(Bool32 value) { this->tileProperties = value; }
  Bool32 getTileProperties() const { return this->tileProperties; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceTilePropertiesFeaturesQCOM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceTilePropertiesFeaturesQCOM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_QCOM_tile_properties

#if VK_KHR_performance_query
struct PhysicalDevicePerformanceQueryFeaturesKHR : VkPhysicalDevicePerformanceQueryFeaturesKHR {
  PhysicalDevicePerformanceQueryFeaturesKHR() noexcept : VkPhysicalDevicePerformanceQueryFeaturesKHR{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR} {}

  // performance counters supported in query pools
  void setPerformanceCounterQueryPools(Bool32 value) { this->performanceCounterQueryPools = value; }
  Bool32 getPerformanceCounterQueryPools() const { return this->performanceCounterQueryPools; }
  // performance counters from multiple query pools can be accessed in the same primary command buffer
  void setPerformanceCounterMultipleQueryPools(Bool32 value) { this->performanceCounterMultipleQueryPools = value; }
  Bool32 getPerformanceCounterMultipleQueryPools() const { return this->performanceCounterMultipleQueryPools; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDevicePerformanceQueryFeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDevicePerformanceQueryFeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_performance_query

#if VK_EXT_shader_object
struct PhysicalDeviceShaderObjectFeaturesEXT : VkPhysicalDeviceShaderObjectFeaturesEXT {
  PhysicalDeviceShaderObjectFeaturesEXT() noexcept : VkPhysicalDeviceShaderObjectFeaturesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT} {}

  void setShaderObject(Bool32 value) { this->shaderObject = value; }
  Bool32 getShaderObject() const { return this->shaderObject; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceShaderObjectFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceShaderObjectFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_shader_object

#if VK_EXT_shader_tile_image
struct PhysicalDeviceShaderTileImageFeaturesEXT : VkPhysicalDeviceShaderTileImageFeaturesEXT {
  PhysicalDeviceShaderTileImageFeaturesEXT() noexcept : VkPhysicalDeviceShaderTileImageFeaturesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT} {}

  void setShaderTileImageColorReadAccess(Bool32 value) { this->shaderTileImageColorReadAccess = value; }
  Bool32 getShaderTileImageColorReadAccess() const { return this->shaderTileImageColorReadAccess; }
  void setShaderTileImageDepthReadAccess(Bool32 value) { this->shaderTileImageDepthReadAccess = value; }
  Bool32 getShaderTileImageDepthReadAccess() const { return this->shaderTileImageDepthReadAccess; }
  void setShaderTileImageStencilReadAccess(Bool32 value) { this->shaderTileImageStencilReadAccess = value; }
  Bool32 getShaderTileImageStencilReadAccess() const { return this->shaderTileImageStencilReadAccess; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceShaderTileImageFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceShaderTileImageFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_shader_tile_image

#if VK_EXT_extended_dynamic_state3
struct PhysicalDeviceExtendedDynamicState3FeaturesEXT : VkPhysicalDeviceExtendedDynamicState3FeaturesEXT {
  PhysicalDeviceExtendedDynamicState3FeaturesEXT() noexcept : VkPhysicalDeviceExtendedDynamicState3FeaturesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT} {}

  void setExtendedDynamicState3TessellationDomainOrigin(Bool32 value) { this->extendedDynamicState3TessellationDomainOrigin = value; }
  Bool32 getExtendedDynamicState3TessellationDomainOrigin() const { return this->extendedDynamicState3TessellationDomainOrigin; }
  void setExtendedDynamicState3DepthClampEnable(Bool32 value) { this->extendedDynamicState3DepthClampEnable = value; }
  Bool32 getExtendedDynamicState3DepthClampEnable() const { return this->extendedDynamicState3DepthClampEnable; }
  void setExtendedDynamicState3PolygonMode(Bool32 value) { this->extendedDynamicState3PolygonMode = value; }
  Bool32 getExtendedDynamicState3PolygonMode() const { return this->extendedDynamicState3PolygonMode; }
  void setExtendedDynamicState3RasterizationSamples(Bool32 value) { this->extendedDynamicState3RasterizationSamples = value; }
  Bool32 getExtendedDynamicState3RasterizationSamples() const { return this->extendedDynamicState3RasterizationSamples; }
  void setExtendedDynamicState3SampleMask(Bool32 value) { this->extendedDynamicState3SampleMask = value; }
  Bool32 getExtendedDynamicState3SampleMask() const { return this->extendedDynamicState3SampleMask; }
  void setExtendedDynamicState3AlphaToCoverageEnable(Bool32 value) { this->extendedDynamicState3AlphaToCoverageEnable = value; }
  Bool32 getExtendedDynamicState3AlphaToCoverageEnable() const { return this->extendedDynamicState3AlphaToCoverageEnable; }
  void setExtendedDynamicState3AlphaToOneEnable(Bool32 value) { this->extendedDynamicState3AlphaToOneEnable = value; }
  Bool32 getExtendedDynamicState3AlphaToOneEnable() const { return this->extendedDynamicState3AlphaToOneEnable; }
  void setExtendedDynamicState3LogicOpEnable(Bool32 value) { this->extendedDynamicState3LogicOpEnable = value; }
  Bool32 getExtendedDynamicState3LogicOpEnable() const { return this->extendedDynamicState3LogicOpEnable; }
  void setExtendedDynamicState3ColorBlendEnable(Bool32 value) { this->extendedDynamicState3ColorBlendEnable = value; }
  Bool32 getExtendedDynamicState3ColorBlendEnable() const { return this->extendedDynamicState3ColorBlendEnable; }
  void setExtendedDynamicState3ColorBlendEquation(Bool32 value) { this->extendedDynamicState3ColorBlendEquation = value; }
  Bool32 getExtendedDynamicState3ColorBlendEquation() const { return this->extendedDynamicState3ColorBlendEquation; }
  void setExtendedDynamicState3ColorWriteMask(Bool32 value) { this->extendedDynamicState3ColorWriteMask = value; }
  Bool32 getExtendedDynamicState3ColorWriteMask() const { return this->extendedDynamicState3ColorWriteMask; }
  void setExtendedDynamicState3RasterizationStream(Bool32 value) { this->extendedDynamicState3RasterizationStream = value; }
  Bool32 getExtendedDynamicState3RasterizationStream() const { return this->extendedDynamicState3RasterizationStream; }
  void setExtendedDynamicState3ConservativeRasterizationMode(Bool32 value) { this->extendedDynamicState3ConservativeRasterizationMode = value; }
  Bool32 getExtendedDynamicState3ConservativeRasterizationMode() const { return this->extendedDynamicState3ConservativeRasterizationMode; }
  void setExtendedDynamicState3ExtraPrimitiveOverestimationSize(Bool32 value) { this->extendedDynamicState3ExtraPrimitiveOverestimationSize = value; }
  Bool32 getExtendedDynamicState3ExtraPrimitiveOverestimationSize() const { return this->extendedDynamicState3ExtraPrimitiveOverestimationSize; }
  void setExtendedDynamicState3DepthClipEnable(Bool32 value) { this->extendedDynamicState3DepthClipEnable = value; }
  Bool32 getExtendedDynamicState3DepthClipEnable() const { return this->extendedDynamicState3DepthClipEnable; }
  void setExtendedDynamicState3SampleLocationsEnable(Bool32 value) { this->extendedDynamicState3SampleLocationsEnable = value; }
  Bool32 getExtendedDynamicState3SampleLocationsEnable() const { return this->extendedDynamicState3SampleLocationsEnable; }
  void setExtendedDynamicState3ColorBlendAdvanced(Bool32 value) { this->extendedDynamicState3ColorBlendAdvanced = value; }
  Bool32 getExtendedDynamicState3ColorBlendAdvanced() const { return this->extendedDynamicState3ColorBlendAdvanced; }
  void setExtendedDynamicState3ProvokingVertexMode(Bool32 value) { this->extendedDynamicState3ProvokingVertexMode = value; }
  Bool32 getExtendedDynamicState3ProvokingVertexMode() const { return this->extendedDynamicState3ProvokingVertexMode; }
  void setExtendedDynamicState3LineRasterizationMode(Bool32 value) { this->extendedDynamicState3LineRasterizationMode = value; }
  Bool32 getExtendedDynamicState3LineRasterizationMode() const { return this->extendedDynamicState3LineRasterizationMode; }
  void setExtendedDynamicState3LineStippleEnable(Bool32 value) { this->extendedDynamicState3LineStippleEnable = value; }
  Bool32 getExtendedDynamicState3LineStippleEnable() const { return this->extendedDynamicState3LineStippleEnable; }
  void setExtendedDynamicState3DepthClipNegativeOneToOne(Bool32 value) { this->extendedDynamicState3DepthClipNegativeOneToOne = value; }
  Bool32 getExtendedDynamicState3DepthClipNegativeOneToOne() const { return this->extendedDynamicState3DepthClipNegativeOneToOne; }
  void setExtendedDynamicState3ViewportWScalingEnable(Bool32 value) { this->extendedDynamicState3ViewportWScalingEnable = value; }
  Bool32 getExtendedDynamicState3ViewportWScalingEnable() const { return this->extendedDynamicState3ViewportWScalingEnable; }
  void setExtendedDynamicState3ViewportSwizzle(Bool32 value) { this->extendedDynamicState3ViewportSwizzle = value; }
  Bool32 getExtendedDynamicState3ViewportSwizzle() const { return this->extendedDynamicState3ViewportSwizzle; }
  void setExtendedDynamicState3CoverageToColorEnable(Bool32 value) { this->extendedDynamicState3CoverageToColorEnable = value; }
  Bool32 getExtendedDynamicState3CoverageToColorEnable() const { return this->extendedDynamicState3CoverageToColorEnable; }
  void setExtendedDynamicState3CoverageToColorLocation(Bool32 value) { this->extendedDynamicState3CoverageToColorLocation = value; }
  Bool32 getExtendedDynamicState3CoverageToColorLocation() const { return this->extendedDynamicState3CoverageToColorLocation; }
  void setExtendedDynamicState3CoverageModulationMode(Bool32 value) { this->extendedDynamicState3CoverageModulationMode = value; }
  Bool32 getExtendedDynamicState3CoverageModulationMode() const { return this->extendedDynamicState3CoverageModulationMode; }
  void setExtendedDynamicState3CoverageModulationTableEnable(Bool32 value) { this->extendedDynamicState3CoverageModulationTableEnable = value; }
  Bool32 getExtendedDynamicState3CoverageModulationTableEnable() const { return this->extendedDynamicState3CoverageModulationTableEnable; }
  void setExtendedDynamicState3CoverageModulationTable(Bool32 value) { this->extendedDynamicState3CoverageModulationTable = value; }
  Bool32 getExtendedDynamicState3CoverageModulationTable() const { return this->extendedDynamicState3CoverageModulationTable; }
  void setExtendedDynamicState3CoverageReductionMode(Bool32 value) { this->extendedDynamicState3CoverageReductionMode = value; }
  Bool32 getExtendedDynamicState3CoverageReductionMode() const { return this->extendedDynamicState3CoverageReductionMode; }
  void setExtendedDynamicState3RepresentativeFragmentTestEnable(Bool32 value) { this->extendedDynamicState3RepresentativeFragmentTestEnable = value; }
  Bool32 getExtendedDynamicState3RepresentativeFragmentTestEnable() const { return this->extendedDynamicState3RepresentativeFragmentTestEnable; }
  void setExtendedDynamicState3ShadingRateImageEnable(Bool32 value) { this->extendedDynamicState3ShadingRateImageEnable = value; }
  Bool32 getExtendedDynamicState3ShadingRateImageEnable() const { return this->extendedDynamicState3ShadingRateImageEnable; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceExtendedDynamicState3FeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceExtendedDynamicState3FeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_extended_dynamic_state3

#if VK_QNX_external_memory_screen_buffer
struct PhysicalDeviceExternalMemoryScreenBufferFeaturesQNX : VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX {
  PhysicalDeviceExternalMemoryScreenBufferFeaturesQNX() noexcept : VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCREEN_BUFFER_FEATURES_QNX} {}

  void setScreenBufferImport(Bool32 value) { this->screenBufferImport = value; }
  Bool32 getScreenBufferImport() const { return this->screenBufferImport; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceExternalMemoryScreenBufferFeaturesQNX& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceExternalMemoryScreenBufferFeaturesQNX& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_QNX_external_memory_screen_buffer

#if VK_KHR_cooperative_matrix
struct PhysicalDeviceCooperativeMatrixFeaturesKHR : VkPhysicalDeviceCooperativeMatrixFeaturesKHR {
  PhysicalDeviceCooperativeMatrixFeaturesKHR() noexcept : VkPhysicalDeviceCooperativeMatrixFeaturesKHR{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR} {}

  void setCooperativeMatrix(Bool32 value) { this->cooperativeMatrix = value; }
  Bool32 getCooperativeMatrix() const { return this->cooperativeMatrix; }
  void setCooperativeMatrixRobustBufferAccess(Bool32 value) { this->cooperativeMatrixRobustBufferAccess = value; }
  Bool32 getCooperativeMatrixRobustBufferAccess() const { return this->cooperativeMatrixRobustBufferAccess; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceCooperativeMatrixFeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceCooperativeMatrixFeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_cooperative_matrix

#if VK_EXT_image_sliced_view_of_3d
struct PhysicalDeviceImageSlicedViewOf3DFeaturesEXT : VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT {
  PhysicalDeviceImageSlicedViewOf3DFeaturesEXT() noexcept : VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT} {}

  void setImageSlicedViewOf3D(Bool32 value) { this->imageSlicedViewOf3D = value; }
  Bool32 getImageSlicedViewOf3D() const { return this->imageSlicedViewOf3D; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceImageSlicedViewOf3DFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceImageSlicedViewOf3DFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_image_sliced_view_of_3d

#if VK_EXT_astc_decode_mode
struct PhysicalDeviceASTCDecodeFeaturesEXT : VkPhysicalDeviceASTCDecodeFeaturesEXT {
  PhysicalDeviceASTCDecodeFeaturesEXT() noexcept : VkPhysicalDeviceASTCDecodeFeaturesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT} {}

  void setDecodeModeSharedExponent(Bool32 value) { this->decodeModeSharedExponent = value; }
  Bool32 getDecodeModeSharedExponent() const { return this->decodeModeSharedExponent; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceASTCDecodeFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceASTCDecodeFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_astc_decode_mode

#if VK_EXT_border_color_swizzle
struct PhysicalDeviceBorderColorSwizzleFeaturesEXT : VkPhysicalDeviceBorderColorSwizzleFeaturesEXT {
  PhysicalDeviceBorderColorSwizzleFeaturesEXT() noexcept : VkPhysicalDeviceBorderColorSwizzleFeaturesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT} {}

  void setBorderColorSwizzle(Bool32 value) { this->borderColorSwizzle = value; }
  Bool32 getBorderColorSwizzle() const { return this->borderColorSwizzle; }
  void setBorderColorSwizzleFromImage(Bool32 value) { this->borderColorSwizzleFromImage = value; }
  Bool32 getBorderColorSwizzleFromImage() const { return this->borderColorSwizzleFromImage; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceBorderColorSwizzleFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceBorderColorSwizzleFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_border_color_swizzle

#if VK_AMD_anti_lag
struct PhysicalDeviceAntiLagFeaturesAMD : VkPhysicalDeviceAntiLagFeaturesAMD {
  PhysicalDeviceAntiLagFeaturesAMD() noexcept : VkPhysicalDeviceAntiLagFeaturesAMD{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ANTI_LAG_FEATURES_AMD} {}

  void setAntiLag(Bool32 value) { this->antiLag = value; }
  Bool32 getAntiLag() const { return this->antiLag; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceAntiLagFeaturesAMD& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceAntiLagFeaturesAMD& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_AMD_anti_lag

#if VK_EXT_pageable_device_local_memory
struct PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT : VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT {
  PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT() noexcept : VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT} {}

  void setPageableDeviceLocalMemory(Bool32 value) { this->pageableDeviceLocalMemory = value; }
  Bool32 getPageableDeviceLocalMemory() const { return this->pageableDeviceLocalMemory; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_pageable_device_local_memory

#if VK_VERSION_1_2
struct PhysicalDeviceTimelineSemaphoreFeatures : VkPhysicalDeviceTimelineSemaphoreFeatures {
  PhysicalDeviceTimelineSemaphoreFeatures() noexcept : VkPhysicalDeviceTimelineSemaphoreFeatures{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES} {}

  void setTimelineSemaphore(Bool32 value) { this->timelineSemaphore = value; }
  Bool32 getTimelineSemaphore() const { return this->timelineSemaphore; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceTimelineSemaphoreFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceTimelineSemaphoreFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_2

#if VK_QCOM_tile_memory_heap
struct PhysicalDeviceTileMemoryHeapFeaturesQCOM : VkPhysicalDeviceTileMemoryHeapFeaturesQCOM {
  PhysicalDeviceTileMemoryHeapFeaturesQCOM() noexcept : VkPhysicalDeviceTileMemoryHeapFeaturesQCOM{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_FEATURES_QCOM} {}

  void setTileMemoryHeap(Bool32 value) { this->tileMemoryHeap = value; }
  Bool32 getTileMemoryHeap() const { return this->tileMemoryHeap; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceTileMemoryHeapFeaturesQCOM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceTileMemoryHeapFeaturesQCOM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_QCOM_tile_memory_heap

#if VK_VERSION_1_3
struct PhysicalDeviceVulkan13Features : VkPhysicalDeviceVulkan13Features {
  PhysicalDeviceVulkan13Features() noexcept : VkPhysicalDeviceVulkan13Features{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES} {}

  void setRobustImageAccess(Bool32 value) { this->robustImageAccess = value; }
  Bool32 getRobustImageAccess() const { return this->robustImageAccess; }
  void setInlineUniformBlock(Bool32 value) { this->inlineUniformBlock = value; }
  Bool32 getInlineUniformBlock() const { return this->inlineUniformBlock; }
  void setDescriptorBindingInlineUniformBlockUpdateAfterBind(Bool32 value) { this->descriptorBindingInlineUniformBlockUpdateAfterBind = value; }
  Bool32 getDescriptorBindingInlineUniformBlockUpdateAfterBind() const { return this->descriptorBindingInlineUniformBlockUpdateAfterBind; }
  void setPipelineCreationCacheControl(Bool32 value) { this->pipelineCreationCacheControl = value; }
  Bool32 getPipelineCreationCacheControl() const { return this->pipelineCreationCacheControl; }
  void setPrivateData(Bool32 value) { this->privateData = value; }
  Bool32 getPrivateData() const { return this->privateData; }
  void setShaderDemoteToHelperInvocation(Bool32 value) { this->shaderDemoteToHelperInvocation = value; }
  Bool32 getShaderDemoteToHelperInvocation() const { return this->shaderDemoteToHelperInvocation; }
  void setShaderTerminateInvocation(Bool32 value) { this->shaderTerminateInvocation = value; }
  Bool32 getShaderTerminateInvocation() const { return this->shaderTerminateInvocation; }
  void setSubgroupSizeControl(Bool32 value) { this->subgroupSizeControl = value; }
  Bool32 getSubgroupSizeControl() const { return this->subgroupSizeControl; }
  void setComputeFullSubgroups(Bool32 value) { this->computeFullSubgroups = value; }
  Bool32 getComputeFullSubgroups() const { return this->computeFullSubgroups; }
  void setSynchronization2(Bool32 value) { this->synchronization2 = value; }
  Bool32 getSynchronization2() const { return this->synchronization2; }
  void setTextureCompressionASTC_HDR(Bool32 value) { this->textureCompressionASTC_HDR = value; }
  Bool32 getTextureCompressionASTC_HDR() const { return this->textureCompressionASTC_HDR; }
  void setShaderZeroInitializeWorkgroupMemory(Bool32 value) { this->shaderZeroInitializeWorkgroupMemory = value; }
  Bool32 getShaderZeroInitializeWorkgroupMemory() const { return this->shaderZeroInitializeWorkgroupMemory; }
  void setDynamicRendering(Bool32 value) { this->dynamicRendering = value; }
  Bool32 getDynamicRendering() const { return this->dynamicRendering; }
  void setShaderIntegerDotProduct(Bool32 value) { this->shaderIntegerDotProduct = value; }
  Bool32 getShaderIntegerDotProduct() const { return this->shaderIntegerDotProduct; }
  void setMaintenance4(Bool32 value) { this->maintenance4 = value; }
  Bool32 getMaintenance4() const { return this->maintenance4; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceVulkan13Features& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceVulkan13Features& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_3

#if VK_EXT_fragment_density_map
struct PhysicalDeviceFragmentDensityMapFeaturesEXT : VkPhysicalDeviceFragmentDensityMapFeaturesEXT {
  PhysicalDeviceFragmentDensityMapFeaturesEXT() noexcept : VkPhysicalDeviceFragmentDensityMapFeaturesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT} {}

  void setFragmentDensityMap(Bool32 value) { this->fragmentDensityMap = value; }
  Bool32 getFragmentDensityMap() const { return this->fragmentDensityMap; }
  void setFragmentDensityMapDynamic(Bool32 value) { this->fragmentDensityMapDynamic = value; }
  Bool32 getFragmentDensityMapDynamic() const { return this->fragmentDensityMapDynamic; }
  void setFragmentDensityMapNonSubsampledImages(Bool32 value) { this->fragmentDensityMapNonSubsampledImages = value; }
  Bool32 getFragmentDensityMapNonSubsampledImages() const { return this->fragmentDensityMapNonSubsampledImages; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceFragmentDensityMapFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceFragmentDensityMapFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_fragment_density_map

#if VK_EXT_vertex_input_dynamic_state
struct PhysicalDeviceVertexInputDynamicStateFeaturesEXT : VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT {
  PhysicalDeviceVertexInputDynamicStateFeaturesEXT() noexcept : VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT} {}

  void setVertexInputDynamicState(Bool32 value) { this->vertexInputDynamicState = value; }
  Bool32 getVertexInputDynamicState() const { return this->vertexInputDynamicState; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceVertexInputDynamicStateFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceVertexInputDynamicStateFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_vertex_input_dynamic_state

#if VK_KHR_acceleration_structure
struct PhysicalDeviceAccelerationStructureFeaturesKHR : VkPhysicalDeviceAccelerationStructureFeaturesKHR {
  PhysicalDeviceAccelerationStructureFeaturesKHR() noexcept : VkPhysicalDeviceAccelerationStructureFeaturesKHR{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR} {}

  void setAccelerationStructure(Bool32 value) { this->accelerationStructure = value; }
  Bool32 getAccelerationStructure() const { return this->accelerationStructure; }
  void setAccelerationStructureCaptureReplay(Bool32 value) { this->accelerationStructureCaptureReplay = value; }
  Bool32 getAccelerationStructureCaptureReplay() const { return this->accelerationStructureCaptureReplay; }
  void setAccelerationStructureIndirectBuild(Bool32 value) { this->accelerationStructureIndirectBuild = value; }
  Bool32 getAccelerationStructureIndirectBuild() const { return this->accelerationStructureIndirectBuild; }
  void setAccelerationStructureHostCommands(Bool32 value) { this->accelerationStructureHostCommands = value; }
  Bool32 getAccelerationStructureHostCommands() const { return this->accelerationStructureHostCommands; }
  void setDescriptorBindingAccelerationStructureUpdateAfterBind(Bool32 value) { this->descriptorBindingAccelerationStructureUpdateAfterBind = value; }
  Bool32 getDescriptorBindingAccelerationStructureUpdateAfterBind() const { return this->descriptorBindingAccelerationStructureUpdateAfterBind; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceAccelerationStructureFeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceAccelerationStructureFeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_acceleration_structure

#if VK_NV_device_generated_commands
struct PhysicalDeviceDeviceGeneratedCommandsFeaturesNV : VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV {
  PhysicalDeviceDeviceGeneratedCommandsFeaturesNV() noexcept : VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV} {}

  void setDeviceGeneratedCommands(Bool32 value) { this->deviceGeneratedCommands = value; }
  Bool32 getDeviceGeneratedCommands() const { return this->deviceGeneratedCommands; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceDeviceGeneratedCommandsFeaturesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceDeviceGeneratedCommandsFeaturesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_device_generated_commands

#if VK_VERSION_1_3
struct PhysicalDeviceTextureCompressionASTCHDRFeatures : VkPhysicalDeviceTextureCompressionASTCHDRFeatures {
  PhysicalDeviceTextureCompressionASTCHDRFeatures() noexcept : VkPhysicalDeviceTextureCompressionASTCHDRFeatures{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES} {}

  void setTextureCompressionASTC_HDR(Bool32 value) { this->textureCompressionASTC_HDR = value; }
  Bool32 getTextureCompressionASTC_HDR() const { return this->textureCompressionASTC_HDR; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceTextureCompressionASTCHDRFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceTextureCompressionASTCHDRFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_3

#if VK_QCOM_filter_cubic_clamp
struct PhysicalDeviceCubicClampFeaturesQCOM : VkPhysicalDeviceCubicClampFeaturesQCOM {
  PhysicalDeviceCubicClampFeaturesQCOM() noexcept : VkPhysicalDeviceCubicClampFeaturesQCOM{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM} {}

  void setCubicRangeClamp(Bool32 value) { this->cubicRangeClamp = value; }
  Bool32 getCubicRangeClamp() const { return this->cubicRangeClamp; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceCubicClampFeaturesQCOM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceCubicClampFeaturesQCOM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_QCOM_filter_cubic_clamp

#if VK_QCOM_ycbcr_degamma
struct PhysicalDeviceYcbcrDegammaFeaturesQCOM : VkPhysicalDeviceYcbcrDegammaFeaturesQCOM {
  PhysicalDeviceYcbcrDegammaFeaturesQCOM() noexcept : VkPhysicalDeviceYcbcrDegammaFeaturesQCOM{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM} {}

  void setYcbcrDegamma(Bool32 value) { this->ycbcrDegamma = value; }
  Bool32 getYcbcrDegamma() const { return this->ycbcrDegamma; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceYcbcrDegammaFeaturesQCOM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceYcbcrDegammaFeaturesQCOM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_QCOM_ycbcr_degamma

#if VK_EXT_4444_formats
struct PhysicalDevice4444FormatsFeaturesEXT : VkPhysicalDevice4444FormatsFeaturesEXT {
  PhysicalDevice4444FormatsFeaturesEXT() noexcept : VkPhysicalDevice4444FormatsFeaturesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT} {}

  void setFormatA4R4G4B4(Bool32 value) { this->formatA4R4G4B4 = value; }
  Bool32 getFormatA4R4G4B4() const { return this->formatA4R4G4B4; }
  void setFormatA4B4G4R4(Bool32 value) { this->formatA4B4G4R4 = value; }
  Bool32 getFormatA4B4G4R4() const { return this->formatA4B4G4R4; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDevice4444FormatsFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDevice4444FormatsFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_4444_formats

#if VK_QCOM_filter_cubic_weights
struct PhysicalDeviceCubicWeightsFeaturesQCOM : VkPhysicalDeviceCubicWeightsFeaturesQCOM {
  PhysicalDeviceCubicWeightsFeaturesQCOM() noexcept : VkPhysicalDeviceCubicWeightsFeaturesQCOM{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM} {}

  void setSelectableCubicWeights(Bool32 value) { this->selectableCubicWeights = value; }
  Bool32 getSelectableCubicWeights() const { return this->selectableCubicWeights; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceCubicWeightsFeaturesQCOM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceCubicWeightsFeaturesQCOM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_QCOM_filter_cubic_weights

#if VK_QCOM_image_processing2
struct PhysicalDeviceImageProcessing2FeaturesQCOM : VkPhysicalDeviceImageProcessing2FeaturesQCOM {
  PhysicalDeviceImageProcessing2FeaturesQCOM() noexcept : VkPhysicalDeviceImageProcessing2FeaturesQCOM{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM} {}

  void setTextureBlockMatch2(Bool32 value) { this->textureBlockMatch2 = value; }
  Bool32 getTextureBlockMatch2() const { return this->textureBlockMatch2; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceImageProcessing2FeaturesQCOM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceImageProcessing2FeaturesQCOM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_QCOM_image_processing2

#if VK_NV_descriptor_pool_overallocation
struct PhysicalDeviceDescriptorPoolOverallocationFeaturesNV : VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV {
  PhysicalDeviceDescriptorPoolOverallocationFeaturesNV() noexcept : VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV} {}

  void setDescriptorPoolOverallocation(Bool32 value) { this->descriptorPoolOverallocation = value; }
  Bool32 getDescriptorPoolOverallocation() const { return this->descriptorPoolOverallocation; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceDescriptorPoolOverallocationFeaturesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceDescriptorPoolOverallocationFeaturesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_descriptor_pool_overallocation

#if VK_NV_per_stage_descriptor_set
struct PhysicalDevicePerStageDescriptorSetFeaturesNV : VkPhysicalDevicePerStageDescriptorSetFeaturesNV {
  PhysicalDevicePerStageDescriptorSetFeaturesNV() noexcept : VkPhysicalDevicePerStageDescriptorSetFeaturesNV{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PER_STAGE_DESCRIPTOR_SET_FEATURES_NV} {}

  void setPerStageDescriptorSet(Bool32 value) { this->perStageDescriptorSet = value; }
  Bool32 getPerStageDescriptorSet() const { return this->perStageDescriptorSet; }
  void setDynamicPipelineLayout(Bool32 value) { this->dynamicPipelineLayout = value; }
  Bool32 getDynamicPipelineLayout() const { return this->dynamicPipelineLayout; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDevicePerStageDescriptorSetFeaturesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDevicePerStageDescriptorSetFeaturesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_per_stage_descriptor_set

#if VK_ANDROID_external_format_resolve
struct PhysicalDeviceExternalFormatResolveFeaturesANDROID : VkPhysicalDeviceExternalFormatResolveFeaturesANDROID {
  PhysicalDeviceExternalFormatResolveFeaturesANDROID() noexcept : VkPhysicalDeviceExternalFormatResolveFeaturesANDROID{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_FEATURES_ANDROID} {}

  void setExternalFormatResolve(Bool32 value) { this->externalFormatResolve = value; }
  Bool32 getExternalFormatResolve() const { return this->externalFormatResolve; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceExternalFormatResolveFeaturesANDROID& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceExternalFormatResolveFeaturesANDROID& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_ANDROID_external_format_resolve

#if VK_NV_linear_color_attachment
struct PhysicalDeviceLinearColorAttachmentFeaturesNV : VkPhysicalDeviceLinearColorAttachmentFeaturesNV {
  PhysicalDeviceLinearColorAttachmentFeaturesNV() noexcept : VkPhysicalDeviceLinearColorAttachmentFeaturesNV{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV} {}

  void setLinearColorAttachment(Bool32 value) { this->linearColorAttachment = value; }
  Bool32 getLinearColorAttachment() const { return this->linearColorAttachment; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceLinearColorAttachmentFeaturesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceLinearColorAttachmentFeaturesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_linear_color_attachment

#if VK_NV_representative_fragment_test
struct PhysicalDeviceRepresentativeFragmentTestFeaturesNV : VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV {
  PhysicalDeviceRepresentativeFragmentTestFeaturesNV() noexcept : VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV} {}

  void setRepresentativeFragmentTest(Bool32 value) { this->representativeFragmentTest = value; }
  Bool32 getRepresentativeFragmentTest() const { return this->representativeFragmentTest; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceRepresentativeFragmentTestFeaturesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceRepresentativeFragmentTestFeaturesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_representative_fragment_test

#if VK_NV_ray_tracing_linear_swept_spheres
struct PhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV : VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV {
  PhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV() noexcept : VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_LINEAR_SWEPT_SPHERES_FEATURES_NV} {}

  void setSpheres(Bool32 value) { this->spheres = value; }
  Bool32 getSpheres() const { return this->spheres; }
  void setLinearSweptSpheres(Bool32 value) { this->linearSweptSpheres = value; }
  Bool32 getLinearSweptSpheres() const { return this->linearSweptSpheres; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_ray_tracing_linear_swept_spheres

#if VK_ARM_scheduling_controls
struct PhysicalDeviceSchedulingControlsFeaturesARM : VkPhysicalDeviceSchedulingControlsFeaturesARM {
  PhysicalDeviceSchedulingControlsFeaturesARM() noexcept : VkPhysicalDeviceSchedulingControlsFeaturesARM{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_FEATURES_ARM} {}

  void setSchedulingControls(Bool32 value) { this->schedulingControls = value; }
  Bool32 getSchedulingControls() const { return this->schedulingControls; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceSchedulingControlsFeaturesARM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceSchedulingControlsFeaturesARM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_ARM_scheduling_controls

#if VK_IMG_relaxed_line_rasterization
struct PhysicalDeviceRelaxedLineRasterizationFeaturesIMG : VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG {
  PhysicalDeviceRelaxedLineRasterizationFeaturesIMG() noexcept : VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RELAXED_LINE_RASTERIZATION_FEATURES_IMG} {}

  void setRelaxedLineRasterization(Bool32 value) { this->relaxedLineRasterization = value; }
  Bool32 getRelaxedLineRasterization() const { return this->relaxedLineRasterization; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceRelaxedLineRasterizationFeaturesIMG& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceRelaxedLineRasterizationFeaturesIMG& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_IMG_relaxed_line_rasterization

#if VK_ARM_render_pass_striped
struct PhysicalDeviceRenderPassStripedFeaturesARM : VkPhysicalDeviceRenderPassStripedFeaturesARM {
  PhysicalDeviceRenderPassStripedFeaturesARM() noexcept : VkPhysicalDeviceRenderPassStripedFeaturesARM{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_FEATURES_ARM} {}

  void setRenderPassStriped(Bool32 value) { this->renderPassStriped = value; }
  Bool32 getRenderPassStriped() const { return this->renderPassStriped; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceRenderPassStripedFeaturesARM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceRenderPassStripedFeaturesARM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_ARM_render_pass_striped

#if VK_KHR_workgroup_memory_explicit_layout
struct PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR : VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR {
  PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR() noexcept : VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR} {}

  void setWorkgroupMemoryExplicitLayout(Bool32 value) { this->workgroupMemoryExplicitLayout = value; }
  Bool32 getWorkgroupMemoryExplicitLayout() const { return this->workgroupMemoryExplicitLayout; }
  void setWorkgroupMemoryExplicitLayoutScalarBlockLayout(Bool32 value) { this->workgroupMemoryExplicitLayoutScalarBlockLayout = value; }
  Bool32 getWorkgroupMemoryExplicitLayoutScalarBlockLayout() const { return this->workgroupMemoryExplicitLayoutScalarBlockLayout; }
  void setWorkgroupMemoryExplicitLayout8BitAccess(Bool32 value) { this->workgroupMemoryExplicitLayout8BitAccess = value; }
  Bool32 getWorkgroupMemoryExplicitLayout8BitAccess() const { return this->workgroupMemoryExplicitLayout8BitAccess; }
  void setWorkgroupMemoryExplicitLayout16BitAccess(Bool32 value) { this->workgroupMemoryExplicitLayout16BitAccess = value; }
  Bool32 getWorkgroupMemoryExplicitLayout16BitAccess() const { return this->workgroupMemoryExplicitLayout16BitAccess; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_workgroup_memory_explicit_layout

#if VK_ARM_pipeline_opacity_micromap
struct PhysicalDevicePipelineOpacityMicromapFeaturesARM : VkPhysicalDevicePipelineOpacityMicromapFeaturesARM {
  PhysicalDevicePipelineOpacityMicromapFeaturesARM() noexcept : VkPhysicalDevicePipelineOpacityMicromapFeaturesARM{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_OPACITY_MICROMAP_FEATURES_ARM} {}

  void setPipelineOpacityMicromap(Bool32 value) { this->pipelineOpacityMicromap = value; }
  Bool32 getPipelineOpacityMicromap() const { return this->pipelineOpacityMicromap; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDevicePipelineOpacityMicromapFeaturesARM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDevicePipelineOpacityMicromapFeaturesARM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_ARM_pipeline_opacity_micromap

#if VK_KHR_shader_maximal_reconvergence
struct PhysicalDeviceShaderMaximalReconvergenceFeaturesKHR : VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR {
  PhysicalDeviceShaderMaximalReconvergenceFeaturesKHR() noexcept : VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MAXIMAL_RECONVERGENCE_FEATURES_KHR} {}

  void setShaderMaximalReconvergence(Bool32 value) { this->shaderMaximalReconvergence = value; }
  Bool32 getShaderMaximalReconvergence() const { return this->shaderMaximalReconvergence; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceShaderMaximalReconvergenceFeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceShaderMaximalReconvergenceFeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_shader_maximal_reconvergence

#if VK_VERSION_1_4
struct PhysicalDeviceShaderSubgroupRotateFeatures : VkPhysicalDeviceShaderSubgroupRotateFeatures {
  PhysicalDeviceShaderSubgroupRotateFeatures() noexcept : VkPhysicalDeviceShaderSubgroupRotateFeatures{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES} {}

  void setShaderSubgroupRotate(Bool32 value) { this->shaderSubgroupRotate = value; }
  Bool32 getShaderSubgroupRotate() const { return this->shaderSubgroupRotate; }
  void setShaderSubgroupRotateClustered(Bool32 value) { this->shaderSubgroupRotateClustered = value; }
  Bool32 getShaderSubgroupRotateClustered() const { return this->shaderSubgroupRotateClustered; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceShaderSubgroupRotateFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceShaderSubgroupRotateFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }

struct PhysicalDeviceShaderExpectAssumeFeatures : VkPhysicalDeviceShaderExpectAssumeFeatures {
  PhysicalDeviceShaderExpectAssumeFeatures() noexcept : VkPhysicalDeviceShaderExpectAssumeFeatures{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES} {}

  void setShaderExpectAssume(Bool32 value) { this->shaderExpectAssume = value; }
  Bool32 getShaderExpectAssume() const { return this->shaderExpectAssume; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceShaderExpectAssumeFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceShaderExpectAssumeFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }

struct PhysicalDeviceShaderFloatControls2Features : VkPhysicalDeviceShaderFloatControls2Features {
  PhysicalDeviceShaderFloatControls2Features() noexcept : VkPhysicalDeviceShaderFloatControls2Features{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES} {}

  void setShaderFloatControls2(Bool32 value) { this->shaderFloatControls2 = value; }
  Bool32 getShaderFloatControls2() const { return this->shaderFloatControls2; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceShaderFloatControls2Features& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceShaderFloatControls2Features& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }

struct PhysicalDeviceDynamicRenderingLocalReadFeatures : VkPhysicalDeviceDynamicRenderingLocalReadFeatures {
  PhysicalDeviceDynamicRenderingLocalReadFeatures() noexcept : VkPhysicalDeviceDynamicRenderingLocalReadFeatures{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES} {}

  void setDynamicRenderingLocalRead(Bool32 value) { this->dynamicRenderingLocalRead = value; }
  Bool32 getDynamicRenderingLocalRead() const { return this->dynamicRenderingLocalRead; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceDynamicRenderingLocalReadFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceDynamicRenderingLocalReadFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_4

#if VK_KHR_shader_quad_control
struct PhysicalDeviceShaderQuadControlFeaturesKHR : VkPhysicalDeviceShaderQuadControlFeaturesKHR {
  PhysicalDeviceShaderQuadControlFeaturesKHR() noexcept : VkPhysicalDeviceShaderQuadControlFeaturesKHR{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_QUAD_CONTROL_FEATURES_KHR} {}

  void setShaderQuadControl(Bool32 value) { this->shaderQuadControl = value; }
  Bool32 getShaderQuadControl() const { return this->shaderQuadControl; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceShaderQuadControlFeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceShaderQuadControlFeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_shader_quad_control

#if VK_NV_shader_atomic_float16_vector
struct PhysicalDeviceShaderAtomicFloat16VectorFeaturesNV : VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV {
  PhysicalDeviceShaderAtomicFloat16VectorFeaturesNV() noexcept : VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT16_VECTOR_FEATURES_NV} {}

  void setShaderFloat16VectorAtomics(Bool32 value) { this->shaderFloat16VectorAtomics = value; }
  Bool32 getShaderFloat16VectorAtomics() const { return this->shaderFloat16VectorAtomics; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceShaderAtomicFloat16VectorFeaturesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceShaderAtomicFloat16VectorFeaturesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_shader_atomic_float16_vector

#if VK_EXT_map_memory_placed
struct PhysicalDeviceMapMemoryPlacedFeaturesEXT : VkPhysicalDeviceMapMemoryPlacedFeaturesEXT {
  PhysicalDeviceMapMemoryPlacedFeaturesEXT() noexcept : VkPhysicalDeviceMapMemoryPlacedFeaturesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_FEATURES_EXT} {}

  void setMemoryMapPlaced(Bool32 value) { this->memoryMapPlaced = value; }
  Bool32 getMemoryMapPlaced() const { return this->memoryMapPlaced; }
  void setMemoryMapRangePlaced(Bool32 value) { this->memoryMapRangePlaced = value; }
  Bool32 getMemoryMapRangePlaced() const { return this->memoryMapRangePlaced; }
  void setMemoryUnmapReserve(Bool32 value) { this->memoryUnmapReserve = value; }
  Bool32 getMemoryUnmapReserve() const { return this->memoryUnmapReserve; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceMapMemoryPlacedFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceMapMemoryPlacedFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_map_memory_placed

#if VK_KHR_shader_bfloat16
struct PhysicalDeviceShaderBfloat16FeaturesKHR : VkPhysicalDeviceShaderBfloat16FeaturesKHR {
  PhysicalDeviceShaderBfloat16FeaturesKHR() noexcept : VkPhysicalDeviceShaderBfloat16FeaturesKHR{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_BFLOAT16_FEATURES_KHR} {}

  void setShaderBFloat16Type(Bool32 value) { this->shaderBFloat16Type = value; }
  Bool32 getShaderBFloat16Type() const { return this->shaderBFloat16Type; }
  void setShaderBFloat16DotProduct(Bool32 value) { this->shaderBFloat16DotProduct = value; }
  Bool32 getShaderBFloat16DotProduct() const { return this->shaderBFloat16DotProduct; }
  void setShaderBFloat16CooperativeMatrix(Bool32 value) { this->shaderBFloat16CooperativeMatrix = value; }
  Bool32 getShaderBFloat16CooperativeMatrix() const { return this->shaderBFloat16CooperativeMatrix; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceShaderBfloat16FeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceShaderBfloat16FeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_shader_bfloat16

#if VK_NV_raw_access_chains
struct PhysicalDeviceRawAccessChainsFeaturesNV : VkPhysicalDeviceRawAccessChainsFeaturesNV {
  PhysicalDeviceRawAccessChainsFeaturesNV() noexcept : VkPhysicalDeviceRawAccessChainsFeaturesNV{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAW_ACCESS_CHAINS_FEATURES_NV} {}

  void setShaderRawAccessChains(Bool32 value) { this->shaderRawAccessChains = value; }
  Bool32 getShaderRawAccessChains() const { return this->shaderRawAccessChains; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceRawAccessChainsFeaturesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceRawAccessChainsFeaturesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_raw_access_chains

#if VK_NV_command_buffer_inheritance
struct PhysicalDeviceCommandBufferInheritanceFeaturesNV : VkPhysicalDeviceCommandBufferInheritanceFeaturesNV {
  PhysicalDeviceCommandBufferInheritanceFeaturesNV() noexcept : VkPhysicalDeviceCommandBufferInheritanceFeaturesNV{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMMAND_BUFFER_INHERITANCE_FEATURES_NV} {}

  void setCommandBufferInheritance(Bool32 value) { this->commandBufferInheritance = value; }
  Bool32 getCommandBufferInheritance() const { return this->commandBufferInheritance; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceCommandBufferInheritanceFeaturesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceCommandBufferInheritanceFeaturesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_command_buffer_inheritance

#if VK_MESA_image_alignment_control
struct PhysicalDeviceImageAlignmentControlFeaturesMESA : VkPhysicalDeviceImageAlignmentControlFeaturesMESA {
  PhysicalDeviceImageAlignmentControlFeaturesMESA() noexcept : VkPhysicalDeviceImageAlignmentControlFeaturesMESA{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_FEATURES_MESA} {}

  void setImageAlignmentControl(Bool32 value) { this->imageAlignmentControl = value; }
  Bool32 getImageAlignmentControl() const { return this->imageAlignmentControl; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceImageAlignmentControlFeaturesMESA& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceImageAlignmentControlFeaturesMESA& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_MESA_image_alignment_control

#if VK_VERSION_1_1
struct PhysicalDeviceShaderDrawParametersFeatures : VkPhysicalDeviceShaderDrawParametersFeatures {
  PhysicalDeviceShaderDrawParametersFeatures() noexcept : VkPhysicalDeviceShaderDrawParametersFeatures{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES} {}

  void setShaderDrawParameters(Bool32 value) { this->shaderDrawParameters = value; }
  Bool32 getShaderDrawParameters() const { return this->shaderDrawParameters; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceShaderDrawParametersFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceShaderDrawParametersFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_1

#if VK_EXT_shader_replicated_composites
struct PhysicalDeviceShaderReplicatedCompositesFeaturesEXT : VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT {
  PhysicalDeviceShaderReplicatedCompositesFeaturesEXT() noexcept : VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_REPLICATED_COMPOSITES_FEATURES_EXT} {}

  void setShaderReplicatedComposites(Bool32 value) { this->shaderReplicatedComposites = value; }
  Bool32 getShaderReplicatedComposites() const { return this->shaderReplicatedComposites; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceShaderReplicatedCompositesFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceShaderReplicatedCompositesFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_shader_replicated_composites

#if VK_KHR_present_mode_fifo_latest_ready
struct PhysicalDevicePresentModeFifoLatestReadyFeaturesKHR : VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR {
  PhysicalDevicePresentModeFifoLatestReadyFeaturesKHR() noexcept : VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_KHR} {}

  void setPresentModeFifoLatestReady(Bool32 value) { this->presentModeFifoLatestReady = value; }
  Bool32 getPresentModeFifoLatestReady() const { return this->presentModeFifoLatestReady; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDevicePresentModeFifoLatestReadyFeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDevicePresentModeFifoLatestReadyFeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_present_mode_fifo_latest_ready

#if VK_VERSION_1_3
struct PhysicalDevicePipelineCreationCacheControlFeatures : VkPhysicalDevicePipelineCreationCacheControlFeatures {
  PhysicalDevicePipelineCreationCacheControlFeatures() noexcept : VkPhysicalDevicePipelineCreationCacheControlFeatures{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES} {}

  void setPipelineCreationCacheControl(Bool32 value) { this->pipelineCreationCacheControl = value; }
  Bool32 getPipelineCreationCacheControl() const { return this->pipelineCreationCacheControl; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDevicePipelineCreationCacheControlFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDevicePipelineCreationCacheControlFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_3

#if VK_NV_cooperative_matrix2
struct PhysicalDeviceCooperativeMatrix2FeaturesNV : VkPhysicalDeviceCooperativeMatrix2FeaturesNV {
  PhysicalDeviceCooperativeMatrix2FeaturesNV() noexcept : VkPhysicalDeviceCooperativeMatrix2FeaturesNV{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_FEATURES_NV} {}

  void setCooperativeMatrixWorkgroupScope(Bool32 value) { this->cooperativeMatrixWorkgroupScope = value; }
  Bool32 getCooperativeMatrixWorkgroupScope() const { return this->cooperativeMatrixWorkgroupScope; }
  void setCooperativeMatrixFlexibleDimensions(Bool32 value) { this->cooperativeMatrixFlexibleDimensions = value; }
  Bool32 getCooperativeMatrixFlexibleDimensions() const { return this->cooperativeMatrixFlexibleDimensions; }
  void setCooperativeMatrixReductions(Bool32 value) { this->cooperativeMatrixReductions = value; }
  Bool32 getCooperativeMatrixReductions() const { return this->cooperativeMatrixReductions; }
  void setCooperativeMatrixConversions(Bool32 value) { this->cooperativeMatrixConversions = value; }
  Bool32 getCooperativeMatrixConversions() const { return this->cooperativeMatrixConversions; }
  void setCooperativeMatrixPerElementOperations(Bool32 value) { this->cooperativeMatrixPerElementOperations = value; }
  Bool32 getCooperativeMatrixPerElementOperations() const { return this->cooperativeMatrixPerElementOperations; }
  void setCooperativeMatrixTensorAddressing(Bool32 value) { this->cooperativeMatrixTensorAddressing = value; }
  Bool32 getCooperativeMatrixTensorAddressing() const { return this->cooperativeMatrixTensorAddressing; }
  void setCooperativeMatrixBlockLoads(Bool32 value) { this->cooperativeMatrixBlockLoads = value; }
  Bool32 getCooperativeMatrixBlockLoads() const { return this->cooperativeMatrixBlockLoads; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceCooperativeMatrix2FeaturesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceCooperativeMatrix2FeaturesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_cooperative_matrix2

#if VK_NV_shader_sm_builtins
struct PhysicalDeviceShaderSMBuiltinsFeaturesNV : VkPhysicalDeviceShaderSMBuiltinsFeaturesNV {
  PhysicalDeviceShaderSMBuiltinsFeaturesNV() noexcept : VkPhysicalDeviceShaderSMBuiltinsFeaturesNV{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV} {}

  void setShaderSMBuiltins(Bool32 value) { this->shaderSMBuiltins = value; }
  Bool32 getShaderSMBuiltins() const { return this->shaderSMBuiltins; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceShaderSMBuiltinsFeaturesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceShaderSMBuiltinsFeaturesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_shader_sm_builtins

#if VK_HUAWEI_hdr_vivid
struct PhysicalDeviceHdrVividFeaturesHUAWEI : VkPhysicalDeviceHdrVividFeaturesHUAWEI {
  PhysicalDeviceHdrVividFeaturesHUAWEI() noexcept : VkPhysicalDeviceHdrVividFeaturesHUAWEI{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HDR_VIVID_FEATURES_HUAWEI} {}

  void setHdrVivid(Bool32 value) { this->hdrVivid = value; }
  Bool32 getHdrVivid() const { return this->hdrVivid; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceHdrVividFeaturesHUAWEI& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceHdrVividFeaturesHUAWEI& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_HUAWEI_hdr_vivid

#if VK_EXT_vertex_attribute_robustness
struct PhysicalDeviceVertexAttributeRobustnessFeaturesEXT : VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT {
  PhysicalDeviceVertexAttributeRobustnessFeaturesEXT() noexcept : VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_ROBUSTNESS_FEATURES_EXT} {}

  void setVertexAttributeRobustness(Bool32 value) { this->vertexAttributeRobustness = value; }
  Bool32 getVertexAttributeRobustness() const { return this->vertexAttributeRobustness; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceVertexAttributeRobustnessFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceVertexAttributeRobustnessFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_vertex_attribute_robustness

#if VK_KHR_depth_clamp_zero_one
struct PhysicalDeviceDepthClampZeroOneFeaturesKHR : VkPhysicalDeviceDepthClampZeroOneFeaturesKHR {
  PhysicalDeviceDepthClampZeroOneFeaturesKHR() noexcept : VkPhysicalDeviceDepthClampZeroOneFeaturesKHR{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_KHR} {}

  void setDepthClampZeroOne(Bool32 value) { this->depthClampZeroOne = value; }
  Bool32 getDepthClampZeroOne() const { return this->depthClampZeroOne; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceDepthClampZeroOneFeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceDepthClampZeroOneFeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_depth_clamp_zero_one

#if VK_NV_cooperative_vector
struct PhysicalDeviceCooperativeVectorFeaturesNV : VkPhysicalDeviceCooperativeVectorFeaturesNV {
  PhysicalDeviceCooperativeVectorFeaturesNV() noexcept : VkPhysicalDeviceCooperativeVectorFeaturesNV{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_FEATURES_NV} {}

  void setCooperativeVector(Bool32 value) { this->cooperativeVector = value; }
  Bool32 getCooperativeVector() const { return this->cooperativeVector; }
  void setCooperativeVectorTraining(Bool32 value) { this->cooperativeVectorTraining = value; }
  Bool32 getCooperativeVectorTraining() const { return this->cooperativeVectorTraining; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceCooperativeVectorFeaturesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceCooperativeVectorFeaturesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_cooperative_vector

#if VK_QCOM_tile_shading
struct PhysicalDeviceTileShadingFeaturesQCOM : VkPhysicalDeviceTileShadingFeaturesQCOM {
  PhysicalDeviceTileShadingFeaturesQCOM() noexcept : VkPhysicalDeviceTileShadingFeaturesQCOM{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_FEATURES_QCOM} {}

  void setTileShading(Bool32 value) { this->tileShading = value; }
  Bool32 getTileShading() const { return this->tileShading; }
  void setTileShadingFragmentStage(Bool32 value) { this->tileShadingFragmentStage = value; }
  Bool32 getTileShadingFragmentStage() const { return this->tileShadingFragmentStage; }
  void setTileShadingColorAttachments(Bool32 value) { this->tileShadingColorAttachments = value; }
  Bool32 getTileShadingColorAttachments() const { return this->tileShadingColorAttachments; }
  void setTileShadingDepthAttachments(Bool32 value) { this->tileShadingDepthAttachments = value; }
  Bool32 getTileShadingDepthAttachments() const { return this->tileShadingDepthAttachments; }
  void setTileShadingStencilAttachments(Bool32 value) { this->tileShadingStencilAttachments = value; }
  Bool32 getTileShadingStencilAttachments() const { return this->tileShadingStencilAttachments; }
  void setTileShadingInputAttachments(Bool32 value) { this->tileShadingInputAttachments = value; }
  Bool32 getTileShadingInputAttachments() const { return this->tileShadingInputAttachments; }
  void setTileShadingSampledAttachments(Bool32 value) { this->tileShadingSampledAttachments = value; }
  Bool32 getTileShadingSampledAttachments() const { return this->tileShadingSampledAttachments; }
  void setTileShadingPerTileDraw(Bool32 value) { this->tileShadingPerTileDraw = value; }
  Bool32 getTileShadingPerTileDraw() const { return this->tileShadingPerTileDraw; }
  void setTileShadingPerTileDispatch(Bool32 value) { this->tileShadingPerTileDispatch = value; }
  Bool32 getTileShadingPerTileDispatch() const { return this->tileShadingPerTileDispatch; }
  void setTileShadingDispatchTile(Bool32 value) { this->tileShadingDispatchTile = value; }
  Bool32 getTileShadingDispatchTile() const { return this->tileShadingDispatchTile; }
  void setTileShadingApron(Bool32 value) { this->tileShadingApron = value; }
  Bool32 getTileShadingApron() const { return this->tileShadingApron; }
  void setTileShadingAnisotropicApron(Bool32 value) { this->tileShadingAnisotropicApron = value; }
  Bool32 getTileShadingAnisotropicApron() const { return this->tileShadingAnisotropicApron; }
  void setTileShadingAtomicOps(Bool32 value) { this->tileShadingAtomicOps = value; }
  Bool32 getTileShadingAtomicOps() const { return this->tileShadingAtomicOps; }
  void setTileShadingImageProcessing(Bool32 value) { this->tileShadingImageProcessing = value; }
  Bool32 getTileShadingImageProcessing() const { return this->tileShadingImageProcessing; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceTileShadingFeaturesQCOM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceTileShadingFeaturesQCOM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_QCOM_tile_shading

#if VK_NV_inherited_viewport_scissor
struct PhysicalDeviceInheritedViewportScissorFeaturesNV : VkPhysicalDeviceInheritedViewportScissorFeaturesNV {
  PhysicalDeviceInheritedViewportScissorFeaturesNV() noexcept : VkPhysicalDeviceInheritedViewportScissorFeaturesNV{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV} {}

  void setInheritedViewportScissor2D(Bool32 value) { this->inheritedViewportScissor2D = value; }
  Bool32 getInheritedViewportScissor2D() const { return this->inheritedViewportScissor2D; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceInheritedViewportScissorFeaturesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceInheritedViewportScissorFeaturesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_inherited_viewport_scissor

#if VK_NV_cluster_acceleration_structure
struct PhysicalDeviceClusterAccelerationStructureFeaturesNV : VkPhysicalDeviceClusterAccelerationStructureFeaturesNV {
  PhysicalDeviceClusterAccelerationStructureFeaturesNV() noexcept : VkPhysicalDeviceClusterAccelerationStructureFeaturesNV{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_FEATURES_NV} {}

  void setClusterAccelerationStructure(Bool32 value) { this->clusterAccelerationStructure = value; }
  Bool32 getClusterAccelerationStructure() const { return this->clusterAccelerationStructure; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceClusterAccelerationStructureFeaturesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceClusterAccelerationStructureFeaturesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_cluster_acceleration_structure

#if VK_VALVE_fragment_density_map_layered
struct PhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE : VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE {
  PhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE() noexcept : VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_FEATURES_VALVE} {}

  Bool32 getFragmentDensityMapLayered() const { return this->fragmentDensityMapLayered; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VALVE_fragment_density_map_layered

#if VK_EXT_shader_image_atomic_int64
struct PhysicalDeviceShaderImageAtomicInt64FeaturesEXT : VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT {
  PhysicalDeviceShaderImageAtomicInt64FeaturesEXT() noexcept : VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT} {}

  void setShaderImageInt64Atomics(Bool32 value) { this->shaderImageInt64Atomics = value; }
  Bool32 getShaderImageInt64Atomics() const { return this->shaderImageInt64Atomics; }
  void setSparseImageInt64Atomics(Bool32 value) { this->sparseImageInt64Atomics = value; }
  Bool32 getSparseImageInt64Atomics() const { return this->sparseImageInt64Atomics; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceShaderImageAtomicInt64FeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceShaderImageAtomicInt64FeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_shader_image_atomic_int64

#if VK_NV_scissor_exclusive
struct PhysicalDeviceExclusiveScissorFeaturesNV : VkPhysicalDeviceExclusiveScissorFeaturesNV {
  PhysicalDeviceExclusiveScissorFeaturesNV() noexcept : VkPhysicalDeviceExclusiveScissorFeaturesNV{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV} {}

  void setExclusiveScissor(Bool32 value) { this->exclusiveScissor = value; }
  Bool32 getExclusiveScissor() const { return this->exclusiveScissor; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceExclusiveScissorFeaturesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceExclusiveScissorFeaturesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_scissor_exclusive

#if VK_ARM_format_pack
struct PhysicalDeviceFormatPackFeaturesARM : VkPhysicalDeviceFormatPackFeaturesARM {
  PhysicalDeviceFormatPackFeaturesARM() noexcept : VkPhysicalDeviceFormatPackFeaturesARM{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FORMAT_PACK_FEATURES_ARM} {}

  void setFormatPack(Bool32 value) { this->formatPack = value; }
  Bool32 getFormatPack() const { return this->formatPack; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceFormatPackFeaturesARM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceFormatPackFeaturesARM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_ARM_format_pack

#if VK_AMD_device_coherent_memory
struct PhysicalDeviceCoherentMemoryFeaturesAMD : VkPhysicalDeviceCoherentMemoryFeaturesAMD {
  PhysicalDeviceCoherentMemoryFeaturesAMD() noexcept : VkPhysicalDeviceCoherentMemoryFeaturesAMD{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD} {}

  void setDeviceCoherentMemory(Bool32 value) { this->deviceCoherentMemory = value; }
  Bool32 getDeviceCoherentMemory() const { return this->deviceCoherentMemory; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceCoherentMemoryFeaturesAMD& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceCoherentMemoryFeaturesAMD& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_AMD_device_coherent_memory

#if VK_EXT_fragment_density_map2
struct PhysicalDeviceFragmentDensityMap2FeaturesEXT : VkPhysicalDeviceFragmentDensityMap2FeaturesEXT {
  PhysicalDeviceFragmentDensityMap2FeaturesEXT() noexcept : VkPhysicalDeviceFragmentDensityMap2FeaturesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT} {}

  void setFragmentDensityMapDeferred(Bool32 value) { this->fragmentDensityMapDeferred = value; }
  Bool32 getFragmentDensityMapDeferred() const { return this->fragmentDensityMapDeferred; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceFragmentDensityMap2FeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceFragmentDensityMap2FeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_fragment_density_map2

#if VK_EXT_fragment_density_map_offset
struct PhysicalDeviceFragmentDensityMapOffsetFeaturesEXT : VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT {
  PhysicalDeviceFragmentDensityMapOffsetFeaturesEXT() noexcept : VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_EXT} {}

  void setFragmentDensityMapOffset(Bool32 value) { this->fragmentDensityMapOffset = value; }
  Bool32 getFragmentDensityMapOffset() const { return this->fragmentDensityMapOffset; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceFragmentDensityMapOffsetFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceFragmentDensityMapOffsetFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_fragment_density_map_offset

#if VK_ARM_tensors
struct PhysicalDeviceTensorFeaturesARM : VkPhysicalDeviceTensorFeaturesARM {
  PhysicalDeviceTensorFeaturesARM() noexcept : VkPhysicalDeviceTensorFeaturesARM{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_FEATURES_ARM} {}

  void setTensorNonPacked(Bool32 value) { this->tensorNonPacked = value; }
  Bool32 getTensorNonPacked() const { return this->tensorNonPacked; }
  void setShaderTensorAccess(Bool32 value) { this->shaderTensorAccess = value; }
  Bool32 getShaderTensorAccess() const { return this->shaderTensorAccess; }
  void setShaderStorageTensorArrayDynamicIndexing(Bool32 value) { this->shaderStorageTensorArrayDynamicIndexing = value; }
  Bool32 getShaderStorageTensorArrayDynamicIndexing() const { return this->shaderStorageTensorArrayDynamicIndexing; }
  void setShaderStorageTensorArrayNonUniformIndexing(Bool32 value) { this->shaderStorageTensorArrayNonUniformIndexing = value; }
  Bool32 getShaderStorageTensorArrayNonUniformIndexing() const { return this->shaderStorageTensorArrayNonUniformIndexing; }
  void setDescriptorBindingStorageTensorUpdateAfterBind(Bool32 value) { this->descriptorBindingStorageTensorUpdateAfterBind = value; }
  Bool32 getDescriptorBindingStorageTensorUpdateAfterBind() const { return this->descriptorBindingStorageTensorUpdateAfterBind; }
  void setTensors(Bool32 value) { this->tensors = value; }
  Bool32 getTensors() const { return this->tensors; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceTensorFeaturesARM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceTensorFeaturesARM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_ARM_tensors

#if VK_EXT_non_seamless_cube_map
struct PhysicalDeviceNonSeamlessCubeMapFeaturesEXT : VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT {
  PhysicalDeviceNonSeamlessCubeMapFeaturesEXT() noexcept : VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT} {}

  void setNonSeamlessCubeMap(Bool32 value) { this->nonSeamlessCubeMap = value; }
  Bool32 getNonSeamlessCubeMap() const { return this->nonSeamlessCubeMap; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceNonSeamlessCubeMapFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceNonSeamlessCubeMapFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_non_seamless_cube_map

#if VK_HUAWEI_invocation_mask
struct PhysicalDeviceInvocationMaskFeaturesHUAWEI : VkPhysicalDeviceInvocationMaskFeaturesHUAWEI {
  PhysicalDeviceInvocationMaskFeaturesHUAWEI() noexcept : VkPhysicalDeviceInvocationMaskFeaturesHUAWEI{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI} {}

  void setInvocationMask(Bool32 value) { this->invocationMask = value; }
  Bool32 getInvocationMask() const { return this->invocationMask; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceInvocationMaskFeaturesHUAWEI& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceInvocationMaskFeaturesHUAWEI& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_HUAWEI_invocation_mask

#if VK_ARM_tensors
struct PhysicalDeviceDescriptorBufferTensorFeaturesARM : VkPhysicalDeviceDescriptorBufferTensorFeaturesARM {
  PhysicalDeviceDescriptorBufferTensorFeaturesARM() noexcept : VkPhysicalDeviceDescriptorBufferTensorFeaturesARM{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_FEATURES_ARM} {}

  void setDescriptorBufferTensorDescriptors(Bool32 value) { this->descriptorBufferTensorDescriptors = value; }
  Bool32 getDescriptorBufferTensorDescriptors() const { return this->descriptorBufferTensorDescriptors; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceDescriptorBufferTensorFeaturesARM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceDescriptorBufferTensorFeaturesARM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_ARM_tensors

#if VK_EXT_attachment_feedback_loop_layout
struct PhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT : VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT {
  PhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT() noexcept : VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT} {}

  void setAttachmentFeedbackLoopLayout(Bool32 value) { this->attachmentFeedbackLoopLayout = value; }
  Bool32 getAttachmentFeedbackLoopLayout() const { return this->attachmentFeedbackLoopLayout; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_attachment_feedback_loop_layout

#if VK_VERSION_1_2
struct PhysicalDeviceVulkanMemoryModelFeatures : VkPhysicalDeviceVulkanMemoryModelFeatures {
  PhysicalDeviceVulkanMemoryModelFeatures() noexcept : VkPhysicalDeviceVulkanMemoryModelFeatures{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES} {}

  void setVulkanMemoryModel(Bool32 value) { this->vulkanMemoryModel = value; }
  Bool32 getVulkanMemoryModel() const { return this->vulkanMemoryModel; }
  void setVulkanMemoryModelDeviceScope(Bool32 value) { this->vulkanMemoryModelDeviceScope = value; }
  Bool32 getVulkanMemoryModelDeviceScope() const { return this->vulkanMemoryModelDeviceScope; }
  void setVulkanMemoryModelAvailabilityVisibilityChains(Bool32 value) { this->vulkanMemoryModelAvailabilityVisibilityChains = value; }
  Bool32 getVulkanMemoryModelAvailabilityVisibilityChains() const { return this->vulkanMemoryModelAvailabilityVisibilityChains; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceVulkanMemoryModelFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceVulkanMemoryModelFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_2

#if VK_EXT_shader_float8
struct PhysicalDeviceShaderFloat8FeaturesEXT : VkPhysicalDeviceShaderFloat8FeaturesEXT {
  PhysicalDeviceShaderFloat8FeaturesEXT() noexcept : VkPhysicalDeviceShaderFloat8FeaturesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT8_FEATURES_EXT} {}

  void setShaderFloat8(Bool32 value) { this->shaderFloat8 = value; }
  Bool32 getShaderFloat8() const { return this->shaderFloat8; }
  void setShaderFloat8CooperativeMatrix(Bool32 value) { this->shaderFloat8CooperativeMatrix = value; }
  Bool32 getShaderFloat8CooperativeMatrix() const { return this->shaderFloat8CooperativeMatrix; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceShaderFloat8FeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceShaderFloat8FeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_shader_float8

#if VK_KHR_get_physical_device_properties2
using PhysicalDeviceFeatures2KHR = PhysicalDeviceFeatures2;
#endif // VK_KHR_get_physical_device_properties2

#if VK_ARM_data_graph
struct PhysicalDeviceDataGraphFeaturesARM : VkPhysicalDeviceDataGraphFeaturesARM {
  PhysicalDeviceDataGraphFeaturesARM() noexcept : VkPhysicalDeviceDataGraphFeaturesARM{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DATA_GRAPH_FEATURES_ARM} {}

  void setDataGraph(Bool32 value) { this->dataGraph = value; }
  Bool32 getDataGraph() const { return this->dataGraph; }
  void setDataGraphUpdateAfterBind(Bool32 value) { this->dataGraphUpdateAfterBind = value; }
  Bool32 getDataGraphUpdateAfterBind() const { return this->dataGraphUpdateAfterBind; }
  void setDataGraphSpecializationConstants(Bool32 value) { this->dataGraphSpecializationConstants = value; }
  Bool32 getDataGraphSpecializationConstants() const { return this->dataGraphSpecializationConstants; }
  void setDataGraphDescriptorBuffer(Bool32 value) { this->dataGraphDescriptorBuffer = value; }
  Bool32 getDataGraphDescriptorBuffer() const { return this->dataGraphDescriptorBuffer; }
  void setDataGraphShaderModule(Bool32 value) { this->dataGraphShaderModule = value; }
  Bool32 getDataGraphShaderModule() const { return this->dataGraphShaderModule; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceDataGraphFeaturesARM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceDataGraphFeaturesARM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_ARM_data_graph

#if VK_VERSION_1_2
struct PhysicalDevice8BitStorageFeatures : VkPhysicalDevice8BitStorageFeatures {
  PhysicalDevice8BitStorageFeatures() noexcept : VkPhysicalDevice8BitStorageFeatures{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES} {}

  // 8-bit integer variables supported in StorageBuffer
  void setStorageBuffer8BitAccess(Bool32 value) { this->storageBuffer8BitAccess = value; }
  Bool32 getStorageBuffer8BitAccess() const { return this->storageBuffer8BitAccess; }
  // 8-bit integer variables supported in StorageBuffer and Uniform
  void setUniformAndStorageBuffer8BitAccess(Bool32 value) { this->uniformAndStorageBuffer8BitAccess = value; }
  Bool32 getUniformAndStorageBuffer8BitAccess() const { return this->uniformAndStorageBuffer8BitAccess; }
  // 8-bit integer variables supported in PushConstant
  void setStoragePushConstant8(Bool32 value) { this->storagePushConstant8 = value; }
  Bool32 getStoragePushConstant8() const { return this->storagePushConstant8; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDevice8BitStorageFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDevice8BitStorageFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_2

#if VK_EXT_conditional_rendering
struct PhysicalDeviceConditionalRenderingFeaturesEXT : VkPhysicalDeviceConditionalRenderingFeaturesEXT {
  PhysicalDeviceConditionalRenderingFeaturesEXT() noexcept : VkPhysicalDeviceConditionalRenderingFeaturesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT} {}

  void setConditionalRendering(Bool32 value) { this->conditionalRendering = value; }
  Bool32 getConditionalRendering() const { return this->conditionalRendering; }
  void setInheritedConditionalRendering(Bool32 value) { this->inheritedConditionalRendering = value; }
  Bool32 getInheritedConditionalRendering() const { return this->inheritedConditionalRendering; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceConditionalRenderingFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceConditionalRenderingFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_conditional_rendering

#if VK_NV_corner_sampled_image
struct PhysicalDeviceCornerSampledImageFeaturesNV : VkPhysicalDeviceCornerSampledImageFeaturesNV {
  PhysicalDeviceCornerSampledImageFeaturesNV() noexcept : VkPhysicalDeviceCornerSampledImageFeaturesNV{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV} {}

  void setCornerSampledImage(Bool32 value) { this->cornerSampledImage = value; }
  Bool32 getCornerSampledImage() const { return this->cornerSampledImage; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceCornerSampledImageFeaturesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceCornerSampledImageFeaturesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_corner_sampled_image

#if VK_KHR_ray_tracing_maintenance1
struct PhysicalDeviceRayTracingMaintenance1FeaturesKHR : VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR {
  PhysicalDeviceRayTracingMaintenance1FeaturesKHR() noexcept : VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR} {}

  void setRayTracingMaintenance1(Bool32 value) { this->rayTracingMaintenance1 = value; }
  Bool32 getRayTracingMaintenance1() const { return this->rayTracingMaintenance1; }
  void setRayTracingPipelineTraceRaysIndirect2(Bool32 value) { this->rayTracingPipelineTraceRaysIndirect2 = value; }
  Bool32 getRayTracingPipelineTraceRaysIndirect2() const { return this->rayTracingPipelineTraceRaysIndirect2; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceRayTracingMaintenance1FeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceRayTracingMaintenance1FeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_ray_tracing_maintenance1

#if VK_NV_shading_rate_image
struct PhysicalDeviceShadingRateImageFeaturesNV : VkPhysicalDeviceShadingRateImageFeaturesNV {
  PhysicalDeviceShadingRateImageFeaturesNV() noexcept : VkPhysicalDeviceShadingRateImageFeaturesNV{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV} {}

  void setShadingRateImage(Bool32 value) { this->shadingRateImage = value; }
  Bool32 getShadingRateImage() const { return this->shadingRateImage; }
  void setShadingRateCoarseSampleOrder(Bool32 value) { this->shadingRateCoarseSampleOrder = value; }
  Bool32 getShadingRateCoarseSampleOrder() const { return this->shadingRateCoarseSampleOrder; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceShadingRateImageFeaturesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceShadingRateImageFeaturesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_shading_rate_image

#if VK_EXT_zero_initialize_device_memory
struct PhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT : VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT {
  PhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT() noexcept : VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_DEVICE_MEMORY_FEATURES_EXT} {}

  void setZeroInitializeDeviceMemory(Bool32 value) { this->zeroInitializeDeviceMemory = value; }
  Bool32 getZeroInitializeDeviceMemory() const { return this->zeroInitializeDeviceMemory; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_zero_initialize_device_memory

#if VK_EXT_extended_dynamic_state
struct PhysicalDeviceExtendedDynamicStateFeaturesEXT : VkPhysicalDeviceExtendedDynamicStateFeaturesEXT {
  PhysicalDeviceExtendedDynamicStateFeaturesEXT() noexcept : VkPhysicalDeviceExtendedDynamicStateFeaturesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT} {}

  void setExtendedDynamicState(Bool32 value) { this->extendedDynamicState = value; }
  Bool32 getExtendedDynamicState() const { return this->extendedDynamicState; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceExtendedDynamicStateFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceExtendedDynamicStateFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_extended_dynamic_state

#if VK_EXT_device_memory_report
struct PhysicalDeviceDeviceMemoryReportFeaturesEXT : VkPhysicalDeviceDeviceMemoryReportFeaturesEXT {
  PhysicalDeviceDeviceMemoryReportFeaturesEXT() noexcept : VkPhysicalDeviceDeviceMemoryReportFeaturesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT} {}

  void setDeviceMemoryReport(Bool32 value) { this->deviceMemoryReport = value; }
  Bool32 getDeviceMemoryReport() const { return this->deviceMemoryReport; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceDeviceMemoryReportFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceDeviceMemoryReportFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_device_memory_report

#if VK_HUAWEI_subpass_shading
struct PhysicalDeviceSubpassShadingFeaturesHUAWEI : VkPhysicalDeviceSubpassShadingFeaturesHUAWEI {
  PhysicalDeviceSubpassShadingFeaturesHUAWEI() noexcept : VkPhysicalDeviceSubpassShadingFeaturesHUAWEI{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI} {}

  void setSubpassShading(Bool32 value) { this->subpassShading = value; }
  Bool32 getSubpassShading() const { return this->subpassShading; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceSubpassShadingFeaturesHUAWEI& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceSubpassShadingFeaturesHUAWEI& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_HUAWEI_subpass_shading

#if VK_EXT_extended_dynamic_state2
struct PhysicalDeviceExtendedDynamicState2FeaturesEXT : VkPhysicalDeviceExtendedDynamicState2FeaturesEXT {
  PhysicalDeviceExtendedDynamicState2FeaturesEXT() noexcept : VkPhysicalDeviceExtendedDynamicState2FeaturesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT} {}

  void setExtendedDynamicState2(Bool32 value) { this->extendedDynamicState2 = value; }
  Bool32 getExtendedDynamicState2() const { return this->extendedDynamicState2; }
  void setExtendedDynamicState2LogicOp(Bool32 value) { this->extendedDynamicState2LogicOp = value; }
  Bool32 getExtendedDynamicState2LogicOp() const { return this->extendedDynamicState2LogicOp; }
  void setExtendedDynamicState2PatchControlPoints(Bool32 value) { this->extendedDynamicState2PatchControlPoints = value; }
  Bool32 getExtendedDynamicState2PatchControlPoints() const { return this->extendedDynamicState2PatchControlPoints; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceExtendedDynamicState2FeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceExtendedDynamicState2FeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_extended_dynamic_state2

#if VK_VERSION_1_1
struct PhysicalDevice16BitStorageFeatures : VkPhysicalDevice16BitStorageFeatures {
  PhysicalDevice16BitStorageFeatures() noexcept : VkPhysicalDevice16BitStorageFeatures{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES} {}

  // 16-bit integer/floating-point variables supported in BufferBlock
  void setStorageBuffer16BitAccess(Bool32 value) { this->storageBuffer16BitAccess = value; }
  Bool32 getStorageBuffer16BitAccess() const { return this->storageBuffer16BitAccess; }
  // 16-bit integer/floating-point variables supported in BufferBlock and Block
  void setUniformAndStorageBuffer16BitAccess(Bool32 value) { this->uniformAndStorageBuffer16BitAccess = value; }
  Bool32 getUniformAndStorageBuffer16BitAccess() const { return this->uniformAndStorageBuffer16BitAccess; }
  // 16-bit integer/floating-point variables supported in PushConstant
  void setStoragePushConstant16(Bool32 value) { this->storagePushConstant16 = value; }
  Bool32 getStoragePushConstant16() const { return this->storagePushConstant16; }
  // 16-bit integer/floating-point variables supported in shader inputs and outputs
  void setStorageInputOutput16(Bool32 value) { this->storageInputOutput16 = value; }
  Bool32 getStorageInputOutput16() const { return this->storageInputOutput16; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDevice16BitStorageFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDevice16BitStorageFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_1

#if VK_SEC_pipeline_cache_incremental_mode
struct PhysicalDevicePipelineCacheIncrementalModeFeaturesSEC : VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC {
  PhysicalDevicePipelineCacheIncrementalModeFeaturesSEC() noexcept : VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CACHE_INCREMENTAL_MODE_FEATURES_SEC} {}

  void setPipelineCacheIncrementalMode(Bool32 value) { this->pipelineCacheIncrementalMode = value; }
  Bool32 getPipelineCacheIncrementalMode() const { return this->pipelineCacheIncrementalMode; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDevicePipelineCacheIncrementalModeFeaturesSEC& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDevicePipelineCacheIncrementalModeFeaturesSEC& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_SEC_pipeline_cache_incremental_mode

#if VK_EXT_texel_buffer_alignment
struct PhysicalDeviceTexelBufferAlignmentFeaturesEXT : VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT {
  PhysicalDeviceTexelBufferAlignmentFeaturesEXT() noexcept : VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT} {}

  void setTexelBufferAlignment(Bool32 value) { this->texelBufferAlignment = value; }
  Bool32 getTexelBufferAlignment() const { return this->texelBufferAlignment; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceTexelBufferAlignmentFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceTexelBufferAlignmentFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_texel_buffer_alignment

#if VK_VERSION_1_3
struct PhysicalDeviceSubgroupSizeControlFeatures : VkPhysicalDeviceSubgroupSizeControlFeatures {
  PhysicalDeviceSubgroupSizeControlFeatures() noexcept : VkPhysicalDeviceSubgroupSizeControlFeatures{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES} {}

  void setSubgroupSizeControl(Bool32 value) { this->subgroupSizeControl = value; }
  Bool32 getSubgroupSizeControl() const { return this->subgroupSizeControl; }
  void setComputeFullSubgroups(Bool32 value) { this->computeFullSubgroups = value; }
  Bool32 getComputeFullSubgroups() const { return this->computeFullSubgroups; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceSubgroupSizeControlFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceSubgroupSizeControlFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_3

#if VK_EXT_mesh_shader
struct PhysicalDeviceMeshShaderFeaturesEXT : VkPhysicalDeviceMeshShaderFeaturesEXT {
  PhysicalDeviceMeshShaderFeaturesEXT() noexcept : VkPhysicalDeviceMeshShaderFeaturesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT} {}

  void setTaskShader(Bool32 value) { this->taskShader = value; }
  Bool32 getTaskShader() const { return this->taskShader; }
  void setMeshShader(Bool32 value) { this->meshShader = value; }
  Bool32 getMeshShader() const { return this->meshShader; }
  void setMultiviewMeshShader(Bool32 value) { this->multiviewMeshShader = value; }
  Bool32 getMultiviewMeshShader() const { return this->multiviewMeshShader; }
  void setPrimitiveFragmentShadingRateMeshShader(Bool32 value) { this->primitiveFragmentShadingRateMeshShader = value; }
  Bool32 getPrimitiveFragmentShadingRateMeshShader() const { return this->primitiveFragmentShadingRateMeshShader; }
  void setMeshShaderQueries(Bool32 value) { this->meshShaderQueries = value; }
  Bool32 getMeshShaderQueries() const { return this->meshShaderQueries; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceMeshShaderFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceMeshShaderFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_mesh_shader

#if VK_KHR_shader_clock
struct PhysicalDeviceShaderClockFeaturesKHR : VkPhysicalDeviceShaderClockFeaturesKHR {
  PhysicalDeviceShaderClockFeaturesKHR() noexcept : VkPhysicalDeviceShaderClockFeaturesKHR{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR} {}

  void setShaderSubgroupClock(Bool32 value) { this->shaderSubgroupClock = value; }
  Bool32 getShaderSubgroupClock() const { return this->shaderSubgroupClock; }
  void setShaderDeviceClock(Bool32 value) { this->shaderDeviceClock = value; }
  Bool32 getShaderDeviceClock() const { return this->shaderDeviceClock; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceShaderClockFeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceShaderClockFeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_shader_clock

#if VK_EXT_device_address_binding_report
struct PhysicalDeviceAddressBindingReportFeaturesEXT : VkPhysicalDeviceAddressBindingReportFeaturesEXT {
  PhysicalDeviceAddressBindingReportFeaturesEXT() noexcept : VkPhysicalDeviceAddressBindingReportFeaturesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT} {}

  void setReportAddressBinding(Bool32 value) { this->reportAddressBinding = value; }
  Bool32 getReportAddressBinding() const { return this->reportAddressBinding; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceAddressBindingReportFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceAddressBindingReportFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_device_address_binding_report

#if VK_KHR_video_encode_av1
struct PhysicalDeviceVideoEncodeAV1FeaturesKHR : VkPhysicalDeviceVideoEncodeAV1FeaturesKHR {
  PhysicalDeviceVideoEncodeAV1FeaturesKHR() noexcept : VkPhysicalDeviceVideoEncodeAV1FeaturesKHR{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_AV1_FEATURES_KHR} {}

  void setVideoEncodeAV1(Bool32 value) { this->videoEncodeAV1 = value; }
  Bool32 getVideoEncodeAV1() const { return this->videoEncodeAV1; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceVideoEncodeAV1FeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceVideoEncodeAV1FeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_encode_av1

#if VK_HUAWEI_cluster_culling_shader
struct PhysicalDeviceClusterCullingShaderFeaturesHUAWEI : VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI {
  PhysicalDeviceClusterCullingShaderFeaturesHUAWEI() noexcept : VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI} {}

  void setClustercullingShader(Bool32 value) { this->clustercullingShader = value; }
  Bool32 getClustercullingShader() const { return this->clustercullingShader; }
  void setMultiviewClusterCullingShader(Bool32 value) { this->multiviewClusterCullingShader = value; }
  Bool32 getMultiviewClusterCullingShader() const { return this->multiviewClusterCullingShader; }

  void attach(struct PhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI&);
};
inline void PhysicalDeviceFeatures2::attachHead(PhysicalDeviceClusterCullingShaderFeaturesHUAWEI& ext) { pNext = &ext; }
inline void DeviceCreateInfo::attachHead(PhysicalDeviceClusterCullingShaderFeaturesHUAWEI& ext) { pNext = &ext; }
#endif // VK_HUAWEI_cluster_culling_shader

#if VK_EXT_attachment_feedback_loop_dynamic_state
struct PhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT : VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT {
  PhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT() noexcept : VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT} {}

  void setAttachmentFeedbackLoopDynamicState(Bool32 value) { this->attachmentFeedbackLoopDynamicState = value; }
  Bool32 getAttachmentFeedbackLoopDynamicState() const { return this->attachmentFeedbackLoopDynamicState; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_attachment_feedback_loop_dynamic_state

#if VK_KHR_pipeline_executable_properties
struct PhysicalDevicePipelineExecutablePropertiesFeaturesKHR : VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR {
  PhysicalDevicePipelineExecutablePropertiesFeaturesKHR() noexcept : VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR} {}

  void setPipelineExecutableInfo(Bool32 value) { this->pipelineExecutableInfo = value; }
  Bool32 getPipelineExecutableInfo() const { return this->pipelineExecutableInfo; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDevicePipelineExecutablePropertiesFeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDevicePipelineExecutablePropertiesFeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_pipeline_executable_properties

#if VK_VERSION_1_2
struct PhysicalDeviceImagelessFramebufferFeatures : VkPhysicalDeviceImagelessFramebufferFeatures {
  PhysicalDeviceImagelessFramebufferFeatures() noexcept : VkPhysicalDeviceImagelessFramebufferFeatures{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES} {}

  void setImagelessFramebuffer(Bool32 value) { this->imagelessFramebuffer = value; }
  Bool32 getImagelessFramebuffer() const { return this->imagelessFramebuffer; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceImagelessFramebufferFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceImagelessFramebufferFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_2

#if VK_VERSION_1_3
struct PhysicalDeviceShaderDemoteToHelperInvocationFeatures : VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures {
  PhysicalDeviceShaderDemoteToHelperInvocationFeatures() noexcept : VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES} {}

  void setShaderDemoteToHelperInvocation(Bool32 value) { this->shaderDemoteToHelperInvocation = value; }
  Bool32 getShaderDemoteToHelperInvocation() const { return this->shaderDemoteToHelperInvocation; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceShaderDemoteToHelperInvocationFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceShaderDemoteToHelperInvocationFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_3

#if VK_KHR_present_id2
struct PhysicalDevicePresentId2FeaturesKHR : VkPhysicalDevicePresentId2FeaturesKHR {
  PhysicalDevicePresentId2FeaturesKHR() noexcept : VkPhysicalDevicePresentId2FeaturesKHR{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_2_FEATURES_KHR} {}

  // Present ID2 in VkPresentInfoKHR
  void setPresentId2(Bool32 value) { this->presentId2 = value; }
  Bool32 getPresentId2() const { return this->presentId2; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDevicePresentId2FeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDevicePresentId2FeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_present_id2

#if VK_KHR_present_wait2
struct PhysicalDevicePresentWait2FeaturesKHR : VkPhysicalDevicePresentWait2FeaturesKHR {
  PhysicalDevicePresentWait2FeaturesKHR() noexcept : VkPhysicalDevicePresentWait2FeaturesKHR{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_2_FEATURES_KHR} {}

  // vkWaitForPresent2KHR is supported
  void setPresentWait2(Bool32 value) { this->presentWait2 = value; }
  Bool32 getPresentWait2() const { return this->presentWait2; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDevicePresentWait2FeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDevicePresentWait2FeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_present_wait2

#if VK_NV_device_diagnostics_config
struct PhysicalDeviceDiagnosticsConfigFeaturesNV : VkPhysicalDeviceDiagnosticsConfigFeaturesNV {
  PhysicalDeviceDiagnosticsConfigFeaturesNV() noexcept : VkPhysicalDeviceDiagnosticsConfigFeaturesNV{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV} {}

  void setDiagnosticsConfig(Bool32 value) { this->diagnosticsConfig = value; }
  Bool32 getDiagnosticsConfig() const { return this->diagnosticsConfig; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceDiagnosticsConfigFeaturesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceDiagnosticsConfigFeaturesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_device_diagnostics_config

#if VK_KHR_unified_image_layouts
struct PhysicalDeviceUnifiedImageLayoutsFeaturesKHR : VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR {
  PhysicalDeviceUnifiedImageLayoutsFeaturesKHR() noexcept : VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFIED_IMAGE_LAYOUTS_FEATURES_KHR} {}

  void setUnifiedImageLayouts(Bool32 value) { this->unifiedImageLayouts = value; }
  Bool32 getUnifiedImageLayouts() const { return this->unifiedImageLayouts; }
  void setUnifiedImageLayoutsVideo(Bool32 value) { this->unifiedImageLayoutsVideo = value; }
  Bool32 getUnifiedImageLayoutsVideo() const { return this->unifiedImageLayoutsVideo; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceUnifiedImageLayoutsFeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceUnifiedImageLayoutsFeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_unified_image_layouts

#if VK_EXT_custom_border_color
struct PhysicalDeviceCustomBorderColorFeaturesEXT : VkPhysicalDeviceCustomBorderColorFeaturesEXT {
  PhysicalDeviceCustomBorderColorFeaturesEXT() noexcept : VkPhysicalDeviceCustomBorderColorFeaturesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT} {}

  void setCustomBorderColors(Bool32 value) { this->customBorderColors = value; }
  Bool32 getCustomBorderColors() const { return this->customBorderColors; }
  void setCustomBorderColorWithoutFormat(Bool32 value) { this->customBorderColorWithoutFormat = value; }
  Bool32 getCustomBorderColorWithoutFormat() const { return this->customBorderColorWithoutFormat; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceCustomBorderColorFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceCustomBorderColorFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_custom_border_color

#if VK_NV_memory_decompression
struct PhysicalDeviceMemoryDecompressionFeaturesNV : VkPhysicalDeviceMemoryDecompressionFeaturesNV {
  PhysicalDeviceMemoryDecompressionFeaturesNV() noexcept : VkPhysicalDeviceMemoryDecompressionFeaturesNV{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV} {}

  void setMemoryDecompression(Bool32 value) { this->memoryDecompression = value; }
  Bool32 getMemoryDecompression() const { return this->memoryDecompression; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceMemoryDecompressionFeaturesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceMemoryDecompressionFeaturesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_memory_decompression

#if VK_EXT_legacy_dithering
struct PhysicalDeviceLegacyDitheringFeaturesEXT : VkPhysicalDeviceLegacyDitheringFeaturesEXT {
  PhysicalDeviceLegacyDitheringFeaturesEXT() noexcept : VkPhysicalDeviceLegacyDitheringFeaturesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT} {}

  void setLegacyDithering(Bool32 value) { this->legacyDithering = value; }
  Bool32 getLegacyDithering() const { return this->legacyDithering; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceLegacyDitheringFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceLegacyDitheringFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_legacy_dithering

#if VK_NV_optical_flow
struct PhysicalDeviceOpticalFlowFeaturesNV : VkPhysicalDeviceOpticalFlowFeaturesNV {
  PhysicalDeviceOpticalFlowFeaturesNV() noexcept : VkPhysicalDeviceOpticalFlowFeaturesNV{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV} {}

  void setOpticalFlow(Bool32 value) { this->opticalFlow = value; }
  Bool32 getOpticalFlow() const { return this->opticalFlow; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceOpticalFlowFeaturesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceOpticalFlowFeaturesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_optical_flow

#if VK_VERSION_1_3
struct PhysicalDeviceShaderIntegerDotProductFeatures : VkPhysicalDeviceShaderIntegerDotProductFeatures {
  PhysicalDeviceShaderIntegerDotProductFeatures() noexcept : VkPhysicalDeviceShaderIntegerDotProductFeatures{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES} {}

  void setShaderIntegerDotProduct(Bool32 value) { this->shaderIntegerDotProduct = value; }
  Bool32 getShaderIntegerDotProduct() const { return this->shaderIntegerDotProduct; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceShaderIntegerDotProductFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceShaderIntegerDotProductFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_3

#if VK_VERSION_1_1
struct PhysicalDeviceMultiviewFeatures : VkPhysicalDeviceMultiviewFeatures {
  PhysicalDeviceMultiviewFeatures() noexcept : VkPhysicalDeviceMultiviewFeatures{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES} {}

  // Multiple views in a render pass
  void setMultiview(Bool32 value) { this->multiview = value; }
  Bool32 getMultiview() const { return this->multiview; }
  // Multiple views in a render pass w/ geometry shader
  void setMultiviewGeometryShader(Bool32 value) { this->multiviewGeometryShader = value; }
  Bool32 getMultiviewGeometryShader() const { return this->multiviewGeometryShader; }
  // Multiple views in a render pass w/ tessellation shader
  void setMultiviewTessellationShader(Bool32 value) { this->multiviewTessellationShader = value; }
  Bool32 getMultiviewTessellationShader() const { return this->multiviewTessellationShader; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceMultiviewFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceMultiviewFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_1

#if VK_VERSION_1_4
struct PhysicalDeviceIndexTypeUint8Features : VkPhysicalDeviceIndexTypeUint8Features {
  PhysicalDeviceIndexTypeUint8Features() noexcept : VkPhysicalDeviceIndexTypeUint8Features{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES} {}

  void setIndexTypeUint8(Bool32 value) { this->indexTypeUint8 = value; }
  Bool32 getIndexTypeUint8() const { return this->indexTypeUint8; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceIndexTypeUint8Features& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceIndexTypeUint8Features& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }

struct PhysicalDeviceLineRasterizationFeatures : VkPhysicalDeviceLineRasterizationFeatures {
  PhysicalDeviceLineRasterizationFeatures() noexcept : VkPhysicalDeviceLineRasterizationFeatures{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES} {}

  void setRectangularLines(Bool32 value) { this->rectangularLines = value; }
  Bool32 getRectangularLines() const { return this->rectangularLines; }
  void setBresenhamLines(Bool32 value) { this->bresenhamLines = value; }
  Bool32 getBresenhamLines() const { return this->bresenhamLines; }
  void setSmoothLines(Bool32 value) { this->smoothLines = value; }
  Bool32 getSmoothLines() const { return this->smoothLines; }
  void setStippledRectangularLines(Bool32 value) { this->stippledRectangularLines = value; }
  Bool32 getStippledRectangularLines() const { return this->stippledRectangularLines; }
  void setStippledBresenhamLines(Bool32 value) { this->stippledBresenhamLines = value; }
  Bool32 getStippledBresenhamLines() const { return this->stippledBresenhamLines; }
  void setStippledSmoothLines(Bool32 value) { this->stippledSmoothLines = value; }
  Bool32 getStippledSmoothLines() const { return this->stippledSmoothLines; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceLineRasterizationFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceLineRasterizationFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_4

#if VK_EXT_rasterization_order_attachment_access
struct PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT : VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT {
  PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT() noexcept : VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT} {}

  void setRasterizationOrderColorAttachmentAccess(Bool32 value) { this->rasterizationOrderColorAttachmentAccess = value; }
  Bool32 getRasterizationOrderColorAttachmentAccess() const { return this->rasterizationOrderColorAttachmentAccess; }
  void setRasterizationOrderDepthAttachmentAccess(Bool32 value) { this->rasterizationOrderDepthAttachmentAccess = value; }
  Bool32 getRasterizationOrderDepthAttachmentAccess() const { return this->rasterizationOrderDepthAttachmentAccess; }
  void setRasterizationOrderStencilAttachmentAccess(Bool32 value) { this->rasterizationOrderStencilAttachmentAccess = value; }
  Bool32 getRasterizationOrderStencilAttachmentAccess() const { return this->rasterizationOrderStencilAttachmentAccess; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_rasterization_order_attachment_access

#if VK_NV_partitioned_acceleration_structure
struct PhysicalDevicePartitionedAccelerationStructureFeaturesNV : VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV {
  PhysicalDevicePartitionedAccelerationStructureFeaturesNV() noexcept : VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_FEATURES_NV} {}

  void setPartitionedAccelerationStructure(Bool32 value) { this->partitionedAccelerationStructure = value; }
  Bool32 getPartitionedAccelerationStructure() const { return this->partitionedAccelerationStructure; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDevicePartitionedAccelerationStructureFeaturesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDevicePartitionedAccelerationStructureFeaturesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_partitioned_acceleration_structure

#if VK_KHR_video_maintenance2
struct PhysicalDeviceVideoMaintenance2FeaturesKHR : VkPhysicalDeviceVideoMaintenance2FeaturesKHR {
  PhysicalDeviceVideoMaintenance2FeaturesKHR() noexcept : VkPhysicalDeviceVideoMaintenance2FeaturesKHR{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_2_FEATURES_KHR} {}

  void setVideoMaintenance2(Bool32 value) { this->videoMaintenance2 = value; }
  Bool32 getVideoMaintenance2() const { return this->videoMaintenance2; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceVideoMaintenance2FeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceVideoMaintenance2FeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_maintenance2

#if VK_EXT_ycbcr_2plane_444_formats
struct PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT : VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT {
  PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT() noexcept : VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT} {}

  void setYcbcr2plane444Formats(Bool32 value) { this->ycbcr2plane444Formats = value; }
  Bool32 getYcbcr2plane444Formats() const { return this->ycbcr2plane444Formats; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_ycbcr_2plane_444_formats

#if VK_NV_shader_image_footprint
struct PhysicalDeviceShaderImageFootprintFeaturesNV : VkPhysicalDeviceShaderImageFootprintFeaturesNV {
  PhysicalDeviceShaderImageFootprintFeaturesNV() noexcept : VkPhysicalDeviceShaderImageFootprintFeaturesNV{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV} {}

  void setImageFootprint(Bool32 value) { this->imageFootprint = value; }
  Bool32 getImageFootprint() const { return this->imageFootprint; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceShaderImageFootprintFeaturesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceShaderImageFootprintFeaturesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_shader_image_footprint

#if VK_VERSION_1_2
struct PhysicalDeviceShaderAtomicInt64Features : VkPhysicalDeviceShaderAtomicInt64Features {
  PhysicalDeviceShaderAtomicInt64Features() noexcept : VkPhysicalDeviceShaderAtomicInt64Features{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES} {}

  void setShaderBufferInt64Atomics(Bool32 value) { this->shaderBufferInt64Atomics = value; }
  Bool32 getShaderBufferInt64Atomics() const { return this->shaderBufferInt64Atomics; }
  void setShaderSharedInt64Atomics(Bool32 value) { this->shaderSharedInt64Atomics = value; }
  Bool32 getShaderSharedInt64Atomics() const { return this->shaderSharedInt64Atomics; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceShaderAtomicInt64Features& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceShaderAtomicInt64Features& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_2

#if VK_KHR_video_decode_vp9
struct PhysicalDeviceVideoDecodeVP9FeaturesKHR : VkPhysicalDeviceVideoDecodeVP9FeaturesKHR {
  PhysicalDeviceVideoDecodeVP9FeaturesKHR() noexcept : VkPhysicalDeviceVideoDecodeVP9FeaturesKHR{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_DECODE_VP9_FEATURES_KHR} {}

  void setVideoDecodeVP9(Bool32 value) { this->videoDecodeVP9 = value; }
  Bool32 getVideoDecodeVP9() const { return this->videoDecodeVP9; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceVideoDecodeVP9FeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceVideoDecodeVP9FeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_decode_vp9

#if VK_VERSION_1_3
struct PhysicalDeviceMaintenance4Features : VkPhysicalDeviceMaintenance4Features {
  PhysicalDeviceMaintenance4Features() noexcept : VkPhysicalDeviceMaintenance4Features{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES} {}

  void setMaintenance4(Bool32 value) { this->maintenance4 = value; }
  Bool32 getMaintenance4() const { return this->maintenance4; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceMaintenance4Features& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceMaintenance4Features& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_3

#if VK_EXT_shader_module_identifier
struct PhysicalDeviceShaderModuleIdentifierFeaturesEXT : VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT {
  PhysicalDeviceShaderModuleIdentifierFeaturesEXT() noexcept : VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT} {}

  void setShaderModuleIdentifier(Bool32 value) { this->shaderModuleIdentifier = value; }
  Bool32 getShaderModuleIdentifier() const { return this->shaderModuleIdentifier; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceShaderModuleIdentifierFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceShaderModuleIdentifierFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_shader_module_identifier

#if VK_KHR_maintenance8
struct PhysicalDeviceMaintenance8FeaturesKHR : VkPhysicalDeviceMaintenance8FeaturesKHR {
  PhysicalDeviceMaintenance8FeaturesKHR() noexcept : VkPhysicalDeviceMaintenance8FeaturesKHR{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_8_FEATURES_KHR} {}

  void setMaintenance8(Bool32 value) { this->maintenance8 = value; }
  Bool32 getMaintenance8() const { return this->maintenance8; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceMaintenance8FeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceMaintenance8FeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_maintenance8

#if VK_EXT_depth_clamp_control
struct PhysicalDeviceDepthClampControlFeaturesEXT : VkPhysicalDeviceDepthClampControlFeaturesEXT {
  PhysicalDeviceDepthClampControlFeaturesEXT() noexcept : VkPhysicalDeviceDepthClampControlFeaturesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_CONTROL_FEATURES_EXT} {}

  void setDepthClampControl(Bool32 value) { this->depthClampControl = value; }
  Bool32 getDepthClampControl() const { return this->depthClampControl; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceDepthClampControlFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceDepthClampControlFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_depth_clamp_control

#if VK_EXT_pipeline_properties
struct PhysicalDevicePipelinePropertiesFeaturesEXT : VkPhysicalDevicePipelinePropertiesFeaturesEXT {
  PhysicalDevicePipelinePropertiesFeaturesEXT() noexcept : VkPhysicalDevicePipelinePropertiesFeaturesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT} {}

  void setPipelinePropertiesIdentifier(Bool32 value) { this->pipelinePropertiesIdentifier = value; }
  Bool32 getPipelinePropertiesIdentifier() const { return this->pipelinePropertiesIdentifier; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDevicePipelinePropertiesFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDevicePipelinePropertiesFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_pipeline_properties

#if VK_EXT_memory_priority
struct PhysicalDeviceMemoryPriorityFeaturesEXT : VkPhysicalDeviceMemoryPriorityFeaturesEXT {
  PhysicalDeviceMemoryPriorityFeaturesEXT() noexcept : VkPhysicalDeviceMemoryPriorityFeaturesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT} {}

  void setMemoryPriority(Bool32 value) { this->memoryPriority = value; }
  Bool32 getMemoryPriority() const { return this->memoryPriority; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceMemoryPriorityFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceMemoryPriorityFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_memory_priority

#if VK_EXT_blend_operation_advanced
struct PhysicalDeviceBlendOperationAdvancedFeaturesEXT : VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT {
  PhysicalDeviceBlendOperationAdvancedFeaturesEXT() noexcept : VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT} {}

  void setAdvancedBlendCoherentOperations(Bool32 value) { this->advancedBlendCoherentOperations = value; }
  Bool32 getAdvancedBlendCoherentOperations() const { return this->advancedBlendCoherentOperations; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceBlendOperationAdvancedFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceBlendOperationAdvancedFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_blend_operation_advanced

#if VK_KHR_shader_subgroup_uniform_control_flow
struct PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR : VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR {
  PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR() noexcept : VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR} {}

  void setShaderSubgroupUniformControlFlow(Bool32 value) { this->shaderSubgroupUniformControlFlow = value; }
  Bool32 getShaderSubgroupUniformControlFlow() const { return this->shaderSubgroupUniformControlFlow; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_shader_subgroup_uniform_control_flow

#if VK_VERSION_1_3
struct PhysicalDeviceInlineUniformBlockFeatures : VkPhysicalDeviceInlineUniformBlockFeatures {
  PhysicalDeviceInlineUniformBlockFeatures() noexcept : VkPhysicalDeviceInlineUniformBlockFeatures{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES} {}

  void setInlineUniformBlock(Bool32 value) { this->inlineUniformBlock = value; }
  Bool32 getInlineUniformBlock() const { return this->inlineUniformBlock; }
  void setDescriptorBindingInlineUniformBlockUpdateAfterBind(Bool32 value) { this->descriptorBindingInlineUniformBlockUpdateAfterBind = value; }
  Bool32 getDescriptorBindingInlineUniformBlockUpdateAfterBind() const { return this->descriptorBindingInlineUniformBlockUpdateAfterBind; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceInlineUniformBlockFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceInlineUniformBlockFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_3

#if VK_EXT_multi_draw
struct PhysicalDeviceMultiDrawFeaturesEXT : VkPhysicalDeviceMultiDrawFeaturesEXT {
  PhysicalDeviceMultiDrawFeaturesEXT() noexcept : VkPhysicalDeviceMultiDrawFeaturesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT} {}

  void setMultiDraw(Bool32 value) { this->multiDraw = value; }
  Bool32 getMultiDraw() const { return this->multiDraw; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceMultiDrawFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceMultiDrawFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_multi_draw

#if VK_EXT_provoking_vertex
struct PhysicalDeviceProvokingVertexFeaturesEXT : VkPhysicalDeviceProvokingVertexFeaturesEXT {
  PhysicalDeviceProvokingVertexFeaturesEXT() noexcept : VkPhysicalDeviceProvokingVertexFeaturesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT} {}

  void setProvokingVertexLast(Bool32 value) { this->provokingVertexLast = value; }
  Bool32 getProvokingVertexLast() const { return this->provokingVertexLast; }
  void setTransformFeedbackPreservesProvokingVertex(Bool32 value) { this->transformFeedbackPreservesProvokingVertex = value; }
  Bool32 getTransformFeedbackPreservesProvokingVertex() const { return this->transformFeedbackPreservesProvokingVertex; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceProvokingVertexFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceProvokingVertexFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_provoking_vertex

#if VK_AMD_shader_early_and_late_fragment_tests
struct PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD : VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD {
  PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD() noexcept : VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD} {}

  void setShaderEarlyAndLateFragmentTests(Bool32 value) { this->shaderEarlyAndLateFragmentTests = value; }
  Bool32 getShaderEarlyAndLateFragmentTests() const { return this->shaderEarlyAndLateFragmentTests; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_AMD_shader_early_and_late_fragment_tests

#if VK_VERSION_1_2
struct PhysicalDeviceSeparateDepthStencilLayoutsFeatures : VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures {
  PhysicalDeviceSeparateDepthStencilLayoutsFeatures() noexcept : VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES} {}

  void setSeparateDepthStencilLayouts(Bool32 value) { this->separateDepthStencilLayouts = value; }
  Bool32 getSeparateDepthStencilLayouts() const { return this->separateDepthStencilLayouts; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceSeparateDepthStencilLayoutsFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceSeparateDepthStencilLayoutsFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_2

#if VK_EXT_depth_clip_control
struct PhysicalDeviceDepthClipControlFeaturesEXT : VkPhysicalDeviceDepthClipControlFeaturesEXT {
  PhysicalDeviceDepthClipControlFeaturesEXT() noexcept : VkPhysicalDeviceDepthClipControlFeaturesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT} {}

  void setDepthClipControl(Bool32 value) { this->depthClipControl = value; }
  Bool32 getDepthClipControl() const { return this->depthClipControl; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceDepthClipControlFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceDepthClipControlFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_depth_clip_control

#if VK_VERSION_1_4
struct PhysicalDeviceMaintenance6Features : VkPhysicalDeviceMaintenance6Features {
  PhysicalDeviceMaintenance6Features() noexcept : VkPhysicalDeviceMaintenance6Features{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES} {}

  void setMaintenance6(Bool32 value) { this->maintenance6 = value; }
  Bool32 getMaintenance6() const { return this->maintenance6; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceMaintenance6Features& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceMaintenance6Features& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_4

#if VK_KHR_maintenance7
struct PhysicalDeviceMaintenance7FeaturesKHR : VkPhysicalDeviceMaintenance7FeaturesKHR {
  PhysicalDeviceMaintenance7FeaturesKHR() noexcept : VkPhysicalDeviceMaintenance7FeaturesKHR{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_FEATURES_KHR} {}

  void setMaintenance7(Bool32 value) { this->maintenance7 = value; }
  Bool32 getMaintenance7() const { return this->maintenance7; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceMaintenance7FeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceMaintenance7FeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_maintenance7

#if VK_EXT_rgba10x6_formats
struct PhysicalDeviceRGBA10X6FormatsFeaturesEXT : VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT {
  PhysicalDeviceRGBA10X6FormatsFeaturesEXT() noexcept : VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT} {}

  void setFormatRgba10x6WithoutYCbCrSampler(Bool32 value) { this->formatRgba10x6WithoutYCbCrSampler = value; }
  Bool32 getFormatRgba10x6WithoutYCbCrSampler() const { return this->formatRgba10x6WithoutYCbCrSampler; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceRGBA10X6FormatsFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceRGBA10X6FormatsFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_rgba10x6_formats

#if VK_VERSION_1_2
struct PhysicalDeviceHostQueryResetFeatures : VkPhysicalDeviceHostQueryResetFeatures {
  PhysicalDeviceHostQueryResetFeatures() noexcept : VkPhysicalDeviceHostQueryResetFeatures{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES} {}

  void setHostQueryReset(Bool32 value) { this->hostQueryReset = value; }
  Bool32 getHostQueryReset() const { return this->hostQueryReset; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceHostQueryResetFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceHostQueryResetFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_2

#if VK_VERSION_1_1
struct PhysicalDeviceVariablePointersFeatures : VkPhysicalDeviceVariablePointersFeatures {
  PhysicalDeviceVariablePointersFeatures() noexcept : VkPhysicalDeviceVariablePointersFeatures{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES} {}

  void setVariablePointersStorageBuffer(Bool32 value) { this->variablePointersStorageBuffer = value; }
  Bool32 getVariablePointersStorageBuffer() const { return this->variablePointersStorageBuffer; }
  void setVariablePointers(Bool32 value) { this->variablePointers = value; }
  Bool32 getVariablePointers() const { return this->variablePointers; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceVariablePointersFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceVariablePointersFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_1

#if VK_VERSION_1_3
struct PhysicalDeviceDynamicRenderingFeatures : VkPhysicalDeviceDynamicRenderingFeatures {
  PhysicalDeviceDynamicRenderingFeatures() noexcept : VkPhysicalDeviceDynamicRenderingFeatures{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES} {}

  void setDynamicRendering(Bool32 value) { this->dynamicRendering = value; }
  Bool32 getDynamicRendering() const { return this->dynamicRendering; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceDynamicRenderingFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceDynamicRenderingFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_3

#if VK_KHR_fragment_shader_barycentric
struct PhysicalDeviceFragmentShaderBarycentricFeaturesKHR : VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR {
  PhysicalDeviceFragmentShaderBarycentricFeaturesKHR() noexcept : VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR} {}

  void setFragmentShaderBarycentric(Bool32 value) { this->fragmentShaderBarycentric = value; }
  Bool32 getFragmentShaderBarycentric() const { return this->fragmentShaderBarycentric; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceFragmentShaderBarycentricFeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceFragmentShaderBarycentricFeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_fragment_shader_barycentric

#if VK_KHR_ray_tracing_pipeline
struct PhysicalDeviceRayTracingPipelineFeaturesKHR : VkPhysicalDeviceRayTracingPipelineFeaturesKHR {
  PhysicalDeviceRayTracingPipelineFeaturesKHR() noexcept : VkPhysicalDeviceRayTracingPipelineFeaturesKHR{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR} {}

  void setRayTracingPipeline(Bool32 value) { this->rayTracingPipeline = value; }
  Bool32 getRayTracingPipeline() const { return this->rayTracingPipeline; }
  void setRayTracingPipelineShaderGroupHandleCaptureReplay(Bool32 value) { this->rayTracingPipelineShaderGroupHandleCaptureReplay = value; }
  Bool32 getRayTracingPipelineShaderGroupHandleCaptureReplay() const { return this->rayTracingPipelineShaderGroupHandleCaptureReplay; }
  void setRayTracingPipelineShaderGroupHandleCaptureReplayMixed(Bool32 value) { this->rayTracingPipelineShaderGroupHandleCaptureReplayMixed = value; }
  Bool32 getRayTracingPipelineShaderGroupHandleCaptureReplayMixed() const { return this->rayTracingPipelineShaderGroupHandleCaptureReplayMixed; }
  void setRayTracingPipelineTraceRaysIndirect(Bool32 value) { this->rayTracingPipelineTraceRaysIndirect = value; }
  Bool32 getRayTracingPipelineTraceRaysIndirect() const { return this->rayTracingPipelineTraceRaysIndirect; }
  void setRayTraversalPrimitiveCulling(Bool32 value) { this->rayTraversalPrimitiveCulling = value; }
  Bool32 getRayTraversalPrimitiveCulling() const { return this->rayTraversalPrimitiveCulling; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceRayTracingPipelineFeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceRayTracingPipelineFeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_ray_tracing_pipeline

#if VK_EXT_graphics_pipeline_library
struct PhysicalDeviceGraphicsPipelineLibraryFeaturesEXT : VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT {
  PhysicalDeviceGraphicsPipelineLibraryFeaturesEXT() noexcept : VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT} {}

  void setGraphicsPipelineLibrary(Bool32 value) { this->graphicsPipelineLibrary = value; }
  Bool32 getGraphicsPipelineLibrary() const { return this->graphicsPipelineLibrary; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceGraphicsPipelineLibraryFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceGraphicsPipelineLibraryFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_graphics_pipeline_library

#if VK_KHR_ray_query
struct PhysicalDeviceRayQueryFeaturesKHR : VkPhysicalDeviceRayQueryFeaturesKHR {
  PhysicalDeviceRayQueryFeaturesKHR() noexcept : VkPhysicalDeviceRayQueryFeaturesKHR{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR} {}

  void setRayQuery(Bool32 value) { this->rayQuery = value; }
  Bool32 getRayQuery() const { return this->rayQuery; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceRayQueryFeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceRayQueryFeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_ray_query

#if VK_EXT_opacity_micromap
struct PhysicalDeviceOpacityMicromapFeaturesEXT : VkPhysicalDeviceOpacityMicromapFeaturesEXT {
  PhysicalDeviceOpacityMicromapFeaturesEXT() noexcept : VkPhysicalDeviceOpacityMicromapFeaturesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT} {}

  void setMicromap(Bool32 value) { this->micromap = value; }
  Bool32 getMicromap() const { return this->micromap; }
  void setMicromapCaptureReplay(Bool32 value) { this->micromapCaptureReplay = value; }
  Bool32 getMicromapCaptureReplay() const { return this->micromapCaptureReplay; }
  void setMicromapHostCommands(Bool32 value) { this->micromapHostCommands = value; }
  Bool32 getMicromapHostCommands() const { return this->micromapHostCommands; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceOpacityMicromapFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceOpacityMicromapFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_opacity_micromap

#if VK_EXT_multisampled_render_to_single_sampled
struct PhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT : VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT {
  PhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT() noexcept : VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT} {}

  void setMultisampledRenderToSingleSampled(Bool32 value) { this->multisampledRenderToSingleSampled = value; }
  Bool32 getMultisampledRenderToSingleSampled() const { return this->multisampledRenderToSingleSampled; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_multisampled_render_to_single_sampled

#if VK_EXT_image_compression_control_swapchain
struct PhysicalDeviceImageCompressionControlSwapchainFeaturesEXT : VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT {
  PhysicalDeviceImageCompressionControlSwapchainFeaturesEXT() noexcept : VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT} {}

  void setImageCompressionControlSwapchain(Bool32 value) { this->imageCompressionControlSwapchain = value; }
  Bool32 getImageCompressionControlSwapchain() const { return this->imageCompressionControlSwapchain; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceImageCompressionControlSwapchainFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceImageCompressionControlSwapchainFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_image_compression_control_swapchain

#if VK_NV_present_barrier
struct PhysicalDevicePresentBarrierFeaturesNV : VkPhysicalDevicePresentBarrierFeaturesNV {
  PhysicalDevicePresentBarrierFeaturesNV() noexcept : VkPhysicalDevicePresentBarrierFeaturesNV{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV} {}

  void setPresentBarrier(Bool32 value) { this->presentBarrier = value; }
  Bool32 getPresentBarrier() const { return this->presentBarrier; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDevicePresentBarrierFeaturesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDevicePresentBarrierFeaturesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_present_barrier

#if VK_NV_external_memory_rdma
struct PhysicalDeviceExternalMemoryRDMAFeaturesNV : VkPhysicalDeviceExternalMemoryRDMAFeaturesNV {
  PhysicalDeviceExternalMemoryRDMAFeaturesNV() noexcept : VkPhysicalDeviceExternalMemoryRDMAFeaturesNV{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV} {}

  void setExternalMemoryRDMA(Bool32 value) { this->externalMemoryRDMA = value; }
  Bool32 getExternalMemoryRDMA() const { return this->externalMemoryRDMA; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceExternalMemoryRDMAFeaturesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceExternalMemoryRDMAFeaturesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_external_memory_rdma

#if VK_EXT_fragment_shader_interlock
struct PhysicalDeviceFragmentShaderInterlockFeaturesEXT : VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT {
  PhysicalDeviceFragmentShaderInterlockFeaturesEXT() noexcept : VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT} {}

  void setFragmentShaderSampleInterlock(Bool32 value) { this->fragmentShaderSampleInterlock = value; }
  Bool32 getFragmentShaderSampleInterlock() const { return this->fragmentShaderSampleInterlock; }
  void setFragmentShaderPixelInterlock(Bool32 value) { this->fragmentShaderPixelInterlock = value; }
  Bool32 getFragmentShaderPixelInterlock() const { return this->fragmentShaderPixelInterlock; }
  void setFragmentShaderShadingRateInterlock(Bool32 value) { this->fragmentShaderShadingRateInterlock = value; }
  Bool32 getFragmentShaderShadingRateInterlock() const { return this->fragmentShaderShadingRateInterlock; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceFragmentShaderInterlockFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceFragmentShaderInterlockFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_fragment_shader_interlock

#if VK_EXT_shader_atomic_float
struct PhysicalDeviceShaderAtomicFloatFeaturesEXT : VkPhysicalDeviceShaderAtomicFloatFeaturesEXT {
  PhysicalDeviceShaderAtomicFloatFeaturesEXT() noexcept : VkPhysicalDeviceShaderAtomicFloatFeaturesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT} {}

  void setShaderBufferFloat32Atomics(Bool32 value) { this->shaderBufferFloat32Atomics = value; }
  Bool32 getShaderBufferFloat32Atomics() const { return this->shaderBufferFloat32Atomics; }
  void setShaderBufferFloat32AtomicAdd(Bool32 value) { this->shaderBufferFloat32AtomicAdd = value; }
  Bool32 getShaderBufferFloat32AtomicAdd() const { return this->shaderBufferFloat32AtomicAdd; }
  void setShaderBufferFloat64Atomics(Bool32 value) { this->shaderBufferFloat64Atomics = value; }
  Bool32 getShaderBufferFloat64Atomics() const { return this->shaderBufferFloat64Atomics; }
  void setShaderBufferFloat64AtomicAdd(Bool32 value) { this->shaderBufferFloat64AtomicAdd = value; }
  Bool32 getShaderBufferFloat64AtomicAdd() const { return this->shaderBufferFloat64AtomicAdd; }
  void setShaderSharedFloat32Atomics(Bool32 value) { this->shaderSharedFloat32Atomics = value; }
  Bool32 getShaderSharedFloat32Atomics() const { return this->shaderSharedFloat32Atomics; }
  void setShaderSharedFloat32AtomicAdd(Bool32 value) { this->shaderSharedFloat32AtomicAdd = value; }
  Bool32 getShaderSharedFloat32AtomicAdd() const { return this->shaderSharedFloat32AtomicAdd; }
  void setShaderSharedFloat64Atomics(Bool32 value) { this->shaderSharedFloat64Atomics = value; }
  Bool32 getShaderSharedFloat64Atomics() const { return this->shaderSharedFloat64Atomics; }
  void setShaderSharedFloat64AtomicAdd(Bool32 value) { this->shaderSharedFloat64AtomicAdd = value; }
  Bool32 getShaderSharedFloat64AtomicAdd() const { return this->shaderSharedFloat64AtomicAdd; }
  void setShaderImageFloat32Atomics(Bool32 value) { this->shaderImageFloat32Atomics = value; }
  Bool32 getShaderImageFloat32Atomics() const { return this->shaderImageFloat32Atomics; }
  void setShaderImageFloat32AtomicAdd(Bool32 value) { this->shaderImageFloat32AtomicAdd = value; }
  Bool32 getShaderImageFloat32AtomicAdd() const { return this->shaderImageFloat32AtomicAdd; }
  void setSparseImageFloat32Atomics(Bool32 value) { this->sparseImageFloat32Atomics = value; }
  Bool32 getSparseImageFloat32Atomics() const { return this->sparseImageFloat32Atomics; }
  void setSparseImageFloat32AtomicAdd(Bool32 value) { this->sparseImageFloat32AtomicAdd = value; }
  Bool32 getSparseImageFloat32AtomicAdd() const { return this->sparseImageFloat32AtomicAdd; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceShaderAtomicFloatFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceShaderAtomicFloatFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_shader_atomic_float

#if VK_KHR_shader_relaxed_extended_instruction
struct PhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR : VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR {
  PhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR() noexcept : VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_RELAXED_EXTENDED_INSTRUCTION_FEATURES_KHR} {}

  void setShaderRelaxedExtendedInstruction(Bool32 value) { this->shaderRelaxedExtendedInstruction = value; }
  Bool32 getShaderRelaxedExtendedInstruction() const { return this->shaderRelaxedExtendedInstruction; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_shader_relaxed_extended_instruction

#if VK_EXT_shader_atomic_float2
struct PhysicalDeviceShaderAtomicFloat2FeaturesEXT : VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT {
  PhysicalDeviceShaderAtomicFloat2FeaturesEXT() noexcept : VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT} {}

  void setShaderBufferFloat16Atomics(Bool32 value) { this->shaderBufferFloat16Atomics = value; }
  Bool32 getShaderBufferFloat16Atomics() const { return this->shaderBufferFloat16Atomics; }
  void setShaderBufferFloat16AtomicAdd(Bool32 value) { this->shaderBufferFloat16AtomicAdd = value; }
  Bool32 getShaderBufferFloat16AtomicAdd() const { return this->shaderBufferFloat16AtomicAdd; }
  void setShaderBufferFloat16AtomicMinMax(Bool32 value) { this->shaderBufferFloat16AtomicMinMax = value; }
  Bool32 getShaderBufferFloat16AtomicMinMax() const { return this->shaderBufferFloat16AtomicMinMax; }
  void setShaderBufferFloat32AtomicMinMax(Bool32 value) { this->shaderBufferFloat32AtomicMinMax = value; }
  Bool32 getShaderBufferFloat32AtomicMinMax() const { return this->shaderBufferFloat32AtomicMinMax; }
  void setShaderBufferFloat64AtomicMinMax(Bool32 value) { this->shaderBufferFloat64AtomicMinMax = value; }
  Bool32 getShaderBufferFloat64AtomicMinMax() const { return this->shaderBufferFloat64AtomicMinMax; }
  void setShaderSharedFloat16Atomics(Bool32 value) { this->shaderSharedFloat16Atomics = value; }
  Bool32 getShaderSharedFloat16Atomics() const { return this->shaderSharedFloat16Atomics; }
  void setShaderSharedFloat16AtomicAdd(Bool32 value) { this->shaderSharedFloat16AtomicAdd = value; }
  Bool32 getShaderSharedFloat16AtomicAdd() const { return this->shaderSharedFloat16AtomicAdd; }
  void setShaderSharedFloat16AtomicMinMax(Bool32 value) { this->shaderSharedFloat16AtomicMinMax = value; }
  Bool32 getShaderSharedFloat16AtomicMinMax() const { return this->shaderSharedFloat16AtomicMinMax; }
  void setShaderSharedFloat32AtomicMinMax(Bool32 value) { this->shaderSharedFloat32AtomicMinMax = value; }
  Bool32 getShaderSharedFloat32AtomicMinMax() const { return this->shaderSharedFloat32AtomicMinMax; }
  void setShaderSharedFloat64AtomicMinMax(Bool32 value) { this->shaderSharedFloat64AtomicMinMax = value; }
  Bool32 getShaderSharedFloat64AtomicMinMax() const { return this->shaderSharedFloat64AtomicMinMax; }
  void setShaderImageFloat32AtomicMinMax(Bool32 value) { this->shaderImageFloat32AtomicMinMax = value; }
  Bool32 getShaderImageFloat32AtomicMinMax() const { return this->shaderImageFloat32AtomicMinMax; }
  void setSparseImageFloat32AtomicMinMax(Bool32 value) { this->sparseImageFloat32AtomicMinMax = value; }
  Bool32 getSparseImageFloat32AtomicMinMax() const { return this->sparseImageFloat32AtomicMinMax; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceShaderAtomicFloat2FeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceShaderAtomicFloat2FeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_shader_atomic_float2

#if VK_VERSION_1_4
struct PhysicalDeviceVertexAttributeDivisorFeatures : VkPhysicalDeviceVertexAttributeDivisorFeatures {
  PhysicalDeviceVertexAttributeDivisorFeatures() noexcept : VkPhysicalDeviceVertexAttributeDivisorFeatures{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES} {}

  void setVertexAttributeInstanceRateDivisor(Bool32 value) { this->vertexAttributeInstanceRateDivisor = value; }
  Bool32 getVertexAttributeInstanceRateDivisor() const { return this->vertexAttributeInstanceRateDivisor; }
  void setVertexAttributeInstanceRateZeroDivisor(Bool32 value) { this->vertexAttributeInstanceRateZeroDivisor = value; }
  Bool32 getVertexAttributeInstanceRateZeroDivisor() const { return this->vertexAttributeInstanceRateZeroDivisor; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceVertexAttributeDivisorFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceVertexAttributeDivisorFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_4

#if VK_VERSION_1_3
struct PhysicalDeviceImageRobustnessFeatures : VkPhysicalDeviceImageRobustnessFeatures {
  PhysicalDeviceImageRobustnessFeatures() noexcept : VkPhysicalDeviceImageRobustnessFeatures{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES} {}

  void setRobustImageAccess(Bool32 value) { this->robustImageAccess = value; }
  Bool32 getRobustImageAccess() const { return this->robustImageAccess; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceImageRobustnessFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceImageRobustnessFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_3

#if VK_VERSION_1_2
struct PhysicalDeviceUniformBufferStandardLayoutFeatures : VkPhysicalDeviceUniformBufferStandardLayoutFeatures {
  PhysicalDeviceUniformBufferStandardLayoutFeatures() noexcept : VkPhysicalDeviceUniformBufferStandardLayoutFeatures{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES} {}

  void setUniformBufferStandardLayout(Bool32 value) { this->uniformBufferStandardLayout = value; }
  Bool32 getUniformBufferStandardLayout() const { return this->uniformBufferStandardLayout; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceUniformBufferStandardLayoutFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceUniformBufferStandardLayoutFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_2

#if VK_EXT_transform_feedback
struct PhysicalDeviceTransformFeedbackFeaturesEXT : VkPhysicalDeviceTransformFeedbackFeaturesEXT {
  PhysicalDeviceTransformFeedbackFeaturesEXT() noexcept : VkPhysicalDeviceTransformFeedbackFeaturesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT} {}

  void setTransformFeedback(Bool32 value) { this->transformFeedback = value; }
  Bool32 getTransformFeedback() const { return this->transformFeedback; }
  void setGeometryStreams(Bool32 value) { this->geometryStreams = value; }
  Bool32 getGeometryStreams() const { return this->geometryStreams; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceTransformFeedbackFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceTransformFeedbackFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_transform_feedback

#if VK_NV_ray_tracing_motion_blur
struct PhysicalDeviceRayTracingMotionBlurFeaturesNV : VkPhysicalDeviceRayTracingMotionBlurFeaturesNV {
  PhysicalDeviceRayTracingMotionBlurFeaturesNV() noexcept : VkPhysicalDeviceRayTracingMotionBlurFeaturesNV{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV} {}

  void setRayTracingMotionBlur(Bool32 value) { this->rayTracingMotionBlur = value; }
  Bool32 getRayTracingMotionBlur() const { return this->rayTracingMotionBlur; }
  void setRayTracingMotionBlurPipelineTraceRaysIndirect(Bool32 value) { this->rayTracingMotionBlurPipelineTraceRaysIndirect = value; }
  Bool32 getRayTracingMotionBlurPipelineTraceRaysIndirect() const { return this->rayTracingMotionBlurPipelineTraceRaysIndirect; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceRayTracingMotionBlurFeaturesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceRayTracingMotionBlurFeaturesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_ray_tracing_motion_blur

#if VK_KHR_compute_shader_derivatives
struct PhysicalDeviceComputeShaderDerivativesFeaturesKHR : VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR {
  PhysicalDeviceComputeShaderDerivativesFeaturesKHR() noexcept : VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_KHR} {}

  void setComputeDerivativeGroupQuads(Bool32 value) { this->computeDerivativeGroupQuads = value; }
  Bool32 getComputeDerivativeGroupQuads() const { return this->computeDerivativeGroupQuads; }
  void setComputeDerivativeGroupLinear(Bool32 value) { this->computeDerivativeGroupLinear = value; }
  Bool32 getComputeDerivativeGroupLinear() const { return this->computeDerivativeGroupLinear; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceComputeShaderDerivativesFeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceComputeShaderDerivativesFeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_compute_shader_derivatives

#if VK_EXT_image_compression_control
struct PhysicalDeviceImageCompressionControlFeaturesEXT : VkPhysicalDeviceImageCompressionControlFeaturesEXT {
  PhysicalDeviceImageCompressionControlFeaturesEXT() noexcept : VkPhysicalDeviceImageCompressionControlFeaturesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT} {}

  void setImageCompressionControl(Bool32 value) { this->imageCompressionControl = value; }
  Bool32 getImageCompressionControl() const { return this->imageCompressionControl; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceImageCompressionControlFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceImageCompressionControlFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_image_compression_control

#if VK_VERSION_1_3
struct PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures : VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures {
  PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures() noexcept : VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES} {}

  void setShaderZeroInitializeWorkgroupMemory(Bool32 value) { this->shaderZeroInitializeWorkgroupMemory = value; }
  Bool32 getShaderZeroInitializeWorkgroupMemory() const { return this->shaderZeroInitializeWorkgroupMemory; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_3

#if VK_VERSION_1_4
struct PhysicalDeviceMaintenance5Features : VkPhysicalDeviceMaintenance5Features {
  PhysicalDeviceMaintenance5Features() noexcept : VkPhysicalDeviceMaintenance5Features{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES} {}

  void setMaintenance5(Bool32 value) { this->maintenance5 = value; }
  Bool32 getMaintenance5() const { return this->maintenance5; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceMaintenance5Features& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceMaintenance5Features& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_4

#if VK_KHR_maintenance9
struct PhysicalDeviceMaintenance9FeaturesKHR : VkPhysicalDeviceMaintenance9FeaturesKHR {
  PhysicalDeviceMaintenance9FeaturesKHR() noexcept : VkPhysicalDeviceMaintenance9FeaturesKHR{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_FEATURES_KHR} {}

  void setMaintenance9(Bool32 value) { this->maintenance9 = value; }
  Bool32 getMaintenance9() const { return this->maintenance9; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceMaintenance9FeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceMaintenance9FeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_maintenance9

#if VK_KHR_fragment_shading_rate
struct PhysicalDeviceFragmentShadingRateFeaturesKHR : VkPhysicalDeviceFragmentShadingRateFeaturesKHR {
  PhysicalDeviceFragmentShadingRateFeaturesKHR() noexcept : VkPhysicalDeviceFragmentShadingRateFeaturesKHR{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR} {}

  void setPipelineFragmentShadingRate(Bool32 value) { this->pipelineFragmentShadingRate = value; }
  Bool32 getPipelineFragmentShadingRate() const { return this->pipelineFragmentShadingRate; }
  void setPrimitiveFragmentShadingRate(Bool32 value) { this->primitiveFragmentShadingRate = value; }
  Bool32 getPrimitiveFragmentShadingRate() const { return this->primitiveFragmentShadingRate; }
  void setAttachmentFragmentShadingRate(Bool32 value) { this->attachmentFragmentShadingRate = value; }
  Bool32 getAttachmentFragmentShadingRate() const { return this->attachmentFragmentShadingRate; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceFragmentShadingRateFeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceFragmentShadingRateFeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_fragment_shading_rate

#if VK_KHR_present_id
struct PhysicalDevicePresentIdFeaturesKHR : VkPhysicalDevicePresentIdFeaturesKHR {
  PhysicalDevicePresentIdFeaturesKHR() noexcept : VkPhysicalDevicePresentIdFeaturesKHR{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR} {}

  // Present ID in VkPresentInfoKHR
  void setPresentId(Bool32 value) { this->presentId = value; }
  Bool32 getPresentId() const { return this->presentId; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDevicePresentIdFeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDevicePresentIdFeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_present_id

#if VK_KHR_present_wait
struct PhysicalDevicePresentWaitFeaturesKHR : VkPhysicalDevicePresentWaitFeaturesKHR {
  PhysicalDevicePresentWaitFeaturesKHR() noexcept : VkPhysicalDevicePresentWaitFeaturesKHR{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR} {}

  // vkWaitForPresentKHR is supported
  void setPresentWait(Bool32 value) { this->presentWait = value; }
  Bool32 getPresentWait() const { return this->presentWait; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDevicePresentWaitFeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDevicePresentWaitFeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_present_wait

#if VK_NV_mesh_shader
struct PhysicalDeviceMeshShaderFeaturesNV : VkPhysicalDeviceMeshShaderFeaturesNV {
  PhysicalDeviceMeshShaderFeaturesNV() noexcept : VkPhysicalDeviceMeshShaderFeaturesNV{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV} {}

  void setTaskShader(Bool32 value) { this->taskShader = value; }
  Bool32 getTaskShader() const { return this->taskShader; }
  void setMeshShader(Bool32 value) { this->meshShader = value; }
  Bool32 getMeshShader() const { return this->meshShader; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceMeshShaderFeaturesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceMeshShaderFeaturesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_mesh_shader

#if VK_VERSION_1_4
struct PhysicalDeviceGlobalPriorityQueryFeatures : VkPhysicalDeviceGlobalPriorityQueryFeatures {
  PhysicalDeviceGlobalPriorityQueryFeatures() noexcept : VkPhysicalDeviceGlobalPriorityQueryFeatures{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES} {}

  void setGlobalPriorityQuery(Bool32 value) { this->globalPriorityQuery = value; }
  Bool32 getGlobalPriorityQuery() const { return this->globalPriorityQuery; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceGlobalPriorityQueryFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceGlobalPriorityQueryFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_4

#if VK_VERSION_1_3
struct PhysicalDeviceShaderTerminateInvocationFeatures : VkPhysicalDeviceShaderTerminateInvocationFeatures {
  PhysicalDeviceShaderTerminateInvocationFeatures() noexcept : VkPhysicalDeviceShaderTerminateInvocationFeatures{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES} {}

  void setShaderTerminateInvocation(Bool32 value) { this->shaderTerminateInvocation = value; }
  Bool32 getShaderTerminateInvocation() const { return this->shaderTerminateInvocation; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceShaderTerminateInvocationFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceShaderTerminateInvocationFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_3

#if VK_KHR_video_maintenance1
struct PhysicalDeviceVideoMaintenance1FeaturesKHR : VkPhysicalDeviceVideoMaintenance1FeaturesKHR {
  PhysicalDeviceVideoMaintenance1FeaturesKHR() noexcept : VkPhysicalDeviceVideoMaintenance1FeaturesKHR{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_1_FEATURES_KHR} {}

  void setVideoMaintenance1(Bool32 value) { this->videoMaintenance1 = value; }
  Bool32 getVideoMaintenance1() const { return this->videoMaintenance1; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceVideoMaintenance1FeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceVideoMaintenance1FeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_maintenance1

#if VK_EXT_legacy_vertex_attributes
struct PhysicalDeviceLegacyVertexAttributesFeaturesEXT : VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT {
  PhysicalDeviceLegacyVertexAttributesFeaturesEXT() noexcept : VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_FEATURES_EXT} {}

  void setLegacyVertexAttributes(Bool32 value) { this->legacyVertexAttributes = value; }
  Bool32 getLegacyVertexAttributes() const { return this->legacyVertexAttributes; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceLegacyVertexAttributesFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceLegacyVertexAttributesFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_legacy_vertex_attributes

#if VK_NV_cooperative_matrix
struct PhysicalDeviceCooperativeMatrixFeaturesNV : VkPhysicalDeviceCooperativeMatrixFeaturesNV {
  PhysicalDeviceCooperativeMatrixFeaturesNV() noexcept : VkPhysicalDeviceCooperativeMatrixFeaturesNV{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV} {}

  void setCooperativeMatrix(Bool32 value) { this->cooperativeMatrix = value; }
  Bool32 getCooperativeMatrix() const { return this->cooperativeMatrix; }
  void setCooperativeMatrixRobustBufferAccess(Bool32 value) { this->cooperativeMatrixRobustBufferAccess = value; }
  Bool32 getCooperativeMatrixRobustBufferAccess() const { return this->cooperativeMatrixRobustBufferAccess; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceCooperativeMatrixFeaturesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceCooperativeMatrixFeaturesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_cooperative_matrix

#if VK_EXT_device_generated_commands
struct PhysicalDeviceDeviceGeneratedCommandsFeaturesEXT : VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT {
  PhysicalDeviceDeviceGeneratedCommandsFeaturesEXT() noexcept : VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_EXT} {}

  void setDeviceGeneratedCommands(Bool32 value) { this->deviceGeneratedCommands = value; }
  Bool32 getDeviceGeneratedCommands() const { return this->deviceGeneratedCommands; }
  void setDynamicGeneratedPipelineLayout(Bool32 value) { this->dynamicGeneratedPipelineLayout = value; }
  Bool32 getDynamicGeneratedPipelineLayout() const { return this->dynamicGeneratedPipelineLayout; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceDeviceGeneratedCommandsFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceDeviceGeneratedCommandsFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_device_generated_commands

#if VK_NV_device_generated_commands_compute
struct PhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV : VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV {
  PhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV() noexcept : VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV} {}

  void setDeviceGeneratedCompute(Bool32 value) { this->deviceGeneratedCompute = value; }
  Bool32 getDeviceGeneratedCompute() const { return this->deviceGeneratedCompute; }
  void setDeviceGeneratedComputePipelines(Bool32 value) { this->deviceGeneratedComputePipelines = value; }
  Bool32 getDeviceGeneratedComputePipelines() const { return this->deviceGeneratedComputePipelines; }
  void setDeviceGeneratedComputeCaptureReplay(Bool32 value) { this->deviceGeneratedComputeCaptureReplay = value; }
  Bool32 getDeviceGeneratedComputeCaptureReplay() const { return this->deviceGeneratedComputeCaptureReplay; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_device_generated_commands_compute

#if VK_VERSION_1_2
struct PhysicalDeviceBufferDeviceAddressFeatures : VkPhysicalDeviceBufferDeviceAddressFeatures {
  PhysicalDeviceBufferDeviceAddressFeatures() noexcept : VkPhysicalDeviceBufferDeviceAddressFeatures{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES} {}

  void setBufferDeviceAddress(Bool32 value) { this->bufferDeviceAddress = value; }
  Bool32 getBufferDeviceAddress() const { return this->bufferDeviceAddress; }
  void setBufferDeviceAddressCaptureReplay(Bool32 value) { this->bufferDeviceAddressCaptureReplay = value; }
  Bool32 getBufferDeviceAddressCaptureReplay() const { return this->bufferDeviceAddressCaptureReplay; }
  void setBufferDeviceAddressMultiDevice(Bool32 value) { this->bufferDeviceAddressMultiDevice = value; }
  Bool32 getBufferDeviceAddressMultiDevice() const { return this->bufferDeviceAddressMultiDevice; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceBufferDeviceAddressFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceBufferDeviceAddressFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }

struct PhysicalDeviceShaderSubgroupExtendedTypesFeatures : VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures {
  PhysicalDeviceShaderSubgroupExtendedTypesFeatures() noexcept : VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES} {}

  // Flag to specify whether subgroup operations with extended types are supported
  void setShaderSubgroupExtendedTypes(Bool32 value) { this->shaderSubgroupExtendedTypes = value; }
  Bool32 getShaderSubgroupExtendedTypes() const { return this->shaderSubgroupExtendedTypes; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceShaderSubgroupExtendedTypesFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceShaderSubgroupExtendedTypesFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_2

#if VK_EXT_nested_command_buffer
struct PhysicalDeviceNestedCommandBufferFeaturesEXT : VkPhysicalDeviceNestedCommandBufferFeaturesEXT {
  PhysicalDeviceNestedCommandBufferFeaturesEXT() noexcept : VkPhysicalDeviceNestedCommandBufferFeaturesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT} {}

  void setNestedCommandBuffer(Bool32 value) { this->nestedCommandBuffer = value; }
  Bool32 getNestedCommandBuffer() const { return this->nestedCommandBuffer; }
  void setNestedCommandBufferRendering(Bool32 value) { this->nestedCommandBufferRendering = value; }
  Bool32 getNestedCommandBufferRendering() const { return this->nestedCommandBufferRendering; }
  void setNestedCommandBufferSimultaneousUse(Bool32 value) { this->nestedCommandBufferSimultaneousUse = value; }
  Bool32 getNestedCommandBufferSimultaneousUse() const { return this->nestedCommandBufferSimultaneousUse; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceNestedCommandBufferFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceNestedCommandBufferFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_nested_command_buffer

#if VK_KHR_robustness2
struct PhysicalDeviceRobustness2FeaturesKHR : VkPhysicalDeviceRobustness2FeaturesKHR {
  PhysicalDeviceRobustness2FeaturesKHR() noexcept : VkPhysicalDeviceRobustness2FeaturesKHR{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_KHR} {}

  void setRobustBufferAccess2(Bool32 value) { this->robustBufferAccess2 = value; }
  Bool32 getRobustBufferAccess2() const { return this->robustBufferAccess2; }
  void setRobustImageAccess2(Bool32 value) { this->robustImageAccess2 = value; }
  Bool32 getRobustImageAccess2() const { return this->robustImageAccess2; }
  void setNullDescriptor(Bool32 value) { this->nullDescriptor = value; }
  Bool32 getNullDescriptor() const { return this->nullDescriptor; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceRobustness2FeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceRobustness2FeaturesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_robustness2

#if VK_EXT_device_fault
struct PhysicalDeviceFaultFeaturesEXT : VkPhysicalDeviceFaultFeaturesEXT {
  PhysicalDeviceFaultFeaturesEXT() noexcept : VkPhysicalDeviceFaultFeaturesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT} {}

  void setDeviceFault(Bool32 value) { this->deviceFault = value; }
  Bool32 getDeviceFault() const { return this->deviceFault; }
  void setDeviceFaultVendorBinary(Bool32 value) { this->deviceFaultVendorBinary = value; }
  Bool32 getDeviceFaultVendorBinary() const { return this->deviceFaultVendorBinary; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceFaultFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceFaultFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_device_fault

#if VK_NV_coverage_reduction_mode
struct PhysicalDeviceCoverageReductionModeFeaturesNV : VkPhysicalDeviceCoverageReductionModeFeaturesNV {
  PhysicalDeviceCoverageReductionModeFeaturesNV() noexcept : VkPhysicalDeviceCoverageReductionModeFeaturesNV{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV} {}

  void setCoverageReductionMode(Bool32 value) { this->coverageReductionMode = value; }
  Bool32 getCoverageReductionMode() const { return this->coverageReductionMode; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceCoverageReductionModeFeaturesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceCoverageReductionModeFeaturesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_coverage_reduction_mode

#if VK_NV_copy_memory_indirect
struct PhysicalDeviceCopyMemoryIndirectFeaturesNV : VkPhysicalDeviceCopyMemoryIndirectFeaturesNV {
  PhysicalDeviceCopyMemoryIndirectFeaturesNV() noexcept : VkPhysicalDeviceCopyMemoryIndirectFeaturesNV{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV} {}

  void setIndirectCopy(Bool32 value) { this->indirectCopy = value; }
  Bool32 getIndirectCopy() const { return this->indirectCopy; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceCopyMemoryIndirectFeaturesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceCopyMemoryIndirectFeaturesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_copy_memory_indirect

#if VK_NV_ray_tracing_validation
struct PhysicalDeviceRayTracingValidationFeaturesNV : VkPhysicalDeviceRayTracingValidationFeaturesNV {
  PhysicalDeviceRayTracingValidationFeaturesNV() noexcept : VkPhysicalDeviceRayTracingValidationFeaturesNV{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_VALIDATION_FEATURES_NV} {}

  void setRayTracingValidation(Bool32 value) { this->rayTracingValidation = value; }
  Bool32 getRayTracingValidation() const { return this->rayTracingValidation; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceRayTracingValidationFeaturesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceRayTracingValidationFeaturesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_ray_tracing_validation

#if VK_EXT_mutable_descriptor_type
struct PhysicalDeviceMutableDescriptorTypeFeaturesEXT : VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT {
  PhysicalDeviceMutableDescriptorTypeFeaturesEXT() noexcept : VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT} {}

  void setMutableDescriptorType(Bool32 value) { this->mutableDescriptorType = value; }
  Bool32 getMutableDescriptorType() const { return this->mutableDescriptorType; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceMutableDescriptorTypeFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceMutableDescriptorTypeFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_mutable_descriptor_type

#if VK_VERSION_1_4
struct PhysicalDeviceHostImageCopyFeatures : VkPhysicalDeviceHostImageCopyFeatures {
  PhysicalDeviceHostImageCopyFeatures() noexcept : VkPhysicalDeviceHostImageCopyFeatures{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES} {}

  void setHostImageCopy(Bool32 value) { this->hostImageCopy = value; }
  Bool32 getHostImageCopy() const { return this->hostImageCopy; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceHostImageCopyFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceHostImageCopyFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_4

#if VK_EXT_descriptor_buffer
struct PhysicalDeviceDescriptorBufferFeaturesEXT : VkPhysicalDeviceDescriptorBufferFeaturesEXT {
  PhysicalDeviceDescriptorBufferFeaturesEXT() noexcept : VkPhysicalDeviceDescriptorBufferFeaturesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT} {}

  void setDescriptorBuffer(Bool32 value) { this->descriptorBuffer = value; }
  Bool32 getDescriptorBuffer() const { return this->descriptorBuffer; }
  void setDescriptorBufferCaptureReplay(Bool32 value) { this->descriptorBufferCaptureReplay = value; }
  Bool32 getDescriptorBufferCaptureReplay() const { return this->descriptorBufferCaptureReplay; }
  void setDescriptorBufferImageLayoutIgnored(Bool32 value) { this->descriptorBufferImageLayoutIgnored = value; }
  Bool32 getDescriptorBufferImageLayoutIgnored() const { return this->descriptorBufferImageLayoutIgnored; }
  void setDescriptorBufferPushDescriptors(Bool32 value) { this->descriptorBufferPushDescriptors = value; }
  Bool32 getDescriptorBufferPushDescriptors() const { return this->descriptorBufferPushDescriptors; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceDescriptorBufferFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceDescriptorBufferFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_descriptor_buffer

#if VK_NV_dedicated_allocation_image_aliasing
struct PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV : VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV {
  PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV() noexcept : VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV} {}

  void setDedicatedAllocationImageAliasing(Bool32 value) { this->dedicatedAllocationImageAliasing = value; }
  Bool32 getDedicatedAllocationImageAliasing() const { return this->dedicatedAllocationImageAliasing; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_dedicated_allocation_image_aliasing

#if VK_VERSION_1_4
struct PhysicalDevicePipelineProtectedAccessFeatures : VkPhysicalDevicePipelineProtectedAccessFeatures {
  PhysicalDevicePipelineProtectedAccessFeatures() noexcept : VkPhysicalDevicePipelineProtectedAccessFeatures{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES} {}

  void setPipelineProtectedAccess(Bool32 value) { this->pipelineProtectedAccess = value; }
  Bool32 getPipelineProtectedAccess() const { return this->pipelineProtectedAccess; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDevicePipelineProtectedAccessFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDevicePipelineProtectedAccessFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_4

#if VK_VERSION_1_3
struct PhysicalDevicePrivateDataFeatures : VkPhysicalDevicePrivateDataFeatures {
  PhysicalDevicePrivateDataFeatures() noexcept : VkPhysicalDevicePrivateDataFeatures{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES} {}

  void setPrivateData(Bool32 value) { this->privateData = value; }
  Bool32 getPrivateData() const { return this->privateData; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDevicePrivateDataFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDevicePrivateDataFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_3

#if VK_EXT_primitives_generated_query
struct PhysicalDevicePrimitivesGeneratedQueryFeaturesEXT : VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT {
  PhysicalDevicePrimitivesGeneratedQueryFeaturesEXT() noexcept : VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT} {}

  void setPrimitivesGeneratedQuery(Bool32 value) { this->primitivesGeneratedQuery = value; }
  Bool32 getPrimitivesGeneratedQuery() const { return this->primitivesGeneratedQuery; }
  void setPrimitivesGeneratedQueryWithRasterizerDiscard(Bool32 value) { this->primitivesGeneratedQueryWithRasterizerDiscard = value; }
  Bool32 getPrimitivesGeneratedQueryWithRasterizerDiscard() const { return this->primitivesGeneratedQueryWithRasterizerDiscard; }
  void setPrimitivesGeneratedQueryWithNonZeroStreams(Bool32 value) { this->primitivesGeneratedQueryWithNonZeroStreams = value; }
  Bool32 getPrimitivesGeneratedQueryWithNonZeroStreams() const { return this->primitivesGeneratedQueryWithNonZeroStreams; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDevicePrimitivesGeneratedQueryFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDevicePrimitivesGeneratedQueryFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_primitives_generated_query

#if VK_INTEL_shader_integer_functions2
struct PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL : VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL {
  PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL() noexcept : VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL} {}

  void setShaderIntegerFunctions2(Bool32 value) { this->shaderIntegerFunctions2 = value; }
  Bool32 getShaderIntegerFunctions2() const { return this->shaderIntegerFunctions2; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_INTEL_shader_integer_functions2

#if VK_VERSION_1_1
struct PhysicalDeviceSamplerYcbcrConversionFeatures : VkPhysicalDeviceSamplerYcbcrConversionFeatures {
  PhysicalDeviceSamplerYcbcrConversionFeatures() noexcept : VkPhysicalDeviceSamplerYcbcrConversionFeatures{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES} {}

  // Sampler color conversion supported
  void setSamplerYcbcrConversion(Bool32 value) { this->samplerYcbcrConversion = value; }
  Bool32 getSamplerYcbcrConversion() const { return this->samplerYcbcrConversion; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceSamplerYcbcrConversionFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceSamplerYcbcrConversionFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_1

#if VK_VERSION_1_2
struct PhysicalDeviceScalarBlockLayoutFeatures : VkPhysicalDeviceScalarBlockLayoutFeatures {
  PhysicalDeviceScalarBlockLayoutFeatures() noexcept : VkPhysicalDeviceScalarBlockLayoutFeatures{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES} {}

  void setScalarBlockLayout(Bool32 value) { this->scalarBlockLayout = value; }
  Bool32 getScalarBlockLayout() const { return this->scalarBlockLayout; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceScalarBlockLayoutFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceScalarBlockLayoutFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_2

#if VK_EXT_color_write_enable
struct PhysicalDeviceColorWriteEnableFeaturesEXT : VkPhysicalDeviceColorWriteEnableFeaturesEXT {
  PhysicalDeviceColorWriteEnableFeaturesEXT() noexcept : VkPhysicalDeviceColorWriteEnableFeaturesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT} {}

  void setColorWriteEnable(Bool32 value) { this->colorWriteEnable = value; }
  Bool32 getColorWriteEnable() const { return this->colorWriteEnable; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceColorWriteEnableFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceColorWriteEnableFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_color_write_enable

#if VK_VERSION_1_2
struct PhysicalDeviceDescriptorIndexingFeatures : VkPhysicalDeviceDescriptorIndexingFeatures {
  PhysicalDeviceDescriptorIndexingFeatures() noexcept : VkPhysicalDeviceDescriptorIndexingFeatures{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES} {}

  void setShaderInputAttachmentArrayDynamicIndexing(Bool32 value) { this->shaderInputAttachmentArrayDynamicIndexing = value; }
  Bool32 getShaderInputAttachmentArrayDynamicIndexing() const { return this->shaderInputAttachmentArrayDynamicIndexing; }
  void setShaderUniformTexelBufferArrayDynamicIndexing(Bool32 value) { this->shaderUniformTexelBufferArrayDynamicIndexing = value; }
  Bool32 getShaderUniformTexelBufferArrayDynamicIndexing() const { return this->shaderUniformTexelBufferArrayDynamicIndexing; }
  void setShaderStorageTexelBufferArrayDynamicIndexing(Bool32 value) { this->shaderStorageTexelBufferArrayDynamicIndexing = value; }
  Bool32 getShaderStorageTexelBufferArrayDynamicIndexing() const { return this->shaderStorageTexelBufferArrayDynamicIndexing; }
  void setShaderUniformBufferArrayNonUniformIndexing(Bool32 value) { this->shaderUniformBufferArrayNonUniformIndexing = value; }
  Bool32 getShaderUniformBufferArrayNonUniformIndexing() const { return this->shaderUniformBufferArrayNonUniformIndexing; }
  void setShaderSampledImageArrayNonUniformIndexing(Bool32 value) { this->shaderSampledImageArrayNonUniformIndexing = value; }
  Bool32 getShaderSampledImageArrayNonUniformIndexing() const { return this->shaderSampledImageArrayNonUniformIndexing; }
  void setShaderStorageBufferArrayNonUniformIndexing(Bool32 value) { this->shaderStorageBufferArrayNonUniformIndexing = value; }
  Bool32 getShaderStorageBufferArrayNonUniformIndexing() const { return this->shaderStorageBufferArrayNonUniformIndexing; }
  void setShaderStorageImageArrayNonUniformIndexing(Bool32 value) { this->shaderStorageImageArrayNonUniformIndexing = value; }
  Bool32 getShaderStorageImageArrayNonUniformIndexing() const { return this->shaderStorageImageArrayNonUniformIndexing; }
  void setShaderInputAttachmentArrayNonUniformIndexing(Bool32 value) { this->shaderInputAttachmentArrayNonUniformIndexing = value; }
  Bool32 getShaderInputAttachmentArrayNonUniformIndexing() const { return this->shaderInputAttachmentArrayNonUniformIndexing; }
  void setShaderUniformTexelBufferArrayNonUniformIndexing(Bool32 value) { this->shaderUniformTexelBufferArrayNonUniformIndexing = value; }
  Bool32 getShaderUniformTexelBufferArrayNonUniformIndexing() const { return this->shaderUniformTexelBufferArrayNonUniformIndexing; }
  void setShaderStorageTexelBufferArrayNonUniformIndexing(Bool32 value) { this->shaderStorageTexelBufferArrayNonUniformIndexing = value; }
  Bool32 getShaderStorageTexelBufferArrayNonUniformIndexing() const { return this->shaderStorageTexelBufferArrayNonUniformIndexing; }
  void setDescriptorBindingUniformBufferUpdateAfterBind(Bool32 value) { this->descriptorBindingUniformBufferUpdateAfterBind = value; }
  Bool32 getDescriptorBindingUniformBufferUpdateAfterBind() const { return this->descriptorBindingUniformBufferUpdateAfterBind; }
  void setDescriptorBindingSampledImageUpdateAfterBind(Bool32 value) { this->descriptorBindingSampledImageUpdateAfterBind = value; }
  Bool32 getDescriptorBindingSampledImageUpdateAfterBind() const { return this->descriptorBindingSampledImageUpdateAfterBind; }
  void setDescriptorBindingStorageImageUpdateAfterBind(Bool32 value) { this->descriptorBindingStorageImageUpdateAfterBind = value; }
  Bool32 getDescriptorBindingStorageImageUpdateAfterBind() const { return this->descriptorBindingStorageImageUpdateAfterBind; }
  void setDescriptorBindingStorageBufferUpdateAfterBind(Bool32 value) { this->descriptorBindingStorageBufferUpdateAfterBind = value; }
  Bool32 getDescriptorBindingStorageBufferUpdateAfterBind() const { return this->descriptorBindingStorageBufferUpdateAfterBind; }
  void setDescriptorBindingUniformTexelBufferUpdateAfterBind(Bool32 value) { this->descriptorBindingUniformTexelBufferUpdateAfterBind = value; }
  Bool32 getDescriptorBindingUniformTexelBufferUpdateAfterBind() const { return this->descriptorBindingUniformTexelBufferUpdateAfterBind; }
  void setDescriptorBindingStorageTexelBufferUpdateAfterBind(Bool32 value) { this->descriptorBindingStorageTexelBufferUpdateAfterBind = value; }
  Bool32 getDescriptorBindingStorageTexelBufferUpdateAfterBind() const { return this->descriptorBindingStorageTexelBufferUpdateAfterBind; }
  void setDescriptorBindingUpdateUnusedWhilePending(Bool32 value) { this->descriptorBindingUpdateUnusedWhilePending = value; }
  Bool32 getDescriptorBindingUpdateUnusedWhilePending() const { return this->descriptorBindingUpdateUnusedWhilePending; }
  void setDescriptorBindingPartiallyBound(Bool32 value) { this->descriptorBindingPartiallyBound = value; }
  Bool32 getDescriptorBindingPartiallyBound() const { return this->descriptorBindingPartiallyBound; }
  void setDescriptorBindingVariableDescriptorCount(Bool32 value) { this->descriptorBindingVariableDescriptorCount = value; }
  Bool32 getDescriptorBindingVariableDescriptorCount() const { return this->descriptorBindingVariableDescriptorCount; }
  void setRuntimeDescriptorArray(Bool32 value) { this->runtimeDescriptorArray = value; }
  Bool32 getRuntimeDescriptorArray() const { return this->runtimeDescriptorArray; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceDescriptorIndexingFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceDescriptorIndexingFeatures& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_2

#if VK_VERSION_1_3
struct PhysicalDeviceSynchronization2Features : VkPhysicalDeviceSynchronization2Features {
  PhysicalDeviceSynchronization2Features() noexcept : VkPhysicalDeviceSynchronization2Features{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES} {}

  void setSynchronization2(Bool32 value) { this->synchronization2 = value; }
  Bool32 getSynchronization2() const { return this->synchronization2; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceSynchronization2Features& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceSynchronization2Features& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_3

#if VK_VERSION_1_2
struct PhysicalDeviceVulkan11Features : VkPhysicalDeviceVulkan11Features {
  PhysicalDeviceVulkan11Features() noexcept : VkPhysicalDeviceVulkan11Features{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES} {}

  // 16-bit integer/floating-point variables supported in BufferBlock
  void setStorageBuffer16BitAccess(Bool32 value) { this->storageBuffer16BitAccess = value; }
  Bool32 getStorageBuffer16BitAccess() const { return this->storageBuffer16BitAccess; }
  // 16-bit integer/floating-point variables supported in BufferBlock and Block
  void setUniformAndStorageBuffer16BitAccess(Bool32 value) { this->uniformAndStorageBuffer16BitAccess = value; }
  Bool32 getUniformAndStorageBuffer16BitAccess() const { return this->uniformAndStorageBuffer16BitAccess; }
  // 16-bit integer/floating-point variables supported in PushConstant
  void setStoragePushConstant16(Bool32 value) { this->storagePushConstant16 = value; }
  Bool32 getStoragePushConstant16() const { return this->storagePushConstant16; }
  // 16-bit integer/floating-point variables supported in shader inputs and outputs
  void setStorageInputOutput16(Bool32 value) { this->storageInputOutput16 = value; }
  Bool32 getStorageInputOutput16() const { return this->storageInputOutput16; }
  // Multiple views in a render pass
  void setMultiview(Bool32 value) { this->multiview = value; }
  Bool32 getMultiview() const { return this->multiview; }
  // Multiple views in a render pass w/ geometry shader
  void setMultiviewGeometryShader(Bool32 value) { this->multiviewGeometryShader = value; }
  Bool32 getMultiviewGeometryShader() const { return this->multiviewGeometryShader; }
  // Multiple views in a render pass w/ tessellation shader
  void setMultiviewTessellationShader(Bool32 value) { this->multiviewTessellationShader = value; }
  Bool32 getMultiviewTessellationShader() const { return this->multiviewTessellationShader; }
  void setVariablePointersStorageBuffer(Bool32 value) { this->variablePointersStorageBuffer = value; }
  Bool32 getVariablePointersStorageBuffer() const { return this->variablePointersStorageBuffer; }
  void setVariablePointers(Bool32 value) { this->variablePointers = value; }
  Bool32 getVariablePointers() const { return this->variablePointers; }
  void setProtectedMemory(Bool32 value) { this->protectedMemory = value; }
  Bool32 getProtectedMemory() const { return this->protectedMemory; }
  // Sampler color conversion supported
  void setSamplerYcbcrConversion(Bool32 value) { this->samplerYcbcrConversion = value; }
  Bool32 getSamplerYcbcrConversion() const { return this->samplerYcbcrConversion; }
  void setShaderDrawParameters(Bool32 value) { this->shaderDrawParameters = value; }
  Bool32 getShaderDrawParameters() const { return this->shaderDrawParameters; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDeviceVulkan11Features& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDeviceVulkan11Features& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_2

#if VK_EXT_primitive_topology_list_restart
struct PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT : VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT {
  PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT() noexcept : VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT} {}

  void setPrimitiveTopologyListRestart(Bool32 value) { this->primitiveTopologyListRestart = value; }
  Bool32 getPrimitiveTopologyListRestart() const { return this->primitiveTopologyListRestart; }
  void setPrimitiveTopologyPatchListRestart(Bool32 value) { this->primitiveTopologyPatchListRestart = value; }
  Bool32 getPrimitiveTopologyPatchListRestart() const { return this->primitiveTopologyPatchListRestart; }
};
inline void PhysicalDeviceFeatures2::attach(PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void DeviceCreateInfo::attach(PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_primitive_topology_list_restart

#if VK_EXT_memory_budget
struct PhysicalDeviceMemoryBudgetPropertiesEXT : VkPhysicalDeviceMemoryBudgetPropertiesEXT {
  PhysicalDeviceMemoryBudgetPropertiesEXT() noexcept : VkPhysicalDeviceMemoryBudgetPropertiesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT} {}

  std::span<const DeviceSize, VK_MAX_MEMORY_HEAPS> getHeapBudget() const { return this->heapBudget; }
  std::span<const DeviceSize, VK_MAX_MEMORY_HEAPS> getHeapUsage() const { return this->heapUsage; }
};
inline void PhysicalDeviceMemoryProperties2::attach(PhysicalDeviceMemoryBudgetPropertiesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_memory_budget

#if VK_KHR_get_physical_device_properties2
using PhysicalDeviceMemoryProperties2KHR = PhysicalDeviceMemoryProperties2;
#endif // VK_KHR_get_physical_device_properties2
#if VK_EXT_subgroup_size_control
using PipelineShaderStageRequiredSubgroupSizeCreateInfoEXT = PipelineShaderStageRequiredSubgroupSizeCreateInfo;
#endif // VK_EXT_subgroup_size_control
#if VK_EXT_shader_object
using ShaderRequiredSubgroupSizeCreateInfoEXT = PipelineShaderStageRequiredSubgroupSizeCreateInfo;
#endif // VK_EXT_shader_object
#if VK_VALVE_mutable_descriptor_type
using MutableDescriptorTypeCreateInfoVALVE = MutableDescriptorTypeCreateInfoEXT;
#endif // VK_VALVE_mutable_descriptor_type
#if VK_EXT_descriptor_indexing
using DescriptorSetLayoutBindingFlagsCreateInfoEXT = DescriptorSetLayoutBindingFlagsCreateInfo;
#endif // VK_EXT_descriptor_indexing

#if VK_VERSION_1_0
struct ShaderModuleCreateInfo : VkShaderModuleCreateInfo {
  ShaderModuleCreateInfo() noexcept : VkShaderModuleCreateInfo{.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO} {}

  // Specified in bytes
  void setCodeSize(size_t value) { this->codeSize = value; }
  size_t getCodeSize() const { return this->codeSize; }
  // Binary code of size codeSize
  void setCode(const uint32_t* value) { this->pCode = value; }
  const uint32_t* getCode() const { return this->pCode; }

  void setFlags(ShaderModuleCreateFlags value) { this->flags = std::bit_cast<VkShaderModuleCreateFlags>(value); }
  ShaderModuleCreateFlags getFlags() const { return std::bit_cast<ShaderModuleCreateFlags>(this->flags); }

#if VK_EXT_validation_cache
  void attach(struct ShaderModuleValidationCacheCreateInfoEXT&);
#endif // VK_EXT_validation_cache
};
inline void PipelineShaderStageCreateInfo::attachHead(ShaderModuleCreateInfo& ext) { pNext = &ext; }
#if VK_ARM_data_graph
inline void DataGraphPipelineShaderModuleCreateInfoARM::attachHead(ShaderModuleCreateInfo& ext) { pNext = &ext; }
#endif // VK_ARM_data_graph
#endif // VK_VERSION_1_0

#if VK_EXT_device_address_binding_report
struct DeviceAddressBindingCallbackDataEXT : VkDeviceAddressBindingCallbackDataEXT {
  DeviceAddressBindingCallbackDataEXT() noexcept : VkDeviceAddressBindingCallbackDataEXT{.sType = VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT} {}

  void setBaseAddress(DeviceAddress value) { this->baseAddress = value; }
  DeviceAddress getBaseAddress() const { return this->baseAddress; }
  void setSize(DeviceSize value) { this->size = value; }
  DeviceSize getSize() const { return this->size; }
  void setBindingType(DeviceAddressBindingTypeEXT value) { this->bindingType = std::bit_cast<VkDeviceAddressBindingTypeEXT>(value); }
  DeviceAddressBindingTypeEXT getBindingType() const { return std::bit_cast<DeviceAddressBindingTypeEXT>(this->bindingType); }

  void setFlags(DeviceAddressBindingFlagsEXT value) { this->flags = std::bit_cast<VkDeviceAddressBindingFlagsEXT>(value); }
  DeviceAddressBindingFlagsEXT getFlags() const { return std::bit_cast<DeviceAddressBindingFlagsEXT>(this->flags); }
};
inline void DebugUtilsMessengerCallbackDataEXT::attach(DeviceAddressBindingCallbackDataEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_device_address_binding_report

#if VK_VERSION_1_4
struct RenderingAttachmentLocationInfo : VkRenderingAttachmentLocationInfo {
  RenderingAttachmentLocationInfo() noexcept : VkRenderingAttachmentLocationInfo{.sType = VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO} {}

  void setColorAttachmentCount(uint32_t value) { this->colorAttachmentCount = value; }
  uint32_t getColorAttachmentCount() const { return this->colorAttachmentCount; }
  void setColorAttachmentLocations(const uint32_t* value) { this->pColorAttachmentLocations = value; }
  const uint32_t* getColorAttachmentLocations() const { return this->pColorAttachmentLocations; }
};
inline void GraphicsPipelineCreateInfo::attach(RenderingAttachmentLocationInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void CommandBufferInheritanceInfo::attach(RenderingAttachmentLocationInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }

struct RenderingInputAttachmentIndexInfo : VkRenderingInputAttachmentIndexInfo {
  RenderingInputAttachmentIndexInfo() noexcept : VkRenderingInputAttachmentIndexInfo{.sType = VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO} {}

  void setColorAttachmentCount(uint32_t value) { this->colorAttachmentCount = value; }
  uint32_t getColorAttachmentCount() const { return this->colorAttachmentCount; }
  void setColorAttachmentInputIndices(const uint32_t* value) { this->pColorAttachmentInputIndices = value; }
  const uint32_t* getColorAttachmentInputIndices() const { return this->pColorAttachmentInputIndices; }
  void setDepthInputAttachmentIndex(const uint32_t* value) { this->pDepthInputAttachmentIndex = value; }
  const uint32_t* getDepthInputAttachmentIndex() const { return this->pDepthInputAttachmentIndex; }
  void setStencilInputAttachmentIndex(const uint32_t* value) { this->pStencilInputAttachmentIndex = value; }
  const uint32_t* getStencilInputAttachmentIndex() const { return this->pStencilInputAttachmentIndex; }
};
inline void GraphicsPipelineCreateInfo::attach(RenderingInputAttachmentIndexInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void CommandBufferInheritanceInfo::attach(RenderingInputAttachmentIndexInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_4

#if VK_KHR_fragment_shading_rate
struct PipelineFragmentShadingRateStateCreateInfoKHR : VkPipelineFragmentShadingRateStateCreateInfoKHR {
  PipelineFragmentShadingRateStateCreateInfoKHR() noexcept : VkPipelineFragmentShadingRateStateCreateInfoKHR{.sType = VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR} {}

  void setFragmentSize(const Extent2D& value) { this->fragmentSize = value; }
  const Extent2D& getFragmentSize() const { return static_cast<const Extent2D&>(this->fragmentSize); }
  void setCombinerOps(std::span<const FragmentShadingRateCombinerOpKHR, 2> value) { std::memcpy(&this->combinerOps, value.data(), value.size_bytes()); }
  std::span<const FragmentShadingRateCombinerOpKHR, 2> getCombinerOps() const { return std::span<const FragmentShadingRateCombinerOpKHR, 2>(std::bit_cast<const FragmentShadingRateCombinerOpKHR*>(&this->combinerOps), 2); }
};
inline void GraphicsPipelineCreateInfo::attach(PipelineFragmentShadingRateStateCreateInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_fragment_shading_rate

#if VK_VALVE_fragment_density_map_layered
struct PipelineFragmentDensityMapLayeredCreateInfoVALVE : VkPipelineFragmentDensityMapLayeredCreateInfoVALVE {
  PipelineFragmentDensityMapLayeredCreateInfoVALVE() noexcept : VkPipelineFragmentDensityMapLayeredCreateInfoVALVE{.sType = VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_DENSITY_MAP_LAYERED_CREATE_INFO_VALVE} {}

  void setMaxFragmentDensityMapLayers(uint32_t value) { this->maxFragmentDensityMapLayers = value; }
  uint32_t getMaxFragmentDensityMapLayers() const { return this->maxFragmentDensityMapLayers; }
};
inline void GraphicsPipelineCreateInfo::attach(PipelineFragmentDensityMapLayeredCreateInfoVALVE& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VALVE_fragment_density_map_layered

#if VK_KHR_pipeline_library
struct PipelineLibraryCreateInfoKHR : VkPipelineLibraryCreateInfoKHR {
  PipelineLibraryCreateInfoKHR() noexcept : VkPipelineLibraryCreateInfoKHR{.sType = VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR} {}

  void setLibraryCount(uint32_t value) { this->libraryCount = value; }
  uint32_t getLibraryCount() const { return this->libraryCount; }
  void setLibraries(const Pipeline* value) { this->pLibraries = std::bit_cast<const VkPipeline*>(value); }
  const Pipeline* getLibraries() const { return std::bit_cast<const Pipeline*>(this->pLibraries); }
};
inline void GraphicsPipelineCreateInfo::attach(PipelineLibraryCreateInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_pipeline_library

#if VK_ANDROID_external_memory_android_hardware_buffer
struct ExternalFormatANDROID : VkExternalFormatANDROID {
  ExternalFormatANDROID() noexcept : VkExternalFormatANDROID{.sType = VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID} {}

  void setExternalFormat(uint64_t value) { this->externalFormat = value; }
  uint64_t getExternalFormat() const { return this->externalFormat; }
};
inline void ImageCreateInfo::attach(ExternalFormatANDROID& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void SamplerYcbcrConversionCreateInfo::attach(ExternalFormatANDROID& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void AttachmentDescription2::attach(ExternalFormatANDROID& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void GraphicsPipelineCreateInfo::attach(ExternalFormatANDROID& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void CommandBufferInheritanceInfo::attach(ExternalFormatANDROID& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_ANDROID_external_memory_android_hardware_buffer

#if VK_EXT_graphics_pipeline_library
struct GraphicsPipelineLibraryCreateInfoEXT : VkGraphicsPipelineLibraryCreateInfoEXT {
  GraphicsPipelineLibraryCreateInfoEXT() noexcept : VkGraphicsPipelineLibraryCreateInfoEXT{.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT} {}

  void setFlags(GraphicsPipelineLibraryFlagsEXT value) { this->flags = std::bit_cast<VkGraphicsPipelineLibraryFlagsEXT>(value); }
  GraphicsPipelineLibraryFlagsEXT getFlags() const { return std::bit_cast<GraphicsPipelineLibraryFlagsEXT>(this->flags); }
};
inline void GraphicsPipelineCreateInfo::attach(GraphicsPipelineLibraryCreateInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_graphics_pipeline_library

#if VK_NV_fragment_shading_rate_enums
struct PipelineFragmentShadingRateEnumStateCreateInfoNV : VkPipelineFragmentShadingRateEnumStateCreateInfoNV {
  PipelineFragmentShadingRateEnumStateCreateInfoNV() noexcept : VkPipelineFragmentShadingRateEnumStateCreateInfoNV{.sType = VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV} {}

  void setShadingRateType(FragmentShadingRateTypeNV value) { this->shadingRateType = std::bit_cast<VkFragmentShadingRateTypeNV>(value); }
  FragmentShadingRateTypeNV getShadingRateType() const { return std::bit_cast<FragmentShadingRateTypeNV>(this->shadingRateType); }
  void setShadingRate(FragmentShadingRateNV value) { this->shadingRate = std::bit_cast<VkFragmentShadingRateNV>(value); }
  FragmentShadingRateNV getShadingRate() const { return std::bit_cast<FragmentShadingRateNV>(this->shadingRate); }
  void setCombinerOps(std::span<const FragmentShadingRateCombinerOpKHR, 2> value) { std::memcpy(&this->combinerOps, value.data(), value.size_bytes()); }
  std::span<const FragmentShadingRateCombinerOpKHR, 2> getCombinerOps() const { return std::span<const FragmentShadingRateCombinerOpKHR, 2>(std::bit_cast<const FragmentShadingRateCombinerOpKHR*>(&this->combinerOps), 2); }
};
inline void GraphicsPipelineCreateInfo::attach(PipelineFragmentShadingRateEnumStateCreateInfoNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_fragment_shading_rate_enums

#if VK_NV_device_generated_commands
struct GraphicsPipelineShaderGroupsCreateInfoNV : VkGraphicsPipelineShaderGroupsCreateInfoNV {
  GraphicsPipelineShaderGroupsCreateInfoNV() noexcept : VkGraphicsPipelineShaderGroupsCreateInfoNV{.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV} {}

  void setGroupCount(uint32_t value) { this->groupCount = value; }
  uint32_t getGroupCount() const { return this->groupCount; }
  void setGroups(const GraphicsShaderGroupCreateInfoNV* value) { this->pGroups = std::bit_cast<const VkGraphicsShaderGroupCreateInfoNV*>(value); }
  const GraphicsShaderGroupCreateInfoNV* getGroups() const { return std::bit_cast<const GraphicsShaderGroupCreateInfoNV*>(this->pGroups); }
  void setPipelineCount(uint32_t value) { this->pipelineCount = value; }
  uint32_t getPipelineCount() const { return this->pipelineCount; }
  void setPipelines(const Pipeline* value) { this->pPipelines = std::bit_cast<const VkPipeline*>(value); }
  const Pipeline* getPipelines() const { return std::bit_cast<const Pipeline*>(this->pPipelines); }
};
inline void GraphicsPipelineCreateInfo::attach(GraphicsPipelineShaderGroupsCreateInfoNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_device_generated_commands

#if VK_NV_representative_fragment_test
struct PipelineRepresentativeFragmentTestStateCreateInfoNV : VkPipelineRepresentativeFragmentTestStateCreateInfoNV {
  PipelineRepresentativeFragmentTestStateCreateInfoNV() noexcept : VkPipelineRepresentativeFragmentTestStateCreateInfoNV{.sType = VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV} {}

  void setRepresentativeFragmentTestEnable(Bool32 value) { this->representativeFragmentTestEnable = value; }
  Bool32 getRepresentativeFragmentTestEnable() const { return this->representativeFragmentTestEnable; }
};
inline void GraphicsPipelineCreateInfo::attach(PipelineRepresentativeFragmentTestStateCreateInfoNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_representative_fragment_test

#if VK_EXT_discard_rectangles
struct PipelineDiscardRectangleStateCreateInfoEXT : VkPipelineDiscardRectangleStateCreateInfoEXT {
  PipelineDiscardRectangleStateCreateInfoEXT() noexcept : VkPipelineDiscardRectangleStateCreateInfoEXT{.sType = VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT} {}

  void setDiscardRectangleMode(DiscardRectangleModeEXT value) { this->discardRectangleMode = std::bit_cast<VkDiscardRectangleModeEXT>(value); }
  DiscardRectangleModeEXT getDiscardRectangleMode() const { return std::bit_cast<DiscardRectangleModeEXT>(this->discardRectangleMode); }

  void setFlags(PipelineDiscardRectangleStateCreateFlagsEXT value) { this->flags = std::bit_cast<VkPipelineDiscardRectangleStateCreateFlagsEXT>(value); }
  PipelineDiscardRectangleStateCreateFlagsEXT getFlags() const { return std::bit_cast<PipelineDiscardRectangleStateCreateFlagsEXT>(this->flags); }
  void setDiscardRectangleCount(uint32_t value) { this->discardRectangleCount = value; }
  uint32_t getDiscardRectangleCount() const { return this->discardRectangleCount; }
  void setDiscardRectangles(const Rect2D* value) { this->pDiscardRectangles = std::bit_cast<const VkRect2D*>(value); }
  const Rect2D* getDiscardRectangles() const { return std::bit_cast<const Rect2D*>(this->pDiscardRectangles); }
};
inline void GraphicsPipelineCreateInfo::attach(PipelineDiscardRectangleStateCreateInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_discard_rectangles

#if VK_AMD_mixed_attachment_samples
struct AttachmentSampleCountInfoAMD : VkAttachmentSampleCountInfoAMD {
  AttachmentSampleCountInfoAMD() noexcept : VkAttachmentSampleCountInfoAMD{.sType = VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD} {}

  void setColorAttachmentCount(uint32_t value) { this->colorAttachmentCount = value; }
  uint32_t getColorAttachmentCount() const { return this->colorAttachmentCount; }
  void setColorAttachmentSamples(const SampleCountFlagBits* value) { this->pColorAttachmentSamples = std::bit_cast<const VkSampleCountFlagBits*>(value); }
  const SampleCountFlagBits* getColorAttachmentSamples() const { return std::bit_cast<const SampleCountFlagBits*>(this->pColorAttachmentSamples); }
  void setDepthStencilAttachmentSamples(SampleCountFlagBits value) { this->depthStencilAttachmentSamples = std::bit_cast<VkSampleCountFlagBits>(value); }
  SampleCountFlagBits getDepthStencilAttachmentSamples() const { return std::bit_cast<SampleCountFlagBits>(this->depthStencilAttachmentSamples); }
};
inline void CommandBufferInheritanceInfo::attach(AttachmentSampleCountInfoAMD& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void GraphicsPipelineCreateInfo::attach(AttachmentSampleCountInfoAMD& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_AMD_mixed_attachment_samples

#if VK_NVX_multiview_per_view_attributes
struct MultiviewPerViewAttributesInfoNVX : VkMultiviewPerViewAttributesInfoNVX {
  MultiviewPerViewAttributesInfoNVX() noexcept : VkMultiviewPerViewAttributesInfoNVX{.sType = VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX} {}

  void setPerViewAttributes(Bool32 value) { this->perViewAttributes = value; }
  Bool32 getPerViewAttributes() const { return this->perViewAttributes; }
  void setPerViewAttributesPositionXOnly(Bool32 value) { this->perViewAttributesPositionXOnly = value; }
  Bool32 getPerViewAttributesPositionXOnly() const { return this->perViewAttributesPositionXOnly; }
};
inline void CommandBufferInheritanceInfo::attach(MultiviewPerViewAttributesInfoNVX& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void GraphicsPipelineCreateInfo::attach(MultiviewPerViewAttributesInfoNVX& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void RenderingInfo::attach(MultiviewPerViewAttributesInfoNVX& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NVX_multiview_per_view_attributes

#if VK_VERSION_1_3
struct PipelineRenderingCreateInfo : VkPipelineRenderingCreateInfo {
  PipelineRenderingCreateInfo() noexcept : VkPipelineRenderingCreateInfo{.sType = VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO} {}

  void setViewMask(uint32_t value) { this->viewMask = value; }
  uint32_t getViewMask() const { return this->viewMask; }
  void setDepthAttachmentFormat(Format value) { this->depthAttachmentFormat = std::bit_cast<VkFormat>(value); }
  Format getDepthAttachmentFormat() const { return std::bit_cast<Format>(this->depthAttachmentFormat); }
  void setStencilAttachmentFormat(Format value) { this->stencilAttachmentFormat = std::bit_cast<VkFormat>(value); }
  Format getStencilAttachmentFormat() const { return std::bit_cast<Format>(this->stencilAttachmentFormat); }

  void setColorAttachmentCount(uint32_t value) { this->colorAttachmentCount = value; }
  uint32_t getColorAttachmentCount() const { return this->colorAttachmentCount; }
  void setColorAttachmentFormats(const Format* value) { this->pColorAttachmentFormats = std::bit_cast<const VkFormat*>(value); }
  const Format* getColorAttachmentFormats() const { return std::bit_cast<const Format*>(this->pColorAttachmentFormats); }
};
inline void GraphicsPipelineCreateInfo::attach(PipelineRenderingCreateInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_3

#if VK_KHR_format_feature_flags2
using FormatProperties3KHR = FormatProperties3;
#endif // VK_KHR_format_feature_flags2
#if VK_KHR_device_group
using DeviceGroupCommandBufferBeginInfoKHR = DeviceGroupCommandBufferBeginInfo;
#endif // VK_KHR_device_group

#if VK_QCOM_tile_memory_heap
struct TileMemorySizeInfoQCOM : VkTileMemorySizeInfoQCOM {
  TileMemorySizeInfoQCOM() noexcept : VkTileMemorySizeInfoQCOM{.sType = VK_STRUCTURE_TYPE_TILE_MEMORY_SIZE_INFO_QCOM} {}

  void setSize(DeviceSize value) { this->size = value; }
  DeviceSize getSize() const { return this->size; }
};
inline void RenderPassCreateInfo::attach(TileMemorySizeInfoQCOM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void RenderPassCreateInfo2::attach(TileMemorySizeInfoQCOM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void RenderingInfo::attach(TileMemorySizeInfoQCOM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_QCOM_tile_memory_heap

#if VK_KHR_create_renderpass2
using RenderPassCreateInfo2KHR = RenderPassCreateInfo2;
#endif // VK_KHR_create_renderpass2

#if VK_EXT_subpass_merge_feedback
struct RenderPassCreationFeedbackCreateInfoEXT : VkRenderPassCreationFeedbackCreateInfoEXT {
  RenderPassCreationFeedbackCreateInfoEXT() noexcept : VkRenderPassCreationFeedbackCreateInfoEXT{.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT} {}

  void setRenderPassFeedback(RenderPassCreationFeedbackInfoEXT* value) { this->pRenderPassFeedback = std::bit_cast<VkRenderPassCreationFeedbackInfoEXT*>(value); }
  RenderPassCreationFeedbackInfoEXT* getRenderPassFeedback() const { return std::bit_cast<RenderPassCreationFeedbackInfoEXT*>(this->pRenderPassFeedback); }
};
inline void RenderPassCreateInfo2::attach(RenderPassCreationFeedbackCreateInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_subpass_merge_feedback

#if VK_QCOM_tile_shading
struct RenderPassTileShadingCreateInfoQCOM : VkRenderPassTileShadingCreateInfoQCOM {
  RenderPassTileShadingCreateInfoQCOM() noexcept : VkRenderPassTileShadingCreateInfoQCOM{.sType = VK_STRUCTURE_TYPE_RENDER_PASS_TILE_SHADING_CREATE_INFO_QCOM} {}

  void setFlags(TileShadingRenderPassFlagsQCOM value) { this->flags = std::bit_cast<VkTileShadingRenderPassFlagsQCOM>(value); }
  TileShadingRenderPassFlagsQCOM getFlags() const { return std::bit_cast<TileShadingRenderPassFlagsQCOM>(this->flags); }
  void setTileApronSize(const Extent2D& value) { this->tileApronSize = value; }
  const Extent2D& getTileApronSize() const { return static_cast<const Extent2D&>(this->tileApronSize); }
};
inline void RenderPassCreateInfo::attach(RenderPassTileShadingCreateInfoQCOM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void RenderPassCreateInfo2::attach(RenderPassTileShadingCreateInfoQCOM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void RenderingInfo::attach(RenderPassTileShadingCreateInfoQCOM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void CommandBufferInheritanceInfo::attach(RenderPassTileShadingCreateInfoQCOM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_QCOM_tile_shading

#if VK_EXT_subpass_merge_feedback
struct RenderPassCreationControlEXT : VkRenderPassCreationControlEXT {
  RenderPassCreationControlEXT() noexcept : VkRenderPassCreationControlEXT{.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT} {}

  void setDisallowMerging(Bool32 value) { this->disallowMerging = value; }
  Bool32 getDisallowMerging() const { return this->disallowMerging; }
};
inline void RenderPassCreateInfo2::attach(RenderPassCreationControlEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void SubpassDescription2::attach(RenderPassCreationControlEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_subpass_merge_feedback

#if VK_EXT_fragment_density_map
struct RenderPassFragmentDensityMapCreateInfoEXT : VkRenderPassFragmentDensityMapCreateInfoEXT {
  RenderPassFragmentDensityMapCreateInfoEXT() noexcept : VkRenderPassFragmentDensityMapCreateInfoEXT{.sType = VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT} {}

  void setFragmentDensityMapAttachment(const AttachmentReference& value) { this->fragmentDensityMapAttachment = value; }
  const AttachmentReference& getFragmentDensityMapAttachment() const { return static_cast<const AttachmentReference&>(this->fragmentDensityMapAttachment); }
};
inline void RenderPassCreateInfo::attach(RenderPassFragmentDensityMapCreateInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void RenderPassCreateInfo2::attach(RenderPassFragmentDensityMapCreateInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_fragment_density_map

#if VK_KHR_depth_stencil_resolve
using SubpassDescriptionDepthStencilResolveKHR = SubpassDescriptionDepthStencilResolve;
#endif // VK_KHR_depth_stencil_resolve
#if VK_KHR_maintenance5
using DeviceImageSubresourceInfoKHR = DeviceImageSubresourceInfo;
#endif // VK_KHR_maintenance5

#if VK_VERSION_1_0
struct BindSparseInfo : VkBindSparseInfo {
  BindSparseInfo() noexcept : VkBindSparseInfo{.sType = VK_STRUCTURE_TYPE_BIND_SPARSE_INFO} {}

  void setWaitSemaphoreCount(uint32_t value) { this->waitSemaphoreCount = value; }
  uint32_t getWaitSemaphoreCount() const { return this->waitSemaphoreCount; }
  void setWaitSemaphores(const Semaphore* value) { this->pWaitSemaphores = std::bit_cast<const VkSemaphore*>(value); }
  const Semaphore* getWaitSemaphores() const { return std::bit_cast<const Semaphore*>(this->pWaitSemaphores); }
  void setBufferBindCount(uint32_t value) { this->bufferBindCount = value; }
  uint32_t getBufferBindCount() const { return this->bufferBindCount; }
  void setBufferBinds(const SparseBufferMemoryBindInfo* value) { this->pBufferBinds = std::bit_cast<const VkSparseBufferMemoryBindInfo*>(value); }
  const SparseBufferMemoryBindInfo* getBufferBinds() const { return std::bit_cast<const SparseBufferMemoryBindInfo*>(this->pBufferBinds); }
  void setImageOpaqueBindCount(uint32_t value) { this->imageOpaqueBindCount = value; }
  uint32_t getImageOpaqueBindCount() const { return this->imageOpaqueBindCount; }
  void setImageOpaqueBinds(const SparseImageOpaqueMemoryBindInfo* value) { this->pImageOpaqueBinds = std::bit_cast<const VkSparseImageOpaqueMemoryBindInfo*>(value); }
  const SparseImageOpaqueMemoryBindInfo* getImageOpaqueBinds() const { return std::bit_cast<const SparseImageOpaqueMemoryBindInfo*>(this->pImageOpaqueBinds); }
  void setImageBindCount(uint32_t value) { this->imageBindCount = value; }
  uint32_t getImageBindCount() const { return this->imageBindCount; }
  void setImageBinds(const SparseImageMemoryBindInfo* value) { this->pImageBinds = std::bit_cast<const VkSparseImageMemoryBindInfo*>(value); }
  const SparseImageMemoryBindInfo* getImageBinds() const { return std::bit_cast<const SparseImageMemoryBindInfo*>(this->pImageBinds); }
  void setSignalSemaphoreCount(uint32_t value) { this->signalSemaphoreCount = value; }
  uint32_t getSignalSemaphoreCount() const { return this->signalSemaphoreCount; }
  void setSignalSemaphores(const Semaphore* value) { this->pSignalSemaphores = std::bit_cast<const VkSemaphore*>(value); }
  const Semaphore* getSignalSemaphores() const { return std::bit_cast<const Semaphore*>(this->pSignalSemaphores); }

#if VK_VERSION_1_1
  void attach(struct DeviceGroupBindSparseInfo&);
#endif // VK_VERSION_1_1
#if VK_VERSION_1_2
  void attach(struct TimelineSemaphoreSubmitInfo&);
#endif // VK_VERSION_1_2
#if VK_EXT_frame_boundary
  void attach(struct FrameBoundaryEXT&);
#endif // VK_EXT_frame_boundary
#if VK_ARM_tensors
  void attach(struct FrameBoundaryTensorsARM&);
#endif // VK_ARM_tensors
};
#endif // VK_VERSION_1_0

#if VK_QCOM_filter_cubic_weights
struct BlitImageCubicWeightsInfoQCOM : VkBlitImageCubicWeightsInfoQCOM {
  BlitImageCubicWeightsInfoQCOM() noexcept : VkBlitImageCubicWeightsInfoQCOM{.sType = VK_STRUCTURE_TYPE_BLIT_IMAGE_CUBIC_WEIGHTS_INFO_QCOM} {}

  void setCubicWeights(CubicFilterWeightsQCOM value) { this->cubicWeights = std::bit_cast<VkCubicFilterWeightsQCOM>(value); }
  CubicFilterWeightsQCOM getCubicWeights() const { return std::bit_cast<CubicFilterWeightsQCOM>(this->cubicWeights); }
};
inline void BlitImageInfo2::attach(BlitImageCubicWeightsInfoQCOM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_QCOM_filter_cubic_weights

#if VK_KHR_copy_commands2
using BlitImageInfo2KHR = BlitImageInfo2;
#endif // VK_KHR_copy_commands2
#if VK_EXT_host_image_copy
using CopyMemoryToImageInfoEXT = CopyMemoryToImageInfo;
using CopyImageToMemoryInfoEXT = CopyImageToMemoryInfo;
#endif // VK_EXT_host_image_copy
#if VK_KHR_copy_commands2
using CopyImageToBufferInfo2KHR = CopyImageToBufferInfo2;
using CopyBufferToImageInfo2KHR = CopyBufferToImageInfo2;
using CopyImageInfo2KHR = CopyImageInfo2;
#endif // VK_KHR_copy_commands2
#if VK_EXT_host_image_copy
using CopyImageToImageInfoEXT = CopyImageToImageInfo;
#endif // VK_EXT_host_image_copy
#if VK_KHR_copy_commands2
using ResolveImageInfo2KHR = ResolveImageInfo2;
#endif // VK_KHR_copy_commands2

#if VK_EXT_sample_locations
struct AttachmentSampleLocationsEXT : VkAttachmentSampleLocationsEXT {
  AttachmentSampleLocationsEXT() noexcept : VkAttachmentSampleLocationsEXT{} {}
  AttachmentSampleLocationsEXT(uint32_t attachmentIndex, const SampleLocationsInfoEXT& sampleLocationsInfo) noexcept : VkAttachmentSampleLocationsEXT{.attachmentIndex = attachmentIndex, .sampleLocationsInfo = sampleLocationsInfo} {}

  void setAttachmentIndex(uint32_t value) { this->attachmentIndex = value; }
  uint32_t getAttachmentIndex() const { return this->attachmentIndex; }
  void setSampleLocationsInfo(const SampleLocationsInfoEXT& value) { this->sampleLocationsInfo = value; }
  const SampleLocationsInfoEXT& getSampleLocationsInfo() const { return static_cast<const SampleLocationsInfoEXT&>(this->sampleLocationsInfo); }
};

struct PipelineSampleLocationsStateCreateInfoEXT : VkPipelineSampleLocationsStateCreateInfoEXT {
  PipelineSampleLocationsStateCreateInfoEXT() noexcept : VkPipelineSampleLocationsStateCreateInfoEXT{.sType = VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT} {}

  void setSampleLocationsInfo(const SampleLocationsInfoEXT& value) { this->sampleLocationsInfo = value; }
  const SampleLocationsInfoEXT& getSampleLocationsInfo() const { return static_cast<const SampleLocationsInfoEXT&>(this->sampleLocationsInfo); }

  void setSampleLocationsEnable(Bool32 value) { this->sampleLocationsEnable = value; }
  Bool32 getSampleLocationsEnable() const { return this->sampleLocationsEnable; }
};
inline void PipelineMultisampleStateCreateInfo::attach(PipelineSampleLocationsStateCreateInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }

struct SubpassSampleLocationsEXT : VkSubpassSampleLocationsEXT {
  SubpassSampleLocationsEXT() noexcept : VkSubpassSampleLocationsEXT{} {}
  SubpassSampleLocationsEXT(uint32_t subpassIndex, const SampleLocationsInfoEXT& sampleLocationsInfo) noexcept : VkSubpassSampleLocationsEXT{.subpassIndex = subpassIndex, .sampleLocationsInfo = sampleLocationsInfo} {}

  void setSubpassIndex(uint32_t value) { this->subpassIndex = value; }
  uint32_t getSubpassIndex() const { return this->subpassIndex; }
  void setSampleLocationsInfo(const SampleLocationsInfoEXT& value) { this->sampleLocationsInfo = value; }
  const SampleLocationsInfoEXT& getSampleLocationsInfo() const { return static_cast<const SampleLocationsInfoEXT&>(this->sampleLocationsInfo); }
};
#endif // VK_EXT_sample_locations

#if VK_KHR_maintenance2
using ImageViewUsageCreateInfoKHR = ImageViewUsageCreateInfo;
#endif // VK_KHR_maintenance2
#if VK_KHR_sampler_ycbcr_conversion
using SamplerYcbcrConversionInfoKHR = SamplerYcbcrConversionInfo;
#endif // VK_KHR_sampler_ycbcr_conversion
#if VK_KHR_get_memory_requirements2
using SparseImageMemoryRequirements2KHR = SparseImageMemoryRequirements2;
#endif // VK_KHR_get_memory_requirements2
#if VK_EXT_host_image_copy
using HostImageCopyDevicePerformanceQueryEXT = HostImageCopyDevicePerformanceQuery;
#endif // VK_EXT_host_image_copy
#if VK_KHR_sampler_ycbcr_conversion
using SamplerYcbcrConversionImageFormatPropertiesKHR = SamplerYcbcrConversionImageFormatProperties;
#endif // VK_KHR_sampler_ycbcr_conversion
#if VK_KHR_external_memory_capabilities
using ExternalImageFormatPropertiesKHR = ExternalImageFormatProperties;
#endif // VK_KHR_external_memory_capabilities

#if VK_NV_mesh_shader
struct PhysicalDeviceMeshShaderPropertiesNV : VkPhysicalDeviceMeshShaderPropertiesNV {
  PhysicalDeviceMeshShaderPropertiesNV() noexcept : VkPhysicalDeviceMeshShaderPropertiesNV{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV} {}

  uint32_t getMaxDrawMeshTasksCount() const { return this->maxDrawMeshTasksCount; }
  uint32_t getMaxTaskWorkGroupInvocations() const { return this->maxTaskWorkGroupInvocations; }
  std::span<const uint32_t, 3> getMaxTaskWorkGroupSize() const { return this->maxTaskWorkGroupSize; }
  uint32_t getMaxTaskTotalMemorySize() const { return this->maxTaskTotalMemorySize; }
  uint32_t getMaxTaskOutputCount() const { return this->maxTaskOutputCount; }
  uint32_t getMaxMeshWorkGroupInvocations() const { return this->maxMeshWorkGroupInvocations; }
  std::span<const uint32_t, 3> getMaxMeshWorkGroupSize() const { return this->maxMeshWorkGroupSize; }
  uint32_t getMaxMeshTotalMemorySize() const { return this->maxMeshTotalMemorySize; }
  uint32_t getMaxMeshOutputVertices() const { return this->maxMeshOutputVertices; }
  uint32_t getMaxMeshOutputPrimitives() const { return this->maxMeshOutputPrimitives; }
  uint32_t getMaxMeshMultiviewViewCount() const { return this->maxMeshMultiviewViewCount; }
  uint32_t getMeshOutputPerVertexGranularity() const { return this->meshOutputPerVertexGranularity; }
  uint32_t getMeshOutputPerPrimitiveGranularity() const { return this->meshOutputPerPrimitiveGranularity; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceMeshShaderPropertiesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_mesh_shader

#if VK_VERSION_1_2
struct PhysicalDeviceDepthStencilResolveProperties : VkPhysicalDeviceDepthStencilResolveProperties {
  PhysicalDeviceDepthStencilResolveProperties() noexcept : VkPhysicalDeviceDepthStencilResolveProperties{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES} {}

  // supported depth resolve modes
  ResolveModeFlags getSupportedDepthResolveModes() const { return std::bit_cast<ResolveModeFlags>(this->supportedDepthResolveModes); }
  // supported stencil resolve modes
  ResolveModeFlags getSupportedStencilResolveModes() const { return std::bit_cast<ResolveModeFlags>(this->supportedStencilResolveModes); }
  // depth and stencil resolve modes can be set independently if one of them is none
  Bool32 getIndependentResolveNone() const { return this->independentResolveNone; }
  // depth and stencil resolve modes can be set independently
  Bool32 getIndependentResolve() const { return this->independentResolve; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceDepthStencilResolveProperties& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_2

#if VK_EXT_extended_dynamic_state3
struct PhysicalDeviceExtendedDynamicState3PropertiesEXT : VkPhysicalDeviceExtendedDynamicState3PropertiesEXT {
  PhysicalDeviceExtendedDynamicState3PropertiesEXT() noexcept : VkPhysicalDeviceExtendedDynamicState3PropertiesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT} {}

  Bool32 getDynamicPrimitiveTopologyUnrestricted() const { return this->dynamicPrimitiveTopologyUnrestricted; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceExtendedDynamicState3PropertiesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_extended_dynamic_state3

#if VK_MESA_image_alignment_control
struct PhysicalDeviceImageAlignmentControlPropertiesMESA : VkPhysicalDeviceImageAlignmentControlPropertiesMESA {
  PhysicalDeviceImageAlignmentControlPropertiesMESA() noexcept : VkPhysicalDeviceImageAlignmentControlPropertiesMESA{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_PROPERTIES_MESA} {}

  uint32_t getSupportedImageAlignmentMask() const { return this->supportedImageAlignmentMask; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceImageAlignmentControlPropertiesMESA& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_MESA_image_alignment_control

#if VK_HUAWEI_subpass_shading
struct PhysicalDeviceSubpassShadingPropertiesHUAWEI : VkPhysicalDeviceSubpassShadingPropertiesHUAWEI {
  PhysicalDeviceSubpassShadingPropertiesHUAWEI() noexcept : VkPhysicalDeviceSubpassShadingPropertiesHUAWEI{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI} {}

  uint32_t getMaxSubpassShadingWorkgroupSizeAspectRatio() const { return this->maxSubpassShadingWorkgroupSizeAspectRatio; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceSubpassShadingPropertiesHUAWEI& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_HUAWEI_subpass_shading

#if VK_KHR_maintenance7
struct PhysicalDeviceLayeredApiVulkanPropertiesKHR : VkPhysicalDeviceLayeredApiVulkanPropertiesKHR {
  PhysicalDeviceLayeredApiVulkanPropertiesKHR() noexcept : VkPhysicalDeviceLayeredApiVulkanPropertiesKHR{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_VULKAN_PROPERTIES_KHR} {}

  const PhysicalDeviceProperties2& getProperties() const { return static_cast<const PhysicalDeviceProperties2&>(this->properties); }
};
inline void PhysicalDeviceLayeredApiPropertiesKHR::attach(PhysicalDeviceLayeredApiVulkanPropertiesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }

struct PhysicalDeviceLayeredApiPropertiesListKHR : VkPhysicalDeviceLayeredApiPropertiesListKHR {
  PhysicalDeviceLayeredApiPropertiesListKHR() noexcept : VkPhysicalDeviceLayeredApiPropertiesListKHR{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_LIST_KHR} {}

  void setLayeredApiCount(uint32_t value) { this->layeredApiCount = value; }
  uint32_t getLayeredApiCount() const { return this->layeredApiCount; }
  // Output list of layered implementations underneath the physical device
  void setLayeredApis(PhysicalDeviceLayeredApiPropertiesKHR* value) { this->pLayeredApis = std::bit_cast<VkPhysicalDeviceLayeredApiPropertiesKHR*>(value); }
  PhysicalDeviceLayeredApiPropertiesKHR* getLayeredApis() const { return std::bit_cast<PhysicalDeviceLayeredApiPropertiesKHR*>(this->pLayeredApis); }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceLayeredApiPropertiesListKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_maintenance7

#if VK_VERSION_1_2
struct PhysicalDeviceSamplerFilterMinmaxProperties : VkPhysicalDeviceSamplerFilterMinmaxProperties {
  PhysicalDeviceSamplerFilterMinmaxProperties() noexcept : VkPhysicalDeviceSamplerFilterMinmaxProperties{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES} {}

  Bool32 getFilterMinmaxSingleComponentFormats() const { return this->filterMinmaxSingleComponentFormats; }
  Bool32 getFilterMinmaxImageComponentMapping() const { return this->filterMinmaxImageComponentMapping; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceSamplerFilterMinmaxProperties& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_2

#if VK_NV_cooperative_matrix2
struct PhysicalDeviceCooperativeMatrix2PropertiesNV : VkPhysicalDeviceCooperativeMatrix2PropertiesNV {
  PhysicalDeviceCooperativeMatrix2PropertiesNV() noexcept : VkPhysicalDeviceCooperativeMatrix2PropertiesNV{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_PROPERTIES_NV} {}

  uint32_t getCooperativeMatrixWorkgroupScopeMaxWorkgroupSize() const { return this->cooperativeMatrixWorkgroupScopeMaxWorkgroupSize; }
  uint32_t getCooperativeMatrixFlexibleDimensionsMaxDimension() const { return this->cooperativeMatrixFlexibleDimensionsMaxDimension; }
  uint32_t getCooperativeMatrixWorkgroupScopeReservedSharedMemory() const { return this->cooperativeMatrixWorkgroupScopeReservedSharedMemory; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceCooperativeMatrix2PropertiesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_cooperative_matrix2

#if VK_EXT_descriptor_buffer
struct PhysicalDeviceDescriptorBufferDensityMapPropertiesEXT : VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT {
  PhysicalDeviceDescriptorBufferDensityMapPropertiesEXT() noexcept : VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT} {}

  size_t getCombinedImageSamplerDensityMapDescriptorSize() const { return this->combinedImageSamplerDensityMapDescriptorSize; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceDescriptorBufferDensityMapPropertiesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_descriptor_buffer

#if VK_VERSION_1_3
struct PhysicalDeviceShaderIntegerDotProductProperties : VkPhysicalDeviceShaderIntegerDotProductProperties {
  PhysicalDeviceShaderIntegerDotProductProperties() noexcept : VkPhysicalDeviceShaderIntegerDotProductProperties{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES} {}

  Bool32 getIntegerDotProduct8BitUnsignedAccelerated() const { return this->integerDotProduct8BitUnsignedAccelerated; }
  Bool32 getIntegerDotProduct8BitSignedAccelerated() const { return this->integerDotProduct8BitSignedAccelerated; }
  Bool32 getIntegerDotProduct8BitMixedSignednessAccelerated() const { return this->integerDotProduct8BitMixedSignednessAccelerated; }
  Bool32 getIntegerDotProduct4x8BitPackedUnsignedAccelerated() const { return this->integerDotProduct4x8BitPackedUnsignedAccelerated; }
  Bool32 getIntegerDotProduct4x8BitPackedSignedAccelerated() const { return this->integerDotProduct4x8BitPackedSignedAccelerated; }
  Bool32 getIntegerDotProduct4x8BitPackedMixedSignednessAccelerated() const { return this->integerDotProduct4x8BitPackedMixedSignednessAccelerated; }
  Bool32 getIntegerDotProduct16BitUnsignedAccelerated() const { return this->integerDotProduct16BitUnsignedAccelerated; }
  Bool32 getIntegerDotProduct16BitSignedAccelerated() const { return this->integerDotProduct16BitSignedAccelerated; }
  Bool32 getIntegerDotProduct16BitMixedSignednessAccelerated() const { return this->integerDotProduct16BitMixedSignednessAccelerated; }
  Bool32 getIntegerDotProduct32BitUnsignedAccelerated() const { return this->integerDotProduct32BitUnsignedAccelerated; }
  Bool32 getIntegerDotProduct32BitSignedAccelerated() const { return this->integerDotProduct32BitSignedAccelerated; }
  Bool32 getIntegerDotProduct32BitMixedSignednessAccelerated() const { return this->integerDotProduct32BitMixedSignednessAccelerated; }
  Bool32 getIntegerDotProduct64BitUnsignedAccelerated() const { return this->integerDotProduct64BitUnsignedAccelerated; }
  Bool32 getIntegerDotProduct64BitSignedAccelerated() const { return this->integerDotProduct64BitSignedAccelerated; }
  Bool32 getIntegerDotProduct64BitMixedSignednessAccelerated() const { return this->integerDotProduct64BitMixedSignednessAccelerated; }
  Bool32 getIntegerDotProductAccumulatingSaturating8BitUnsignedAccelerated() const { return this->integerDotProductAccumulatingSaturating8BitUnsignedAccelerated; }
  Bool32 getIntegerDotProductAccumulatingSaturating8BitSignedAccelerated() const { return this->integerDotProductAccumulatingSaturating8BitSignedAccelerated; }
  Bool32 getIntegerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated() const { return this->integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated; }
  Bool32 getIntegerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated() const { return this->integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated; }
  Bool32 getIntegerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated() const { return this->integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated; }
  Bool32 getIntegerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated() const { return this->integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated; }
  Bool32 getIntegerDotProductAccumulatingSaturating16BitUnsignedAccelerated() const { return this->integerDotProductAccumulatingSaturating16BitUnsignedAccelerated; }
  Bool32 getIntegerDotProductAccumulatingSaturating16BitSignedAccelerated() const { return this->integerDotProductAccumulatingSaturating16BitSignedAccelerated; }
  Bool32 getIntegerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated() const { return this->integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated; }
  Bool32 getIntegerDotProductAccumulatingSaturating32BitUnsignedAccelerated() const { return this->integerDotProductAccumulatingSaturating32BitUnsignedAccelerated; }
  Bool32 getIntegerDotProductAccumulatingSaturating32BitSignedAccelerated() const { return this->integerDotProductAccumulatingSaturating32BitSignedAccelerated; }
  Bool32 getIntegerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated() const { return this->integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated; }
  Bool32 getIntegerDotProductAccumulatingSaturating64BitUnsignedAccelerated() const { return this->integerDotProductAccumulatingSaturating64BitUnsignedAccelerated; }
  Bool32 getIntegerDotProductAccumulatingSaturating64BitSignedAccelerated() const { return this->integerDotProductAccumulatingSaturating64BitSignedAccelerated; }
  Bool32 getIntegerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated() const { return this->integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceShaderIntegerDotProductProperties& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_3

#if VK_VERSION_1_2
struct PhysicalDeviceVulkan11Properties : VkPhysicalDeviceVulkan11Properties {
  PhysicalDeviceVulkan11Properties() noexcept : VkPhysicalDeviceVulkan11Properties{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES} {}

  std::span<const uint8_t, VK_UUID_SIZE> getDeviceUUID() const { return this->deviceUUID; }
  std::span<const uint8_t, VK_UUID_SIZE> getDriverUUID() const { return this->driverUUID; }
  std::span<const uint8_t, VK_LUID_SIZE> getDeviceLUID() const { return this->deviceLUID; }
  uint32_t getDeviceNodeMask() const { return this->deviceNodeMask; }
  Bool32 getDeviceLUIDValid() const { return this->deviceLUIDValid; }
  // The size of a subgroup for this queue.
  uint32_t getSubgroupSize() const { return this->subgroupSize; }
  // Bitfield of what shader stages support subgroup operations
  ShaderStageFlags getSubgroupSupportedStages() const { return std::bit_cast<ShaderStageFlags>(this->subgroupSupportedStages); }
  // Bitfield of what subgroup operations are supported.
  SubgroupFeatureFlags getSubgroupSupportedOperations() const { return std::bit_cast<SubgroupFeatureFlags>(this->subgroupSupportedOperations); }
  // Flag to specify whether quad operations are available in all stages.
  Bool32 getSubgroupQuadOperationsInAllStages() const { return this->subgroupQuadOperationsInAllStages; }
  PointClippingBehavior getPointClippingBehavior() const { return std::bit_cast<PointClippingBehavior>(this->pointClippingBehavior); }
  // max number of views in a subpass
  uint32_t getMaxMultiviewViewCount() const { return this->maxMultiviewViewCount; }
  // max instance index for a draw in a multiview subpass
  uint32_t getMaxMultiviewInstanceIndex() const { return this->maxMultiviewInstanceIndex; }
  Bool32 getProtectedNoFault() const { return this->protectedNoFault; }
  uint32_t getMaxPerSetDescriptors() const { return this->maxPerSetDescriptors; }
  DeviceSize getMaxMemoryAllocationSize() const { return this->maxMemoryAllocationSize; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceVulkan11Properties& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_2

#if VK_VERSION_1_4
struct PhysicalDevicePipelineRobustnessProperties : VkPhysicalDevicePipelineRobustnessProperties {
  PhysicalDevicePipelineRobustnessProperties() noexcept : VkPhysicalDevicePipelineRobustnessProperties{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES} {}

  PipelineRobustnessBufferBehavior getDefaultRobustnessStorageBuffers() const { return std::bit_cast<PipelineRobustnessBufferBehavior>(this->defaultRobustnessStorageBuffers); }
  PipelineRobustnessBufferBehavior getDefaultRobustnessUniformBuffers() const { return std::bit_cast<PipelineRobustnessBufferBehavior>(this->defaultRobustnessUniformBuffers); }
  PipelineRobustnessBufferBehavior getDefaultRobustnessVertexInputs() const { return std::bit_cast<PipelineRobustnessBufferBehavior>(this->defaultRobustnessVertexInputs); }
  PipelineRobustnessImageBehavior getDefaultRobustnessImages() const { return std::bit_cast<PipelineRobustnessImageBehavior>(this->defaultRobustnessImages); }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDevicePipelineRobustnessProperties& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_4

#if VK_EXT_blend_operation_advanced
struct PhysicalDeviceBlendOperationAdvancedPropertiesEXT : VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT {
  PhysicalDeviceBlendOperationAdvancedPropertiesEXT() noexcept : VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT} {}

  uint32_t getAdvancedBlendMaxColorAttachments() const { return this->advancedBlendMaxColorAttachments; }
  Bool32 getAdvancedBlendIndependentBlend() const { return this->advancedBlendIndependentBlend; }
  Bool32 getAdvancedBlendNonPremultipliedSrcColor() const { return this->advancedBlendNonPremultipliedSrcColor; }
  Bool32 getAdvancedBlendNonPremultipliedDstColor() const { return this->advancedBlendNonPremultipliedDstColor; }
  Bool32 getAdvancedBlendCorrelatedOverlap() const { return this->advancedBlendCorrelatedOverlap; }
  Bool32 getAdvancedBlendAllOperations() const { return this->advancedBlendAllOperations; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceBlendOperationAdvancedPropertiesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_blend_operation_advanced

#if VK_NV_cooperative_vector
struct PhysicalDeviceCooperativeVectorPropertiesNV : VkPhysicalDeviceCooperativeVectorPropertiesNV {
  PhysicalDeviceCooperativeVectorPropertiesNV() noexcept : VkPhysicalDeviceCooperativeVectorPropertiesNV{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_PROPERTIES_NV} {}

  ShaderStageFlags getCooperativeVectorSupportedStages() const { return std::bit_cast<ShaderStageFlags>(this->cooperativeVectorSupportedStages); }
  Bool32 getCooperativeVectorTrainingFloat16Accumulation() const { return this->cooperativeVectorTrainingFloat16Accumulation; }
  Bool32 getCooperativeVectorTrainingFloat32Accumulation() const { return this->cooperativeVectorTrainingFloat32Accumulation; }
  uint32_t getMaxCooperativeVectorComponents() const { return this->maxCooperativeVectorComponents; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceCooperativeVectorPropertiesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_cooperative_vector

#if VK_VERSION_1_3
struct PhysicalDeviceInlineUniformBlockProperties : VkPhysicalDeviceInlineUniformBlockProperties {
  PhysicalDeviceInlineUniformBlockProperties() noexcept : VkPhysicalDeviceInlineUniformBlockProperties{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES} {}

  uint32_t getMaxInlineUniformBlockSize() const { return this->maxInlineUniformBlockSize; }
  uint32_t getMaxPerStageDescriptorInlineUniformBlocks() const { return this->maxPerStageDescriptorInlineUniformBlocks; }
  uint32_t getMaxPerStageDescriptorUpdateAfterBindInlineUniformBlocks() const { return this->maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks; }
  uint32_t getMaxDescriptorSetInlineUniformBlocks() const { return this->maxDescriptorSetInlineUniformBlocks; }
  uint32_t getMaxDescriptorSetUpdateAfterBindInlineUniformBlocks() const { return this->maxDescriptorSetUpdateAfterBindInlineUniformBlocks; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceInlineUniformBlockProperties& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_3

#if VK_NV_cluster_acceleration_structure
struct PhysicalDeviceClusterAccelerationStructurePropertiesNV : VkPhysicalDeviceClusterAccelerationStructurePropertiesNV {
  PhysicalDeviceClusterAccelerationStructurePropertiesNV() noexcept : VkPhysicalDeviceClusterAccelerationStructurePropertiesNV{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_PROPERTIES_NV} {}

  uint32_t getMaxVerticesPerCluster() const { return this->maxVerticesPerCluster; }
  uint32_t getMaxTrianglesPerCluster() const { return this->maxTrianglesPerCluster; }
  uint32_t getClusterScratchByteAlignment() const { return this->clusterScratchByteAlignment; }
  uint32_t getClusterByteAlignment() const { return this->clusterByteAlignment; }
  uint32_t getClusterTemplateByteAlignment() const { return this->clusterTemplateByteAlignment; }
  uint32_t getClusterBottomLevelByteAlignment() const { return this->clusterBottomLevelByteAlignment; }
  uint32_t getClusterTemplateBoundsByteAlignment() const { return this->clusterTemplateBoundsByteAlignment; }
  uint32_t getMaxClusterGeometryIndex() const { return this->maxClusterGeometryIndex; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceClusterAccelerationStructurePropertiesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_cluster_acceleration_structure

#if VK_QCOM_tile_shading
struct PhysicalDeviceTileShadingPropertiesQCOM : VkPhysicalDeviceTileShadingPropertiesQCOM {
  PhysicalDeviceTileShadingPropertiesQCOM() noexcept : VkPhysicalDeviceTileShadingPropertiesQCOM{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_PROPERTIES_QCOM} {}

  uint32_t getMaxApronSize() const { return this->maxApronSize; }
  Bool32 getPreferNonCoherent() const { return this->preferNonCoherent; }
  const Extent2D& getTileGranularity() const { return static_cast<const Extent2D&>(this->tileGranularity); }
  const Extent2D& getMaxTileShadingRate() const { return static_cast<const Extent2D&>(this->maxTileShadingRate); }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceTileShadingPropertiesQCOM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_QCOM_tile_shading

#if VK_EXT_sample_locations
struct PhysicalDeviceSampleLocationsPropertiesEXT : VkPhysicalDeviceSampleLocationsPropertiesEXT {
  PhysicalDeviceSampleLocationsPropertiesEXT() noexcept : VkPhysicalDeviceSampleLocationsPropertiesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT} {}

  SampleCountFlags getSampleLocationSampleCounts() const { return std::bit_cast<SampleCountFlags>(this->sampleLocationSampleCounts); }
  const Extent2D& getMaxSampleLocationGridSize() const { return static_cast<const Extent2D&>(this->maxSampleLocationGridSize); }
  std::span<const float, 2> getSampleLocationCoordinateRange() const { return this->sampleLocationCoordinateRange; }
  uint32_t getSampleLocationSubPixelBits() const { return this->sampleLocationSubPixelBits; }
  Bool32 getVariableSampleLocations() const { return this->variableSampleLocations; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceSampleLocationsPropertiesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_sample_locations

#if VK_VERSION_1_4
struct PhysicalDeviceHostImageCopyProperties : VkPhysicalDeviceHostImageCopyProperties {
  PhysicalDeviceHostImageCopyProperties() noexcept : VkPhysicalDeviceHostImageCopyProperties{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES} {}

  void setCopySrcLayoutCount(uint32_t value) { this->copySrcLayoutCount = value; }
  uint32_t getCopySrcLayoutCount() const { return this->copySrcLayoutCount; }
  void setCopySrcLayouts(ImageLayout* value) { this->pCopySrcLayouts = std::bit_cast<VkImageLayout*>(value); }
  ImageLayout* getCopySrcLayouts() const { return std::bit_cast<ImageLayout*>(this->pCopySrcLayouts); }
  void setCopyDstLayoutCount(uint32_t value) { this->copyDstLayoutCount = value; }
  uint32_t getCopyDstLayoutCount() const { return this->copyDstLayoutCount; }
  void setCopyDstLayouts(ImageLayout* value) { this->pCopyDstLayouts = std::bit_cast<VkImageLayout*>(value); }
  ImageLayout* getCopyDstLayouts() const { return std::bit_cast<ImageLayout*>(this->pCopyDstLayouts); }
  void setOptimalTilingLayoutUUID(std::span<const uint8_t, VK_UUID_SIZE> value) { std::memcpy(&this->optimalTilingLayoutUUID, value.data(), value.size_bytes()); }
  std::span<const uint8_t, VK_UUID_SIZE> getOptimalTilingLayoutUUID() const { return this->optimalTilingLayoutUUID; }
  void setIdenticalMemoryTypeRequirements(Bool32 value) { this->identicalMemoryTypeRequirements = value; }
  Bool32 getIdenticalMemoryTypeRequirements() const { return this->identicalMemoryTypeRequirements; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceHostImageCopyProperties& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }

struct PhysicalDeviceMaintenance5Properties : VkPhysicalDeviceMaintenance5Properties {
  PhysicalDeviceMaintenance5Properties() noexcept : VkPhysicalDeviceMaintenance5Properties{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES} {}

  Bool32 getEarlyFragmentMultisampleCoverageAfterSampleCounting() const { return this->earlyFragmentMultisampleCoverageAfterSampleCounting; }
  Bool32 getEarlyFragmentSampleMaskTestBeforeSampleCounting() const { return this->earlyFragmentSampleMaskTestBeforeSampleCounting; }
  Bool32 getDepthStencilSwizzleOneSupport() const { return this->depthStencilSwizzleOneSupport; }
  Bool32 getPolygonModePointSize() const { return this->polygonModePointSize; }
  Bool32 getNonStrictSinglePixelWideLinesUseParallelogram() const { return this->nonStrictSinglePixelWideLinesUseParallelogram; }
  Bool32 getNonStrictWideLinesUseParallelogram() const { return this->nonStrictWideLinesUseParallelogram; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceMaintenance5Properties& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }

struct PhysicalDeviceMaintenance6Properties : VkPhysicalDeviceMaintenance6Properties {
  PhysicalDeviceMaintenance6Properties() noexcept : VkPhysicalDeviceMaintenance6Properties{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES} {}

  Bool32 getBlockTexelViewCompatibleMultipleLayers() const { return this->blockTexelViewCompatibleMultipleLayers; }
  uint32_t getMaxCombinedImageSamplerDescriptorCount() const { return this->maxCombinedImageSamplerDescriptorCount; }
  Bool32 getFragmentShadingRateClampCombinerInputs() const { return this->fragmentShadingRateClampCombinerInputs; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceMaintenance6Properties& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_4

#if VK_EXT_mesh_shader
struct PhysicalDeviceMeshShaderPropertiesEXT : VkPhysicalDeviceMeshShaderPropertiesEXT {
  PhysicalDeviceMeshShaderPropertiesEXT() noexcept : VkPhysicalDeviceMeshShaderPropertiesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT} {}

  uint32_t getMaxTaskWorkGroupTotalCount() const { return this->maxTaskWorkGroupTotalCount; }
  std::span<const uint32_t, 3> getMaxTaskWorkGroupCount() const { return this->maxTaskWorkGroupCount; }
  uint32_t getMaxTaskWorkGroupInvocations() const { return this->maxTaskWorkGroupInvocations; }
  std::span<const uint32_t, 3> getMaxTaskWorkGroupSize() const { return this->maxTaskWorkGroupSize; }
  uint32_t getMaxTaskPayloadSize() const { return this->maxTaskPayloadSize; }
  uint32_t getMaxTaskSharedMemorySize() const { return this->maxTaskSharedMemorySize; }
  uint32_t getMaxTaskPayloadAndSharedMemorySize() const { return this->maxTaskPayloadAndSharedMemorySize; }
  uint32_t getMaxMeshWorkGroupTotalCount() const { return this->maxMeshWorkGroupTotalCount; }
  std::span<const uint32_t, 3> getMaxMeshWorkGroupCount() const { return this->maxMeshWorkGroupCount; }
  uint32_t getMaxMeshWorkGroupInvocations() const { return this->maxMeshWorkGroupInvocations; }
  std::span<const uint32_t, 3> getMaxMeshWorkGroupSize() const { return this->maxMeshWorkGroupSize; }
  uint32_t getMaxMeshSharedMemorySize() const { return this->maxMeshSharedMemorySize; }
  uint32_t getMaxMeshPayloadAndSharedMemorySize() const { return this->maxMeshPayloadAndSharedMemorySize; }
  uint32_t getMaxMeshOutputMemorySize() const { return this->maxMeshOutputMemorySize; }
  uint32_t getMaxMeshPayloadAndOutputMemorySize() const { return this->maxMeshPayloadAndOutputMemorySize; }
  uint32_t getMaxMeshOutputComponents() const { return this->maxMeshOutputComponents; }
  uint32_t getMaxMeshOutputVertices() const { return this->maxMeshOutputVertices; }
  uint32_t getMaxMeshOutputPrimitives() const { return this->maxMeshOutputPrimitives; }
  uint32_t getMaxMeshOutputLayers() const { return this->maxMeshOutputLayers; }
  uint32_t getMaxMeshMultiviewViewCount() const { return this->maxMeshMultiviewViewCount; }
  uint32_t getMeshOutputPerVertexGranularity() const { return this->meshOutputPerVertexGranularity; }
  uint32_t getMeshOutputPerPrimitiveGranularity() const { return this->meshOutputPerPrimitiveGranularity; }
  uint32_t getMaxPreferredTaskWorkGroupInvocations() const { return this->maxPreferredTaskWorkGroupInvocations; }
  uint32_t getMaxPreferredMeshWorkGroupInvocations() const { return this->maxPreferredMeshWorkGroupInvocations; }
  Bool32 getPrefersLocalInvocationVertexOutput() const { return this->prefersLocalInvocationVertexOutput; }
  Bool32 getPrefersLocalInvocationPrimitiveOutput() const { return this->prefersLocalInvocationPrimitiveOutput; }
  Bool32 getPrefersCompactVertexOutput() const { return this->prefersCompactVertexOutput; }
  Bool32 getPrefersCompactPrimitiveOutput() const { return this->prefersCompactPrimitiveOutput; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceMeshShaderPropertiesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_mesh_shader

#if VK_KHR_maintenance7
struct PhysicalDeviceMaintenance7PropertiesKHR : VkPhysicalDeviceMaintenance7PropertiesKHR {
  PhysicalDeviceMaintenance7PropertiesKHR() noexcept : VkPhysicalDeviceMaintenance7PropertiesKHR{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_PROPERTIES_KHR} {}

  Bool32 getRobustFragmentShadingRateAttachmentAccess() const { return this->robustFragmentShadingRateAttachmentAccess; }
  Bool32 getSeparateDepthStencilAttachmentAccess() const { return this->separateDepthStencilAttachmentAccess; }
  uint32_t getMaxDescriptorSetTotalUniformBuffersDynamic() const { return this->maxDescriptorSetTotalUniformBuffersDynamic; }
  uint32_t getMaxDescriptorSetTotalStorageBuffersDynamic() const { return this->maxDescriptorSetTotalStorageBuffersDynamic; }
  uint32_t getMaxDescriptorSetTotalBuffersDynamic() const { return this->maxDescriptorSetTotalBuffersDynamic; }
  uint32_t getMaxDescriptorSetUpdateAfterBindTotalUniformBuffersDynamic() const { return this->maxDescriptorSetUpdateAfterBindTotalUniformBuffersDynamic; }
  uint32_t getMaxDescriptorSetUpdateAfterBindTotalStorageBuffersDynamic() const { return this->maxDescriptorSetUpdateAfterBindTotalStorageBuffersDynamic; }
  uint32_t getMaxDescriptorSetUpdateAfterBindTotalBuffersDynamic() const { return this->maxDescriptorSetUpdateAfterBindTotalBuffersDynamic; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceMaintenance7PropertiesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_maintenance7

#if VK_VALVE_fragment_density_map_layered
struct PhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE : VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE {
  PhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE() noexcept : VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_PROPERTIES_VALVE} {}

  uint32_t getMaxFragmentDensityMapLayers() const { return this->maxFragmentDensityMapLayers; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VALVE_fragment_density_map_layered

#if VK_VERSION_1_4
struct PhysicalDeviceVertexAttributeDivisorProperties : VkPhysicalDeviceVertexAttributeDivisorProperties {
  PhysicalDeviceVertexAttributeDivisorProperties() noexcept : VkPhysicalDeviceVertexAttributeDivisorProperties{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES} {}

  // max value of vertex attribute divisor
  uint32_t getMaxVertexAttribDivisor() const { return this->maxVertexAttribDivisor; }
  Bool32 getSupportsNonZeroFirstInstance() const { return this->supportsNonZeroFirstInstance; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceVertexAttributeDivisorProperties& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_4

#if VK_NV_cooperative_matrix
struct PhysicalDeviceCooperativeMatrixPropertiesNV : VkPhysicalDeviceCooperativeMatrixPropertiesNV {
  PhysicalDeviceCooperativeMatrixPropertiesNV() noexcept : VkPhysicalDeviceCooperativeMatrixPropertiesNV{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV} {}

  ShaderStageFlags getCooperativeMatrixSupportedStages() const { return std::bit_cast<ShaderStageFlags>(this->cooperativeMatrixSupportedStages); }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceCooperativeMatrixPropertiesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_cooperative_matrix

#if VK_EXT_shader_object
struct PhysicalDeviceShaderObjectPropertiesEXT : VkPhysicalDeviceShaderObjectPropertiesEXT {
  PhysicalDeviceShaderObjectPropertiesEXT() noexcept : VkPhysicalDeviceShaderObjectPropertiesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT} {}

  std::span<const uint8_t, VK_UUID_SIZE> getShaderBinaryUUID() const { return this->shaderBinaryUUID; }
  uint32_t getShaderBinaryVersion() const { return this->shaderBinaryVersion; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceShaderObjectPropertiesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_shader_object

#if VK_VERSION_1_4
struct PhysicalDevicePushDescriptorProperties : VkPhysicalDevicePushDescriptorProperties {
  PhysicalDevicePushDescriptorProperties() noexcept : VkPhysicalDevicePushDescriptorProperties{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES} {}

  uint32_t getMaxPushDescriptors() const { return this->maxPushDescriptors; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDevicePushDescriptorProperties& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_4

#if VK_VERSION_1_3
struct PhysicalDeviceVulkan13Properties : VkPhysicalDeviceVulkan13Properties {
  PhysicalDeviceVulkan13Properties() noexcept : VkPhysicalDeviceVulkan13Properties{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES} {}

  // The minimum subgroup size supported by this device
  uint32_t getMinSubgroupSize() const { return this->minSubgroupSize; }
  // The maximum subgroup size supported by this device
  uint32_t getMaxSubgroupSize() const { return this->maxSubgroupSize; }
  // The maximum number of subgroups supported in a workgroup
  uint32_t getMaxComputeWorkgroupSubgroups() const { return this->maxComputeWorkgroupSubgroups; }
  // The shader stages that support specifying a subgroup size
  ShaderStageFlags getRequiredSubgroupSizeStages() const { return std::bit_cast<ShaderStageFlags>(this->requiredSubgroupSizeStages); }
  uint32_t getMaxInlineUniformBlockSize() const { return this->maxInlineUniformBlockSize; }
  uint32_t getMaxPerStageDescriptorInlineUniformBlocks() const { return this->maxPerStageDescriptorInlineUniformBlocks; }
  uint32_t getMaxPerStageDescriptorUpdateAfterBindInlineUniformBlocks() const { return this->maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks; }
  uint32_t getMaxDescriptorSetInlineUniformBlocks() const { return this->maxDescriptorSetInlineUniformBlocks; }
  uint32_t getMaxDescriptorSetUpdateAfterBindInlineUniformBlocks() const { return this->maxDescriptorSetUpdateAfterBindInlineUniformBlocks; }
  uint32_t getMaxInlineUniformTotalSize() const { return this->maxInlineUniformTotalSize; }
  Bool32 getIntegerDotProduct8BitUnsignedAccelerated() const { return this->integerDotProduct8BitUnsignedAccelerated; }
  Bool32 getIntegerDotProduct8BitSignedAccelerated() const { return this->integerDotProduct8BitSignedAccelerated; }
  Bool32 getIntegerDotProduct8BitMixedSignednessAccelerated() const { return this->integerDotProduct8BitMixedSignednessAccelerated; }
  Bool32 getIntegerDotProduct4x8BitPackedUnsignedAccelerated() const { return this->integerDotProduct4x8BitPackedUnsignedAccelerated; }
  Bool32 getIntegerDotProduct4x8BitPackedSignedAccelerated() const { return this->integerDotProduct4x8BitPackedSignedAccelerated; }
  Bool32 getIntegerDotProduct4x8BitPackedMixedSignednessAccelerated() const { return this->integerDotProduct4x8BitPackedMixedSignednessAccelerated; }
  Bool32 getIntegerDotProduct16BitUnsignedAccelerated() const { return this->integerDotProduct16BitUnsignedAccelerated; }
  Bool32 getIntegerDotProduct16BitSignedAccelerated() const { return this->integerDotProduct16BitSignedAccelerated; }
  Bool32 getIntegerDotProduct16BitMixedSignednessAccelerated() const { return this->integerDotProduct16BitMixedSignednessAccelerated; }
  Bool32 getIntegerDotProduct32BitUnsignedAccelerated() const { return this->integerDotProduct32BitUnsignedAccelerated; }
  Bool32 getIntegerDotProduct32BitSignedAccelerated() const { return this->integerDotProduct32BitSignedAccelerated; }
  Bool32 getIntegerDotProduct32BitMixedSignednessAccelerated() const { return this->integerDotProduct32BitMixedSignednessAccelerated; }
  Bool32 getIntegerDotProduct64BitUnsignedAccelerated() const { return this->integerDotProduct64BitUnsignedAccelerated; }
  Bool32 getIntegerDotProduct64BitSignedAccelerated() const { return this->integerDotProduct64BitSignedAccelerated; }
  Bool32 getIntegerDotProduct64BitMixedSignednessAccelerated() const { return this->integerDotProduct64BitMixedSignednessAccelerated; }
  Bool32 getIntegerDotProductAccumulatingSaturating8BitUnsignedAccelerated() const { return this->integerDotProductAccumulatingSaturating8BitUnsignedAccelerated; }
  Bool32 getIntegerDotProductAccumulatingSaturating8BitSignedAccelerated() const { return this->integerDotProductAccumulatingSaturating8BitSignedAccelerated; }
  Bool32 getIntegerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated() const { return this->integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated; }
  Bool32 getIntegerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated() const { return this->integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated; }
  Bool32 getIntegerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated() const { return this->integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated; }
  Bool32 getIntegerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated() const { return this->integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated; }
  Bool32 getIntegerDotProductAccumulatingSaturating16BitUnsignedAccelerated() const { return this->integerDotProductAccumulatingSaturating16BitUnsignedAccelerated; }
  Bool32 getIntegerDotProductAccumulatingSaturating16BitSignedAccelerated() const { return this->integerDotProductAccumulatingSaturating16BitSignedAccelerated; }
  Bool32 getIntegerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated() const { return this->integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated; }
  Bool32 getIntegerDotProductAccumulatingSaturating32BitUnsignedAccelerated() const { return this->integerDotProductAccumulatingSaturating32BitUnsignedAccelerated; }
  Bool32 getIntegerDotProductAccumulatingSaturating32BitSignedAccelerated() const { return this->integerDotProductAccumulatingSaturating32BitSignedAccelerated; }
  Bool32 getIntegerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated() const { return this->integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated; }
  Bool32 getIntegerDotProductAccumulatingSaturating64BitUnsignedAccelerated() const { return this->integerDotProductAccumulatingSaturating64BitUnsignedAccelerated; }
  Bool32 getIntegerDotProductAccumulatingSaturating64BitSignedAccelerated() const { return this->integerDotProductAccumulatingSaturating64BitSignedAccelerated; }
  Bool32 getIntegerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated() const { return this->integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated; }
  DeviceSize getStorageTexelBufferOffsetAlignmentBytes() const { return this->storageTexelBufferOffsetAlignmentBytes; }
  Bool32 getStorageTexelBufferOffsetSingleTexelAlignment() const { return this->storageTexelBufferOffsetSingleTexelAlignment; }
  DeviceSize getUniformTexelBufferOffsetAlignmentBytes() const { return this->uniformTexelBufferOffsetAlignmentBytes; }
  Bool32 getUniformTexelBufferOffsetSingleTexelAlignment() const { return this->uniformTexelBufferOffsetSingleTexelAlignment; }
  DeviceSize getMaxBufferSize() const { return this->maxBufferSize; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceVulkan13Properties& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_3

#if VK_EXT_shader_module_identifier
struct PhysicalDeviceShaderModuleIdentifierPropertiesEXT : VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT {
  PhysicalDeviceShaderModuleIdentifierPropertiesEXT() noexcept : VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT} {}

  std::span<const uint8_t, VK_UUID_SIZE> getShaderModuleIdentifierAlgorithmUUID() const { return this->shaderModuleIdentifierAlgorithmUUID; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceShaderModuleIdentifierPropertiesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_shader_module_identifier

#if VK_VERSION_1_2
struct PhysicalDeviceDriverProperties : VkPhysicalDeviceDriverProperties {
  PhysicalDeviceDriverProperties() noexcept : VkPhysicalDeviceDriverProperties{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES} {}

  DriverId getDriverID() const { return std::bit_cast<DriverId>(this->driverID); }
  std::string_view getDriverName() const { return this->driverName; }
  std::string_view getDriverInfo() const { return this->driverInfo; }
  const ConformanceVersion& getConformanceVersion() const { return static_cast<const ConformanceVersion&>(this->conformanceVersion); }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceDriverProperties& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_2

#if VK_AMD_shader_core_properties
struct PhysicalDeviceShaderCorePropertiesAMD : VkPhysicalDeviceShaderCorePropertiesAMD {
  PhysicalDeviceShaderCorePropertiesAMD() noexcept : VkPhysicalDeviceShaderCorePropertiesAMD{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD} {}

  // number of shader engines
  uint32_t getShaderEngineCount() const { return this->shaderEngineCount; }
  // number of shader arrays
  uint32_t getShaderArraysPerEngineCount() const { return this->shaderArraysPerEngineCount; }
  // number of physical CUs per shader array
  uint32_t getComputeUnitsPerShaderArray() const { return this->computeUnitsPerShaderArray; }
  // number of SIMDs per compute unit
  uint32_t getSimdPerComputeUnit() const { return this->simdPerComputeUnit; }
  // number of wavefront slots in each SIMD
  uint32_t getWavefrontsPerSimd() const { return this->wavefrontsPerSimd; }
  // maximum number of threads per wavefront
  uint32_t getWavefrontSize() const { return this->wavefrontSize; }
  // number of physical SGPRs per SIMD
  uint32_t getSgprsPerSimd() const { return this->sgprsPerSimd; }
  // minimum number of SGPRs that can be allocated by a wave
  uint32_t getMinSgprAllocation() const { return this->minSgprAllocation; }
  // number of available SGPRs
  uint32_t getMaxSgprAllocation() const { return this->maxSgprAllocation; }
  // SGPRs are allocated in groups of this size
  uint32_t getSgprAllocationGranularity() const { return this->sgprAllocationGranularity; }
  // number of physical VGPRs per SIMD
  uint32_t getVgprsPerSimd() const { return this->vgprsPerSimd; }
  // minimum number of VGPRs that can be allocated by a wave
  uint32_t getMinVgprAllocation() const { return this->minVgprAllocation; }
  // number of available VGPRs
  uint32_t getMaxVgprAllocation() const { return this->maxVgprAllocation; }
  // VGPRs are allocated in groups of this size
  uint32_t getVgprAllocationGranularity() const { return this->vgprAllocationGranularity; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceShaderCorePropertiesAMD& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_AMD_shader_core_properties

#if VK_NV_copy_memory_indirect
struct PhysicalDeviceCopyMemoryIndirectPropertiesNV : VkPhysicalDeviceCopyMemoryIndirectPropertiesNV {
  PhysicalDeviceCopyMemoryIndirectPropertiesNV() noexcept : VkPhysicalDeviceCopyMemoryIndirectPropertiesNV{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_NV} {}

  // Bitfield of which queues are supported for indirect copy
  QueueFlags getSupportedQueues() const { return std::bit_cast<QueueFlags>(this->supportedQueues); }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceCopyMemoryIndirectPropertiesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_copy_memory_indirect

#if VK_KHR_compute_shader_derivatives
struct PhysicalDeviceComputeShaderDerivativesPropertiesKHR : VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR {
  PhysicalDeviceComputeShaderDerivativesPropertiesKHR() noexcept : VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_PROPERTIES_KHR} {}

  Bool32 getMeshAndTaskShaderDerivatives() const { return this->meshAndTaskShaderDerivatives; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceComputeShaderDerivativesPropertiesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_compute_shader_derivatives

#if VK_QCOM_tile_memory_heap
struct PhysicalDeviceTileMemoryHeapPropertiesQCOM : VkPhysicalDeviceTileMemoryHeapPropertiesQCOM {
  PhysicalDeviceTileMemoryHeapPropertiesQCOM() noexcept : VkPhysicalDeviceTileMemoryHeapPropertiesQCOM{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_PROPERTIES_QCOM} {}

  void setQueueSubmitBoundary(Bool32 value) { this->queueSubmitBoundary = value; }
  Bool32 getQueueSubmitBoundary() const { return this->queueSubmitBoundary; }
  void setTileBufferTransfers(Bool32 value) { this->tileBufferTransfers = value; }
  Bool32 getTileBufferTransfers() const { return this->tileBufferTransfers; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceTileMemoryHeapPropertiesQCOM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_QCOM_tile_memory_heap

#if VK_EXT_graphics_pipeline_library
struct PhysicalDeviceGraphicsPipelineLibraryPropertiesEXT : VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT {
  PhysicalDeviceGraphicsPipelineLibraryPropertiesEXT() noexcept : VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT} {}

  Bool32 getGraphicsPipelineLibraryFastLinking() const { return this->graphicsPipelineLibraryFastLinking; }
  Bool32 getGraphicsPipelineLibraryIndependentInterpolationDecoration() const { return this->graphicsPipelineLibraryIndependentInterpolationDecoration; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceGraphicsPipelineLibraryPropertiesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_graphics_pipeline_library

#if VK_KHR_performance_query
struct PhysicalDevicePerformanceQueryPropertiesKHR : VkPhysicalDevicePerformanceQueryPropertiesKHR {
  PhysicalDevicePerformanceQueryPropertiesKHR() noexcept : VkPhysicalDevicePerformanceQueryPropertiesKHR{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR} {}

  // Flag to specify whether performance queries are allowed to be used in vkCmdCopyQueryPoolResults
  Bool32 getAllowCommandBufferQueryCopies() const { return this->allowCommandBufferQueryCopies; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDevicePerformanceQueryPropertiesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_performance_query

#if VK_NV_external_compute_queue
struct PhysicalDeviceExternalComputeQueuePropertiesNV : VkPhysicalDeviceExternalComputeQueuePropertiesNV {
  PhysicalDeviceExternalComputeQueuePropertiesNV() noexcept : VkPhysicalDeviceExternalComputeQueuePropertiesNV{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_COMPUTE_QUEUE_PROPERTIES_NV} {}

  uint32_t getExternalDataSize() const { return this->externalDataSize; }
  uint32_t getMaxExternalQueues() const { return this->maxExternalQueues; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceExternalComputeQueuePropertiesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_external_compute_queue

#if VK_VERSION_1_1
struct PhysicalDeviceIDProperties : VkPhysicalDeviceIDProperties {
  PhysicalDeviceIDProperties() noexcept : VkPhysicalDeviceIDProperties{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES} {}

  std::span<const uint8_t, VK_UUID_SIZE> getDeviceUUID() const { return this->deviceUUID; }
  std::span<const uint8_t, VK_UUID_SIZE> getDriverUUID() const { return this->driverUUID; }
  std::span<const uint8_t, VK_LUID_SIZE> getDeviceLUID() const { return this->deviceLUID; }
  uint32_t getDeviceNodeMask() const { return this->deviceNodeMask; }
  Bool32 getDeviceLUIDValid() const { return this->deviceLUIDValid; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceIDProperties& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_1

#if VK_EXT_device_generated_commands
struct PhysicalDeviceDeviceGeneratedCommandsPropertiesEXT : VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT {
  PhysicalDeviceDeviceGeneratedCommandsPropertiesEXT() noexcept : VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_EXT} {}

  uint32_t getMaxIndirectPipelineCount() const { return this->maxIndirectPipelineCount; }
  uint32_t getMaxIndirectShaderObjectCount() const { return this->maxIndirectShaderObjectCount; }
  uint32_t getMaxIndirectSequenceCount() const { return this->maxIndirectSequenceCount; }
  uint32_t getMaxIndirectCommandsTokenCount() const { return this->maxIndirectCommandsTokenCount; }
  uint32_t getMaxIndirectCommandsTokenOffset() const { return this->maxIndirectCommandsTokenOffset; }
  uint32_t getMaxIndirectCommandsIndirectStride() const { return this->maxIndirectCommandsIndirectStride; }
  IndirectCommandsInputModeFlagsEXT getSupportedIndirectCommandsInputModes() const { return std::bit_cast<IndirectCommandsInputModeFlagsEXT>(this->supportedIndirectCommandsInputModes); }
  ShaderStageFlags getSupportedIndirectCommandsShaderStages() const { return std::bit_cast<ShaderStageFlags>(this->supportedIndirectCommandsShaderStages); }
  ShaderStageFlags getSupportedIndirectCommandsShaderStagesPipelineBinding() const { return std::bit_cast<ShaderStageFlags>(this->supportedIndirectCommandsShaderStagesPipelineBinding); }
  ShaderStageFlags getSupportedIndirectCommandsShaderStagesShaderBinding() const { return std::bit_cast<ShaderStageFlags>(this->supportedIndirectCommandsShaderStagesShaderBinding); }
  Bool32 getDeviceGeneratedCommandsTransformFeedback() const { return this->deviceGeneratedCommandsTransformFeedback; }
  Bool32 getDeviceGeneratedCommandsMultiDrawIndirectCount() const { return this->deviceGeneratedCommandsMultiDrawIndirectCount; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceDeviceGeneratedCommandsPropertiesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_device_generated_commands

#if VK_KHR_fragment_shader_barycentric
struct PhysicalDeviceFragmentShaderBarycentricPropertiesKHR : VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR {
  PhysicalDeviceFragmentShaderBarycentricPropertiesKHR() noexcept : VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR} {}

  Bool32 getTriStripVertexOrderIndependentOfProvokingVertex() const { return this->triStripVertexOrderIndependentOfProvokingVertex; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceFragmentShaderBarycentricPropertiesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_fragment_shader_barycentric

#if VK_VERSION_1_2
struct PhysicalDeviceTimelineSemaphoreProperties : VkPhysicalDeviceTimelineSemaphoreProperties {
  PhysicalDeviceTimelineSemaphoreProperties() noexcept : VkPhysicalDeviceTimelineSemaphoreProperties{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES} {}

  uint64_t getMaxTimelineSemaphoreValueDifference() const { return this->maxTimelineSemaphoreValueDifference; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceTimelineSemaphoreProperties& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_2

#if VK_EXT_vertex_attribute_divisor
struct PhysicalDeviceVertexAttributeDivisorPropertiesEXT : VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT {
  PhysicalDeviceVertexAttributeDivisorPropertiesEXT() noexcept : VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT} {}

  // max value of vertex attribute divisor
  uint32_t getMaxVertexAttribDivisor() const { return this->maxVertexAttribDivisor; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceVertexAttributeDivisorPropertiesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_vertex_attribute_divisor

#if VK_EXT_pci_bus_info
struct PhysicalDevicePCIBusInfoPropertiesEXT : VkPhysicalDevicePCIBusInfoPropertiesEXT {
  PhysicalDevicePCIBusInfoPropertiesEXT() noexcept : VkPhysicalDevicePCIBusInfoPropertiesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT} {}

  uint32_t getPciDomain() const { return this->pciDomain; }
  uint32_t getPciBus() const { return this->pciBus; }
  uint32_t getPciDevice() const { return this->pciDevice; }
  uint32_t getPciFunction() const { return this->pciFunction; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDevicePCIBusInfoPropertiesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_pci_bus_info

#if VK_EXT_external_memory_host
struct PhysicalDeviceExternalMemoryHostPropertiesEXT : VkPhysicalDeviceExternalMemoryHostPropertiesEXT {
  PhysicalDeviceExternalMemoryHostPropertiesEXT() noexcept : VkPhysicalDeviceExternalMemoryHostPropertiesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT} {}

  DeviceSize getMinImportedHostPointerAlignment() const { return this->minImportedHostPointerAlignment; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceExternalMemoryHostPropertiesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_external_memory_host

#if VK_QCOM_image_processing2
struct PhysicalDeviceImageProcessing2PropertiesQCOM : VkPhysicalDeviceImageProcessing2PropertiesQCOM {
  PhysicalDeviceImageProcessing2PropertiesQCOM() noexcept : VkPhysicalDeviceImageProcessing2PropertiesQCOM{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_PROPERTIES_QCOM} {}

  const Extent2D& getMaxBlockMatchWindow() const { return static_cast<const Extent2D&>(this->maxBlockMatchWindow); }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceImageProcessing2PropertiesQCOM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_QCOM_image_processing2

#if VK_EXT_shader_tile_image
struct PhysicalDeviceShaderTileImagePropertiesEXT : VkPhysicalDeviceShaderTileImagePropertiesEXT {
  PhysicalDeviceShaderTileImagePropertiesEXT() noexcept : VkPhysicalDeviceShaderTileImagePropertiesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT} {}

  Bool32 getShaderTileImageCoherentReadAccelerated() const { return this->shaderTileImageCoherentReadAccelerated; }
  Bool32 getShaderTileImageReadSampleFromPixelRateInvocation() const { return this->shaderTileImageReadSampleFromPixelRateInvocation; }
  Bool32 getShaderTileImageReadFromHelperInvocation() const { return this->shaderTileImageReadFromHelperInvocation; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceShaderTileImagePropertiesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_shader_tile_image

#if VK_VERSION_1_3
struct PhysicalDeviceSubgroupSizeControlProperties : VkPhysicalDeviceSubgroupSizeControlProperties {
  PhysicalDeviceSubgroupSizeControlProperties() noexcept : VkPhysicalDeviceSubgroupSizeControlProperties{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES} {}

  // The minimum subgroup size supported by this device
  uint32_t getMinSubgroupSize() const { return this->minSubgroupSize; }
  // The maximum subgroup size supported by this device
  uint32_t getMaxSubgroupSize() const { return this->maxSubgroupSize; }
  // The maximum number of subgroups supported in a workgroup
  uint32_t getMaxComputeWorkgroupSubgroups() const { return this->maxComputeWorkgroupSubgroups; }
  // The shader stages that support specifying a subgroup size
  ShaderStageFlags getRequiredSubgroupSizeStages() const { return std::bit_cast<ShaderStageFlags>(this->requiredSubgroupSizeStages); }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceSubgroupSizeControlProperties& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_3

#if VK_EXT_map_memory_placed
struct PhysicalDeviceMapMemoryPlacedPropertiesEXT : VkPhysicalDeviceMapMemoryPlacedPropertiesEXT {
  PhysicalDeviceMapMemoryPlacedPropertiesEXT() noexcept : VkPhysicalDeviceMapMemoryPlacedPropertiesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_PROPERTIES_EXT} {}

  DeviceSize getMinPlacedMemoryMapAlignment() const { return this->minPlacedMemoryMapAlignment; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceMapMemoryPlacedPropertiesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_map_memory_placed

#if VK_ARM_tensors
struct PhysicalDeviceTensorPropertiesARM : VkPhysicalDeviceTensorPropertiesARM {
  PhysicalDeviceTensorPropertiesARM() noexcept : VkPhysicalDeviceTensorPropertiesARM{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_PROPERTIES_ARM} {}

  uint32_t getMaxTensorDimensionCount() const { return this->maxTensorDimensionCount; }
  uint64_t getMaxTensorElements() const { return this->maxTensorElements; }
  uint64_t getMaxPerDimensionTensorElements() const { return this->maxPerDimensionTensorElements; }
  int64_t getMaxTensorStride() const { return this->maxTensorStride; }
  uint64_t getMaxTensorSize() const { return this->maxTensorSize; }
  uint32_t getMaxTensorShaderAccessArrayLength() const { return this->maxTensorShaderAccessArrayLength; }
  uint32_t getMaxTensorShaderAccessSize() const { return this->maxTensorShaderAccessSize; }
  uint32_t getMaxDescriptorSetStorageTensors() const { return this->maxDescriptorSetStorageTensors; }
  uint32_t getMaxPerStageDescriptorSetStorageTensors() const { return this->maxPerStageDescriptorSetStorageTensors; }
  uint32_t getMaxDescriptorSetUpdateAfterBindStorageTensors() const { return this->maxDescriptorSetUpdateAfterBindStorageTensors; }
  uint32_t getMaxPerStageDescriptorUpdateAfterBindStorageTensors() const { return this->maxPerStageDescriptorUpdateAfterBindStorageTensors; }
  Bool32 getShaderStorageTensorArrayNonUniformIndexingNative() const { return this->shaderStorageTensorArrayNonUniformIndexingNative; }
  ShaderStageFlags getShaderTensorSupportedStages() const { return std::bit_cast<ShaderStageFlags>(this->shaderTensorSupportedStages); }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceTensorPropertiesARM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_ARM_tensors

#if VK_VERSION_1_1
struct PhysicalDeviceSubgroupProperties : VkPhysicalDeviceSubgroupProperties {
  PhysicalDeviceSubgroupProperties() noexcept : VkPhysicalDeviceSubgroupProperties{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES} {}

  // The size of a subgroup for this queue.
  uint32_t getSubgroupSize() const { return this->subgroupSize; }
  // Bitfield of what shader stages support subgroup operations
  ShaderStageFlags getSupportedStages() const { return std::bit_cast<ShaderStageFlags>(this->supportedStages); }
  // Bitfield of what subgroup operations are supported.
  SubgroupFeatureFlags getSupportedOperations() const { return std::bit_cast<SubgroupFeatureFlags>(this->supportedOperations); }
  // Flag to specify whether quad operations are available in all stages.
  Bool32 getQuadOperationsInAllStages() const { return this->quadOperationsInAllStages; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceSubgroupProperties& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_1

#if VK_MSFT_layered_driver
struct PhysicalDeviceLayeredDriverPropertiesMSFT : VkPhysicalDeviceLayeredDriverPropertiesMSFT {
  PhysicalDeviceLayeredDriverPropertiesMSFT() noexcept : VkPhysicalDeviceLayeredDriverPropertiesMSFT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT} {}

  LayeredDriverUnderlyingApiMSFT getUnderlyingAPI() const { return std::bit_cast<LayeredDriverUnderlyingApiMSFT>(this->underlyingAPI); }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceLayeredDriverPropertiesMSFT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_MSFT_layered_driver

#if VK_EXT_fragment_density_map
struct PhysicalDeviceFragmentDensityMapPropertiesEXT : VkPhysicalDeviceFragmentDensityMapPropertiesEXT {
  PhysicalDeviceFragmentDensityMapPropertiesEXT() noexcept : VkPhysicalDeviceFragmentDensityMapPropertiesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT} {}

  const Extent2D& getMinFragmentDensityTexelSize() const { return static_cast<const Extent2D&>(this->minFragmentDensityTexelSize); }
  const Extent2D& getMaxFragmentDensityTexelSize() const { return static_cast<const Extent2D&>(this->maxFragmentDensityTexelSize); }
  Bool32 getFragmentDensityInvocations() const { return this->fragmentDensityInvocations; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceFragmentDensityMapPropertiesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_fragment_density_map

#if VK_NV_optical_flow
struct PhysicalDeviceOpticalFlowPropertiesNV : VkPhysicalDeviceOpticalFlowPropertiesNV {
  PhysicalDeviceOpticalFlowPropertiesNV() noexcept : VkPhysicalDeviceOpticalFlowPropertiesNV{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV} {}

  OpticalFlowGridSizeFlagsNV getSupportedOutputGridSizes() const { return std::bit_cast<OpticalFlowGridSizeFlagsNV>(this->supportedOutputGridSizes); }
  OpticalFlowGridSizeFlagsNV getSupportedHintGridSizes() const { return std::bit_cast<OpticalFlowGridSizeFlagsNV>(this->supportedHintGridSizes); }
  Bool32 getHintSupported() const { return this->hintSupported; }
  Bool32 getCostSupported() const { return this->costSupported; }
  Bool32 getBidirectionalFlowSupported() const { return this->bidirectionalFlowSupported; }
  Bool32 getGlobalFlowSupported() const { return this->globalFlowSupported; }
  uint32_t getMinWidth() const { return this->minWidth; }
  uint32_t getMinHeight() const { return this->minHeight; }
  uint32_t getMaxWidth() const { return this->maxWidth; }
  uint32_t getMaxHeight() const { return this->maxHeight; }
  uint32_t getMaxNumRegionsOfInterest() const { return this->maxNumRegionsOfInterest; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceOpticalFlowPropertiesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_optical_flow

#if VK_VERSION_1_4
struct PhysicalDeviceLineRasterizationProperties : VkPhysicalDeviceLineRasterizationProperties {
  PhysicalDeviceLineRasterizationProperties() noexcept : VkPhysicalDeviceLineRasterizationProperties{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES} {}

  uint32_t getLineSubPixelPrecisionBits() const { return this->lineSubPixelPrecisionBits; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceLineRasterizationProperties& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_4

#if VK_VERSION_1_1
struct PhysicalDeviceMaintenance3Properties : VkPhysicalDeviceMaintenance3Properties {
  PhysicalDeviceMaintenance3Properties() noexcept : VkPhysicalDeviceMaintenance3Properties{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES} {}

  uint32_t getMaxPerSetDescriptors() const { return this->maxPerSetDescriptors; }
  DeviceSize getMaxMemoryAllocationSize() const { return this->maxMemoryAllocationSize; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceMaintenance3Properties& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_1

#if VK_VERSION_1_3
struct PhysicalDeviceMaintenance4Properties : VkPhysicalDeviceMaintenance4Properties {
  PhysicalDeviceMaintenance4Properties() noexcept : VkPhysicalDeviceMaintenance4Properties{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES} {}

  DeviceSize getMaxBufferSize() const { return this->maxBufferSize; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceMaintenance4Properties& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_3

#if VK_ARM_tensors
struct PhysicalDeviceDescriptorBufferTensorPropertiesARM : VkPhysicalDeviceDescriptorBufferTensorPropertiesARM {
  PhysicalDeviceDescriptorBufferTensorPropertiesARM() noexcept : VkPhysicalDeviceDescriptorBufferTensorPropertiesARM{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_PROPERTIES_ARM} {}

  void setTensorCaptureReplayDescriptorDataSize(size_t value) { this->tensorCaptureReplayDescriptorDataSize = value; }
  size_t getTensorCaptureReplayDescriptorDataSize() const { return this->tensorCaptureReplayDescriptorDataSize; }
  void setTensorViewCaptureReplayDescriptorDataSize(size_t value) { this->tensorViewCaptureReplayDescriptorDataSize = value; }
  size_t getTensorViewCaptureReplayDescriptorDataSize() const { return this->tensorViewCaptureReplayDescriptorDataSize; }
  void setTensorDescriptorSize(size_t value) { this->tensorDescriptorSize = value; }
  size_t getTensorDescriptorSize() const { return this->tensorDescriptorSize; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceDescriptorBufferTensorPropertiesARM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_ARM_tensors

#if VK_ANDROID_external_format_resolve
struct PhysicalDeviceExternalFormatResolvePropertiesANDROID : VkPhysicalDeviceExternalFormatResolvePropertiesANDROID {
  PhysicalDeviceExternalFormatResolvePropertiesANDROID() noexcept : VkPhysicalDeviceExternalFormatResolvePropertiesANDROID{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_PROPERTIES_ANDROID} {}

  Bool32 getNullColorAttachmentWithExternalFormatResolve() const { return this->nullColorAttachmentWithExternalFormatResolve; }
  ChromaLocation getExternalFormatResolveChromaOffsetX() const { return std::bit_cast<ChromaLocation>(this->externalFormatResolveChromaOffsetX); }
  ChromaLocation getExternalFormatResolveChromaOffsetY() const { return std::bit_cast<ChromaLocation>(this->externalFormatResolveChromaOffsetY); }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceExternalFormatResolvePropertiesANDROID& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_ANDROID_external_format_resolve

#if VK_KHR_maintenance9
struct PhysicalDeviceMaintenance9PropertiesKHR : VkPhysicalDeviceMaintenance9PropertiesKHR {
  PhysicalDeviceMaintenance9PropertiesKHR() noexcept : VkPhysicalDeviceMaintenance9PropertiesKHR{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_PROPERTIES_KHR} {}

  Bool32 getImage2DViewOf3DSparse() const { return this->image2DViewOf3DSparse; }
  DefaultVertexAttributeValueKHR getDefaultVertexAttributeValue() const { return std::bit_cast<DefaultVertexAttributeValueKHR>(this->defaultVertexAttributeValue); }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceMaintenance9PropertiesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_maintenance9

#if VK_NV_fragment_shading_rate_enums
struct PhysicalDeviceFragmentShadingRateEnumsPropertiesNV : VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV {
  PhysicalDeviceFragmentShadingRateEnumsPropertiesNV() noexcept : VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV} {}

  SampleCountFlagBits getMaxFragmentShadingRateInvocationCount() const { return std::bit_cast<SampleCountFlagBits>(this->maxFragmentShadingRateInvocationCount); }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceFragmentShadingRateEnumsPropertiesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_fragment_shading_rate_enums

#if VK_NV_shader_sm_builtins
struct PhysicalDeviceShaderSMBuiltinsPropertiesNV : VkPhysicalDeviceShaderSMBuiltinsPropertiesNV {
  PhysicalDeviceShaderSMBuiltinsPropertiesNV() noexcept : VkPhysicalDeviceShaderSMBuiltinsPropertiesNV{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV} {}

  uint32_t getShaderSMCount() const { return this->shaderSMCount; }
  uint32_t getShaderWarpsPerSM() const { return this->shaderWarpsPerSM; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceShaderSMBuiltinsPropertiesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_shader_sm_builtins

#if VK_EXT_fragment_density_map2
struct PhysicalDeviceFragmentDensityMap2PropertiesEXT : VkPhysicalDeviceFragmentDensityMap2PropertiesEXT {
  PhysicalDeviceFragmentDensityMap2PropertiesEXT() noexcept : VkPhysicalDeviceFragmentDensityMap2PropertiesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT} {}

  Bool32 getSubsampledLoads() const { return this->subsampledLoads; }
  Bool32 getSubsampledCoarseReconstructionEarlyAccess() const { return this->subsampledCoarseReconstructionEarlyAccess; }
  uint32_t getMaxSubsampledArrayLayers() const { return this->maxSubsampledArrayLayers; }
  uint32_t getMaxDescriptorSetSubsampledSamplers() const { return this->maxDescriptorSetSubsampledSamplers; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceFragmentDensityMap2PropertiesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_fragment_density_map2

#if VK_VERSION_1_2
struct PhysicalDeviceDescriptorIndexingProperties : VkPhysicalDeviceDescriptorIndexingProperties {
  PhysicalDeviceDescriptorIndexingProperties() noexcept : VkPhysicalDeviceDescriptorIndexingProperties{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES} {}

  uint32_t getMaxUpdateAfterBindDescriptorsInAllPools() const { return this->maxUpdateAfterBindDescriptorsInAllPools; }
  Bool32 getShaderUniformBufferArrayNonUniformIndexingNative() const { return this->shaderUniformBufferArrayNonUniformIndexingNative; }
  Bool32 getShaderSampledImageArrayNonUniformIndexingNative() const { return this->shaderSampledImageArrayNonUniformIndexingNative; }
  Bool32 getShaderStorageBufferArrayNonUniformIndexingNative() const { return this->shaderStorageBufferArrayNonUniformIndexingNative; }
  Bool32 getShaderStorageImageArrayNonUniformIndexingNative() const { return this->shaderStorageImageArrayNonUniformIndexingNative; }
  Bool32 getShaderInputAttachmentArrayNonUniformIndexingNative() const { return this->shaderInputAttachmentArrayNonUniformIndexingNative; }
  Bool32 getRobustBufferAccessUpdateAfterBind() const { return this->robustBufferAccessUpdateAfterBind; }
  Bool32 getQuadDivergentImplicitLod() const { return this->quadDivergentImplicitLod; }
  uint32_t getMaxPerStageDescriptorUpdateAfterBindSamplers() const { return this->maxPerStageDescriptorUpdateAfterBindSamplers; }
  uint32_t getMaxPerStageDescriptorUpdateAfterBindUniformBuffers() const { return this->maxPerStageDescriptorUpdateAfterBindUniformBuffers; }
  uint32_t getMaxPerStageDescriptorUpdateAfterBindStorageBuffers() const { return this->maxPerStageDescriptorUpdateAfterBindStorageBuffers; }
  uint32_t getMaxPerStageDescriptorUpdateAfterBindSampledImages() const { return this->maxPerStageDescriptorUpdateAfterBindSampledImages; }
  uint32_t getMaxPerStageDescriptorUpdateAfterBindStorageImages() const { return this->maxPerStageDescriptorUpdateAfterBindStorageImages; }
  uint32_t getMaxPerStageDescriptorUpdateAfterBindInputAttachments() const { return this->maxPerStageDescriptorUpdateAfterBindInputAttachments; }
  uint32_t getMaxPerStageUpdateAfterBindResources() const { return this->maxPerStageUpdateAfterBindResources; }
  uint32_t getMaxDescriptorSetUpdateAfterBindSamplers() const { return this->maxDescriptorSetUpdateAfterBindSamplers; }
  uint32_t getMaxDescriptorSetUpdateAfterBindUniformBuffers() const { return this->maxDescriptorSetUpdateAfterBindUniformBuffers; }
  uint32_t getMaxDescriptorSetUpdateAfterBindUniformBuffersDynamic() const { return this->maxDescriptorSetUpdateAfterBindUniformBuffersDynamic; }
  uint32_t getMaxDescriptorSetUpdateAfterBindStorageBuffers() const { return this->maxDescriptorSetUpdateAfterBindStorageBuffers; }
  uint32_t getMaxDescriptorSetUpdateAfterBindStorageBuffersDynamic() const { return this->maxDescriptorSetUpdateAfterBindStorageBuffersDynamic; }
  uint32_t getMaxDescriptorSetUpdateAfterBindSampledImages() const { return this->maxDescriptorSetUpdateAfterBindSampledImages; }
  uint32_t getMaxDescriptorSetUpdateAfterBindStorageImages() const { return this->maxDescriptorSetUpdateAfterBindStorageImages; }
  uint32_t getMaxDescriptorSetUpdateAfterBindInputAttachments() const { return this->maxDescriptorSetUpdateAfterBindInputAttachments; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceDescriptorIndexingProperties& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_2

#if VK_EXT_fragment_density_map_offset
struct PhysicalDeviceFragmentDensityMapOffsetPropertiesEXT : VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT {
  PhysicalDeviceFragmentDensityMapOffsetPropertiesEXT() noexcept : VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_EXT} {}

  const Extent2D& getFragmentDensityOffsetGranularity() const { return static_cast<const Extent2D&>(this->fragmentDensityOffsetGranularity); }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceFragmentDensityMapOffsetPropertiesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_fragment_density_map_offset

#if VK_KHR_fragment_shading_rate
struct PhysicalDeviceFragmentShadingRatePropertiesKHR : VkPhysicalDeviceFragmentShadingRatePropertiesKHR {
  PhysicalDeviceFragmentShadingRatePropertiesKHR() noexcept : VkPhysicalDeviceFragmentShadingRatePropertiesKHR{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR} {}

  const Extent2D& getMinFragmentShadingRateAttachmentTexelSize() const { return static_cast<const Extent2D&>(this->minFragmentShadingRateAttachmentTexelSize); }
  const Extent2D& getMaxFragmentShadingRateAttachmentTexelSize() const { return static_cast<const Extent2D&>(this->maxFragmentShadingRateAttachmentTexelSize); }
  uint32_t getMaxFragmentShadingRateAttachmentTexelSizeAspectRatio() const { return this->maxFragmentShadingRateAttachmentTexelSizeAspectRatio; }
  Bool32 getPrimitiveFragmentShadingRateWithMultipleViewports() const { return this->primitiveFragmentShadingRateWithMultipleViewports; }
  Bool32 getLayeredShadingRateAttachments() const { return this->layeredShadingRateAttachments; }
  Bool32 getFragmentShadingRateNonTrivialCombinerOps() const { return this->fragmentShadingRateNonTrivialCombinerOps; }
  const Extent2D& getMaxFragmentSize() const { return static_cast<const Extent2D&>(this->maxFragmentSize); }
  uint32_t getMaxFragmentSizeAspectRatio() const { return this->maxFragmentSizeAspectRatio; }
  uint32_t getMaxFragmentShadingRateCoverageSamples() const { return this->maxFragmentShadingRateCoverageSamples; }
  SampleCountFlagBits getMaxFragmentShadingRateRasterizationSamples() const { return std::bit_cast<SampleCountFlagBits>(this->maxFragmentShadingRateRasterizationSamples); }
  Bool32 getFragmentShadingRateWithShaderDepthStencilWrites() const { return this->fragmentShadingRateWithShaderDepthStencilWrites; }
  Bool32 getFragmentShadingRateWithSampleMask() const { return this->fragmentShadingRateWithSampleMask; }
  Bool32 getFragmentShadingRateWithShaderSampleMask() const { return this->fragmentShadingRateWithShaderSampleMask; }
  Bool32 getFragmentShadingRateWithConservativeRasterization() const { return this->fragmentShadingRateWithConservativeRasterization; }
  Bool32 getFragmentShadingRateWithFragmentShaderInterlock() const { return this->fragmentShadingRateWithFragmentShaderInterlock; }
  Bool32 getFragmentShadingRateWithCustomSampleLocations() const { return this->fragmentShadingRateWithCustomSampleLocations; }
  Bool32 getFragmentShadingRateStrictMultiplyCombiner() const { return this->fragmentShadingRateStrictMultiplyCombiner; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceFragmentShadingRatePropertiesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_fragment_shading_rate

#if VK_EXT_discard_rectangles
struct PhysicalDeviceDiscardRectanglePropertiesEXT : VkPhysicalDeviceDiscardRectanglePropertiesEXT {
  PhysicalDeviceDiscardRectanglePropertiesEXT() noexcept : VkPhysicalDeviceDiscardRectanglePropertiesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT} {}

  // max number of active discard rectangles
  uint32_t getMaxDiscardRectangles() const { return this->maxDiscardRectangles; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceDiscardRectanglePropertiesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_discard_rectangles

#if VK_NVX_multiview_per_view_attributes
struct PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX : VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX {
  PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX() noexcept : VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX} {}

  Bool32 getPerViewPositionAllComponents() const { return this->perViewPositionAllComponents; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NVX_multiview_per_view_attributes

#if VK_VERSION_1_4
struct PhysicalDeviceVulkan14Properties : VkPhysicalDeviceVulkan14Properties {
  PhysicalDeviceVulkan14Properties() noexcept : VkPhysicalDeviceVulkan14Properties{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_PROPERTIES} {}

  uint32_t getLineSubPixelPrecisionBits() const { return this->lineSubPixelPrecisionBits; }
  // max value of vertex attribute divisor
  uint32_t getMaxVertexAttribDivisor() const { return this->maxVertexAttribDivisor; }
  Bool32 getSupportsNonZeroFirstInstance() const { return this->supportsNonZeroFirstInstance; }
  uint32_t getMaxPushDescriptors() const { return this->maxPushDescriptors; }
  Bool32 getDynamicRenderingLocalReadDepthStencilAttachments() const { return this->dynamicRenderingLocalReadDepthStencilAttachments; }
  Bool32 getDynamicRenderingLocalReadMultisampledAttachments() const { return this->dynamicRenderingLocalReadMultisampledAttachments; }
  Bool32 getEarlyFragmentMultisampleCoverageAfterSampleCounting() const { return this->earlyFragmentMultisampleCoverageAfterSampleCounting; }
  Bool32 getEarlyFragmentSampleMaskTestBeforeSampleCounting() const { return this->earlyFragmentSampleMaskTestBeforeSampleCounting; }
  Bool32 getDepthStencilSwizzleOneSupport() const { return this->depthStencilSwizzleOneSupport; }
  Bool32 getPolygonModePointSize() const { return this->polygonModePointSize; }
  Bool32 getNonStrictSinglePixelWideLinesUseParallelogram() const { return this->nonStrictSinglePixelWideLinesUseParallelogram; }
  Bool32 getNonStrictWideLinesUseParallelogram() const { return this->nonStrictWideLinesUseParallelogram; }
  Bool32 getBlockTexelViewCompatibleMultipleLayers() const { return this->blockTexelViewCompatibleMultipleLayers; }
  uint32_t getMaxCombinedImageSamplerDescriptorCount() const { return this->maxCombinedImageSamplerDescriptorCount; }
  Bool32 getFragmentShadingRateClampCombinerInputs() const { return this->fragmentShadingRateClampCombinerInputs; }
  PipelineRobustnessBufferBehavior getDefaultRobustnessStorageBuffers() const { return std::bit_cast<PipelineRobustnessBufferBehavior>(this->defaultRobustnessStorageBuffers); }
  PipelineRobustnessBufferBehavior getDefaultRobustnessUniformBuffers() const { return std::bit_cast<PipelineRobustnessBufferBehavior>(this->defaultRobustnessUniformBuffers); }
  PipelineRobustnessBufferBehavior getDefaultRobustnessVertexInputs() const { return std::bit_cast<PipelineRobustnessBufferBehavior>(this->defaultRobustnessVertexInputs); }
  PipelineRobustnessImageBehavior getDefaultRobustnessImages() const { return std::bit_cast<PipelineRobustnessImageBehavior>(this->defaultRobustnessImages); }
  Bool32 getIdenticalMemoryTypeRequirements() const { return this->identicalMemoryTypeRequirements; }

  uint32_t getCopySrcLayoutCount() const { return this->copySrcLayoutCount; }
  ImageLayout* getCopySrcLayouts() const { return std::bit_cast<ImageLayout*>(this->pCopySrcLayouts); }
  uint32_t getCopyDstLayoutCount() const { return this->copyDstLayoutCount; }
  ImageLayout* getCopyDstLayouts() const { return std::bit_cast<ImageLayout*>(this->pCopyDstLayouts); }
  std::span<const uint8_t, VK_UUID_SIZE> getOptimalTilingLayoutUUID() const { return this->optimalTilingLayoutUUID; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceVulkan14Properties& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_4

#if VK_ARM_shader_core_properties
struct PhysicalDeviceShaderCorePropertiesARM : VkPhysicalDeviceShaderCorePropertiesARM {
  PhysicalDeviceShaderCorePropertiesARM() noexcept : VkPhysicalDeviceShaderCorePropertiesARM{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM} {}

  uint32_t getPixelRate() const { return this->pixelRate; }
  uint32_t getTexelRate() const { return this->texelRate; }
  uint32_t getFmaRate() const { return this->fmaRate; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceShaderCorePropertiesARM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_ARM_shader_core_properties

#if VK_KHR_acceleration_structure
struct PhysicalDeviceAccelerationStructurePropertiesKHR : VkPhysicalDeviceAccelerationStructurePropertiesKHR {
  PhysicalDeviceAccelerationStructurePropertiesKHR() noexcept : VkPhysicalDeviceAccelerationStructurePropertiesKHR{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR} {}

  uint64_t getMaxGeometryCount() const { return this->maxGeometryCount; }
  uint64_t getMaxInstanceCount() const { return this->maxInstanceCount; }
  uint64_t getMaxPrimitiveCount() const { return this->maxPrimitiveCount; }
  uint32_t getMaxPerStageDescriptorAccelerationStructures() const { return this->maxPerStageDescriptorAccelerationStructures; }
  uint32_t getMaxPerStageDescriptorUpdateAfterBindAccelerationStructures() const { return this->maxPerStageDescriptorUpdateAfterBindAccelerationStructures; }
  uint32_t getMaxDescriptorSetAccelerationStructures() const { return this->maxDescriptorSetAccelerationStructures; }
  uint32_t getMaxDescriptorSetUpdateAfterBindAccelerationStructures() const { return this->maxDescriptorSetUpdateAfterBindAccelerationStructures; }
  uint32_t getMinAccelerationStructureScratchOffsetAlignment() const { return this->minAccelerationStructureScratchOffsetAlignment; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceAccelerationStructurePropertiesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_acceleration_structure

#if VK_VERSION_1_1
struct PhysicalDevicePointClippingProperties : VkPhysicalDevicePointClippingProperties {
  PhysicalDevicePointClippingProperties() noexcept : VkPhysicalDevicePointClippingProperties{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES} {}

  PointClippingBehavior getPointClippingBehavior() const { return std::bit_cast<PointClippingBehavior>(this->pointClippingBehavior); }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDevicePointClippingProperties& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_1

#if VK_EXT_multi_draw
struct PhysicalDeviceMultiDrawPropertiesEXT : VkPhysicalDeviceMultiDrawPropertiesEXT {
  PhysicalDeviceMultiDrawPropertiesEXT() noexcept : VkPhysicalDeviceMultiDrawPropertiesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT} {}

  uint32_t getMaxMultiDrawCount() const { return this->maxMultiDrawCount; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceMultiDrawPropertiesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_multi_draw

#if VK_AMD_shader_core_properties2
struct PhysicalDeviceShaderCoreProperties2AMD : VkPhysicalDeviceShaderCoreProperties2AMD {
  PhysicalDeviceShaderCoreProperties2AMD() noexcept : VkPhysicalDeviceShaderCoreProperties2AMD{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD} {}

  // features supported by the shader core
  ShaderCorePropertiesFlagsAMD getShaderCoreFeatures() const { return std::bit_cast<ShaderCorePropertiesFlagsAMD>(this->shaderCoreFeatures); }
  // number of active compute units across all shader engines/arrays
  uint32_t getActiveComputeUnitCount() const { return this->activeComputeUnitCount; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceShaderCoreProperties2AMD& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_AMD_shader_core_properties2

#if VK_EXT_legacy_vertex_attributes
struct PhysicalDeviceLegacyVertexAttributesPropertiesEXT : VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT {
  PhysicalDeviceLegacyVertexAttributesPropertiesEXT() noexcept : VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_PROPERTIES_EXT} {}

  Bool32 getNativeUnalignedPerformance() const { return this->nativeUnalignedPerformance; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceLegacyVertexAttributesPropertiesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_legacy_vertex_attributes

#if VK_KHR_robustness2
struct PhysicalDeviceRobustness2PropertiesKHR : VkPhysicalDeviceRobustness2PropertiesKHR {
  PhysicalDeviceRobustness2PropertiesKHR() noexcept : VkPhysicalDeviceRobustness2PropertiesKHR{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_KHR} {}

  DeviceSize getRobustStorageBufferAccessSizeAlignment() const { return this->robustStorageBufferAccessSizeAlignment; }
  DeviceSize getRobustUniformBufferAccessSizeAlignment() const { return this->robustUniformBufferAccessSizeAlignment; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceRobustness2PropertiesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_robustness2

#if VK_VERSION_1_2
struct PhysicalDeviceFloatControlsProperties : VkPhysicalDeviceFloatControlsProperties {
  PhysicalDeviceFloatControlsProperties() noexcept : VkPhysicalDeviceFloatControlsProperties{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES} {}

  ShaderFloatControlsIndependence getDenormBehaviorIndependence() const { return std::bit_cast<ShaderFloatControlsIndependence>(this->denormBehaviorIndependence); }
  ShaderFloatControlsIndependence getRoundingModeIndependence() const { return std::bit_cast<ShaderFloatControlsIndependence>(this->roundingModeIndependence); }
  // An implementation can preserve signed zero, nan, inf
  Bool32 getShaderSignedZeroInfNanPreserveFloat16() const { return this->shaderSignedZeroInfNanPreserveFloat16; }
  // An implementation can preserve signed zero, nan, inf
  Bool32 getShaderSignedZeroInfNanPreserveFloat32() const { return this->shaderSignedZeroInfNanPreserveFloat32; }
  // An implementation can preserve signed zero, nan, inf
  Bool32 getShaderSignedZeroInfNanPreserveFloat64() const { return this->shaderSignedZeroInfNanPreserveFloat64; }
  // An implementation can preserve  denormals
  Bool32 getShaderDenormPreserveFloat16() const { return this->shaderDenormPreserveFloat16; }
  // An implementation can preserve  denormals
  Bool32 getShaderDenormPreserveFloat32() const { return this->shaderDenormPreserveFloat32; }
  // An implementation can preserve  denormals
  Bool32 getShaderDenormPreserveFloat64() const { return this->shaderDenormPreserveFloat64; }
  // An implementation can flush to zero  denormals
  Bool32 getShaderDenormFlushToZeroFloat16() const { return this->shaderDenormFlushToZeroFloat16; }
  // An implementation can flush to zero  denormals
  Bool32 getShaderDenormFlushToZeroFloat32() const { return this->shaderDenormFlushToZeroFloat32; }
  // An implementation can flush to zero  denormals
  Bool32 getShaderDenormFlushToZeroFloat64() const { return this->shaderDenormFlushToZeroFloat64; }
  // An implementation can support RTE
  Bool32 getShaderRoundingModeRTEFloat16() const { return this->shaderRoundingModeRTEFloat16; }
  // An implementation can support RTE
  Bool32 getShaderRoundingModeRTEFloat32() const { return this->shaderRoundingModeRTEFloat32; }
  // An implementation can support RTE
  Bool32 getShaderRoundingModeRTEFloat64() const { return this->shaderRoundingModeRTEFloat64; }
  // An implementation can support RTZ
  Bool32 getShaderRoundingModeRTZFloat16() const { return this->shaderRoundingModeRTZFloat16; }
  // An implementation can support RTZ
  Bool32 getShaderRoundingModeRTZFloat32() const { return this->shaderRoundingModeRTZFloat32; }
  // An implementation can support RTZ
  Bool32 getShaderRoundingModeRTZFloat64() const { return this->shaderRoundingModeRTZFloat64; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceFloatControlsProperties& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_2

#if VK_VERSION_1_3
struct PhysicalDeviceTexelBufferAlignmentProperties : VkPhysicalDeviceTexelBufferAlignmentProperties {
  PhysicalDeviceTexelBufferAlignmentProperties() noexcept : VkPhysicalDeviceTexelBufferAlignmentProperties{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES} {}

  DeviceSize getStorageTexelBufferOffsetAlignmentBytes() const { return this->storageTexelBufferOffsetAlignmentBytes; }
  Bool32 getStorageTexelBufferOffsetSingleTexelAlignment() const { return this->storageTexelBufferOffsetSingleTexelAlignment; }
  DeviceSize getUniformTexelBufferOffsetAlignmentBytes() const { return this->uniformTexelBufferOffsetAlignmentBytes; }
  Bool32 getUniformTexelBufferOffsetSingleTexelAlignment() const { return this->uniformTexelBufferOffsetSingleTexelAlignment; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceTexelBufferAlignmentProperties& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_3

#if VK_KHR_get_physical_device_properties2
using PhysicalDeviceProperties2KHR = PhysicalDeviceProperties2;
#endif // VK_KHR_get_physical_device_properties2

#if VK_EXT_opacity_micromap
struct PhysicalDeviceOpacityMicromapPropertiesEXT : VkPhysicalDeviceOpacityMicromapPropertiesEXT {
  PhysicalDeviceOpacityMicromapPropertiesEXT() noexcept : VkPhysicalDeviceOpacityMicromapPropertiesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT} {}

  uint32_t getMaxOpacity2StateSubdivisionLevel() const { return this->maxOpacity2StateSubdivisionLevel; }
  uint32_t getMaxOpacity4StateSubdivisionLevel() const { return this->maxOpacity4StateSubdivisionLevel; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceOpacityMicromapPropertiesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_opacity_micromap

#if VK_NV_device_generated_commands
struct PhysicalDeviceDeviceGeneratedCommandsPropertiesNV : VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV {
  PhysicalDeviceDeviceGeneratedCommandsPropertiesNV() noexcept : VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV} {}

  uint32_t getMaxGraphicsShaderGroupCount() const { return this->maxGraphicsShaderGroupCount; }
  uint32_t getMaxIndirectSequenceCount() const { return this->maxIndirectSequenceCount; }
  uint32_t getMaxIndirectCommandsTokenCount() const { return this->maxIndirectCommandsTokenCount; }
  uint32_t getMaxIndirectCommandsStreamCount() const { return this->maxIndirectCommandsStreamCount; }
  uint32_t getMaxIndirectCommandsTokenOffset() const { return this->maxIndirectCommandsTokenOffset; }
  uint32_t getMaxIndirectCommandsStreamStride() const { return this->maxIndirectCommandsStreamStride; }
  uint32_t getMinSequencesCountBufferOffsetAlignment() const { return this->minSequencesCountBufferOffsetAlignment; }
  uint32_t getMinSequencesIndexBufferOffsetAlignment() const { return this->minSequencesIndexBufferOffsetAlignment; }
  uint32_t getMinIndirectCommandsBufferOffsetAlignment() const { return this->minIndirectCommandsBufferOffsetAlignment; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceDeviceGeneratedCommandsPropertiesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_device_generated_commands

#if VK_NV_partitioned_acceleration_structure
struct PhysicalDevicePartitionedAccelerationStructurePropertiesNV : VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV {
  PhysicalDevicePartitionedAccelerationStructurePropertiesNV() noexcept : VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_PROPERTIES_NV} {}

  uint32_t getMaxPartitionCount() const { return this->maxPartitionCount; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDevicePartitionedAccelerationStructurePropertiesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_partitioned_acceleration_structure

#if VK_NV_ray_tracing_invocation_reorder
struct PhysicalDeviceRayTracingInvocationReorderPropertiesNV : VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV {
  PhysicalDeviceRayTracingInvocationReorderPropertiesNV() noexcept : VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV} {}

  RayTracingInvocationReorderModeNV getRayTracingInvocationReorderReorderingHint() const { return std::bit_cast<RayTracingInvocationReorderModeNV>(this->rayTracingInvocationReorderReorderingHint); }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceRayTracingInvocationReorderPropertiesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_ray_tracing_invocation_reorder

#if VK_EXT_transform_feedback
struct PhysicalDeviceTransformFeedbackPropertiesEXT : VkPhysicalDeviceTransformFeedbackPropertiesEXT {
  PhysicalDeviceTransformFeedbackPropertiesEXT() noexcept : VkPhysicalDeviceTransformFeedbackPropertiesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT} {}

  uint32_t getMaxTransformFeedbackStreams() const { return this->maxTransformFeedbackStreams; }
  uint32_t getMaxTransformFeedbackBuffers() const { return this->maxTransformFeedbackBuffers; }
  DeviceSize getMaxTransformFeedbackBufferSize() const { return this->maxTransformFeedbackBufferSize; }
  uint32_t getMaxTransformFeedbackStreamDataSize() const { return this->maxTransformFeedbackStreamDataSize; }
  uint32_t getMaxTransformFeedbackBufferDataSize() const { return this->maxTransformFeedbackBufferDataSize; }
  uint32_t getMaxTransformFeedbackBufferDataStride() const { return this->maxTransformFeedbackBufferDataStride; }
  Bool32 getTransformFeedbackQueries() const { return this->transformFeedbackQueries; }
  Bool32 getTransformFeedbackStreamsLinesTriangles() const { return this->transformFeedbackStreamsLinesTriangles; }
  Bool32 getTransformFeedbackRasterizationStreamSelect() const { return this->transformFeedbackRasterizationStreamSelect; }
  Bool32 getTransformFeedbackDraw() const { return this->transformFeedbackDraw; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceTransformFeedbackPropertiesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_transform_feedback

#if VK_EXT_provoking_vertex
struct PhysicalDeviceProvokingVertexPropertiesEXT : VkPhysicalDeviceProvokingVertexPropertiesEXT {
  PhysicalDeviceProvokingVertexPropertiesEXT() noexcept : VkPhysicalDeviceProvokingVertexPropertiesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT} {}

  Bool32 getProvokingVertexModePerPipeline() const { return this->provokingVertexModePerPipeline; }
  Bool32 getTransformFeedbackPreservesTriangleFanProvokingVertex() const { return this->transformFeedbackPreservesTriangleFanProvokingVertex; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceProvokingVertexPropertiesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_provoking_vertex

#if VK_QCOM_image_processing
struct PhysicalDeviceImageProcessingPropertiesQCOM : VkPhysicalDeviceImageProcessingPropertiesQCOM {
  PhysicalDeviceImageProcessingPropertiesQCOM() noexcept : VkPhysicalDeviceImageProcessingPropertiesQCOM{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM} {}

  uint32_t getMaxWeightFilterPhases() const { return this->maxWeightFilterPhases; }
  const Extent2D& getMaxWeightFilterDimension() const { return static_cast<const Extent2D&>(this->maxWeightFilterDimension); }
  const Extent2D& getMaxBlockMatchRegion() const { return static_cast<const Extent2D&>(this->maxBlockMatchRegion); }
  const Extent2D& getMaxBoxFilterBlockSize() const { return static_cast<const Extent2D&>(this->maxBoxFilterBlockSize); }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceImageProcessingPropertiesQCOM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_QCOM_image_processing

#if VK_NV_memory_decompression
struct PhysicalDeviceMemoryDecompressionPropertiesNV : VkPhysicalDeviceMemoryDecompressionPropertiesNV {
  PhysicalDeviceMemoryDecompressionPropertiesNV() noexcept : VkPhysicalDeviceMemoryDecompressionPropertiesNV{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_NV} {}

  MemoryDecompressionMethodFlagsNV getDecompressionMethods() const { return std::bit_cast<MemoryDecompressionMethodFlagsNV>(this->decompressionMethods); }
  uint64_t getMaxDecompressionIndirectCount() const { return this->maxDecompressionIndirectCount; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceMemoryDecompressionPropertiesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_memory_decompression

#if VK_NV_shading_rate_image
struct PhysicalDeviceShadingRateImagePropertiesNV : VkPhysicalDeviceShadingRateImagePropertiesNV {
  PhysicalDeviceShadingRateImagePropertiesNV() noexcept : VkPhysicalDeviceShadingRateImagePropertiesNV{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV} {}

  const Extent2D& getShadingRateTexelSize() const { return static_cast<const Extent2D&>(this->shadingRateTexelSize); }
  uint32_t getShadingRatePaletteSize() const { return this->shadingRatePaletteSize; }
  uint32_t getShadingRateMaxCoarseSamples() const { return this->shadingRateMaxCoarseSamples; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceShadingRateImagePropertiesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_shading_rate_image

#if VK_VERSION_1_2
struct PhysicalDeviceVulkan12Properties : VkPhysicalDeviceVulkan12Properties {
  PhysicalDeviceVulkan12Properties() noexcept : VkPhysicalDeviceVulkan12Properties{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES} {}

  DriverId getDriverID() const { return std::bit_cast<DriverId>(this->driverID); }
  std::string_view getDriverName() const { return this->driverName; }
  std::string_view getDriverInfo() const { return this->driverInfo; }
  const ConformanceVersion& getConformanceVersion() const { return static_cast<const ConformanceVersion&>(this->conformanceVersion); }
  ShaderFloatControlsIndependence getDenormBehaviorIndependence() const { return std::bit_cast<ShaderFloatControlsIndependence>(this->denormBehaviorIndependence); }
  ShaderFloatControlsIndependence getRoundingModeIndependence() const { return std::bit_cast<ShaderFloatControlsIndependence>(this->roundingModeIndependence); }
  // An implementation can preserve signed zero, nan, inf
  Bool32 getShaderSignedZeroInfNanPreserveFloat16() const { return this->shaderSignedZeroInfNanPreserveFloat16; }
  // An implementation can preserve signed zero, nan, inf
  Bool32 getShaderSignedZeroInfNanPreserveFloat32() const { return this->shaderSignedZeroInfNanPreserveFloat32; }
  // An implementation can preserve signed zero, nan, inf
  Bool32 getShaderSignedZeroInfNanPreserveFloat64() const { return this->shaderSignedZeroInfNanPreserveFloat64; }
  // An implementation can preserve  denormals
  Bool32 getShaderDenormPreserveFloat16() const { return this->shaderDenormPreserveFloat16; }
  // An implementation can preserve  denormals
  Bool32 getShaderDenormPreserveFloat32() const { return this->shaderDenormPreserveFloat32; }
  // An implementation can preserve  denormals
  Bool32 getShaderDenormPreserveFloat64() const { return this->shaderDenormPreserveFloat64; }
  // An implementation can flush to zero  denormals
  Bool32 getShaderDenormFlushToZeroFloat16() const { return this->shaderDenormFlushToZeroFloat16; }
  // An implementation can flush to zero  denormals
  Bool32 getShaderDenormFlushToZeroFloat32() const { return this->shaderDenormFlushToZeroFloat32; }
  // An implementation can flush to zero  denormals
  Bool32 getShaderDenormFlushToZeroFloat64() const { return this->shaderDenormFlushToZeroFloat64; }
  // An implementation can support RTE
  Bool32 getShaderRoundingModeRTEFloat16() const { return this->shaderRoundingModeRTEFloat16; }
  // An implementation can support RTE
  Bool32 getShaderRoundingModeRTEFloat32() const { return this->shaderRoundingModeRTEFloat32; }
  // An implementation can support RTE
  Bool32 getShaderRoundingModeRTEFloat64() const { return this->shaderRoundingModeRTEFloat64; }
  // An implementation can support RTZ
  Bool32 getShaderRoundingModeRTZFloat16() const { return this->shaderRoundingModeRTZFloat16; }
  // An implementation can support RTZ
  Bool32 getShaderRoundingModeRTZFloat32() const { return this->shaderRoundingModeRTZFloat32; }
  // An implementation can support RTZ
  Bool32 getShaderRoundingModeRTZFloat64() const { return this->shaderRoundingModeRTZFloat64; }
  uint32_t getMaxUpdateAfterBindDescriptorsInAllPools() const { return this->maxUpdateAfterBindDescriptorsInAllPools; }
  Bool32 getShaderUniformBufferArrayNonUniformIndexingNative() const { return this->shaderUniformBufferArrayNonUniformIndexingNative; }
  Bool32 getShaderSampledImageArrayNonUniformIndexingNative() const { return this->shaderSampledImageArrayNonUniformIndexingNative; }
  Bool32 getShaderStorageBufferArrayNonUniformIndexingNative() const { return this->shaderStorageBufferArrayNonUniformIndexingNative; }
  Bool32 getShaderStorageImageArrayNonUniformIndexingNative() const { return this->shaderStorageImageArrayNonUniformIndexingNative; }
  Bool32 getShaderInputAttachmentArrayNonUniformIndexingNative() const { return this->shaderInputAttachmentArrayNonUniformIndexingNative; }
  Bool32 getRobustBufferAccessUpdateAfterBind() const { return this->robustBufferAccessUpdateAfterBind; }
  Bool32 getQuadDivergentImplicitLod() const { return this->quadDivergentImplicitLod; }
  uint32_t getMaxPerStageDescriptorUpdateAfterBindSamplers() const { return this->maxPerStageDescriptorUpdateAfterBindSamplers; }
  uint32_t getMaxPerStageDescriptorUpdateAfterBindUniformBuffers() const { return this->maxPerStageDescriptorUpdateAfterBindUniformBuffers; }
  uint32_t getMaxPerStageDescriptorUpdateAfterBindStorageBuffers() const { return this->maxPerStageDescriptorUpdateAfterBindStorageBuffers; }
  uint32_t getMaxPerStageDescriptorUpdateAfterBindSampledImages() const { return this->maxPerStageDescriptorUpdateAfterBindSampledImages; }
  uint32_t getMaxPerStageDescriptorUpdateAfterBindStorageImages() const { return this->maxPerStageDescriptorUpdateAfterBindStorageImages; }
  uint32_t getMaxPerStageDescriptorUpdateAfterBindInputAttachments() const { return this->maxPerStageDescriptorUpdateAfterBindInputAttachments; }
  uint32_t getMaxPerStageUpdateAfterBindResources() const { return this->maxPerStageUpdateAfterBindResources; }
  uint32_t getMaxDescriptorSetUpdateAfterBindSamplers() const { return this->maxDescriptorSetUpdateAfterBindSamplers; }
  uint32_t getMaxDescriptorSetUpdateAfterBindUniformBuffers() const { return this->maxDescriptorSetUpdateAfterBindUniformBuffers; }
  uint32_t getMaxDescriptorSetUpdateAfterBindUniformBuffersDynamic() const { return this->maxDescriptorSetUpdateAfterBindUniformBuffersDynamic; }
  uint32_t getMaxDescriptorSetUpdateAfterBindStorageBuffers() const { return this->maxDescriptorSetUpdateAfterBindStorageBuffers; }
  uint32_t getMaxDescriptorSetUpdateAfterBindStorageBuffersDynamic() const { return this->maxDescriptorSetUpdateAfterBindStorageBuffersDynamic; }
  uint32_t getMaxDescriptorSetUpdateAfterBindSampledImages() const { return this->maxDescriptorSetUpdateAfterBindSampledImages; }
  uint32_t getMaxDescriptorSetUpdateAfterBindStorageImages() const { return this->maxDescriptorSetUpdateAfterBindStorageImages; }
  uint32_t getMaxDescriptorSetUpdateAfterBindInputAttachments() const { return this->maxDescriptorSetUpdateAfterBindInputAttachments; }
  // supported depth resolve modes
  ResolveModeFlags getSupportedDepthResolveModes() const { return std::bit_cast<ResolveModeFlags>(this->supportedDepthResolveModes); }
  // supported stencil resolve modes
  ResolveModeFlags getSupportedStencilResolveModes() const { return std::bit_cast<ResolveModeFlags>(this->supportedStencilResolveModes); }
  // depth and stencil resolve modes can be set independently if one of them is none
  Bool32 getIndependentResolveNone() const { return this->independentResolveNone; }
  // depth and stencil resolve modes can be set independently
  Bool32 getIndependentResolve() const { return this->independentResolve; }
  Bool32 getFilterMinmaxSingleComponentFormats() const { return this->filterMinmaxSingleComponentFormats; }
  Bool32 getFilterMinmaxImageComponentMapping() const { return this->filterMinmaxImageComponentMapping; }
  uint64_t getMaxTimelineSemaphoreValueDifference() const { return this->maxTimelineSemaphoreValueDifference; }

  SampleCountFlags getFramebufferIntegerColorSampleCounts() const { return std::bit_cast<SampleCountFlags>(this->framebufferIntegerColorSampleCounts); }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceVulkan12Properties& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_2

#if VK_VERSION_1_1
struct PhysicalDeviceProtectedMemoryProperties : VkPhysicalDeviceProtectedMemoryProperties {
  PhysicalDeviceProtectedMemoryProperties() noexcept : VkPhysicalDeviceProtectedMemoryProperties{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES} {}

  Bool32 getProtectedNoFault() const { return this->protectedNoFault; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceProtectedMemoryProperties& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_1

#if VK_KHR_pipeline_binary
struct PhysicalDevicePipelineBinaryPropertiesKHR : VkPhysicalDevicePipelineBinaryPropertiesKHR {
  PhysicalDevicePipelineBinaryPropertiesKHR() noexcept : VkPhysicalDevicePipelineBinaryPropertiesKHR{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_PROPERTIES_KHR} {}

  Bool32 getPipelineBinaryInternalCache() const { return this->pipelineBinaryInternalCache; }
  Bool32 getPipelineBinaryInternalCacheControl() const { return this->pipelineBinaryInternalCacheControl; }
  Bool32 getPipelineBinaryPrefersInternalCache() const { return this->pipelineBinaryPrefersInternalCache; }
  Bool32 getPipelineBinaryPrecompiledInternalCache() const { return this->pipelineBinaryPrecompiledInternalCache; }
  Bool32 getPipelineBinaryCompressedData() const { return this->pipelineBinaryCompressedData; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDevicePipelineBinaryPropertiesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_pipeline_binary

#if VK_ARM_shader_core_builtins
struct PhysicalDeviceShaderCoreBuiltinsPropertiesARM : VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM {
  PhysicalDeviceShaderCoreBuiltinsPropertiesARM() noexcept : VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM} {}

  uint64_t getShaderCoreMask() const { return this->shaderCoreMask; }
  uint32_t getShaderCoreCount() const { return this->shaderCoreCount; }
  uint32_t getShaderWarpsPerCore() const { return this->shaderWarpsPerCore; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceShaderCoreBuiltinsPropertiesARM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_ARM_shader_core_builtins

#if VK_EXT_physical_device_drm
struct PhysicalDeviceDrmPropertiesEXT : VkPhysicalDeviceDrmPropertiesEXT {
  PhysicalDeviceDrmPropertiesEXT() noexcept : VkPhysicalDeviceDrmPropertiesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT} {}

  Bool32 getHasPrimary() const { return this->hasPrimary; }
  Bool32 getHasRender() const { return this->hasRender; }
  int64_t getPrimaryMajor() const { return this->primaryMajor; }
  int64_t getPrimaryMinor() const { return this->primaryMinor; }
  int64_t getRenderMajor() const { return this->renderMajor; }
  int64_t getRenderMinor() const { return this->renderMinor; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceDrmPropertiesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_physical_device_drm

#if VK_EXT_descriptor_buffer
struct PhysicalDeviceDescriptorBufferPropertiesEXT : VkPhysicalDeviceDescriptorBufferPropertiesEXT {
  PhysicalDeviceDescriptorBufferPropertiesEXT() noexcept : VkPhysicalDeviceDescriptorBufferPropertiesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT} {}

  Bool32 getCombinedImageSamplerDescriptorSingleArray() const { return this->combinedImageSamplerDescriptorSingleArray; }
  Bool32 getBufferlessPushDescriptors() const { return this->bufferlessPushDescriptors; }
  Bool32 getAllowSamplerImageViewPostSubmitCreation() const { return this->allowSamplerImageViewPostSubmitCreation; }
  DeviceSize getDescriptorBufferOffsetAlignment() const { return this->descriptorBufferOffsetAlignment; }
  uint32_t getMaxDescriptorBufferBindings() const { return this->maxDescriptorBufferBindings; }
  uint32_t getMaxResourceDescriptorBufferBindings() const { return this->maxResourceDescriptorBufferBindings; }
  uint32_t getMaxSamplerDescriptorBufferBindings() const { return this->maxSamplerDescriptorBufferBindings; }
  uint32_t getMaxEmbeddedImmutableSamplerBindings() const { return this->maxEmbeddedImmutableSamplerBindings; }
  uint32_t getMaxEmbeddedImmutableSamplers() const { return this->maxEmbeddedImmutableSamplers; }
  size_t getBufferCaptureReplayDescriptorDataSize() const { return this->bufferCaptureReplayDescriptorDataSize; }
  size_t getImageCaptureReplayDescriptorDataSize() const { return this->imageCaptureReplayDescriptorDataSize; }
  size_t getImageViewCaptureReplayDescriptorDataSize() const { return this->imageViewCaptureReplayDescriptorDataSize; }
  size_t getSamplerCaptureReplayDescriptorDataSize() const { return this->samplerCaptureReplayDescriptorDataSize; }
  size_t getAccelerationStructureCaptureReplayDescriptorDataSize() const { return this->accelerationStructureCaptureReplayDescriptorDataSize; }
  size_t getSamplerDescriptorSize() const { return this->samplerDescriptorSize; }
  size_t getCombinedImageSamplerDescriptorSize() const { return this->combinedImageSamplerDescriptorSize; }
  size_t getSampledImageDescriptorSize() const { return this->sampledImageDescriptorSize; }
  size_t getStorageImageDescriptorSize() const { return this->storageImageDescriptorSize; }
  size_t getUniformTexelBufferDescriptorSize() const { return this->uniformTexelBufferDescriptorSize; }
  size_t getRobustUniformTexelBufferDescriptorSize() const { return this->robustUniformTexelBufferDescriptorSize; }
  size_t getStorageTexelBufferDescriptorSize() const { return this->storageTexelBufferDescriptorSize; }
  size_t getRobustStorageTexelBufferDescriptorSize() const { return this->robustStorageTexelBufferDescriptorSize; }
  size_t getUniformBufferDescriptorSize() const { return this->uniformBufferDescriptorSize; }
  size_t getRobustUniformBufferDescriptorSize() const { return this->robustUniformBufferDescriptorSize; }
  size_t getStorageBufferDescriptorSize() const { return this->storageBufferDescriptorSize; }
  size_t getRobustStorageBufferDescriptorSize() const { return this->robustStorageBufferDescriptorSize; }
  size_t getInputAttachmentDescriptorSize() const { return this->inputAttachmentDescriptorSize; }
  size_t getAccelerationStructureDescriptorSize() const { return this->accelerationStructureDescriptorSize; }
  DeviceSize getMaxSamplerDescriptorBufferRange() const { return this->maxSamplerDescriptorBufferRange; }
  DeviceSize getMaxResourceDescriptorBufferRange() const { return this->maxResourceDescriptorBufferRange; }
  DeviceSize getSamplerDescriptorBufferAddressSpaceSize() const { return this->samplerDescriptorBufferAddressSpaceSize; }
  DeviceSize getResourceDescriptorBufferAddressSpaceSize() const { return this->resourceDescriptorBufferAddressSpaceSize; }
  DeviceSize getDescriptorBufferAddressSpaceSize() const { return this->descriptorBufferAddressSpaceSize; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceDescriptorBufferPropertiesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_descriptor_buffer

#if VK_NV_extended_sparse_address_space
struct PhysicalDeviceExtendedSparseAddressSpacePropertiesNV : VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV {
  PhysicalDeviceExtendedSparseAddressSpacePropertiesNV() noexcept : VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_PROPERTIES_NV} {}

  // Total address space available for extended sparse allocations (bytes)
  DeviceSize getExtendedSparseAddressSpaceSize() const { return this->extendedSparseAddressSpaceSize; }
  // Bitfield of which image usages are supported for extended sparse allocations
  ImageUsageFlags getExtendedSparseImageUsageFlags() const { return std::bit_cast<ImageUsageFlags>(this->extendedSparseImageUsageFlags); }
  // Bitfield of which buffer usages are supported for extended sparse allocations
  BufferUsageFlags getExtendedSparseBufferUsageFlags() const { return std::bit_cast<BufferUsageFlags>(this->extendedSparseBufferUsageFlags); }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceExtendedSparseAddressSpacePropertiesNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_extended_sparse_address_space

#if VK_KHR_ray_tracing_pipeline
struct PhysicalDeviceRayTracingPipelinePropertiesKHR : VkPhysicalDeviceRayTracingPipelinePropertiesKHR {
  PhysicalDeviceRayTracingPipelinePropertiesKHR() noexcept : VkPhysicalDeviceRayTracingPipelinePropertiesKHR{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR} {}

  uint32_t getShaderGroupHandleSize() const { return this->shaderGroupHandleSize; }
  uint32_t getMaxRayRecursionDepth() const { return this->maxRayRecursionDepth; }
  uint32_t getMaxShaderGroupStride() const { return this->maxShaderGroupStride; }
  uint32_t getShaderGroupBaseAlignment() const { return this->shaderGroupBaseAlignment; }
  uint32_t getShaderGroupHandleCaptureReplaySize() const { return this->shaderGroupHandleCaptureReplaySize; }
  uint32_t getMaxRayDispatchInvocationCount() const { return this->maxRayDispatchInvocationCount; }
  uint32_t getShaderGroupHandleAlignment() const { return this->shaderGroupHandleAlignment; }
  uint32_t getMaxRayHitAttributeSize() const { return this->maxRayHitAttributeSize; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceRayTracingPipelinePropertiesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_ray_tracing_pipeline

#if VK_ARM_scheduling_controls
struct PhysicalDeviceSchedulingControlsPropertiesARM : VkPhysicalDeviceSchedulingControlsPropertiesARM {
  PhysicalDeviceSchedulingControlsPropertiesARM() noexcept : VkPhysicalDeviceSchedulingControlsPropertiesARM{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_PROPERTIES_ARM} {}

  PhysicalDeviceSchedulingControlsFlagsARM getSchedulingControlsFlags() const { return std::bit_cast<PhysicalDeviceSchedulingControlsFlagsARM>(this->schedulingControlsFlags); }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceSchedulingControlsPropertiesARM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_ARM_scheduling_controls

#if VK_EXT_conservative_rasterization
struct PhysicalDeviceConservativeRasterizationPropertiesEXT : VkPhysicalDeviceConservativeRasterizationPropertiesEXT {
  PhysicalDeviceConservativeRasterizationPropertiesEXT() noexcept : VkPhysicalDeviceConservativeRasterizationPropertiesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT} {}

  // The size in pixels the primitive is enlarged at each edge during conservative rasterization
  float getPrimitiveOverestimationSize() const { return this->primitiveOverestimationSize; }
  // The maximum additional overestimation the client can specify in the pipeline state
  float getMaxExtraPrimitiveOverestimationSize() const { return this->maxExtraPrimitiveOverestimationSize; }
  // The granularity of extra overestimation sizes the implementations supports between 0 and maxExtraOverestimationSize
  float getExtraPrimitiveOverestimationSizeGranularity() const { return this->extraPrimitiveOverestimationSizeGranularity; }
  // true if the implementation supports conservative rasterization underestimation mode
  Bool32 getPrimitiveUnderestimation() const { return this->primitiveUnderestimation; }
  // true if conservative rasterization also applies to points and lines
  Bool32 getConservativePointAndLineRasterization() const { return this->conservativePointAndLineRasterization; }
  // true if degenerate triangles (those with zero area after snap) are rasterized
  Bool32 getDegenerateTrianglesRasterized() const { return this->degenerateTrianglesRasterized; }
  // true if degenerate lines (those with zero length after snap) are rasterized
  Bool32 getDegenerateLinesRasterized() const { return this->degenerateLinesRasterized; }
  // true if the implementation supports the FullyCoveredEXT SPIR-V builtin fragment shader input variable
  Bool32 getFullyCoveredFragmentShaderInputVariable() const { return this->fullyCoveredFragmentShaderInputVariable; }
  // true if the implementation supports both conservative rasterization and post depth coverage sample coverage mask
  Bool32 getConservativeRasterizationPostDepthCoverage() const { return this->conservativeRasterizationPostDepthCoverage; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceConservativeRasterizationPropertiesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_conservative_rasterization

#if VK_EXT_custom_border_color
struct PhysicalDeviceCustomBorderColorPropertiesEXT : VkPhysicalDeviceCustomBorderColorPropertiesEXT {
  PhysicalDeviceCustomBorderColorPropertiesEXT() noexcept : VkPhysicalDeviceCustomBorderColorPropertiesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT} {}

  uint32_t getMaxCustomBorderColorSamplers() const { return this->maxCustomBorderColorSamplers; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceCustomBorderColorPropertiesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_custom_border_color

#if VK_HUAWEI_cluster_culling_shader
struct PhysicalDeviceClusterCullingShaderPropertiesHUAWEI : VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI {
  PhysicalDeviceClusterCullingShaderPropertiesHUAWEI() noexcept : VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI} {}

  std::span<const uint32_t, 3> getMaxWorkGroupCount() const { return this->maxWorkGroupCount; }
  std::span<const uint32_t, 3> getMaxWorkGroupSize() const { return this->maxWorkGroupSize; }
  uint32_t getMaxOutputClusterCount() const { return this->maxOutputClusterCount; }
  DeviceSize getIndirectBufferOffsetAlignment() const { return this->indirectBufferOffsetAlignment; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceClusterCullingShaderPropertiesHUAWEI& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_HUAWEI_cluster_culling_shader

#if VK_EXT_nested_command_buffer
struct PhysicalDeviceNestedCommandBufferPropertiesEXT : VkPhysicalDeviceNestedCommandBufferPropertiesEXT {
  PhysicalDeviceNestedCommandBufferPropertiesEXT() noexcept : VkPhysicalDeviceNestedCommandBufferPropertiesEXT{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_PROPERTIES_EXT} {}

  uint32_t getMaxCommandBufferNestingLevel() const { return this->maxCommandBufferNestingLevel; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceNestedCommandBufferPropertiesEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_nested_command_buffer

#if VK_KHR_cooperative_matrix
struct PhysicalDeviceCooperativeMatrixPropertiesKHR : VkPhysicalDeviceCooperativeMatrixPropertiesKHR {
  PhysicalDeviceCooperativeMatrixPropertiesKHR() noexcept : VkPhysicalDeviceCooperativeMatrixPropertiesKHR{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR} {}

  ShaderStageFlags getCooperativeMatrixSupportedStages() const { return std::bit_cast<ShaderStageFlags>(this->cooperativeMatrixSupportedStages); }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceCooperativeMatrixPropertiesKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_cooperative_matrix

#if VK_VERSION_1_1
struct PhysicalDeviceMultiviewProperties : VkPhysicalDeviceMultiviewProperties {
  PhysicalDeviceMultiviewProperties() noexcept : VkPhysicalDeviceMultiviewProperties{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES} {}

  // max number of views in a subpass
  uint32_t getMaxMultiviewViewCount() const { return this->maxMultiviewViewCount; }
  // max instance index for a draw in a multiview subpass
  uint32_t getMaxMultiviewInstanceIndex() const { return this->maxMultiviewInstanceIndex; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceMultiviewProperties& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_1

#if VK_ARM_render_pass_striped
struct PhysicalDeviceRenderPassStripedPropertiesARM : VkPhysicalDeviceRenderPassStripedPropertiesARM {
  PhysicalDeviceRenderPassStripedPropertiesARM() noexcept : VkPhysicalDeviceRenderPassStripedPropertiesARM{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_PROPERTIES_ARM} {}

  const Extent2D& getRenderPassStripeGranularity() const { return static_cast<const Extent2D&>(this->renderPassStripeGranularity); }
  uint32_t getMaxRenderPassStripes() const { return this->maxRenderPassStripes; }
};
inline void PhysicalDeviceProperties2::attach(PhysicalDeviceRenderPassStripedPropertiesARM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_ARM_render_pass_striped

#if VK_ARM_tensors
struct TensorMemoryBarrierARM : VkTensorMemoryBarrierARM {
  TensorMemoryBarrierARM() noexcept : VkTensorMemoryBarrierARM{.sType = VK_STRUCTURE_TYPE_TENSOR_MEMORY_BARRIER_ARM} {}

  void setSrcQueueFamilyIndex(uint32_t value) { this->srcQueueFamilyIndex = value; }
  uint32_t getSrcQueueFamilyIndex() const { return this->srcQueueFamilyIndex; }
  void setDstQueueFamilyIndex(uint32_t value) { this->dstQueueFamilyIndex = value; }
  uint32_t getDstQueueFamilyIndex() const { return this->dstQueueFamilyIndex; }
  void setTensor(TensorARM value) { this->tensor = std::bit_cast<VkTensorARM>(value); }
  TensorARM getTensor() const { return std::bit_cast<TensorARM>(this->tensor); }

  void setSrcStageMask(PipelineStageFlags2 value) { this->srcStageMask = std::bit_cast<VkPipelineStageFlags2>(value); }
  PipelineStageFlags2 getSrcStageMask() const { return std::bit_cast<PipelineStageFlags2>(this->srcStageMask); }
  void setSrcAccessMask(AccessFlags2 value) { this->srcAccessMask = std::bit_cast<VkAccessFlags2>(value); }
  AccessFlags2 getSrcAccessMask() const { return std::bit_cast<AccessFlags2>(this->srcAccessMask); }
  void setDstStageMask(PipelineStageFlags2 value) { this->dstStageMask = std::bit_cast<VkPipelineStageFlags2>(value); }
  PipelineStageFlags2 getDstStageMask() const { return std::bit_cast<PipelineStageFlags2>(this->dstStageMask); }
  void setDstAccessMask(AccessFlags2 value) { this->dstAccessMask = std::bit_cast<VkAccessFlags2>(value); }
  AccessFlags2 getDstAccessMask() const { return std::bit_cast<AccessFlags2>(this->dstAccessMask); }
};
inline void DependencyInfo::attach(TensorMemoryBarrierARM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_ARM_tensors

#if VK_KHR_synchronization2
using DependencyInfoKHR = DependencyInfo;
#endif // VK_KHR_synchronization2
#if VK_EXT_surface_maintenance1
using SurfacePresentScalingCapabilitiesEXT = SurfacePresentScalingCapabilitiesKHR;
using SurfacePresentModeCompatibilityEXT = SurfacePresentModeCompatibilityKHR;
#endif // VK_EXT_surface_maintenance1
#if VK_KHR_maintenance2
using RenderPassInputAttachmentAspectCreateInfoKHR = RenderPassInputAttachmentAspectCreateInfo;
#endif // VK_KHR_maintenance2
#if VK_KHR_multiview
using RenderPassMultiviewCreateInfoKHR = RenderPassMultiviewCreateInfo;
#endif // VK_KHR_multiview

#if VK_KHR_video_encode_intra_refresh
struct VideoEncodeSessionIntraRefreshCreateInfoKHR : VkVideoEncodeSessionIntraRefreshCreateInfoKHR {
  VideoEncodeSessionIntraRefreshCreateInfoKHR() noexcept : VkVideoEncodeSessionIntraRefreshCreateInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_INTRA_REFRESH_CREATE_INFO_KHR} {}

  void setIntraRefreshMode(VideoEncodeIntraRefreshModeFlagBitsKHR value) { this->intraRefreshMode = std::bit_cast<VkVideoEncodeIntraRefreshModeFlagBitsKHR>(value); }
  VideoEncodeIntraRefreshModeFlagBitsKHR getIntraRefreshMode() const { return std::bit_cast<VideoEncodeIntraRefreshModeFlagBitsKHR>(this->intraRefreshMode); }
};
inline void VideoSessionCreateInfoKHR::attach(VideoEncodeSessionIntraRefreshCreateInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_encode_intra_refresh

#if VK_KHR_video_encode_av1
struct VideoEncodeAV1SessionCreateInfoKHR : VkVideoEncodeAV1SessionCreateInfoKHR {
  VideoEncodeAV1SessionCreateInfoKHR() noexcept : VkVideoEncodeAV1SessionCreateInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_CREATE_INFO_KHR} {}

  void setMaxLevel(StdVideoAV1Level value) { this->maxLevel = value; }
  StdVideoAV1Level getMaxLevel() const { return this->maxLevel; }

  void setUseMaxLevel(Bool32 value) { this->useMaxLevel = value; }
  Bool32 getUseMaxLevel() const { return this->useMaxLevel; }
};
inline void VideoSessionCreateInfoKHR::attach(VideoEncodeAV1SessionCreateInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_encode_av1

#if VK_KHR_video_encode_h265
struct VideoEncodeH265SessionCreateInfoKHR : VkVideoEncodeH265SessionCreateInfoKHR {
  VideoEncodeH265SessionCreateInfoKHR() noexcept : VkVideoEncodeH265SessionCreateInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_CREATE_INFO_KHR} {}

  void setMaxLevelIdc(StdVideoH265LevelIdc value) { this->maxLevelIdc = value; }
  StdVideoH265LevelIdc getMaxLevelIdc() const { return this->maxLevelIdc; }

  void setUseMaxLevelIdc(Bool32 value) { this->useMaxLevelIdc = value; }
  Bool32 getUseMaxLevelIdc() const { return this->useMaxLevelIdc; }
};
inline void VideoSessionCreateInfoKHR::attach(VideoEncodeH265SessionCreateInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_encode_h265

#if VK_KHR_video_encode_h264
struct VideoEncodeH264SessionCreateInfoKHR : VkVideoEncodeH264SessionCreateInfoKHR {
  VideoEncodeH264SessionCreateInfoKHR() noexcept : VkVideoEncodeH264SessionCreateInfoKHR{.sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_CREATE_INFO_KHR} {}

  void setMaxLevelIdc(StdVideoH264LevelIdc value) { this->maxLevelIdc = value; }
  StdVideoH264LevelIdc getMaxLevelIdc() const { return this->maxLevelIdc; }

  void setUseMaxLevelIdc(Bool32 value) { this->useMaxLevelIdc = value; }
  Bool32 getUseMaxLevelIdc() const { return this->useMaxLevelIdc; }
};
inline void VideoSessionCreateInfoKHR::attach(VideoEncodeH264SessionCreateInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_video_encode_h264

#if VK_KHR_shader_float16_int8
using PhysicalDeviceShaderFloat16Int8FeaturesKHR = PhysicalDeviceShaderFloat16Int8Features;
using PhysicalDeviceFloat16Int8FeaturesKHR = PhysicalDeviceShaderFloat16Int8Features;
#endif // VK_KHR_shader_float16_int8
#if VK_EXT_swapchain_maintenance1
using PhysicalDeviceSwapchainMaintenance1FeaturesEXT = PhysicalDeviceSwapchainMaintenance1FeaturesKHR;
#endif // VK_EXT_swapchain_maintenance1
#if VK_EXT_pipeline_robustness
using PhysicalDevicePipelineRobustnessFeaturesEXT = PhysicalDevicePipelineRobustnessFeatures;
#endif // VK_EXT_pipeline_robustness
#if VK_KHR_timeline_semaphore
using PhysicalDeviceTimelineSemaphoreFeaturesKHR = PhysicalDeviceTimelineSemaphoreFeatures;
#endif // VK_KHR_timeline_semaphore
#if VK_EXT_texture_compression_astc_hdr
using PhysicalDeviceTextureCompressionASTCHDRFeaturesEXT = PhysicalDeviceTextureCompressionASTCHDRFeatures;
#endif // VK_EXT_texture_compression_astc_hdr
#if VK_KHR_shader_subgroup_rotate
using PhysicalDeviceShaderSubgroupRotateFeaturesKHR = PhysicalDeviceShaderSubgroupRotateFeatures;
#endif // VK_KHR_shader_subgroup_rotate
#if VK_KHR_shader_expect_assume
using PhysicalDeviceShaderExpectAssumeFeaturesKHR = PhysicalDeviceShaderExpectAssumeFeatures;
#endif // VK_KHR_shader_expect_assume
#if VK_KHR_shader_float_controls2
using PhysicalDeviceShaderFloatControls2FeaturesKHR = PhysicalDeviceShaderFloatControls2Features;
#endif // VK_KHR_shader_float_controls2
#if VK_KHR_dynamic_rendering_local_read
using PhysicalDeviceDynamicRenderingLocalReadFeaturesKHR = PhysicalDeviceDynamicRenderingLocalReadFeatures;
#endif // VK_KHR_dynamic_rendering_local_read
#if VK_VERSION_1_1
using PhysicalDeviceShaderDrawParameterFeatures = PhysicalDeviceShaderDrawParametersFeatures;
#endif // VK_VERSION_1_1
#if VK_EXT_present_mode_fifo_latest_ready
using PhysicalDevicePresentModeFifoLatestReadyFeaturesEXT = PhysicalDevicePresentModeFifoLatestReadyFeaturesKHR;
#endif // VK_EXT_present_mode_fifo_latest_ready
#if VK_EXT_pipeline_creation_cache_control
using PhysicalDevicePipelineCreationCacheControlFeaturesEXT = PhysicalDevicePipelineCreationCacheControlFeatures;
#endif // VK_EXT_pipeline_creation_cache_control
#if VK_EXT_depth_clamp_zero_one
using PhysicalDeviceDepthClampZeroOneFeaturesEXT = PhysicalDeviceDepthClampZeroOneFeaturesKHR;
#endif // VK_EXT_depth_clamp_zero_one
#if VK_QCOM_fragment_density_map_offset
using PhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM = PhysicalDeviceFragmentDensityMapOffsetFeaturesEXT;
#endif // VK_QCOM_fragment_density_map_offset
#if VK_KHR_vulkan_memory_model
using PhysicalDeviceVulkanMemoryModelFeaturesKHR = PhysicalDeviceVulkanMemoryModelFeatures;
#endif // VK_KHR_vulkan_memory_model
#if VK_KHR_8bit_storage
using PhysicalDevice8BitStorageFeaturesKHR = PhysicalDevice8BitStorageFeatures;
#endif // VK_KHR_8bit_storage
#if VK_KHR_16bit_storage
using PhysicalDevice16BitStorageFeaturesKHR = PhysicalDevice16BitStorageFeatures;
#endif // VK_KHR_16bit_storage
#if VK_EXT_subgroup_size_control
using PhysicalDeviceSubgroupSizeControlFeaturesEXT = PhysicalDeviceSubgroupSizeControlFeatures;
#endif // VK_EXT_subgroup_size_control

#if VK_HUAWEI_cluster_culling_shader
struct PhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI : VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI {
  PhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI() noexcept : VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_VRS_FEATURES_HUAWEI} {}

  void setClusterShadingRate(Bool32 value) { this->clusterShadingRate = value; }
  Bool32 getClusterShadingRate() const { return this->clusterShadingRate; }
};
inline void PhysicalDeviceClusterCullingShaderFeaturesHUAWEI::attach(PhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_HUAWEI_cluster_culling_shader

#if VK_KHR_imageless_framebuffer
using PhysicalDeviceImagelessFramebufferFeaturesKHR = PhysicalDeviceImagelessFramebufferFeatures;
#endif // VK_KHR_imageless_framebuffer
#if VK_EXT_shader_demote_to_helper_invocation
using PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT = PhysicalDeviceShaderDemoteToHelperInvocationFeatures;
#endif // VK_EXT_shader_demote_to_helper_invocation
#if VK_KHR_shader_integer_dot_product
using PhysicalDeviceShaderIntegerDotProductFeaturesKHR = PhysicalDeviceShaderIntegerDotProductFeatures;
#endif // VK_KHR_shader_integer_dot_product
#if VK_KHR_multiview
using PhysicalDeviceMultiviewFeaturesKHR = PhysicalDeviceMultiviewFeatures;
#endif // VK_KHR_multiview
#if VK_KHR_index_type_uint8
using PhysicalDeviceIndexTypeUint8FeaturesKHR = PhysicalDeviceIndexTypeUint8Features;
#endif // VK_KHR_index_type_uint8
#if VK_EXT_index_type_uint8
using PhysicalDeviceIndexTypeUint8FeaturesEXT = PhysicalDeviceIndexTypeUint8Features;
#endif // VK_EXT_index_type_uint8
#if VK_KHR_line_rasterization
using PhysicalDeviceLineRasterizationFeaturesKHR = PhysicalDeviceLineRasterizationFeatures;
#endif // VK_KHR_line_rasterization
#if VK_EXT_line_rasterization
using PhysicalDeviceLineRasterizationFeaturesEXT = PhysicalDeviceLineRasterizationFeatures;
#endif // VK_EXT_line_rasterization
#if VK_ARM_rasterization_order_attachment_access
using PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM = PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT;
#endif // VK_ARM_rasterization_order_attachment_access
#if VK_KHR_shader_atomic_int64
using PhysicalDeviceShaderAtomicInt64FeaturesKHR = PhysicalDeviceShaderAtomicInt64Features;
#endif // VK_KHR_shader_atomic_int64
#if VK_KHR_maintenance4
using PhysicalDeviceMaintenance4FeaturesKHR = PhysicalDeviceMaintenance4Features;
#endif // VK_KHR_maintenance4
#if VK_EXT_inline_uniform_block
using PhysicalDeviceInlineUniformBlockFeaturesEXT = PhysicalDeviceInlineUniformBlockFeatures;
#endif // VK_EXT_inline_uniform_block
#if VK_KHR_separate_depth_stencil_layouts
using PhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR = PhysicalDeviceSeparateDepthStencilLayoutsFeatures;
#endif // VK_KHR_separate_depth_stencil_layouts
#if VK_KHR_maintenance6
using PhysicalDeviceMaintenance6FeaturesKHR = PhysicalDeviceMaintenance6Features;
#endif // VK_KHR_maintenance6
#if VK_EXT_host_query_reset
using PhysicalDeviceHostQueryResetFeaturesEXT = PhysicalDeviceHostQueryResetFeatures;
#endif // VK_EXT_host_query_reset
#if VK_KHR_variable_pointers
using PhysicalDeviceVariablePointersFeaturesKHR = PhysicalDeviceVariablePointersFeatures;
using PhysicalDeviceVariablePointerFeaturesKHR = PhysicalDeviceVariablePointersFeatures;
#endif // VK_KHR_variable_pointers
#if VK_VERSION_1_1
using PhysicalDeviceVariablePointerFeatures = PhysicalDeviceVariablePointersFeatures;
#endif // VK_VERSION_1_1
#if VK_KHR_dynamic_rendering
using PhysicalDeviceDynamicRenderingFeaturesKHR = PhysicalDeviceDynamicRenderingFeatures;
#endif // VK_KHR_dynamic_rendering
#if VK_NV_fragment_shader_barycentric
using PhysicalDeviceFragmentShaderBarycentricFeaturesNV = PhysicalDeviceFragmentShaderBarycentricFeaturesKHR;
#endif // VK_NV_fragment_shader_barycentric
#if VK_KHR_vertex_attribute_divisor
using PhysicalDeviceVertexAttributeDivisorFeaturesKHR = PhysicalDeviceVertexAttributeDivisorFeatures;
#endif // VK_KHR_vertex_attribute_divisor
#if VK_EXT_vertex_attribute_divisor
using PhysicalDeviceVertexAttributeDivisorFeaturesEXT = PhysicalDeviceVertexAttributeDivisorFeatures;
#endif // VK_EXT_vertex_attribute_divisor
#if VK_EXT_image_robustness
using PhysicalDeviceImageRobustnessFeaturesEXT = PhysicalDeviceImageRobustnessFeatures;
#endif // VK_EXT_image_robustness
#if VK_KHR_uniform_buffer_standard_layout
using PhysicalDeviceUniformBufferStandardLayoutFeaturesKHR = PhysicalDeviceUniformBufferStandardLayoutFeatures;
#endif // VK_KHR_uniform_buffer_standard_layout
#if VK_NV_compute_shader_derivatives
using PhysicalDeviceComputeShaderDerivativesFeaturesNV = PhysicalDeviceComputeShaderDerivativesFeaturesKHR;
#endif // VK_NV_compute_shader_derivatives
#if VK_KHR_zero_initialize_workgroup_memory
using PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR = PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures;
#endif // VK_KHR_zero_initialize_workgroup_memory
#if VK_KHR_maintenance5
using PhysicalDeviceMaintenance5FeaturesKHR = PhysicalDeviceMaintenance5Features;
#endif // VK_KHR_maintenance5
#if VK_EXT_global_priority_query
using PhysicalDeviceGlobalPriorityQueryFeaturesEXT = PhysicalDeviceGlobalPriorityQueryFeatures;
#endif // VK_EXT_global_priority_query
#if VK_KHR_global_priority
using PhysicalDeviceGlobalPriorityQueryFeaturesKHR = PhysicalDeviceGlobalPriorityQueryFeatures;
#endif // VK_KHR_global_priority
#if VK_KHR_shader_terminate_invocation
using PhysicalDeviceShaderTerminateInvocationFeaturesKHR = PhysicalDeviceShaderTerminateInvocationFeatures;
#endif // VK_KHR_shader_terminate_invocation
#if VK_KHR_buffer_device_address
using PhysicalDeviceBufferDeviceAddressFeaturesKHR = PhysicalDeviceBufferDeviceAddressFeatures;
#endif // VK_KHR_buffer_device_address
#if VK_KHR_shader_subgroup_extended_types
using PhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR = PhysicalDeviceShaderSubgroupExtendedTypesFeatures;
#endif // VK_KHR_shader_subgroup_extended_types
#if VK_EXT_robustness2
using PhysicalDeviceRobustness2FeaturesEXT = PhysicalDeviceRobustness2FeaturesKHR;
#endif // VK_EXT_robustness2
#if VK_VALVE_mutable_descriptor_type
using PhysicalDeviceMutableDescriptorTypeFeaturesVALVE = PhysicalDeviceMutableDescriptorTypeFeaturesEXT;
#endif // VK_VALVE_mutable_descriptor_type
#if VK_EXT_host_image_copy
using PhysicalDeviceHostImageCopyFeaturesEXT = PhysicalDeviceHostImageCopyFeatures;
#endif // VK_EXT_host_image_copy
#if VK_EXT_pipeline_protected_access
using PhysicalDevicePipelineProtectedAccessFeaturesEXT = PhysicalDevicePipelineProtectedAccessFeatures;
#endif // VK_EXT_pipeline_protected_access
#if VK_EXT_private_data
using PhysicalDevicePrivateDataFeaturesEXT = PhysicalDevicePrivateDataFeatures;
#endif // VK_EXT_private_data
#if VK_KHR_sampler_ycbcr_conversion
using PhysicalDeviceSamplerYcbcrConversionFeaturesKHR = PhysicalDeviceSamplerYcbcrConversionFeatures;
#endif // VK_KHR_sampler_ycbcr_conversion
#if VK_EXT_scalar_block_layout
using PhysicalDeviceScalarBlockLayoutFeaturesEXT = PhysicalDeviceScalarBlockLayoutFeatures;
#endif // VK_EXT_scalar_block_layout
#if VK_EXT_descriptor_indexing
using PhysicalDeviceDescriptorIndexingFeaturesEXT = PhysicalDeviceDescriptorIndexingFeatures;
#endif // VK_EXT_descriptor_indexing
#if VK_KHR_synchronization2
using PhysicalDeviceSynchronization2FeaturesKHR = PhysicalDeviceSynchronization2Features;
#endif // VK_KHR_synchronization2

#if VK_EXT_validation_cache
struct ShaderModuleValidationCacheCreateInfoEXT : VkShaderModuleValidationCacheCreateInfoEXT {
  ShaderModuleValidationCacheCreateInfoEXT() noexcept : VkShaderModuleValidationCacheCreateInfoEXT{.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT} {}

  void setValidationCache(ValidationCacheEXT value) { this->validationCache = std::bit_cast<VkValidationCacheEXT>(value); }
  ValidationCacheEXT getValidationCache() const { return std::bit_cast<ValidationCacheEXT>(this->validationCache); }
};
inline void ShaderModuleCreateInfo::attach(ShaderModuleValidationCacheCreateInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void PipelineShaderStageCreateInfo::attach(ShaderModuleValidationCacheCreateInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_validation_cache

#if VK_KHR_dynamic_rendering_local_read
using RenderingAttachmentLocationInfoKHR = RenderingAttachmentLocationInfo;
using RenderingInputAttachmentIndexInfoKHR = RenderingInputAttachmentIndexInfo;
#endif // VK_KHR_dynamic_rendering_local_read

#if VK_VERSION_1_0
struct CommandBuffer : Handle<VkCommandBuffer, ObjectType::eCommandBuffer> {
  Result begin(const CommandBufferBeginInfo& beginInfo) const { return Result(vkBeginCommandBuffer(this->handle, std::bit_cast<const VkCommandBufferBeginInfo*>(&beginInfo))); }
  Result end() const { return Result(vkEndCommandBuffer(this->handle)); }
  Result reset(CommandBufferResetFlags flags = {}) const { return Result(vkResetCommandBuffer(this->handle, std::bit_cast<VkCommandBufferResetFlags>(flags))); }
  void cmdBindPipeline(PipelineBindPoint pipelineBindPoint, Pipeline pipeline) const { vkCmdBindPipeline(this->handle, std::bit_cast<VkPipelineBindPoint>(pipelineBindPoint), std::bit_cast<VkPipeline>(pipeline)); }
#if VK_EXT_attachment_feedback_loop_dynamic_state
  void cmdSetAttachmentFeedbackLoopEnableEXT(ImageAspectFlags aspectMask = {}) const { vkCmdSetAttachmentFeedbackLoopEnableEXT(this->handle, std::bit_cast<VkImageAspectFlags>(aspectMask)); }
#endif // VK_EXT_attachment_feedback_loop_dynamic_state
  void cmdSetViewport(uint32_t firstViewport, uint32_t viewportCount, const Viewport* pViewports) const { vkCmdSetViewport(this->handle, firstViewport, viewportCount, std::bit_cast<const VkViewport*>(pViewports)); }
  void cmdSetScissor(uint32_t firstScissor, uint32_t scissorCount, const Rect2D* pScissors) const { vkCmdSetScissor(this->handle, firstScissor, scissorCount, std::bit_cast<const VkRect2D*>(pScissors)); }
  void cmdSetLineWidth(float lineWidth) const { vkCmdSetLineWidth(this->handle, lineWidth); }
  void cmdSetDepthBias(float depthBiasConstantFactor, float depthBiasClamp, float depthBiasSlopeFactor) const { vkCmdSetDepthBias(this->handle, depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor); }
  void cmdSetBlendConstants(std::span<const float, 4> blendConstants) const { vkCmdSetBlendConstants(this->handle, blendConstants.data()); }
  void cmdSetDepthBounds(float minDepthBounds, float maxDepthBounds) const { vkCmdSetDepthBounds(this->handle, minDepthBounds, maxDepthBounds); }
  void cmdSetStencilCompareMask(StencilFaceFlags faceMask, uint32_t compareMask) const { vkCmdSetStencilCompareMask(this->handle, std::bit_cast<VkStencilFaceFlags>(faceMask), compareMask); }
  void cmdSetStencilWriteMask(StencilFaceFlags faceMask, uint32_t writeMask) const { vkCmdSetStencilWriteMask(this->handle, std::bit_cast<VkStencilFaceFlags>(faceMask), writeMask); }
  void cmdSetStencilReference(StencilFaceFlags faceMask, uint32_t reference) const { vkCmdSetStencilReference(this->handle, std::bit_cast<VkStencilFaceFlags>(faceMask), reference); }
  void cmdBindDescriptorSets(PipelineBindPoint pipelineBindPoint, PipelineLayout layout, uint32_t firstSet, uint32_t descriptorSetCount, const DescriptorSet* pDescriptorSets, uint32_t dynamicOffsetCount = {}, const uint32_t* pDynamicOffsets = {}) const { vkCmdBindDescriptorSets(this->handle, std::bit_cast<VkPipelineBindPoint>(pipelineBindPoint), std::bit_cast<VkPipelineLayout>(layout), firstSet, descriptorSetCount, std::bit_cast<const VkDescriptorSet*>(pDescriptorSets), dynamicOffsetCount, pDynamicOffsets); }
  void cmdBindIndexBuffer(Buffer buffer, DeviceSize offset, IndexType indexType) const { vkCmdBindIndexBuffer(this->handle, std::bit_cast<VkBuffer>(buffer), offset, std::bit_cast<VkIndexType>(indexType)); }
  void cmdBindVertexBuffers(uint32_t firstBinding, uint32_t bindingCount, const Buffer* pBuffers, const DeviceSize* pOffsets) const { vkCmdBindVertexBuffers(this->handle, firstBinding, bindingCount, std::bit_cast<const VkBuffer*>(pBuffers), pOffsets); }
  void cmdDraw(uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance) const { vkCmdDraw(this->handle, vertexCount, instanceCount, firstVertex, firstInstance); }
  void cmdDrawIndexed(uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t vertexOffset, uint32_t firstInstance) const { vkCmdDrawIndexed(this->handle, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance); }
#if VK_EXT_multi_draw
  void cmdDrawMultiEXT(uint32_t drawCount, const MultiDrawInfoEXT* pVertexInfo, uint32_t instanceCount, uint32_t firstInstance, uint32_t stride) const { vkCmdDrawMultiEXT(this->handle, drawCount, std::bit_cast<const VkMultiDrawInfoEXT*>(pVertexInfo), instanceCount, firstInstance, stride); }
  void cmdDrawMultiIndexedEXT(uint32_t drawCount, const MultiDrawIndexedInfoEXT* pIndexInfo, uint32_t instanceCount, uint32_t firstInstance, uint32_t stride, const int32_t* pVertexOffset = {}) const { vkCmdDrawMultiIndexedEXT(this->handle, drawCount, std::bit_cast<const VkMultiDrawIndexedInfoEXT*>(pIndexInfo), instanceCount, firstInstance, stride, pVertexOffset); }
#endif // VK_EXT_multi_draw
  void cmdDrawIndirect(Buffer buffer, DeviceSize offset, uint32_t drawCount, uint32_t stride) const { vkCmdDrawIndirect(this->handle, std::bit_cast<VkBuffer>(buffer), offset, drawCount, stride); }
  void cmdDrawIndexedIndirect(Buffer buffer, DeviceSize offset, uint32_t drawCount, uint32_t stride) const { vkCmdDrawIndexedIndirect(this->handle, std::bit_cast<VkBuffer>(buffer), offset, drawCount, stride); }
  void cmdDispatch(uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ) const { vkCmdDispatch(this->handle, groupCountX, groupCountY, groupCountZ); }
  void cmdDispatchIndirect(Buffer buffer, DeviceSize offset) const { vkCmdDispatchIndirect(this->handle, std::bit_cast<VkBuffer>(buffer), offset); }
#if VK_HUAWEI_subpass_shading
  void cmdSubpassShadingHUAWEI() const { vkCmdSubpassShadingHUAWEI(this->handle); }
#endif // VK_HUAWEI_subpass_shading
#if VK_HUAWEI_cluster_culling_shader
  void cmdDrawClusterHUAWEI(uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ) const { vkCmdDrawClusterHUAWEI(this->handle, groupCountX, groupCountY, groupCountZ); }
  void cmdDrawClusterIndirectHUAWEI(Buffer buffer, DeviceSize offset) const { vkCmdDrawClusterIndirectHUAWEI(this->handle, std::bit_cast<VkBuffer>(buffer), offset); }
#endif // VK_HUAWEI_cluster_culling_shader
#if VK_NV_device_generated_commands_compute
  void cmdUpdatePipelineIndirectBufferNV(PipelineBindPoint pipelineBindPoint, Pipeline pipeline) const { vkCmdUpdatePipelineIndirectBufferNV(this->handle, std::bit_cast<VkPipelineBindPoint>(pipelineBindPoint), std::bit_cast<VkPipeline>(pipeline)); }
#endif // VK_NV_device_generated_commands_compute
  void cmdCopyBuffer(Buffer srcBuffer, Buffer dstBuffer, uint32_t regionCount, const BufferCopy* pRegions) const { vkCmdCopyBuffer(this->handle, std::bit_cast<VkBuffer>(srcBuffer), std::bit_cast<VkBuffer>(dstBuffer), regionCount, std::bit_cast<const VkBufferCopy*>(pRegions)); }
  void cmdCopyImage(Image srcImage, ImageLayout srcImageLayout, Image dstImage, ImageLayout dstImageLayout, uint32_t regionCount, const ImageCopy* pRegions) const { vkCmdCopyImage(this->handle, std::bit_cast<VkImage>(srcImage), std::bit_cast<VkImageLayout>(srcImageLayout), std::bit_cast<VkImage>(dstImage), std::bit_cast<VkImageLayout>(dstImageLayout), regionCount, std::bit_cast<const VkImageCopy*>(pRegions)); }
  void cmdBlitImage(Image srcImage, ImageLayout srcImageLayout, Image dstImage, ImageLayout dstImageLayout, uint32_t regionCount, const ImageBlit* pRegions, Filter filter) const { vkCmdBlitImage(this->handle, std::bit_cast<VkImage>(srcImage), std::bit_cast<VkImageLayout>(srcImageLayout), std::bit_cast<VkImage>(dstImage), std::bit_cast<VkImageLayout>(dstImageLayout), regionCount, std::bit_cast<const VkImageBlit*>(pRegions), std::bit_cast<VkFilter>(filter)); }
  void cmdCopyBufferToImage(Buffer srcBuffer, Image dstImage, ImageLayout dstImageLayout, uint32_t regionCount, const BufferImageCopy* pRegions) const { vkCmdCopyBufferToImage(this->handle, std::bit_cast<VkBuffer>(srcBuffer), std::bit_cast<VkImage>(dstImage), std::bit_cast<VkImageLayout>(dstImageLayout), regionCount, std::bit_cast<const VkBufferImageCopy*>(pRegions)); }
  void cmdCopyImageToBuffer(Image srcImage, ImageLayout srcImageLayout, Buffer dstBuffer, uint32_t regionCount, const BufferImageCopy* pRegions) const { vkCmdCopyImageToBuffer(this->handle, std::bit_cast<VkImage>(srcImage), std::bit_cast<VkImageLayout>(srcImageLayout), std::bit_cast<VkBuffer>(dstBuffer), regionCount, std::bit_cast<const VkBufferImageCopy*>(pRegions)); }
#if VK_NV_copy_memory_indirect
  void cmdCopyMemoryIndirectNV(DeviceAddress copyBufferAddress, uint32_t copyCount, uint32_t stride) const { vkCmdCopyMemoryIndirectNV(this->handle, copyBufferAddress, copyCount, stride); }
  void cmdCopyMemoryToImageIndirectNV(DeviceAddress copyBufferAddress, uint32_t copyCount, uint32_t stride, Image dstImage, ImageLayout dstImageLayout, const ImageSubresourceLayers* pImageSubresources) const { vkCmdCopyMemoryToImageIndirectNV(this->handle, copyBufferAddress, copyCount, stride, std::bit_cast<VkImage>(dstImage), std::bit_cast<VkImageLayout>(dstImageLayout), std::bit_cast<const VkImageSubresourceLayers*>(pImageSubresources)); }
#endif // VK_NV_copy_memory_indirect
  void cmdUpdateBuffer(Buffer dstBuffer, DeviceSize dstOffset, DeviceSize dataSize, const void* pData) const { vkCmdUpdateBuffer(this->handle, std::bit_cast<VkBuffer>(dstBuffer), dstOffset, dataSize, pData); }
  void cmdFillBuffer(Buffer dstBuffer, DeviceSize dstOffset, DeviceSize size, uint32_t data) const { vkCmdFillBuffer(this->handle, std::bit_cast<VkBuffer>(dstBuffer), dstOffset, size, data); }
  void cmdClearColorImage(Image image, ImageLayout imageLayout, const ClearColorValue& color, uint32_t rangeCount, const ImageSubresourceRange* pRanges) const { vkCmdClearColorImage(this->handle, std::bit_cast<VkImage>(image), std::bit_cast<VkImageLayout>(imageLayout), &color, rangeCount, std::bit_cast<const VkImageSubresourceRange*>(pRanges)); }
  void cmdClearDepthStencilImage(Image image, ImageLayout imageLayout, const ClearDepthStencilValue& depthStencil, uint32_t rangeCount, const ImageSubresourceRange* pRanges) const { vkCmdClearDepthStencilImage(this->handle, std::bit_cast<VkImage>(image), std::bit_cast<VkImageLayout>(imageLayout), std::bit_cast<const VkClearDepthStencilValue*>(&depthStencil), rangeCount, std::bit_cast<const VkImageSubresourceRange*>(pRanges)); }
  void cmdClearAttachments(uint32_t attachmentCount, const ClearAttachment* pAttachments, uint32_t rectCount, const ClearRect* pRects) const { vkCmdClearAttachments(this->handle, attachmentCount, std::bit_cast<const VkClearAttachment*>(pAttachments), rectCount, std::bit_cast<const VkClearRect*>(pRects)); }
  void cmdResolveImage(Image srcImage, ImageLayout srcImageLayout, Image dstImage, ImageLayout dstImageLayout, uint32_t regionCount, const ImageResolve* pRegions) const { vkCmdResolveImage(this->handle, std::bit_cast<VkImage>(srcImage), std::bit_cast<VkImageLayout>(srcImageLayout), std::bit_cast<VkImage>(dstImage), std::bit_cast<VkImageLayout>(dstImageLayout), regionCount, std::bit_cast<const VkImageResolve*>(pRegions)); }
  void cmdSetEvent(Event event, PipelineStageFlags stageMask = {}) const { vkCmdSetEvent(this->handle, std::bit_cast<VkEvent>(event), std::bit_cast<VkPipelineStageFlags>(stageMask)); }
  void cmdResetEvent(Event event, PipelineStageFlags stageMask = {}) const { vkCmdResetEvent(this->handle, std::bit_cast<VkEvent>(event), std::bit_cast<VkPipelineStageFlags>(stageMask)); }
  void cmdWaitEvents(uint32_t eventCount, const Event* pEvents, PipelineStageFlags srcStageMask = {}, PipelineStageFlags dstStageMask = {}, uint32_t memoryBarrierCount = {}, const MemoryBarrier* pMemoryBarriers = {}, uint32_t bufferMemoryBarrierCount = {}, const BufferMemoryBarrier* pBufferMemoryBarriers = {}, uint32_t imageMemoryBarrierCount = {}, const ImageMemoryBarrier* pImageMemoryBarriers = {}) const { vkCmdWaitEvents(this->handle, eventCount, std::bit_cast<const VkEvent*>(pEvents), std::bit_cast<VkPipelineStageFlags>(srcStageMask), std::bit_cast<VkPipelineStageFlags>(dstStageMask), memoryBarrierCount, std::bit_cast<const VkMemoryBarrier*>(pMemoryBarriers), bufferMemoryBarrierCount, std::bit_cast<const VkBufferMemoryBarrier*>(pBufferMemoryBarriers), imageMemoryBarrierCount, std::bit_cast<const VkImageMemoryBarrier*>(pImageMemoryBarriers)); }
  void cmdPipelineBarrier(PipelineStageFlags srcStageMask = {}, PipelineStageFlags dstStageMask = {}, DependencyFlags dependencyFlags = {}, uint32_t memoryBarrierCount = {}, const MemoryBarrier* pMemoryBarriers = {}, uint32_t bufferMemoryBarrierCount = {}, const BufferMemoryBarrier* pBufferMemoryBarriers = {}, uint32_t imageMemoryBarrierCount = {}, const ImageMemoryBarrier* pImageMemoryBarriers = {}) const { vkCmdPipelineBarrier(this->handle, std::bit_cast<VkPipelineStageFlags>(srcStageMask), std::bit_cast<VkPipelineStageFlags>(dstStageMask), std::bit_cast<VkDependencyFlags>(dependencyFlags), memoryBarrierCount, std::bit_cast<const VkMemoryBarrier*>(pMemoryBarriers), bufferMemoryBarrierCount, std::bit_cast<const VkBufferMemoryBarrier*>(pBufferMemoryBarriers), imageMemoryBarrierCount, std::bit_cast<const VkImageMemoryBarrier*>(pImageMemoryBarriers)); }
  void cmdBeginQuery(QueryPool queryPool, uint32_t query, QueryControlFlags flags = {}) const { vkCmdBeginQuery(this->handle, std::bit_cast<VkQueryPool>(queryPool), query, std::bit_cast<VkQueryControlFlags>(flags)); }
  void cmdEndQuery(QueryPool queryPool, uint32_t query) const { vkCmdEndQuery(this->handle, std::bit_cast<VkQueryPool>(queryPool), query); }
#if VK_EXT_conditional_rendering
  void cmdBeginConditionalRenderingEXT(const ConditionalRenderingBeginInfoEXT& conditionalRenderingBegin) const { vkCmdBeginConditionalRenderingEXT(this->handle, std::bit_cast<const VkConditionalRenderingBeginInfoEXT*>(&conditionalRenderingBegin)); }
  void cmdEndConditionalRenderingEXT() const { vkCmdEndConditionalRenderingEXT(this->handle); }
#endif // VK_EXT_conditional_rendering
  void cmdResetQueryPool(QueryPool queryPool, uint32_t firstQuery, uint32_t queryCount) const { vkCmdResetQueryPool(this->handle, std::bit_cast<VkQueryPool>(queryPool), firstQuery, queryCount); }
  void cmdWriteTimestamp(PipelineStageFlagBits pipelineStage, QueryPool queryPool, uint32_t query) const { vkCmdWriteTimestamp(this->handle, std::bit_cast<VkPipelineStageFlagBits>(pipelineStage), std::bit_cast<VkQueryPool>(queryPool), query); }
  void cmdCopyQueryPoolResults(QueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, Buffer dstBuffer, DeviceSize dstOffset, DeviceSize stride, QueryResultFlags flags = {}) const { vkCmdCopyQueryPoolResults(this->handle, std::bit_cast<VkQueryPool>(queryPool), firstQuery, queryCount, std::bit_cast<VkBuffer>(dstBuffer), dstOffset, stride, std::bit_cast<VkQueryResultFlags>(flags)); }
  void cmdPushConstants(PipelineLayout layout, ShaderStageFlags stageFlags, uint32_t offset, uint32_t size, const void* pValues) const { vkCmdPushConstants(this->handle, std::bit_cast<VkPipelineLayout>(layout), std::bit_cast<VkShaderStageFlags>(stageFlags), offset, size, pValues); }
  void cmdBeginRenderPass(const RenderPassBeginInfo& renderPassBegin, SubpassContents contents) const { vkCmdBeginRenderPass(this->handle, std::bit_cast<const VkRenderPassBeginInfo*>(&renderPassBegin), std::bit_cast<VkSubpassContents>(contents)); }
  void cmdNextSubpass(SubpassContents contents) const { vkCmdNextSubpass(this->handle, std::bit_cast<VkSubpassContents>(contents)); }
  void cmdEndRenderPass() const { vkCmdEndRenderPass(this->handle); }
  void cmdExecuteCommands(uint32_t commandBufferCount, const CommandBuffer* pCommandBuffers) const { vkCmdExecuteCommands(this->handle, commandBufferCount, std::bit_cast<const VkCommandBuffer*>(pCommandBuffers)); }
#if VK_EXT_debug_marker
  void cmdDebugMarkerBeginEXT(const DebugMarkerMarkerInfoEXT& markerInfo) const { vkCmdDebugMarkerBeginEXT(this->handle, std::bit_cast<const VkDebugMarkerMarkerInfoEXT*>(&markerInfo)); }
  void cmdDebugMarkerEndEXT() const { vkCmdDebugMarkerEndEXT(this->handle); }
  void cmdDebugMarkerInsertEXT(const DebugMarkerMarkerInfoEXT& markerInfo) const { vkCmdDebugMarkerInsertEXT(this->handle, std::bit_cast<const VkDebugMarkerMarkerInfoEXT*>(&markerInfo)); }
#endif // VK_EXT_debug_marker
#if VK_NV_device_generated_commands
  void cmdExecuteGeneratedCommandsNV(Bool32 isPreprocessed, const GeneratedCommandsInfoNV& generatedCommandsInfo) const { vkCmdExecuteGeneratedCommandsNV(this->handle, isPreprocessed, std::bit_cast<const VkGeneratedCommandsInfoNV*>(&generatedCommandsInfo)); }
  void cmdPreprocessGeneratedCommandsNV(const GeneratedCommandsInfoNV& generatedCommandsInfo) const { vkCmdPreprocessGeneratedCommandsNV(this->handle, std::bit_cast<const VkGeneratedCommandsInfoNV*>(&generatedCommandsInfo)); }
  void cmdBindPipelineShaderGroupNV(PipelineBindPoint pipelineBindPoint, Pipeline pipeline, uint32_t groupIndex) const { vkCmdBindPipelineShaderGroupNV(this->handle, std::bit_cast<VkPipelineBindPoint>(pipelineBindPoint), std::bit_cast<VkPipeline>(pipeline), groupIndex); }
#endif // VK_NV_device_generated_commands
#if VK_EXT_device_generated_commands
  void cmdExecuteGeneratedCommandsEXT(Bool32 isPreprocessed, const GeneratedCommandsInfoEXT& generatedCommandsInfo) const { vkCmdExecuteGeneratedCommandsEXT(this->handle, isPreprocessed, std::bit_cast<const VkGeneratedCommandsInfoEXT*>(&generatedCommandsInfo)); }
  void cmdPreprocessGeneratedCommandsEXT(const GeneratedCommandsInfoEXT& generatedCommandsInfo, CommandBuffer stateCommandBuffer) const { vkCmdPreprocessGeneratedCommandsEXT(this->handle, std::bit_cast<const VkGeneratedCommandsInfoEXT*>(&generatedCommandsInfo), std::bit_cast<VkCommandBuffer>(stateCommandBuffer)); }
#endif // VK_EXT_device_generated_commands
#if VK_VERSION_1_4
  void cmdPushDescriptorSet(PipelineBindPoint pipelineBindPoint, PipelineLayout layout, uint32_t set, uint32_t descriptorWriteCount, const WriteDescriptorSet* pDescriptorWrites) const { vkCmdPushDescriptorSet(this->handle, std::bit_cast<VkPipelineBindPoint>(pipelineBindPoint), std::bit_cast<VkPipelineLayout>(layout), set, descriptorWriteCount, std::bit_cast<const VkWriteDescriptorSet*>(pDescriptorWrites)); }
#endif // VK_VERSION_1_4
#if VK_KHR_push_descriptor
  void cmdPushDescriptorSetKHR(PipelineBindPoint pipelineBindPoint, PipelineLayout layout, uint32_t set, uint32_t descriptorWriteCount, const WriteDescriptorSet* pDescriptorWrites) const { vkCmdPushDescriptorSetKHR(this->handle, std::bit_cast<VkPipelineBindPoint>(pipelineBindPoint), std::bit_cast<VkPipelineLayout>(layout), set, descriptorWriteCount, std::bit_cast<const VkWriteDescriptorSet*>(pDescriptorWrites)); }
#endif // VK_KHR_push_descriptor
#if VK_VERSION_1_1
  void cmdSetDeviceMask(uint32_t deviceMask) const { vkCmdSetDeviceMask(this->handle, deviceMask); }
#endif // VK_VERSION_1_1
#if VK_KHR_device_group
  void cmdSetDeviceMaskKHR(uint32_t deviceMask) const { vkCmdSetDeviceMaskKHR(this->handle, deviceMask); }
#endif // VK_KHR_device_group
#if VK_VERSION_1_1
  void cmdDispatchBase(uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ) const { vkCmdDispatchBase(this->handle, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ); }
#endif // VK_VERSION_1_1
#if VK_KHR_device_group
  void cmdDispatchBaseKHR(uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ) const { vkCmdDispatchBaseKHR(this->handle, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ); }
#endif // VK_KHR_device_group
#if VK_VERSION_1_4
  void cmdPushDescriptorSetWithTemplate(DescriptorUpdateTemplate descriptorUpdateTemplate, PipelineLayout layout, uint32_t set, const void* pData) const { vkCmdPushDescriptorSetWithTemplate(this->handle, std::bit_cast<VkDescriptorUpdateTemplate>(descriptorUpdateTemplate), std::bit_cast<VkPipelineLayout>(layout), set, pData); }
#endif // VK_VERSION_1_4
#if VK_KHR_descriptor_update_template
  void cmdPushDescriptorSetWithTemplateKHR(DescriptorUpdateTemplate descriptorUpdateTemplate, PipelineLayout layout, uint32_t set, const void* pData) const { vkCmdPushDescriptorSetWithTemplateKHR(this->handle, std::bit_cast<VkDescriptorUpdateTemplate>(descriptorUpdateTemplate), std::bit_cast<VkPipelineLayout>(layout), set, pData); }
#endif // VK_KHR_descriptor_update_template
#if VK_NV_clip_space_w_scaling
  void cmdSetViewportWScalingNV(uint32_t firstViewport, uint32_t viewportCount, const ViewportWScalingNV* pViewportWScalings) const { vkCmdSetViewportWScalingNV(this->handle, firstViewport, viewportCount, std::bit_cast<const VkViewportWScalingNV*>(pViewportWScalings)); }
#endif // VK_NV_clip_space_w_scaling
#if VK_EXT_discard_rectangles
  void cmdSetDiscardRectangleEXT(uint32_t firstDiscardRectangle, uint32_t discardRectangleCount, const Rect2D* pDiscardRectangles) const { vkCmdSetDiscardRectangleEXT(this->handle, firstDiscardRectangle, discardRectangleCount, std::bit_cast<const VkRect2D*>(pDiscardRectangles)); }
  void cmdSetDiscardRectangleEnableEXT(Bool32 discardRectangleEnable) const { vkCmdSetDiscardRectangleEnableEXT(this->handle, discardRectangleEnable); }
  void cmdSetDiscardRectangleModeEXT(DiscardRectangleModeEXT discardRectangleMode) const { vkCmdSetDiscardRectangleModeEXT(this->handle, std::bit_cast<VkDiscardRectangleModeEXT>(discardRectangleMode)); }
#endif // VK_EXT_discard_rectangles
#if VK_EXT_sample_locations
  void cmdSetSampleLocationsEXT(const SampleLocationsInfoEXT& sampleLocationsInfo) const { vkCmdSetSampleLocationsEXT(this->handle, std::bit_cast<const VkSampleLocationsInfoEXT*>(&sampleLocationsInfo)); }
#endif // VK_EXT_sample_locations
#if VK_EXT_debug_utils
  void cmdBeginDebugUtilsLabelEXT(const DebugUtilsLabelEXT& labelInfo) const { vkCmdBeginDebugUtilsLabelEXT(this->handle, std::bit_cast<const VkDebugUtilsLabelEXT*>(&labelInfo)); }
  void cmdEndDebugUtilsLabelEXT() const { vkCmdEndDebugUtilsLabelEXT(this->handle); }
  void cmdInsertDebugUtilsLabelEXT(const DebugUtilsLabelEXT& labelInfo) const { vkCmdInsertDebugUtilsLabelEXT(this->handle, std::bit_cast<const VkDebugUtilsLabelEXT*>(&labelInfo)); }
#endif // VK_EXT_debug_utils
#if VK_AMD_buffer_marker
  void cmdWriteBufferMarkerAMD(PipelineStageFlagBits pipelineStage, Buffer dstBuffer, DeviceSize dstOffset, uint32_t marker) const { vkCmdWriteBufferMarkerAMD(this->handle, std::bit_cast<VkPipelineStageFlagBits>(pipelineStage), std::bit_cast<VkBuffer>(dstBuffer), dstOffset, marker); }
#endif // VK_AMD_buffer_marker
#if VK_VERSION_1_2
  void cmdBeginRenderPass2(const RenderPassBeginInfo& renderPassBegin, const SubpassBeginInfo& subpassBeginInfo) const { vkCmdBeginRenderPass2(this->handle, std::bit_cast<const VkRenderPassBeginInfo*>(&renderPassBegin), std::bit_cast<const VkSubpassBeginInfo*>(&subpassBeginInfo)); }
#endif // VK_VERSION_1_2
#if VK_KHR_create_renderpass2
  void cmdBeginRenderPass2KHR(const RenderPassBeginInfo& renderPassBegin, const SubpassBeginInfo& subpassBeginInfo) const { vkCmdBeginRenderPass2KHR(this->handle, std::bit_cast<const VkRenderPassBeginInfo*>(&renderPassBegin), std::bit_cast<const VkSubpassBeginInfo*>(&subpassBeginInfo)); }
#endif // VK_KHR_create_renderpass2
#if VK_VERSION_1_2
  void cmdNextSubpass2(const SubpassBeginInfo& subpassBeginInfo, const SubpassEndInfo& subpassEndInfo) const { vkCmdNextSubpass2(this->handle, std::bit_cast<const VkSubpassBeginInfo*>(&subpassBeginInfo), std::bit_cast<const VkSubpassEndInfo*>(&subpassEndInfo)); }
#endif // VK_VERSION_1_2
#if VK_KHR_create_renderpass2
  void cmdNextSubpass2KHR(const SubpassBeginInfo& subpassBeginInfo, const SubpassEndInfo& subpassEndInfo) const { vkCmdNextSubpass2KHR(this->handle, std::bit_cast<const VkSubpassBeginInfo*>(&subpassBeginInfo), std::bit_cast<const VkSubpassEndInfo*>(&subpassEndInfo)); }
#endif // VK_KHR_create_renderpass2
#if VK_VERSION_1_2
  void cmdEndRenderPass2(const SubpassEndInfo& subpassEndInfo) const { vkCmdEndRenderPass2(this->handle, std::bit_cast<const VkSubpassEndInfo*>(&subpassEndInfo)); }
#endif // VK_VERSION_1_2
#if VK_KHR_create_renderpass2
  void cmdEndRenderPass2KHR(const SubpassEndInfo& subpassEndInfo) const { vkCmdEndRenderPass2KHR(this->handle, std::bit_cast<const VkSubpassEndInfo*>(&subpassEndInfo)); }
#endif // VK_KHR_create_renderpass2
#if VK_VERSION_1_2
  void cmdDrawIndirectCount(Buffer buffer, DeviceSize offset, Buffer countBuffer, DeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) const { vkCmdDrawIndirectCount(this->handle, std::bit_cast<VkBuffer>(buffer), offset, std::bit_cast<VkBuffer>(countBuffer), countBufferOffset, maxDrawCount, stride); }
#endif // VK_VERSION_1_2
#if VK_KHR_draw_indirect_count
  void cmdDrawIndirectCountKHR(Buffer buffer, DeviceSize offset, Buffer countBuffer, DeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) const { vkCmdDrawIndirectCountKHR(this->handle, std::bit_cast<VkBuffer>(buffer), offset, std::bit_cast<VkBuffer>(countBuffer), countBufferOffset, maxDrawCount, stride); }
#endif // VK_KHR_draw_indirect_count
#if VK_AMD_draw_indirect_count
  void cmdDrawIndirectCountAMD(Buffer buffer, DeviceSize offset, Buffer countBuffer, DeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) const { vkCmdDrawIndirectCountAMD(this->handle, std::bit_cast<VkBuffer>(buffer), offset, std::bit_cast<VkBuffer>(countBuffer), countBufferOffset, maxDrawCount, stride); }
#endif // VK_AMD_draw_indirect_count
#if VK_VERSION_1_2
  void cmdDrawIndexedIndirectCount(Buffer buffer, DeviceSize offset, Buffer countBuffer, DeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) const { vkCmdDrawIndexedIndirectCount(this->handle, std::bit_cast<VkBuffer>(buffer), offset, std::bit_cast<VkBuffer>(countBuffer), countBufferOffset, maxDrawCount, stride); }
#endif // VK_VERSION_1_2
#if VK_KHR_draw_indirect_count
  void cmdDrawIndexedIndirectCountKHR(Buffer buffer, DeviceSize offset, Buffer countBuffer, DeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) const { vkCmdDrawIndexedIndirectCountKHR(this->handle, std::bit_cast<VkBuffer>(buffer), offset, std::bit_cast<VkBuffer>(countBuffer), countBufferOffset, maxDrawCount, stride); }
#endif // VK_KHR_draw_indirect_count
#if VK_AMD_draw_indirect_count
  void cmdDrawIndexedIndirectCountAMD(Buffer buffer, DeviceSize offset, Buffer countBuffer, DeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) const { vkCmdDrawIndexedIndirectCountAMD(this->handle, std::bit_cast<VkBuffer>(buffer), offset, std::bit_cast<VkBuffer>(countBuffer), countBufferOffset, maxDrawCount, stride); }
#endif // VK_AMD_draw_indirect_count
#if VK_NV_device_diagnostic_checkpoints
  void cmdSetCheckpointNV(const void* pCheckpointMarker) const { vkCmdSetCheckpointNV(this->handle, pCheckpointMarker); }
#endif // VK_NV_device_diagnostic_checkpoints
#if VK_EXT_transform_feedback
  void cmdBindTransformFeedbackBuffersEXT(uint32_t firstBinding, uint32_t bindingCount, const Buffer* pBuffers, const DeviceSize* pOffsets, const DeviceSize* pSizes = {}) const { vkCmdBindTransformFeedbackBuffersEXT(this->handle, firstBinding, bindingCount, std::bit_cast<const VkBuffer*>(pBuffers), pOffsets, pSizes); }
  void cmdBeginTransformFeedbackEXT(uint32_t firstCounterBuffer, uint32_t counterBufferCount = {}, const Buffer* pCounterBuffers = {}, const DeviceSize* pCounterBufferOffsets = {}) const { vkCmdBeginTransformFeedbackEXT(this->handle, firstCounterBuffer, counterBufferCount, std::bit_cast<const VkBuffer*>(pCounterBuffers), pCounterBufferOffsets); }
  void cmdEndTransformFeedbackEXT(uint32_t firstCounterBuffer, uint32_t counterBufferCount = {}, const Buffer* pCounterBuffers = {}, const DeviceSize* pCounterBufferOffsets = {}) const { vkCmdEndTransformFeedbackEXT(this->handle, firstCounterBuffer, counterBufferCount, std::bit_cast<const VkBuffer*>(pCounterBuffers), pCounterBufferOffsets); }
  void cmdBeginQueryIndexedEXT(QueryPool queryPool, uint32_t query, QueryControlFlags flags, uint32_t index) const { vkCmdBeginQueryIndexedEXT(this->handle, std::bit_cast<VkQueryPool>(queryPool), query, std::bit_cast<VkQueryControlFlags>(flags), index); }
  void cmdEndQueryIndexedEXT(QueryPool queryPool, uint32_t query, uint32_t index) const { vkCmdEndQueryIndexedEXT(this->handle, std::bit_cast<VkQueryPool>(queryPool), query, index); }
  void cmdDrawIndirectByteCountEXT(uint32_t instanceCount, uint32_t firstInstance, Buffer counterBuffer, DeviceSize counterBufferOffset, uint32_t counterOffset, uint32_t vertexStride) const { vkCmdDrawIndirectByteCountEXT(this->handle, instanceCount, firstInstance, std::bit_cast<VkBuffer>(counterBuffer), counterBufferOffset, counterOffset, vertexStride); }
#endif // VK_EXT_transform_feedback
#if VK_NV_scissor_exclusive
  void cmdSetExclusiveScissorNV(uint32_t firstExclusiveScissor, uint32_t exclusiveScissorCount, const Rect2D* pExclusiveScissors) const { vkCmdSetExclusiveScissorNV(this->handle, firstExclusiveScissor, exclusiveScissorCount, std::bit_cast<const VkRect2D*>(pExclusiveScissors)); }
  void cmdSetExclusiveScissorEnableNV(uint32_t firstExclusiveScissor, uint32_t exclusiveScissorCount, const Bool32* pExclusiveScissorEnables) const { vkCmdSetExclusiveScissorEnableNV(this->handle, firstExclusiveScissor, exclusiveScissorCount, pExclusiveScissorEnables); }
#endif // VK_NV_scissor_exclusive
#if VK_NV_shading_rate_image
  void cmdBindShadingRateImageNV(ImageView imageView, ImageLayout imageLayout) const { vkCmdBindShadingRateImageNV(this->handle, std::bit_cast<VkImageView>(imageView), std::bit_cast<VkImageLayout>(imageLayout)); }
  void cmdSetViewportShadingRatePaletteNV(uint32_t firstViewport, uint32_t viewportCount, const ShadingRatePaletteNV* pShadingRatePalettes) const { vkCmdSetViewportShadingRatePaletteNV(this->handle, firstViewport, viewportCount, std::bit_cast<const VkShadingRatePaletteNV*>(pShadingRatePalettes)); }
  void cmdSetCoarseSampleOrderNV(CoarseSampleOrderTypeNV sampleOrderType, uint32_t customSampleOrderCount = {}, const CoarseSampleOrderCustomNV* pCustomSampleOrders = {}) const { vkCmdSetCoarseSampleOrderNV(this->handle, std::bit_cast<VkCoarseSampleOrderTypeNV>(sampleOrderType), customSampleOrderCount, std::bit_cast<const VkCoarseSampleOrderCustomNV*>(pCustomSampleOrders)); }
#endif // VK_NV_shading_rate_image
#if VK_NV_mesh_shader
  void cmdDrawMeshTasksNV(uint32_t taskCount, uint32_t firstTask) const { vkCmdDrawMeshTasksNV(this->handle, taskCount, firstTask); }
  void cmdDrawMeshTasksIndirectNV(Buffer buffer, DeviceSize offset, uint32_t drawCount, uint32_t stride) const { vkCmdDrawMeshTasksIndirectNV(this->handle, std::bit_cast<VkBuffer>(buffer), offset, drawCount, stride); }
  void cmdDrawMeshTasksIndirectCountNV(Buffer buffer, DeviceSize offset, Buffer countBuffer, DeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) const { vkCmdDrawMeshTasksIndirectCountNV(this->handle, std::bit_cast<VkBuffer>(buffer), offset, std::bit_cast<VkBuffer>(countBuffer), countBufferOffset, maxDrawCount, stride); }
#endif // VK_NV_mesh_shader
#if VK_EXT_mesh_shader
  void cmdDrawMeshTasksEXT(uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ) const { vkCmdDrawMeshTasksEXT(this->handle, groupCountX, groupCountY, groupCountZ); }
  void cmdDrawMeshTasksIndirectEXT(Buffer buffer, DeviceSize offset, uint32_t drawCount, uint32_t stride) const { vkCmdDrawMeshTasksIndirectEXT(this->handle, std::bit_cast<VkBuffer>(buffer), offset, drawCount, stride); }
  void cmdDrawMeshTasksIndirectCountEXT(Buffer buffer, DeviceSize offset, Buffer countBuffer, DeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) const { vkCmdDrawMeshTasksIndirectCountEXT(this->handle, std::bit_cast<VkBuffer>(buffer), offset, std::bit_cast<VkBuffer>(countBuffer), countBufferOffset, maxDrawCount, stride); }
#endif // VK_EXT_mesh_shader
#if VK_HUAWEI_invocation_mask
  void cmdBindInvocationMaskHUAWEI(ImageView imageView, ImageLayout imageLayout) const { vkCmdBindInvocationMaskHUAWEI(this->handle, std::bit_cast<VkImageView>(imageView), std::bit_cast<VkImageLayout>(imageLayout)); }
#endif // VK_HUAWEI_invocation_mask
#if VK_KHR_acceleration_structure
  void cmdCopyAccelerationStructureKHR(const CopyAccelerationStructureInfoKHR& info) const { vkCmdCopyAccelerationStructureKHR(this->handle, std::bit_cast<const VkCopyAccelerationStructureInfoKHR*>(&info)); }
  void cmdCopyAccelerationStructureToMemoryKHR(const CopyAccelerationStructureToMemoryInfoKHR& info) const { vkCmdCopyAccelerationStructureToMemoryKHR(this->handle, std::bit_cast<const VkCopyAccelerationStructureToMemoryInfoKHR*>(&info)); }
  void cmdCopyMemoryToAccelerationStructureKHR(const CopyMemoryToAccelerationStructureInfoKHR& info) const { vkCmdCopyMemoryToAccelerationStructureKHR(this->handle, std::bit_cast<const VkCopyMemoryToAccelerationStructureInfoKHR*>(&info)); }
  void cmdWriteAccelerationStructuresPropertiesKHR(uint32_t accelerationStructureCount, const AccelerationStructureKHR* pAccelerationStructures, QueryType queryType, QueryPool queryPool, uint32_t firstQuery) const { vkCmdWriteAccelerationStructuresPropertiesKHR(this->handle, accelerationStructureCount, std::bit_cast<const VkAccelerationStructureKHR*>(pAccelerationStructures), std::bit_cast<VkQueryType>(queryType), std::bit_cast<VkQueryPool>(queryPool), firstQuery); }
#endif // VK_KHR_acceleration_structure
#if VK_KHR_ray_tracing_pipeline
  void cmdTraceRaysKHR(const StridedDeviceAddressRegionKHR& raygenShaderBindingTable, const StridedDeviceAddressRegionKHR& missShaderBindingTable, const StridedDeviceAddressRegionKHR& hitShaderBindingTable, const StridedDeviceAddressRegionKHR& callableShaderBindingTable, uint32_t width, uint32_t height, uint32_t depth) const { vkCmdTraceRaysKHR(this->handle, std::bit_cast<const VkStridedDeviceAddressRegionKHR*>(&raygenShaderBindingTable), std::bit_cast<const VkStridedDeviceAddressRegionKHR*>(&missShaderBindingTable), std::bit_cast<const VkStridedDeviceAddressRegionKHR*>(&hitShaderBindingTable), std::bit_cast<const VkStridedDeviceAddressRegionKHR*>(&callableShaderBindingTable), width, height, depth); }
  void cmdTraceRaysIndirectKHR(const StridedDeviceAddressRegionKHR& raygenShaderBindingTable, const StridedDeviceAddressRegionKHR& missShaderBindingTable, const StridedDeviceAddressRegionKHR& hitShaderBindingTable, const StridedDeviceAddressRegionKHR& callableShaderBindingTable, DeviceAddress indirectDeviceAddress) const { vkCmdTraceRaysIndirectKHR(this->handle, std::bit_cast<const VkStridedDeviceAddressRegionKHR*>(&raygenShaderBindingTable), std::bit_cast<const VkStridedDeviceAddressRegionKHR*>(&missShaderBindingTable), std::bit_cast<const VkStridedDeviceAddressRegionKHR*>(&hitShaderBindingTable), std::bit_cast<const VkStridedDeviceAddressRegionKHR*>(&callableShaderBindingTable), indirectDeviceAddress); }
#endif // VK_KHR_ray_tracing_pipeline
#if VK_KHR_ray_tracing_maintenance1
  void cmdTraceRaysIndirect2KHR(DeviceAddress indirectDeviceAddress) const { vkCmdTraceRaysIndirect2KHR(this->handle, indirectDeviceAddress); }
#endif // VK_KHR_ray_tracing_maintenance1
#if VK_NV_cluster_acceleration_structure
  void cmdBuildClusterAccelerationStructureIndirectNV(const ClusterAccelerationStructureCommandsInfoNV& commandInfos) const { vkCmdBuildClusterAccelerationStructureIndirectNV(this->handle, std::bit_cast<const VkClusterAccelerationStructureCommandsInfoNV*>(&commandInfos)); }
#endif // VK_NV_cluster_acceleration_structure
#if VK_KHR_ray_tracing_pipeline
  void cmdSetRayTracingPipelineStackSizeKHR(uint32_t pipelineStackSize) const { vkCmdSetRayTracingPipelineStackSizeKHR(this->handle, pipelineStackSize); }
#endif // VK_KHR_ray_tracing_pipeline
#if VK_INTEL_performance_query
  Result cmdSetPerformanceMarkerINTEL(const PerformanceMarkerInfoINTEL& markerInfo) const { return Result(vkCmdSetPerformanceMarkerINTEL(this->handle, std::bit_cast<const VkPerformanceMarkerInfoINTEL*>(&markerInfo))); }
  Result cmdSetPerformanceStreamMarkerINTEL(const PerformanceStreamMarkerInfoINTEL& markerInfo) const { return Result(vkCmdSetPerformanceStreamMarkerINTEL(this->handle, std::bit_cast<const VkPerformanceStreamMarkerInfoINTEL*>(&markerInfo))); }
  Result cmdSetPerformanceOverrideINTEL(const PerformanceOverrideInfoINTEL& overrideInfo) const { return Result(vkCmdSetPerformanceOverrideINTEL(this->handle, std::bit_cast<const VkPerformanceOverrideInfoINTEL*>(&overrideInfo))); }
#endif // VK_INTEL_performance_query
#if VK_VERSION_1_4
  void cmdSetLineStipple(uint32_t lineStippleFactor, uint16_t lineStipplePattern) const { vkCmdSetLineStipple(this->handle, lineStippleFactor, lineStipplePattern); }
#endif // VK_VERSION_1_4
#if VK_KHR_line_rasterization
  void cmdSetLineStippleKHR(uint32_t lineStippleFactor, uint16_t lineStipplePattern) const { vkCmdSetLineStippleKHR(this->handle, lineStippleFactor, lineStipplePattern); }
#endif // VK_KHR_line_rasterization
#if VK_EXT_line_rasterization
  void cmdSetLineStippleEXT(uint32_t lineStippleFactor, uint16_t lineStipplePattern) const { vkCmdSetLineStippleEXT(this->handle, lineStippleFactor, lineStipplePattern); }
#endif // VK_EXT_line_rasterization
#if VK_KHR_acceleration_structure
  void cmdBuildAccelerationStructuresKHR(uint32_t infoCount, const AccelerationStructureBuildGeometryInfoKHR* pInfos, const AccelerationStructureBuildRangeInfoKHR* const* ppBuildRangeInfos) const { vkCmdBuildAccelerationStructuresKHR(this->handle, infoCount, std::bit_cast<const VkAccelerationStructureBuildGeometryInfoKHR*>(pInfos), std::bit_cast<const VkAccelerationStructureBuildRangeInfoKHR* const*>(ppBuildRangeInfos)); }
  void cmdBuildAccelerationStructuresIndirectKHR(uint32_t infoCount, const AccelerationStructureBuildGeometryInfoKHR* pInfos, const DeviceAddress* pIndirectDeviceAddresses, const uint32_t* pIndirectStrides, const uint32_t* const* ppMaxPrimitiveCounts) const { vkCmdBuildAccelerationStructuresIndirectKHR(this->handle, infoCount, std::bit_cast<const VkAccelerationStructureBuildGeometryInfoKHR*>(pInfos), pIndirectDeviceAddresses, pIndirectStrides, ppMaxPrimitiveCounts); }
#endif // VK_KHR_acceleration_structure
#if VK_VERSION_1_3
  void cmdSetCullMode(CullModeFlags cullMode = {}) const { vkCmdSetCullMode(this->handle, std::bit_cast<VkCullModeFlags>(cullMode)); }
#endif // VK_VERSION_1_3
#if VK_EXT_extended_dynamic_state
  void cmdSetCullModeEXT(CullModeFlags cullMode = {}) const { vkCmdSetCullModeEXT(this->handle, std::bit_cast<VkCullModeFlags>(cullMode)); }
#endif // VK_EXT_extended_dynamic_state
#if VK_VERSION_1_3
  void cmdSetFrontFace(FrontFace frontFace) const { vkCmdSetFrontFace(this->handle, std::bit_cast<VkFrontFace>(frontFace)); }
#endif // VK_VERSION_1_3
#if VK_EXT_extended_dynamic_state
  void cmdSetFrontFaceEXT(FrontFace frontFace) const { vkCmdSetFrontFaceEXT(this->handle, std::bit_cast<VkFrontFace>(frontFace)); }
#endif // VK_EXT_extended_dynamic_state
#if VK_VERSION_1_3
  void cmdSetPrimitiveTopology(PrimitiveTopology primitiveTopology) const { vkCmdSetPrimitiveTopology(this->handle, std::bit_cast<VkPrimitiveTopology>(primitiveTopology)); }
#endif // VK_VERSION_1_3
#if VK_EXT_extended_dynamic_state
  void cmdSetPrimitiveTopologyEXT(PrimitiveTopology primitiveTopology) const { vkCmdSetPrimitiveTopologyEXT(this->handle, std::bit_cast<VkPrimitiveTopology>(primitiveTopology)); }
#endif // VK_EXT_extended_dynamic_state
#if VK_VERSION_1_3
  void cmdSetViewportWithCount(uint32_t viewportCount, const Viewport* pViewports) const { vkCmdSetViewportWithCount(this->handle, viewportCount, std::bit_cast<const VkViewport*>(pViewports)); }
#endif // VK_VERSION_1_3
#if VK_EXT_extended_dynamic_state
  void cmdSetViewportWithCountEXT(uint32_t viewportCount, const Viewport* pViewports) const { vkCmdSetViewportWithCountEXT(this->handle, viewportCount, std::bit_cast<const VkViewport*>(pViewports)); }
#endif // VK_EXT_extended_dynamic_state
#if VK_VERSION_1_3
  void cmdSetScissorWithCount(uint32_t scissorCount, const Rect2D* pScissors) const { vkCmdSetScissorWithCount(this->handle, scissorCount, std::bit_cast<const VkRect2D*>(pScissors)); }
#endif // VK_VERSION_1_3
#if VK_EXT_extended_dynamic_state
  void cmdSetScissorWithCountEXT(uint32_t scissorCount, const Rect2D* pScissors) const { vkCmdSetScissorWithCountEXT(this->handle, scissorCount, std::bit_cast<const VkRect2D*>(pScissors)); }
#endif // VK_EXT_extended_dynamic_state
#if VK_VERSION_1_4
  void cmdBindIndexBuffer2(Buffer buffer, DeviceSize offset, DeviceSize size, IndexType indexType) const { vkCmdBindIndexBuffer2(this->handle, std::bit_cast<VkBuffer>(buffer), offset, size, std::bit_cast<VkIndexType>(indexType)); }
#endif // VK_VERSION_1_4
#if VK_KHR_maintenance5
  void cmdBindIndexBuffer2KHR(Buffer buffer, DeviceSize offset, DeviceSize size, IndexType indexType) const { vkCmdBindIndexBuffer2KHR(this->handle, std::bit_cast<VkBuffer>(buffer), offset, size, std::bit_cast<VkIndexType>(indexType)); }
#endif // VK_KHR_maintenance5
#if VK_VERSION_1_3
  void cmdBindVertexBuffers2(uint32_t firstBinding, uint32_t bindingCount, const Buffer* pBuffers, const DeviceSize* pOffsets, const DeviceSize* pSizes = {}, const DeviceSize* pStrides = {}) const { vkCmdBindVertexBuffers2(this->handle, firstBinding, bindingCount, std::bit_cast<const VkBuffer*>(pBuffers), pOffsets, pSizes, pStrides); }
#endif // VK_VERSION_1_3
#if VK_EXT_extended_dynamic_state
  void cmdBindVertexBuffers2EXT(uint32_t firstBinding, uint32_t bindingCount, const Buffer* pBuffers, const DeviceSize* pOffsets, const DeviceSize* pSizes = {}, const DeviceSize* pStrides = {}) const { vkCmdBindVertexBuffers2EXT(this->handle, firstBinding, bindingCount, std::bit_cast<const VkBuffer*>(pBuffers), pOffsets, pSizes, pStrides); }
#endif // VK_EXT_extended_dynamic_state
#if VK_VERSION_1_3
  void cmdSetDepthTestEnable(Bool32 depthTestEnable) const { vkCmdSetDepthTestEnable(this->handle, depthTestEnable); }
#endif // VK_VERSION_1_3
#if VK_EXT_extended_dynamic_state
  void cmdSetDepthTestEnableEXT(Bool32 depthTestEnable) const { vkCmdSetDepthTestEnableEXT(this->handle, depthTestEnable); }
#endif // VK_EXT_extended_dynamic_state
#if VK_VERSION_1_3
  void cmdSetDepthWriteEnable(Bool32 depthWriteEnable) const { vkCmdSetDepthWriteEnable(this->handle, depthWriteEnable); }
#endif // VK_VERSION_1_3
#if VK_EXT_extended_dynamic_state
  void cmdSetDepthWriteEnableEXT(Bool32 depthWriteEnable) const { vkCmdSetDepthWriteEnableEXT(this->handle, depthWriteEnable); }
#endif // VK_EXT_extended_dynamic_state
#if VK_VERSION_1_3
  void cmdSetDepthCompareOp(CompareOp depthCompareOp) const { vkCmdSetDepthCompareOp(this->handle, std::bit_cast<VkCompareOp>(depthCompareOp)); }
#endif // VK_VERSION_1_3
#if VK_EXT_extended_dynamic_state
  void cmdSetDepthCompareOpEXT(CompareOp depthCompareOp) const { vkCmdSetDepthCompareOpEXT(this->handle, std::bit_cast<VkCompareOp>(depthCompareOp)); }
#endif // VK_EXT_extended_dynamic_state
#if VK_VERSION_1_3
  void cmdSetDepthBoundsTestEnable(Bool32 depthBoundsTestEnable) const { vkCmdSetDepthBoundsTestEnable(this->handle, depthBoundsTestEnable); }
#endif // VK_VERSION_1_3
#if VK_EXT_extended_dynamic_state
  void cmdSetDepthBoundsTestEnableEXT(Bool32 depthBoundsTestEnable) const { vkCmdSetDepthBoundsTestEnableEXT(this->handle, depthBoundsTestEnable); }
#endif // VK_EXT_extended_dynamic_state
#if VK_VERSION_1_3
  void cmdSetStencilTestEnable(Bool32 stencilTestEnable) const { vkCmdSetStencilTestEnable(this->handle, stencilTestEnable); }
#endif // VK_VERSION_1_3
#if VK_EXT_extended_dynamic_state
  void cmdSetStencilTestEnableEXT(Bool32 stencilTestEnable) const { vkCmdSetStencilTestEnableEXT(this->handle, stencilTestEnable); }
#endif // VK_EXT_extended_dynamic_state
#if VK_VERSION_1_3
  void cmdSetStencilOp(StencilFaceFlags faceMask, StencilOp failOp, StencilOp passOp, StencilOp depthFailOp, CompareOp compareOp) const { vkCmdSetStencilOp(this->handle, std::bit_cast<VkStencilFaceFlags>(faceMask), std::bit_cast<VkStencilOp>(failOp), std::bit_cast<VkStencilOp>(passOp), std::bit_cast<VkStencilOp>(depthFailOp), std::bit_cast<VkCompareOp>(compareOp)); }
#endif // VK_VERSION_1_3
#if VK_EXT_extended_dynamic_state
  void cmdSetStencilOpEXT(StencilFaceFlags faceMask, StencilOp failOp, StencilOp passOp, StencilOp depthFailOp, CompareOp compareOp) const { vkCmdSetStencilOpEXT(this->handle, std::bit_cast<VkStencilFaceFlags>(faceMask), std::bit_cast<VkStencilOp>(failOp), std::bit_cast<VkStencilOp>(passOp), std::bit_cast<VkStencilOp>(depthFailOp), std::bit_cast<VkCompareOp>(compareOp)); }
#endif // VK_EXT_extended_dynamic_state
#if VK_EXT_extended_dynamic_state2
  void cmdSetPatchControlPointsEXT(uint32_t patchControlPoints) const { vkCmdSetPatchControlPointsEXT(this->handle, patchControlPoints); }
#endif // VK_EXT_extended_dynamic_state2
#if VK_VERSION_1_3
  void cmdSetRasterizerDiscardEnable(Bool32 rasterizerDiscardEnable) const { vkCmdSetRasterizerDiscardEnable(this->handle, rasterizerDiscardEnable); }
#endif // VK_VERSION_1_3
#if VK_EXT_extended_dynamic_state2
  void cmdSetRasterizerDiscardEnableEXT(Bool32 rasterizerDiscardEnable) const { vkCmdSetRasterizerDiscardEnableEXT(this->handle, rasterizerDiscardEnable); }
#endif // VK_EXT_extended_dynamic_state2
#if VK_VERSION_1_3
  void cmdSetDepthBiasEnable(Bool32 depthBiasEnable) const { vkCmdSetDepthBiasEnable(this->handle, depthBiasEnable); }
#endif // VK_VERSION_1_3
#if VK_EXT_extended_dynamic_state2
  void cmdSetDepthBiasEnableEXT(Bool32 depthBiasEnable) const { vkCmdSetDepthBiasEnableEXT(this->handle, depthBiasEnable); }
  void cmdSetLogicOpEXT(LogicOp logicOp) const { vkCmdSetLogicOpEXT(this->handle, std::bit_cast<VkLogicOp>(logicOp)); }
#endif // VK_EXT_extended_dynamic_state2
#if VK_VERSION_1_3
  void cmdSetPrimitiveRestartEnable(Bool32 primitiveRestartEnable) const { vkCmdSetPrimitiveRestartEnable(this->handle, primitiveRestartEnable); }
#endif // VK_VERSION_1_3
#if VK_EXT_extended_dynamic_state2
  void cmdSetPrimitiveRestartEnableEXT(Bool32 primitiveRestartEnable) const { vkCmdSetPrimitiveRestartEnableEXT(this->handle, primitiveRestartEnable); }
#endif // VK_EXT_extended_dynamic_state2
#if VK_EXT_extended_dynamic_state3
  void cmdSetTessellationDomainOriginEXT(TessellationDomainOrigin domainOrigin) const { vkCmdSetTessellationDomainOriginEXT(this->handle, std::bit_cast<VkTessellationDomainOrigin>(domainOrigin)); }
  void cmdSetDepthClampEnableEXT(Bool32 depthClampEnable) const { vkCmdSetDepthClampEnableEXT(this->handle, depthClampEnable); }
  void cmdSetPolygonModeEXT(PolygonMode polygonMode) const { vkCmdSetPolygonModeEXT(this->handle, std::bit_cast<VkPolygonMode>(polygonMode)); }
  void cmdSetRasterizationSamplesEXT(SampleCountFlagBits rasterizationSamples) const { vkCmdSetRasterizationSamplesEXT(this->handle, std::bit_cast<VkSampleCountFlagBits>(rasterizationSamples)); }
  void cmdSetSampleMaskEXT(SampleCountFlagBits samples, const SampleMask* pSampleMask) const { vkCmdSetSampleMaskEXT(this->handle, std::bit_cast<VkSampleCountFlagBits>(samples), pSampleMask); }
  void cmdSetAlphaToCoverageEnableEXT(Bool32 alphaToCoverageEnable) const { vkCmdSetAlphaToCoverageEnableEXT(this->handle, alphaToCoverageEnable); }
  void cmdSetAlphaToOneEnableEXT(Bool32 alphaToOneEnable) const { vkCmdSetAlphaToOneEnableEXT(this->handle, alphaToOneEnable); }
  void cmdSetLogicOpEnableEXT(Bool32 logicOpEnable) const { vkCmdSetLogicOpEnableEXT(this->handle, logicOpEnable); }
  void cmdSetColorBlendEnableEXT(uint32_t firstAttachment, uint32_t attachmentCount, const Bool32* pColorBlendEnables) const { vkCmdSetColorBlendEnableEXT(this->handle, firstAttachment, attachmentCount, pColorBlendEnables); }
  void cmdSetColorBlendEquationEXT(uint32_t firstAttachment, uint32_t attachmentCount, const ColorBlendEquationEXT* pColorBlendEquations) const { vkCmdSetColorBlendEquationEXT(this->handle, firstAttachment, attachmentCount, std::bit_cast<const VkColorBlendEquationEXT*>(pColorBlendEquations)); }
  void cmdSetColorWriteMaskEXT(uint32_t firstAttachment, uint32_t attachmentCount, const ColorComponentFlags* pColorWriteMasks) const { vkCmdSetColorWriteMaskEXT(this->handle, firstAttachment, attachmentCount, std::bit_cast<const VkColorComponentFlags*>(pColorWriteMasks)); }
  void cmdSetRasterizationStreamEXT(uint32_t rasterizationStream) const { vkCmdSetRasterizationStreamEXT(this->handle, rasterizationStream); }
  void cmdSetConservativeRasterizationModeEXT(ConservativeRasterizationModeEXT conservativeRasterizationMode) const { vkCmdSetConservativeRasterizationModeEXT(this->handle, std::bit_cast<VkConservativeRasterizationModeEXT>(conservativeRasterizationMode)); }
  void cmdSetExtraPrimitiveOverestimationSizeEXT(float extraPrimitiveOverestimationSize) const { vkCmdSetExtraPrimitiveOverestimationSizeEXT(this->handle, extraPrimitiveOverestimationSize); }
  void cmdSetDepthClipEnableEXT(Bool32 depthClipEnable) const { vkCmdSetDepthClipEnableEXT(this->handle, depthClipEnable); }
  void cmdSetSampleLocationsEnableEXT(Bool32 sampleLocationsEnable) const { vkCmdSetSampleLocationsEnableEXT(this->handle, sampleLocationsEnable); }
  void cmdSetColorBlendAdvancedEXT(uint32_t firstAttachment, uint32_t attachmentCount, const ColorBlendAdvancedEXT* pColorBlendAdvanced) const { vkCmdSetColorBlendAdvancedEXT(this->handle, firstAttachment, attachmentCount, std::bit_cast<const VkColorBlendAdvancedEXT*>(pColorBlendAdvanced)); }
  void cmdSetProvokingVertexModeEXT(ProvokingVertexModeEXT provokingVertexMode) const { vkCmdSetProvokingVertexModeEXT(this->handle, std::bit_cast<VkProvokingVertexModeEXT>(provokingVertexMode)); }
  void cmdSetLineRasterizationModeEXT(LineRasterizationModeEXT lineRasterizationMode) const { vkCmdSetLineRasterizationModeEXT(this->handle, std::bit_cast<VkLineRasterizationModeEXT>(lineRasterizationMode)); }
  void cmdSetLineStippleEnableEXT(Bool32 stippledLineEnable) const { vkCmdSetLineStippleEnableEXT(this->handle, stippledLineEnable); }
  void cmdSetDepthClipNegativeOneToOneEXT(Bool32 negativeOneToOne) const { vkCmdSetDepthClipNegativeOneToOneEXT(this->handle, negativeOneToOne); }
  void cmdSetViewportWScalingEnableNV(Bool32 viewportWScalingEnable) const { vkCmdSetViewportWScalingEnableNV(this->handle, viewportWScalingEnable); }
  void cmdSetViewportSwizzleNV(uint32_t firstViewport, uint32_t viewportCount, const ViewportSwizzleNV* pViewportSwizzles) const { vkCmdSetViewportSwizzleNV(this->handle, firstViewport, viewportCount, std::bit_cast<const VkViewportSwizzleNV*>(pViewportSwizzles)); }
  void cmdSetCoverageToColorEnableNV(Bool32 coverageToColorEnable) const { vkCmdSetCoverageToColorEnableNV(this->handle, coverageToColorEnable); }
  void cmdSetCoverageToColorLocationNV(uint32_t coverageToColorLocation) const { vkCmdSetCoverageToColorLocationNV(this->handle, coverageToColorLocation); }
  void cmdSetCoverageModulationModeNV(CoverageModulationModeNV coverageModulationMode) const { vkCmdSetCoverageModulationModeNV(this->handle, std::bit_cast<VkCoverageModulationModeNV>(coverageModulationMode)); }
  void cmdSetCoverageModulationTableEnableNV(Bool32 coverageModulationTableEnable) const { vkCmdSetCoverageModulationTableEnableNV(this->handle, coverageModulationTableEnable); }
  void cmdSetCoverageModulationTableNV(uint32_t coverageModulationTableCount, const float* pCoverageModulationTable) const { vkCmdSetCoverageModulationTableNV(this->handle, coverageModulationTableCount, pCoverageModulationTable); }
  void cmdSetShadingRateImageEnableNV(Bool32 shadingRateImageEnable) const { vkCmdSetShadingRateImageEnableNV(this->handle, shadingRateImageEnable); }
  void cmdSetCoverageReductionModeNV(CoverageReductionModeNV coverageReductionMode) const { vkCmdSetCoverageReductionModeNV(this->handle, std::bit_cast<VkCoverageReductionModeNV>(coverageReductionMode)); }
  void cmdSetRepresentativeFragmentTestEnableNV(Bool32 representativeFragmentTestEnable) const { vkCmdSetRepresentativeFragmentTestEnableNV(this->handle, representativeFragmentTestEnable); }
#endif // VK_EXT_extended_dynamic_state3
#if VK_VERSION_1_3
  void cmdCopyBuffer2(const CopyBufferInfo2& copyBufferInfo) const { vkCmdCopyBuffer2(this->handle, std::bit_cast<const VkCopyBufferInfo2*>(&copyBufferInfo)); }
#endif // VK_VERSION_1_3
#if VK_KHR_copy_commands2
  void cmdCopyBuffer2KHR(const CopyBufferInfo2& copyBufferInfo) const { vkCmdCopyBuffer2KHR(this->handle, std::bit_cast<const VkCopyBufferInfo2*>(&copyBufferInfo)); }
#endif // VK_KHR_copy_commands2
#if VK_VERSION_1_3
  void cmdCopyImage2(const CopyImageInfo2& copyImageInfo) const { vkCmdCopyImage2(this->handle, std::bit_cast<const VkCopyImageInfo2*>(&copyImageInfo)); }
#endif // VK_VERSION_1_3
#if VK_KHR_copy_commands2
  void cmdCopyImage2KHR(const CopyImageInfo2& copyImageInfo) const { vkCmdCopyImage2KHR(this->handle, std::bit_cast<const VkCopyImageInfo2*>(&copyImageInfo)); }
#endif // VK_KHR_copy_commands2
#if VK_VERSION_1_3
  void cmdBlitImage2(const BlitImageInfo2& blitImageInfo) const { vkCmdBlitImage2(this->handle, std::bit_cast<const VkBlitImageInfo2*>(&blitImageInfo)); }
#endif // VK_VERSION_1_3
#if VK_KHR_copy_commands2
  void cmdBlitImage2KHR(const BlitImageInfo2& blitImageInfo) const { vkCmdBlitImage2KHR(this->handle, std::bit_cast<const VkBlitImageInfo2*>(&blitImageInfo)); }
#endif // VK_KHR_copy_commands2
#if VK_VERSION_1_3
  void cmdCopyBufferToImage2(const CopyBufferToImageInfo2& copyBufferToImageInfo) const { vkCmdCopyBufferToImage2(this->handle, std::bit_cast<const VkCopyBufferToImageInfo2*>(&copyBufferToImageInfo)); }
#endif // VK_VERSION_1_3
#if VK_KHR_copy_commands2
  void cmdCopyBufferToImage2KHR(const CopyBufferToImageInfo2& copyBufferToImageInfo) const { vkCmdCopyBufferToImage2KHR(this->handle, std::bit_cast<const VkCopyBufferToImageInfo2*>(&copyBufferToImageInfo)); }
#endif // VK_KHR_copy_commands2
#if VK_VERSION_1_3
  void cmdCopyImageToBuffer2(const CopyImageToBufferInfo2& copyImageToBufferInfo) const { vkCmdCopyImageToBuffer2(this->handle, std::bit_cast<const VkCopyImageToBufferInfo2*>(&copyImageToBufferInfo)); }
#endif // VK_VERSION_1_3
#if VK_KHR_copy_commands2
  void cmdCopyImageToBuffer2KHR(const CopyImageToBufferInfo2& copyImageToBufferInfo) const { vkCmdCopyImageToBuffer2KHR(this->handle, std::bit_cast<const VkCopyImageToBufferInfo2*>(&copyImageToBufferInfo)); }
#endif // VK_KHR_copy_commands2
#if VK_VERSION_1_3
  void cmdResolveImage2(const ResolveImageInfo2& resolveImageInfo) const { vkCmdResolveImage2(this->handle, std::bit_cast<const VkResolveImageInfo2*>(&resolveImageInfo)); }
#endif // VK_VERSION_1_3
#if VK_KHR_copy_commands2
  void cmdResolveImage2KHR(const ResolveImageInfo2& resolveImageInfo) const { vkCmdResolveImage2KHR(this->handle, std::bit_cast<const VkResolveImageInfo2*>(&resolveImageInfo)); }
#endif // VK_KHR_copy_commands2
#if VK_KHR_fragment_shading_rate
  void cmdSetFragmentShadingRateKHR(const Extent2D& fragmentSize, std::span<const FragmentShadingRateCombinerOpKHR, 2> combinerOps) const { vkCmdSetFragmentShadingRateKHR(this->handle, std::bit_cast<const VkExtent2D*>(&fragmentSize), std::bit_cast<const VkFragmentShadingRateCombinerOpKHR*>(combinerOps.data())); }
#endif // VK_KHR_fragment_shading_rate
#if VK_NV_fragment_shading_rate_enums
  void cmdSetFragmentShadingRateEnumNV(FragmentShadingRateNV shadingRate, std::span<const FragmentShadingRateCombinerOpKHR, 2> combinerOps) const { vkCmdSetFragmentShadingRateEnumNV(this->handle, std::bit_cast<VkFragmentShadingRateNV>(shadingRate), std::bit_cast<const VkFragmentShadingRateCombinerOpKHR*>(combinerOps.data())); }
#endif // VK_NV_fragment_shading_rate_enums
#if VK_EXT_vertex_input_dynamic_state
  void cmdSetVertexInputEXT(uint32_t vertexBindingDescriptionCount = {}, const VertexInputBindingDescription2EXT* pVertexBindingDescriptions = {}, uint32_t vertexAttributeDescriptionCount = {}, const VertexInputAttributeDescription2EXT* pVertexAttributeDescriptions = {}) const { vkCmdSetVertexInputEXT(this->handle, vertexBindingDescriptionCount, std::bit_cast<const VkVertexInputBindingDescription2EXT*>(pVertexBindingDescriptions), vertexAttributeDescriptionCount, std::bit_cast<const VkVertexInputAttributeDescription2EXT*>(pVertexAttributeDescriptions)); }
#endif // VK_EXT_vertex_input_dynamic_state
#if VK_EXT_color_write_enable
  void cmdSetColorWriteEnableEXT(uint32_t attachmentCount, const Bool32* pColorWriteEnables) const { vkCmdSetColorWriteEnableEXT(this->handle, attachmentCount, pColorWriteEnables); }
#endif // VK_EXT_color_write_enable
#if VK_VERSION_1_3
  void cmdSetEvent2(Event event, const DependencyInfo& dependencyInfo) const { vkCmdSetEvent2(this->handle, std::bit_cast<VkEvent>(event), std::bit_cast<const VkDependencyInfo*>(&dependencyInfo)); }
#endif // VK_VERSION_1_3
#if VK_KHR_synchronization2
  void cmdSetEvent2KHR(Event event, const DependencyInfo& dependencyInfo) const { vkCmdSetEvent2KHR(this->handle, std::bit_cast<VkEvent>(event), std::bit_cast<const VkDependencyInfo*>(&dependencyInfo)); }
#endif // VK_KHR_synchronization2
#if VK_VERSION_1_3
  void cmdResetEvent2(Event event, PipelineStageFlags2 stageMask = {}) const { vkCmdResetEvent2(this->handle, std::bit_cast<VkEvent>(event), std::bit_cast<VkPipelineStageFlags2>(stageMask)); }
#endif // VK_VERSION_1_3
#if VK_KHR_synchronization2
  void cmdResetEvent2KHR(Event event, PipelineStageFlags2 stageMask = {}) const { vkCmdResetEvent2KHR(this->handle, std::bit_cast<VkEvent>(event), std::bit_cast<VkPipelineStageFlags2>(stageMask)); }
#endif // VK_KHR_synchronization2
#if VK_VERSION_1_3
  void cmdWaitEvents2(uint32_t eventCount, const Event* pEvents, const DependencyInfo* pDependencyInfos) const { vkCmdWaitEvents2(this->handle, eventCount, std::bit_cast<const VkEvent*>(pEvents), std::bit_cast<const VkDependencyInfo*>(pDependencyInfos)); }
#endif // VK_VERSION_1_3
#if VK_KHR_synchronization2
  void cmdWaitEvents2KHR(uint32_t eventCount, const Event* pEvents, const DependencyInfo* pDependencyInfos) const { vkCmdWaitEvents2KHR(this->handle, eventCount, std::bit_cast<const VkEvent*>(pEvents), std::bit_cast<const VkDependencyInfo*>(pDependencyInfos)); }
#endif // VK_KHR_synchronization2
#if VK_VERSION_1_3
  void cmdPipelineBarrier2(const DependencyInfo& dependencyInfo) const { vkCmdPipelineBarrier2(this->handle, std::bit_cast<const VkDependencyInfo*>(&dependencyInfo)); }
#endif // VK_VERSION_1_3
#if VK_KHR_synchronization2
  void cmdPipelineBarrier2KHR(const DependencyInfo& dependencyInfo) const { vkCmdPipelineBarrier2KHR(this->handle, std::bit_cast<const VkDependencyInfo*>(&dependencyInfo)); }
#endif // VK_KHR_synchronization2
#if VK_VERSION_1_3
  void cmdWriteTimestamp2(PipelineStageFlags2 stage, QueryPool queryPool, uint32_t query) const { vkCmdWriteTimestamp2(this->handle, std::bit_cast<VkPipelineStageFlags2>(stage), std::bit_cast<VkQueryPool>(queryPool), query); }
#endif // VK_VERSION_1_3
#if VK_KHR_synchronization2
  void cmdWriteTimestamp2KHR(PipelineStageFlags2 stage, QueryPool queryPool, uint32_t query) const { vkCmdWriteTimestamp2KHR(this->handle, std::bit_cast<VkPipelineStageFlags2>(stage), std::bit_cast<VkQueryPool>(queryPool), query); }
#endif // VK_KHR_synchronization2
#if VK_KHR_video_decode_queue
  void cmdDecodeVideoKHR(const VideoDecodeInfoKHR& decodeInfo) const { vkCmdDecodeVideoKHR(this->handle, std::bit_cast<const VkVideoDecodeInfoKHR*>(&decodeInfo)); }
#endif // VK_KHR_video_decode_queue
#if VK_KHR_video_queue
  void cmdBeginVideoCodingKHR(const VideoBeginCodingInfoKHR& beginInfo) const { vkCmdBeginVideoCodingKHR(this->handle, std::bit_cast<const VkVideoBeginCodingInfoKHR*>(&beginInfo)); }
  void cmdControlVideoCodingKHR(const VideoCodingControlInfoKHR& codingControlInfo) const { vkCmdControlVideoCodingKHR(this->handle, std::bit_cast<const VkVideoCodingControlInfoKHR*>(&codingControlInfo)); }
  void cmdEndVideoCodingKHR(const VideoEndCodingInfoKHR& endCodingInfo) const { vkCmdEndVideoCodingKHR(this->handle, std::bit_cast<const VkVideoEndCodingInfoKHR*>(&endCodingInfo)); }
#endif // VK_KHR_video_queue
#if VK_KHR_video_encode_queue
  void cmdEncodeVideoKHR(const VideoEncodeInfoKHR& encodeInfo) const { vkCmdEncodeVideoKHR(this->handle, std::bit_cast<const VkVideoEncodeInfoKHR*>(&encodeInfo)); }
#endif // VK_KHR_video_encode_queue
#if VK_NV_memory_decompression
  void cmdDecompressMemoryNV(uint32_t decompressRegionCount, const DecompressMemoryRegionNV* pDecompressMemoryRegions) const { vkCmdDecompressMemoryNV(this->handle, decompressRegionCount, std::bit_cast<const VkDecompressMemoryRegionNV*>(pDecompressMemoryRegions)); }
  void cmdDecompressMemoryIndirectCountNV(DeviceAddress indirectCommandsAddress, DeviceAddress indirectCommandsCountAddress, uint32_t stride) const { vkCmdDecompressMemoryIndirectCountNV(this->handle, indirectCommandsAddress, indirectCommandsCountAddress, stride); }
#endif // VK_NV_memory_decompression
#if VK_NV_partitioned_acceleration_structure
  void cmdBuildPartitionedAccelerationStructuresNV(const BuildPartitionedAccelerationStructureInfoNV& buildInfo) const { vkCmdBuildPartitionedAccelerationStructuresNV(this->handle, std::bit_cast<const VkBuildPartitionedAccelerationStructureInfoNV*>(&buildInfo)); }
#endif // VK_NV_partitioned_acceleration_structure
#if VK_NVX_binary_import
  void cmdCuLaunchKernelNVX(const CuLaunchInfoNVX& launchInfo) const { vkCmdCuLaunchKernelNVX(this->handle, std::bit_cast<const VkCuLaunchInfoNVX*>(&launchInfo)); }
#endif // VK_NVX_binary_import
#if VK_EXT_descriptor_buffer
  void cmdBindDescriptorBuffersEXT(uint32_t bufferCount, const DescriptorBufferBindingInfoEXT* pBindingInfos) const { vkCmdBindDescriptorBuffersEXT(this->handle, bufferCount, std::bit_cast<const VkDescriptorBufferBindingInfoEXT*>(pBindingInfos)); }
  void cmdSetDescriptorBufferOffsetsEXT(PipelineBindPoint pipelineBindPoint, PipelineLayout layout, uint32_t firstSet, uint32_t setCount, const uint32_t* pBufferIndices, const DeviceSize* pOffsets) const { vkCmdSetDescriptorBufferOffsetsEXT(this->handle, std::bit_cast<VkPipelineBindPoint>(pipelineBindPoint), std::bit_cast<VkPipelineLayout>(layout), firstSet, setCount, pBufferIndices, pOffsets); }
  void cmdBindDescriptorBufferEmbeddedSamplersEXT(PipelineBindPoint pipelineBindPoint, PipelineLayout layout, uint32_t set) const { vkCmdBindDescriptorBufferEmbeddedSamplersEXT(this->handle, std::bit_cast<VkPipelineBindPoint>(pipelineBindPoint), std::bit_cast<VkPipelineLayout>(layout), set); }
#endif // VK_EXT_descriptor_buffer
#if VK_VERSION_1_3
  void cmdBeginRendering(const RenderingInfo& renderingInfo) const { vkCmdBeginRendering(this->handle, std::bit_cast<const VkRenderingInfo*>(&renderingInfo)); }
#endif // VK_VERSION_1_3
#if VK_KHR_dynamic_rendering
  void cmdBeginRenderingKHR(const RenderingInfo& renderingInfo) const { vkCmdBeginRenderingKHR(this->handle, std::bit_cast<const VkRenderingInfo*>(&renderingInfo)); }
#endif // VK_KHR_dynamic_rendering
#if VK_VERSION_1_3
  void cmdEndRendering() const { vkCmdEndRendering(this->handle); }
#endif // VK_VERSION_1_3
#if VK_EXT_fragment_density_map_offset
  void cmdEndRendering2EXT(const RenderingEndInfoEXT* pRenderingEndInfo = {}) const { vkCmdEndRendering2EXT(this->handle, std::bit_cast<const VkRenderingEndInfoEXT*>(pRenderingEndInfo)); }
#endif // VK_EXT_fragment_density_map_offset
#if VK_KHR_dynamic_rendering
  void cmdEndRenderingKHR() const { vkCmdEndRenderingKHR(this->handle); }
#endif // VK_KHR_dynamic_rendering
#if VK_EXT_opacity_micromap
  void cmdBuildMicromapsEXT(uint32_t infoCount, const MicromapBuildInfoEXT* pInfos) const { vkCmdBuildMicromapsEXT(this->handle, infoCount, std::bit_cast<const VkMicromapBuildInfoEXT*>(pInfos)); }
  void cmdCopyMicromapEXT(const CopyMicromapInfoEXT& info) const { vkCmdCopyMicromapEXT(this->handle, std::bit_cast<const VkCopyMicromapInfoEXT*>(&info)); }
  void cmdCopyMicromapToMemoryEXT(const CopyMicromapToMemoryInfoEXT& info) const { vkCmdCopyMicromapToMemoryEXT(this->handle, std::bit_cast<const VkCopyMicromapToMemoryInfoEXT*>(&info)); }
  void cmdCopyMemoryToMicromapEXT(const CopyMemoryToMicromapInfoEXT& info) const { vkCmdCopyMemoryToMicromapEXT(this->handle, std::bit_cast<const VkCopyMemoryToMicromapInfoEXT*>(&info)); }
  void cmdWriteMicromapsPropertiesEXT(uint32_t micromapCount, const MicromapEXT* pMicromaps, QueryType queryType, QueryPool queryPool, uint32_t firstQuery) const { vkCmdWriteMicromapsPropertiesEXT(this->handle, micromapCount, std::bit_cast<const VkMicromapEXT*>(pMicromaps), std::bit_cast<VkQueryType>(queryType), std::bit_cast<VkQueryPool>(queryPool), firstQuery); }
#endif // VK_EXT_opacity_micromap
#if VK_QCOM_tile_memory_heap
  void cmdBindTileMemoryQCOM(const TileMemoryBindInfoQCOM* pTileMemoryBindInfo = {}) const { vkCmdBindTileMemoryQCOM(this->handle, std::bit_cast<const VkTileMemoryBindInfoQCOM*>(pTileMemoryBindInfo)); }
#endif // VK_QCOM_tile_memory_heap
#if VK_NV_optical_flow
  void cmdOpticalFlowExecuteNV(OpticalFlowSessionNV session, const OpticalFlowExecuteInfoNV& executeInfo) const { vkCmdOpticalFlowExecuteNV(this->handle, std::bit_cast<VkOpticalFlowSessionNV>(session), std::bit_cast<const VkOpticalFlowExecuteInfoNV*>(&executeInfo)); }
#endif // VK_NV_optical_flow
#if VK_EXT_depth_bias_control
  void cmdSetDepthBias2EXT(const DepthBiasInfoEXT& depthBiasInfo) const { vkCmdSetDepthBias2EXT(this->handle, std::bit_cast<const VkDepthBiasInfoEXT*>(&depthBiasInfo)); }
#endif // VK_EXT_depth_bias_control
#if VK_EXT_shader_object
  void cmdBindShadersEXT(uint32_t stageCount, const ShaderStageFlagBits* pStages, const ShaderEXT* pShaders) const { vkCmdBindShadersEXT(this->handle, stageCount, std::bit_cast<const VkShaderStageFlagBits*>(pStages), std::bit_cast<const VkShaderEXT*>(pShaders)); }
#endif // VK_EXT_shader_object
#if VK_VERSION_1_4
  void cmdBindDescriptorSets2(const BindDescriptorSetsInfo& bindDescriptorSetsInfo) const { vkCmdBindDescriptorSets2(this->handle, std::bit_cast<const VkBindDescriptorSetsInfo*>(&bindDescriptorSetsInfo)); }
#endif // VK_VERSION_1_4
#if VK_KHR_maintenance6
  void cmdBindDescriptorSets2KHR(const BindDescriptorSetsInfo& bindDescriptorSetsInfo) const { vkCmdBindDescriptorSets2KHR(this->handle, std::bit_cast<const VkBindDescriptorSetsInfo*>(&bindDescriptorSetsInfo)); }
#endif // VK_KHR_maintenance6
#if VK_VERSION_1_4
  void cmdPushConstants2(const PushConstantsInfo& pushConstantsInfo) const { vkCmdPushConstants2(this->handle, std::bit_cast<const VkPushConstantsInfo*>(&pushConstantsInfo)); }
#endif // VK_VERSION_1_4
#if VK_KHR_maintenance6
  void cmdPushConstants2KHR(const PushConstantsInfo& pushConstantsInfo) const { vkCmdPushConstants2KHR(this->handle, std::bit_cast<const VkPushConstantsInfo*>(&pushConstantsInfo)); }
#endif // VK_KHR_maintenance6
#if VK_VERSION_1_4
  void cmdPushDescriptorSet2(const PushDescriptorSetInfo& pushDescriptorSetInfo) const { vkCmdPushDescriptorSet2(this->handle, std::bit_cast<const VkPushDescriptorSetInfo*>(&pushDescriptorSetInfo)); }
#endif // VK_VERSION_1_4
#if VK_KHR_maintenance6
  void cmdPushDescriptorSet2KHR(const PushDescriptorSetInfo& pushDescriptorSetInfo) const { vkCmdPushDescriptorSet2KHR(this->handle, std::bit_cast<const VkPushDescriptorSetInfo*>(&pushDescriptorSetInfo)); }
#endif // VK_KHR_maintenance6
#if VK_VERSION_1_4
  void cmdPushDescriptorSetWithTemplate2(const PushDescriptorSetWithTemplateInfo& pushDescriptorSetWithTemplateInfo) const { vkCmdPushDescriptorSetWithTemplate2(this->handle, std::bit_cast<const VkPushDescriptorSetWithTemplateInfo*>(&pushDescriptorSetWithTemplateInfo)); }
#endif // VK_VERSION_1_4
#if VK_KHR_maintenance6
  void cmdPushDescriptorSetWithTemplate2KHR(const PushDescriptorSetWithTemplateInfo& pushDescriptorSetWithTemplateInfo) const { vkCmdPushDescriptorSetWithTemplate2KHR(this->handle, std::bit_cast<const VkPushDescriptorSetWithTemplateInfo*>(&pushDescriptorSetWithTemplateInfo)); }
  void cmdSetDescriptorBufferOffsets2EXT(const SetDescriptorBufferOffsetsInfoEXT& setDescriptorBufferOffsetsInfo) const { vkCmdSetDescriptorBufferOffsets2EXT(this->handle, std::bit_cast<const VkSetDescriptorBufferOffsetsInfoEXT*>(&setDescriptorBufferOffsetsInfo)); }
  void cmdBindDescriptorBufferEmbeddedSamplers2EXT(const BindDescriptorBufferEmbeddedSamplersInfoEXT& bindDescriptorBufferEmbeddedSamplersInfo) const { vkCmdBindDescriptorBufferEmbeddedSamplers2EXT(this->handle, std::bit_cast<const VkBindDescriptorBufferEmbeddedSamplersInfoEXT*>(&bindDescriptorBufferEmbeddedSamplersInfo)); }
#endif // VK_KHR_maintenance6
#if VK_VERSION_1_4
  void cmdSetRenderingAttachmentLocations(const RenderingAttachmentLocationInfo& locationInfo) const { vkCmdSetRenderingAttachmentLocations(this->handle, std::bit_cast<const VkRenderingAttachmentLocationInfo*>(&locationInfo)); }
#endif // VK_VERSION_1_4
#if VK_KHR_dynamic_rendering_local_read
  void cmdSetRenderingAttachmentLocationsKHR(const RenderingAttachmentLocationInfo& locationInfo) const { vkCmdSetRenderingAttachmentLocationsKHR(this->handle, std::bit_cast<const VkRenderingAttachmentLocationInfo*>(&locationInfo)); }
#endif // VK_KHR_dynamic_rendering_local_read
#if VK_VERSION_1_4
  void cmdSetRenderingInputAttachmentIndices(const RenderingInputAttachmentIndexInfo& inputAttachmentIndexInfo) const { vkCmdSetRenderingInputAttachmentIndices(this->handle, std::bit_cast<const VkRenderingInputAttachmentIndexInfo*>(&inputAttachmentIndexInfo)); }
#endif // VK_VERSION_1_4
#if VK_KHR_dynamic_rendering_local_read
  void cmdSetRenderingInputAttachmentIndicesKHR(const RenderingInputAttachmentIndexInfo& inputAttachmentIndexInfo) const { vkCmdSetRenderingInputAttachmentIndicesKHR(this->handle, std::bit_cast<const VkRenderingInputAttachmentIndexInfo*>(&inputAttachmentIndexInfo)); }
#endif // VK_KHR_dynamic_rendering_local_read
#if VK_EXT_depth_clamp_control
  void cmdSetDepthClampRangeEXT(DepthClampModeEXT depthClampMode, const DepthClampRangeEXT* pDepthClampRange = {}) const { vkCmdSetDepthClampRangeEXT(this->handle, std::bit_cast<VkDepthClampModeEXT>(depthClampMode), std::bit_cast<const VkDepthClampRangeEXT*>(pDepthClampRange)); }
#endif // VK_EXT_depth_clamp_control
#if VK_NV_cooperative_vector
  void cmdConvertCooperativeVectorMatrixNV(uint32_t infoCount, const ConvertCooperativeVectorMatrixInfoNV* pInfos) const { vkCmdConvertCooperativeVectorMatrixNV(this->handle, infoCount, std::bit_cast<const VkConvertCooperativeVectorMatrixInfoNV*>(pInfos)); }
#endif // VK_NV_cooperative_vector
#if VK_QCOM_tile_shading
  void cmdDispatchTileQCOM(const DispatchTileInfoQCOM& dispatchTileInfo) const { vkCmdDispatchTileQCOM(this->handle, std::bit_cast<const VkDispatchTileInfoQCOM*>(&dispatchTileInfo)); }
  void cmdBeginPerTileExecutionQCOM(const PerTileBeginInfoQCOM& perTileBeginInfo) const { vkCmdBeginPerTileExecutionQCOM(this->handle, std::bit_cast<const VkPerTileBeginInfoQCOM*>(&perTileBeginInfo)); }
  void cmdEndPerTileExecutionQCOM(const PerTileEndInfoQCOM& perTileEndInfo) const { vkCmdEndPerTileExecutionQCOM(this->handle, std::bit_cast<const VkPerTileEndInfoQCOM*>(&perTileEndInfo)); }
#endif // VK_QCOM_tile_shading
#if VK_ARM_tensors
  void cmdCopyTensorARM( const CopyTensorInfoARM* pCopyTensorInfo) const { vkCmdCopyTensorARM(this->handle, std::bit_cast< const VkCopyTensorInfoARM*>(pCopyTensorInfo)); }
#endif // VK_ARM_tensors
#if VK_ARM_data_graph
  void cmdDispatchDataGraphARM(DataGraphPipelineSessionARM session, const DataGraphPipelineDispatchInfoARM* pInfo = {}) const { vkCmdDispatchDataGraphARM(this->handle, std::bit_cast<VkDataGraphPipelineSessionARM>(session), std::bit_cast<const VkDataGraphPipelineDispatchInfoARM*>(pInfo)); }
#endif // VK_ARM_data_graph
};
#endif // VK_VERSION_1_0

#if VK_KHR_ray_tracing_pipeline
struct RayTracingPipelineCreateInfoKHR : VkRayTracingPipelineCreateInfoKHR {
  RayTracingPipelineCreateInfoKHR() noexcept : VkRayTracingPipelineCreateInfoKHR{.sType = VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR} {}

  void setMaxPipelineRayRecursionDepth(uint32_t value) { this->maxPipelineRayRecursionDepth = value; }
  uint32_t getMaxPipelineRayRecursionDepth() const { return this->maxPipelineRayRecursionDepth; }
  // Interface layout of the pipeline
  void setLayout(PipelineLayout value) { this->layout = std::bit_cast<VkPipelineLayout>(value); }
  PipelineLayout getLayout() const { return std::bit_cast<PipelineLayout>(this->layout); }
  // If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is not -1, it specifies an index into pCreateInfos of the base pipeline this is a derivative of
  void setBasePipelineIndex(int32_t value) { this->basePipelineIndex = value; }
  int32_t getBasePipelineIndex() const { return this->basePipelineIndex; }

  // Pipeline creation flags
  void setFlags(PipelineCreateFlags value) { this->flags = std::bit_cast<VkPipelineCreateFlags>(value); }
  PipelineCreateFlags getFlags() const { return std::bit_cast<PipelineCreateFlags>(this->flags); }
  void setStageCount(uint32_t value) { this->stageCount = value; }
  uint32_t getStageCount() const { return this->stageCount; }
  // One entry for each active shader stage
  void setStages(const PipelineShaderStageCreateInfo* value) { this->pStages = std::bit_cast<const VkPipelineShaderStageCreateInfo*>(value); }
  const PipelineShaderStageCreateInfo* getStages() const { return std::bit_cast<const PipelineShaderStageCreateInfo*>(this->pStages); }
  void setGroupCount(uint32_t value) { this->groupCount = value; }
  uint32_t getGroupCount() const { return this->groupCount; }
  void setGroups(const RayTracingShaderGroupCreateInfoKHR* value) { this->pGroups = std::bit_cast<const VkRayTracingShaderGroupCreateInfoKHR*>(value); }
  const RayTracingShaderGroupCreateInfoKHR* getGroups() const { return std::bit_cast<const RayTracingShaderGroupCreateInfoKHR*>(this->pGroups); }
  void setLibraryInfo(const PipelineLibraryCreateInfoKHR* value) { this->pLibraryInfo = std::bit_cast<const VkPipelineLibraryCreateInfoKHR*>(value); }
  const PipelineLibraryCreateInfoKHR* getLibraryInfo() const { return std::bit_cast<const PipelineLibraryCreateInfoKHR*>(this->pLibraryInfo); }
  void setLibraryInterface(const RayTracingPipelineInterfaceCreateInfoKHR* value) { this->pLibraryInterface = std::bit_cast<const VkRayTracingPipelineInterfaceCreateInfoKHR*>(value); }
  const RayTracingPipelineInterfaceCreateInfoKHR* getLibraryInterface() const { return std::bit_cast<const RayTracingPipelineInterfaceCreateInfoKHR*>(this->pLibraryInterface); }
  void setDynamicState(const PipelineDynamicStateCreateInfo* value) { this->pDynamicState = std::bit_cast<const VkPipelineDynamicStateCreateInfo*>(value); }
  const PipelineDynamicStateCreateInfo* getDynamicState() const { return std::bit_cast<const PipelineDynamicStateCreateInfo*>(this->pDynamicState); }
  // If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is nonzero, it specifies the handle of the base pipeline this is a derivative of
  void setBasePipelineHandle(Pipeline value) { this->basePipelineHandle = std::bit_cast<VkPipeline>(value); }
  Pipeline getBasePipelineHandle() const { return std::bit_cast<Pipeline>(this->basePipelineHandle); }

  void attach(struct PipelineCreateFlags2CreateInfo&);
#if VK_KHR_pipeline_binary
  void attach(struct PipelineBinaryInfoKHR&);
#endif // VK_KHR_pipeline_binary
#if VK_NV_cluster_acceleration_structure
  void attach(struct RayTracingPipelineClusterAccelerationStructureCreateInfoNV&);
#endif // VK_NV_cluster_acceleration_structure
  void attach(struct PipelineCreationFeedbackCreateInfo&);
  void attach(struct PipelineRobustnessCreateInfo&);
};
#endif // VK_KHR_ray_tracing_pipeline

#if VK_NV_framebuffer_mixed_samples
using AttachmentSampleCountInfoNV = AttachmentSampleCountInfoAMD;
#endif // VK_NV_framebuffer_mixed_samples
#if VK_KHR_dynamic_rendering
using PipelineRenderingCreateInfoKHR = PipelineRenderingCreateInfo;
#endif // VK_KHR_dynamic_rendering

#if VK_VERSION_1_1
struct DeviceGroupBindSparseInfo : VkDeviceGroupBindSparseInfo {
  DeviceGroupBindSparseInfo() noexcept : VkDeviceGroupBindSparseInfo{.sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO} {}

  void setResourceDeviceIndex(uint32_t value) { this->resourceDeviceIndex = value; }
  uint32_t getResourceDeviceIndex() const { return this->resourceDeviceIndex; }
  void setMemoryDeviceIndex(uint32_t value) { this->memoryDeviceIndex = value; }
  uint32_t getMemoryDeviceIndex() const { return this->memoryDeviceIndex; }
};
inline void BindSparseInfo::attach(DeviceGroupBindSparseInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_1

#if VK_EXT_sample_locations
struct RenderPassSampleLocationsBeginInfoEXT : VkRenderPassSampleLocationsBeginInfoEXT {
  RenderPassSampleLocationsBeginInfoEXT() noexcept : VkRenderPassSampleLocationsBeginInfoEXT{.sType = VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT} {}

  void setAttachmentInitialSampleLocationsCount(uint32_t value) { this->attachmentInitialSampleLocationsCount = value; }
  uint32_t getAttachmentInitialSampleLocationsCount() const { return this->attachmentInitialSampleLocationsCount; }
  void setAttachmentInitialSampleLocations(const AttachmentSampleLocationsEXT* value) { this->pAttachmentInitialSampleLocations = std::bit_cast<const VkAttachmentSampleLocationsEXT*>(value); }
  const AttachmentSampleLocationsEXT* getAttachmentInitialSampleLocations() const { return std::bit_cast<const AttachmentSampleLocationsEXT*>(this->pAttachmentInitialSampleLocations); }
  void setPostSubpassSampleLocationsCount(uint32_t value) { this->postSubpassSampleLocationsCount = value; }
  uint32_t getPostSubpassSampleLocationsCount() const { return this->postSubpassSampleLocationsCount; }
  void setPostSubpassSampleLocations(const SubpassSampleLocationsEXT* value) { this->pPostSubpassSampleLocations = std::bit_cast<const VkSubpassSampleLocationsEXT*>(value); }
  const SubpassSampleLocationsEXT* getPostSubpassSampleLocations() const { return std::bit_cast<const SubpassSampleLocationsEXT*>(this->pPostSubpassSampleLocations); }
};
inline void RenderPassBeginInfo::attach(RenderPassSampleLocationsBeginInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_sample_locations

#if VK_KHR_depth_stencil_resolve
using PhysicalDeviceDepthStencilResolvePropertiesKHR = PhysicalDeviceDepthStencilResolveProperties;
#endif // VK_KHR_depth_stencil_resolve
#if VK_EXT_sampler_filter_minmax
using PhysicalDeviceSamplerFilterMinmaxPropertiesEXT = PhysicalDeviceSamplerFilterMinmaxProperties;
#endif // VK_EXT_sampler_filter_minmax
#if VK_KHR_shader_integer_dot_product
using PhysicalDeviceShaderIntegerDotProductPropertiesKHR = PhysicalDeviceShaderIntegerDotProductProperties;
#endif // VK_KHR_shader_integer_dot_product
#if VK_EXT_pipeline_robustness
using PhysicalDevicePipelineRobustnessPropertiesEXT = PhysicalDevicePipelineRobustnessProperties;
#endif // VK_EXT_pipeline_robustness
#if VK_EXT_inline_uniform_block
using PhysicalDeviceInlineUniformBlockPropertiesEXT = PhysicalDeviceInlineUniformBlockProperties;
#endif // VK_EXT_inline_uniform_block
#if VK_EXT_host_image_copy
using PhysicalDeviceHostImageCopyPropertiesEXT = PhysicalDeviceHostImageCopyProperties;
#endif // VK_EXT_host_image_copy
#if VK_KHR_maintenance5
using PhysicalDeviceMaintenance5PropertiesKHR = PhysicalDeviceMaintenance5Properties;
#endif // VK_KHR_maintenance5
#if VK_KHR_maintenance6
using PhysicalDeviceMaintenance6PropertiesKHR = PhysicalDeviceMaintenance6Properties;
#endif // VK_KHR_maintenance6
#if VK_KHR_vertex_attribute_divisor
using PhysicalDeviceVertexAttributeDivisorPropertiesKHR = PhysicalDeviceVertexAttributeDivisorProperties;
#endif // VK_KHR_vertex_attribute_divisor
#if VK_KHR_push_descriptor
using PhysicalDevicePushDescriptorPropertiesKHR = PhysicalDevicePushDescriptorProperties;
#endif // VK_KHR_push_descriptor
#if VK_KHR_driver_properties
using PhysicalDeviceDriverPropertiesKHR = PhysicalDeviceDriverProperties;
#endif // VK_KHR_driver_properties
#if VK_KHR_external_memory_capabilities
using PhysicalDeviceIDPropertiesKHR = PhysicalDeviceIDProperties;
#endif // VK_KHR_external_memory_capabilities
#if VK_KHR_timeline_semaphore
using PhysicalDeviceTimelineSemaphorePropertiesKHR = PhysicalDeviceTimelineSemaphoreProperties;
#endif // VK_KHR_timeline_semaphore
#if VK_EXT_subgroup_size_control
using PhysicalDeviceSubgroupSizeControlPropertiesEXT = PhysicalDeviceSubgroupSizeControlProperties;
#endif // VK_EXT_subgroup_size_control
#if VK_KHR_line_rasterization
using PhysicalDeviceLineRasterizationPropertiesKHR = PhysicalDeviceLineRasterizationProperties;
#endif // VK_KHR_line_rasterization
#if VK_EXT_line_rasterization
using PhysicalDeviceLineRasterizationPropertiesEXT = PhysicalDeviceLineRasterizationProperties;
#endif // VK_EXT_line_rasterization
#if VK_KHR_maintenance3
using PhysicalDeviceMaintenance3PropertiesKHR = PhysicalDeviceMaintenance3Properties;
#endif // VK_KHR_maintenance3
#if VK_KHR_maintenance4
using PhysicalDeviceMaintenance4PropertiesKHR = PhysicalDeviceMaintenance4Properties;
#endif // VK_KHR_maintenance4
#if VK_EXT_descriptor_indexing
using PhysicalDeviceDescriptorIndexingPropertiesEXT = PhysicalDeviceDescriptorIndexingProperties;
#endif // VK_EXT_descriptor_indexing
#if VK_QCOM_fragment_density_map_offset
using PhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM = PhysicalDeviceFragmentDensityMapOffsetPropertiesEXT;
#endif // VK_QCOM_fragment_density_map_offset
#if VK_KHR_maintenance2
using PhysicalDevicePointClippingPropertiesKHR = PhysicalDevicePointClippingProperties;
#endif // VK_KHR_maintenance2
#if VK_EXT_robustness2
using PhysicalDeviceRobustness2PropertiesEXT = PhysicalDeviceRobustness2PropertiesKHR;
#endif // VK_EXT_robustness2
#if VK_KHR_shader_float_controls
using PhysicalDeviceFloatControlsPropertiesKHR = PhysicalDeviceFloatControlsProperties;
#endif // VK_KHR_shader_float_controls
#if VK_EXT_texel_buffer_alignment
using PhysicalDeviceTexelBufferAlignmentPropertiesEXT = PhysicalDeviceTexelBufferAlignmentProperties;
#endif // VK_EXT_texel_buffer_alignment
#if VK_KHR_multiview
using PhysicalDeviceMultiviewPropertiesKHR = PhysicalDeviceMultiviewProperties;
#endif // VK_KHR_multiview

#if VK_ARM_tensors
struct TensorDependencyInfoARM : VkTensorDependencyInfoARM {
  TensorDependencyInfoARM() noexcept : VkTensorDependencyInfoARM{.sType = VK_STRUCTURE_TYPE_TENSOR_DEPENDENCY_INFO_ARM} {}

  void setTensorMemoryBarrierCount(uint32_t value) { this->tensorMemoryBarrierCount = value; }
  uint32_t getTensorMemoryBarrierCount() const { return this->tensorMemoryBarrierCount; }
  void setTensorMemoryBarriers(const TensorMemoryBarrierARM* value) { this->pTensorMemoryBarriers = std::bit_cast<const VkTensorMemoryBarrierARM*>(value); }
  const TensorMemoryBarrierARM* getTensorMemoryBarriers() const { return std::bit_cast<const TensorMemoryBarrierARM*>(this->pTensorMemoryBarriers); }
};
inline void DependencyInfo::attach(TensorDependencyInfoARM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_ARM_tensors

#if VK_EXT_descriptor_buffer
struct OpaqueCaptureDescriptorDataCreateInfoEXT : VkOpaqueCaptureDescriptorDataCreateInfoEXT {
  OpaqueCaptureDescriptorDataCreateInfoEXT() noexcept : VkOpaqueCaptureDescriptorDataCreateInfoEXT{.sType = VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT} {}

  void setopaqueCaptureDescriptorData(const void* value) { this->opaqueCaptureDescriptorData = value; }
  const void* getopaqueCaptureDescriptorData() const { return this->opaqueCaptureDescriptorData; }
};
inline void BufferCreateInfo::attach(OpaqueCaptureDescriptorDataCreateInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void ImageCreateInfo::attach(OpaqueCaptureDescriptorDataCreateInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void ImageViewCreateInfo::attach(OpaqueCaptureDescriptorDataCreateInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void SamplerCreateInfo::attach(OpaqueCaptureDescriptorDataCreateInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void AccelerationStructureCreateInfoKHR::attach(OpaqueCaptureDescriptorDataCreateInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#if VK_ARM_tensors
inline void TensorCreateInfoARM::attach(OpaqueCaptureDescriptorDataCreateInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void TensorViewCreateInfoARM::attach(OpaqueCaptureDescriptorDataCreateInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_ARM_tensors
#endif // VK_EXT_descriptor_buffer

#if VK_VERSION_1_3
struct CommandBufferSubmitInfo : VkCommandBufferSubmitInfo {
  CommandBufferSubmitInfo() noexcept : VkCommandBufferSubmitInfo{.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO} {}

  void setCommandBuffer(CommandBuffer value) { this->commandBuffer = std::bit_cast<VkCommandBuffer>(value); }
  CommandBuffer getCommandBuffer() const { return std::bit_cast<CommandBuffer>(this->commandBuffer); }
  void setDeviceMask(uint32_t value) { this->deviceMask = value; }
  uint32_t getDeviceMask() const { return this->deviceMask; }

#if VK_ARM_render_pass_striped
  void attach(struct RenderPassStripeSubmitInfoARM&);
#endif // VK_ARM_render_pass_striped
};
#endif // VK_VERSION_1_3

#if VK_VERSION_1_0
struct SubmitInfo : VkSubmitInfo {
  SubmitInfo() noexcept : VkSubmitInfo{.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO} {}

  void setWaitSemaphoreCount(uint32_t value) { this->waitSemaphoreCount = value; }
  uint32_t getWaitSemaphoreCount() const { return this->waitSemaphoreCount; }
  void setWaitSemaphores(const Semaphore* value) { this->pWaitSemaphores = std::bit_cast<const VkSemaphore*>(value); }
  const Semaphore* getWaitSemaphores() const { return std::bit_cast<const Semaphore*>(this->pWaitSemaphores); }
  void setWaitDstStageMask(const PipelineStageFlags* value) { this->pWaitDstStageMask = std::bit_cast<const VkPipelineStageFlags*>(value); }
  const PipelineStageFlags* getWaitDstStageMask() const { return std::bit_cast<const PipelineStageFlags*>(this->pWaitDstStageMask); }
  void setCommandBufferCount(uint32_t value) { this->commandBufferCount = value; }
  uint32_t getCommandBufferCount() const { return this->commandBufferCount; }
  void setCommandBuffers(const CommandBuffer* value) { this->pCommandBuffers = std::bit_cast<const VkCommandBuffer*>(value); }
  const CommandBuffer* getCommandBuffers() const { return std::bit_cast<const CommandBuffer*>(this->pCommandBuffers); }
  void setSignalSemaphoreCount(uint32_t value) { this->signalSemaphoreCount = value; }
  uint32_t getSignalSemaphoreCount() const { return this->signalSemaphoreCount; }
  void setSignalSemaphores(const Semaphore* value) { this->pSignalSemaphores = std::bit_cast<const VkSemaphore*>(value); }
  const Semaphore* getSignalSemaphores() const { return std::bit_cast<const Semaphore*>(this->pSignalSemaphores); }

#if VK_NV_win32_keyed_mutex
  void attach(struct Win32KeyedMutexAcquireReleaseInfoNV&);
#endif // VK_NV_win32_keyed_mutex
#if VK_KHR_win32_keyed_mutex
  void attach(struct Win32KeyedMutexAcquireReleaseInfoKHR&);
#endif // VK_KHR_win32_keyed_mutex
#if VK_KHR_external_semaphore_win32
  void attach(struct D3D12FenceSubmitInfoKHR&);
#endif // VK_KHR_external_semaphore_win32
#if VK_VERSION_1_1
  void attach(struct DeviceGroupSubmitInfo&);
  void attach(struct ProtectedSubmitInfo&);
#endif // VK_VERSION_1_1
#if VK_VERSION_1_2
  void attach(struct TimelineSemaphoreSubmitInfo&);
#endif // VK_VERSION_1_2
#if VK_KHR_performance_query
  void attach(struct PerformanceQuerySubmitInfoKHR&);
#endif // VK_KHR_performance_query
#if VK_SEC_amigo_profiling
  void attach(struct AmigoProfilingSubmitInfoSEC&);
#endif // VK_SEC_amigo_profiling
#if VK_EXT_frame_boundary
  void attach(struct FrameBoundaryEXT&);
#endif // VK_EXT_frame_boundary
#if VK_NV_low_latency2
  void attach(struct LatencySubmissionPresentIdNV&);
#endif // VK_NV_low_latency2
#if VK_ARM_tensors
  void attach(struct FrameBoundaryTensorsARM&);
#endif // VK_ARM_tensors
};
#endif // VK_VERSION_1_0

#if VK_AMD_pipeline_compiler_control
struct PipelineCompilerControlCreateInfoAMD : VkPipelineCompilerControlCreateInfoAMD {
  PipelineCompilerControlCreateInfoAMD() noexcept : VkPipelineCompilerControlCreateInfoAMD{.sType = VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD} {}

  void setCompilerControlFlags(PipelineCompilerControlFlagsAMD value) { this->compilerControlFlags = std::bit_cast<VkPipelineCompilerControlFlagsAMD>(value); }
  PipelineCompilerControlFlagsAMD getCompilerControlFlags() const { return std::bit_cast<PipelineCompilerControlFlagsAMD>(this->compilerControlFlags); }
};
inline void GraphicsPipelineCreateInfo::attach(PipelineCompilerControlCreateInfoAMD& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void ComputePipelineCreateInfo::attach(PipelineCompilerControlCreateInfoAMD& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_AMD_pipeline_compiler_control

#if VK_VERSION_1_4
struct PipelineRobustnessCreateInfo : VkPipelineRobustnessCreateInfo {
  PipelineRobustnessCreateInfo() noexcept : VkPipelineRobustnessCreateInfo{.sType = VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO} {}

  void setStorageBuffers(PipelineRobustnessBufferBehavior value) { this->storageBuffers = std::bit_cast<VkPipelineRobustnessBufferBehavior>(value); }
  PipelineRobustnessBufferBehavior getStorageBuffers() const { return std::bit_cast<PipelineRobustnessBufferBehavior>(this->storageBuffers); }
  void setUniformBuffers(PipelineRobustnessBufferBehavior value) { this->uniformBuffers = std::bit_cast<VkPipelineRobustnessBufferBehavior>(value); }
  PipelineRobustnessBufferBehavior getUniformBuffers() const { return std::bit_cast<PipelineRobustnessBufferBehavior>(this->uniformBuffers); }
  void setVertexInputs(PipelineRobustnessBufferBehavior value) { this->vertexInputs = std::bit_cast<VkPipelineRobustnessBufferBehavior>(value); }
  PipelineRobustnessBufferBehavior getVertexInputs() const { return std::bit_cast<PipelineRobustnessBufferBehavior>(this->vertexInputs); }
  void setImages(PipelineRobustnessImageBehavior value) { this->images = std::bit_cast<VkPipelineRobustnessImageBehavior>(value); }
  PipelineRobustnessImageBehavior getImages() const { return std::bit_cast<PipelineRobustnessImageBehavior>(this->images); }
};
inline void GraphicsPipelineCreateInfo::attach(PipelineRobustnessCreateInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void ComputePipelineCreateInfo::attach(PipelineRobustnessCreateInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void PipelineShaderStageCreateInfo::attach(PipelineRobustnessCreateInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#if VK_KHR_ray_tracing_pipeline
inline void RayTracingPipelineCreateInfoKHR::attach(PipelineRobustnessCreateInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_ray_tracing_pipeline
#endif // VK_VERSION_1_4

#if VK_NV_cluster_acceleration_structure
struct RayTracingPipelineClusterAccelerationStructureCreateInfoNV : VkRayTracingPipelineClusterAccelerationStructureCreateInfoNV {
  RayTracingPipelineClusterAccelerationStructureCreateInfoNV() noexcept : VkRayTracingPipelineClusterAccelerationStructureCreateInfoNV{.sType = VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CLUSTER_ACCELERATION_STRUCTURE_CREATE_INFO_NV} {}

  void setAllowClusterAccelerationStructure(Bool32 value) { this->allowClusterAccelerationStructure = value; }
  Bool32 getAllowClusterAccelerationStructure() const { return this->allowClusterAccelerationStructure; }
};
inline void RayTracingPipelineCreateInfoKHR::attach(RayTracingPipelineClusterAccelerationStructureCreateInfoNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_cluster_acceleration_structure

#if VK_VERSION_1_4
struct PipelineCreateFlags2CreateInfo : VkPipelineCreateFlags2CreateInfo {
  PipelineCreateFlags2CreateInfo() noexcept : VkPipelineCreateFlags2CreateInfo{.sType = VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO} {}

  void setFlags(PipelineCreateFlags2 value) { this->flags = std::bit_cast<VkPipelineCreateFlags2>(value); }
  PipelineCreateFlags2 getFlags() const { return std::bit_cast<PipelineCreateFlags2>(this->flags); }
};
inline void ComputePipelineCreateInfo::attach(PipelineCreateFlags2CreateInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void GraphicsPipelineCreateInfo::attach(PipelineCreateFlags2CreateInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#if VK_KHR_ray_tracing_pipeline
inline void RayTracingPipelineCreateInfoKHR::attach(PipelineCreateFlags2CreateInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_ray_tracing_pipeline
#endif // VK_VERSION_1_4

#if VK_KHR_pipeline_binary
struct PipelineBinaryInfoKHR : VkPipelineBinaryInfoKHR {
  PipelineBinaryInfoKHR() noexcept : VkPipelineBinaryInfoKHR{.sType = VK_STRUCTURE_TYPE_PIPELINE_BINARY_INFO_KHR} {}

  void setBinaryCount(uint32_t value) { this->binaryCount = value; }
  uint32_t getBinaryCount() const { return this->binaryCount; }
  void setPipelineBinaries(const PipelineBinaryKHR* value) { this->pPipelineBinaries = std::bit_cast<const VkPipelineBinaryKHR*>(value); }
  const PipelineBinaryKHR* getPipelineBinaries() const { return std::bit_cast<const PipelineBinaryKHR*>(this->pPipelineBinaries); }
};
inline void GraphicsPipelineCreateInfo::attach(PipelineBinaryInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void ComputePipelineCreateInfo::attach(PipelineBinaryInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void RayTracingPipelineCreateInfoKHR::attach(PipelineBinaryInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_pipeline_binary

#if VK_VERSION_1_3
struct PipelineCreationFeedbackCreateInfo : VkPipelineCreationFeedbackCreateInfo {
  PipelineCreationFeedbackCreateInfo() noexcept : VkPipelineCreationFeedbackCreateInfo{.sType = VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO} {}

  // Output pipeline creation feedback.
  void setPipelineCreationFeedback(PipelineCreationFeedback* value) { this->pPipelineCreationFeedback = std::bit_cast<VkPipelineCreationFeedback*>(value); }
  PipelineCreationFeedback* getPipelineCreationFeedback() const { return std::bit_cast<PipelineCreationFeedback*>(this->pPipelineCreationFeedback); }

  void setPipelineStageCreationFeedbackCount(uint32_t value) { this->pipelineStageCreationFeedbackCount = value; }
  uint32_t getPipelineStageCreationFeedbackCount() const { return this->pipelineStageCreationFeedbackCount; }
  // One entry for each shader stage specified in the parent Vk*PipelineCreateInfo struct
  void setPipelineStageCreationFeedbacks(PipelineCreationFeedback* value) { this->pPipelineStageCreationFeedbacks = std::bit_cast<VkPipelineCreationFeedback*>(value); }
  PipelineCreationFeedback* getPipelineStageCreationFeedbacks() const { return std::bit_cast<PipelineCreationFeedback*>(this->pPipelineStageCreationFeedbacks); }
};
inline void GraphicsPipelineCreateInfo::attach(PipelineCreationFeedbackCreateInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void ComputePipelineCreateInfo::attach(PipelineCreationFeedbackCreateInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#if VK_KHR_ray_tracing_pipeline
inline void RayTracingPipelineCreateInfoKHR::attach(PipelineCreationFeedbackCreateInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_ray_tracing_pipeline
#if VK_ARM_data_graph
inline void DataGraphPipelineCreateInfoARM::attach(PipelineCreationFeedbackCreateInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_ARM_data_graph
#endif // VK_VERSION_1_3

#if VK_KHR_device_group
using DeviceGroupBindSparseInfoKHR = DeviceGroupBindSparseInfo;
#endif // VK_KHR_device_group

#if VK_VERSION_1_3
struct SubmitInfo2 : VkSubmitInfo2 {
  SubmitInfo2() noexcept : VkSubmitInfo2{.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO_2} {}

  void setFlags(SubmitFlags value) { this->flags = std::bit_cast<VkSubmitFlags>(value); }
  SubmitFlags getFlags() const { return std::bit_cast<SubmitFlags>(this->flags); }
  void setWaitSemaphoreInfoCount(uint32_t value) { this->waitSemaphoreInfoCount = value; }
  uint32_t getWaitSemaphoreInfoCount() const { return this->waitSemaphoreInfoCount; }
  void setWaitSemaphoreInfos(const SemaphoreSubmitInfo* value) { this->pWaitSemaphoreInfos = std::bit_cast<const VkSemaphoreSubmitInfo*>(value); }
  const SemaphoreSubmitInfo* getWaitSemaphoreInfos() const { return std::bit_cast<const SemaphoreSubmitInfo*>(this->pWaitSemaphoreInfos); }
  void setCommandBufferInfoCount(uint32_t value) { this->commandBufferInfoCount = value; }
  uint32_t getCommandBufferInfoCount() const { return this->commandBufferInfoCount; }
  void setCommandBufferInfos(const CommandBufferSubmitInfo* value) { this->pCommandBufferInfos = std::bit_cast<const VkCommandBufferSubmitInfo*>(value); }
  const CommandBufferSubmitInfo* getCommandBufferInfos() const { return std::bit_cast<const CommandBufferSubmitInfo*>(this->pCommandBufferInfos); }
  void setSignalSemaphoreInfoCount(uint32_t value) { this->signalSemaphoreInfoCount = value; }
  uint32_t getSignalSemaphoreInfoCount() const { return this->signalSemaphoreInfoCount; }
  void setSignalSemaphoreInfos(const SemaphoreSubmitInfo* value) { this->pSignalSemaphoreInfos = std::bit_cast<const VkSemaphoreSubmitInfo*>(value); }
  const SemaphoreSubmitInfo* getSignalSemaphoreInfos() const { return std::bit_cast<const SemaphoreSubmitInfo*>(this->pSignalSemaphoreInfos); }

#if VK_NV_win32_keyed_mutex
  void attach(struct Win32KeyedMutexAcquireReleaseInfoNV&);
#endif // VK_NV_win32_keyed_mutex
#if VK_KHR_win32_keyed_mutex
  void attach(struct Win32KeyedMutexAcquireReleaseInfoKHR&);
#endif // VK_KHR_win32_keyed_mutex
#if VK_KHR_performance_query
  void attach(struct PerformanceQuerySubmitInfoKHR&);
#endif // VK_KHR_performance_query
#if VK_EXT_frame_boundary
  void attach(struct FrameBoundaryEXT&);
#endif // VK_EXT_frame_boundary
#if VK_NV_low_latency2
  void attach(struct LatencySubmissionPresentIdNV&);
#endif // VK_NV_low_latency2
#if VK_ARM_tensors
  void attach(struct FrameBoundaryTensorsARM&);
#endif // VK_ARM_tensors
};
#endif // VK_VERSION_1_3

#if VK_ARM_render_pass_striped
struct RenderPassStripeSubmitInfoARM : VkRenderPassStripeSubmitInfoARM {
  RenderPassStripeSubmitInfoARM() noexcept : VkRenderPassStripeSubmitInfoARM{.sType = VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_SUBMIT_INFO_ARM} {}

  void setStripeSemaphoreInfoCount(uint32_t value) { this->stripeSemaphoreInfoCount = value; }
  uint32_t getStripeSemaphoreInfoCount() const { return this->stripeSemaphoreInfoCount; }
  void setStripeSemaphoreInfos(const SemaphoreSubmitInfo* value) { this->pStripeSemaphoreInfos = std::bit_cast<const VkSemaphoreSubmitInfo*>(value); }
  const SemaphoreSubmitInfo* getStripeSemaphoreInfos() const { return std::bit_cast<const SemaphoreSubmitInfo*>(this->pStripeSemaphoreInfos); }
};
inline void CommandBufferSubmitInfo::attach(RenderPassStripeSubmitInfoARM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_ARM_render_pass_striped

#if VK_KHR_synchronization2
using CommandBufferSubmitInfoKHR = CommandBufferSubmitInfo;
#endif // VK_KHR_synchronization2

#if VK_VERSION_1_1
struct DeviceGroupSubmitInfo : VkDeviceGroupSubmitInfo {
  DeviceGroupSubmitInfo() noexcept : VkDeviceGroupSubmitInfo{.sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO} {}

  void setWaitSemaphoreCount(uint32_t value) { this->waitSemaphoreCount = value; }
  uint32_t getWaitSemaphoreCount() const { return this->waitSemaphoreCount; }
  void setWaitSemaphoreDeviceIndices(const uint32_t* value) { this->pWaitSemaphoreDeviceIndices = value; }
  const uint32_t* getWaitSemaphoreDeviceIndices() const { return this->pWaitSemaphoreDeviceIndices; }
  void setCommandBufferCount(uint32_t value) { this->commandBufferCount = value; }
  uint32_t getCommandBufferCount() const { return this->commandBufferCount; }
  void setCommandBufferDeviceMasks(const uint32_t* value) { this->pCommandBufferDeviceMasks = value; }
  const uint32_t* getCommandBufferDeviceMasks() const { return this->pCommandBufferDeviceMasks; }
  void setSignalSemaphoreCount(uint32_t value) { this->signalSemaphoreCount = value; }
  uint32_t getSignalSemaphoreCount() const { return this->signalSemaphoreCount; }
  void setSignalSemaphoreDeviceIndices(const uint32_t* value) { this->pSignalSemaphoreDeviceIndices = value; }
  const uint32_t* getSignalSemaphoreDeviceIndices() const { return this->pSignalSemaphoreDeviceIndices; }
};
inline void SubmitInfo::attach(DeviceGroupSubmitInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_1

#if VK_SEC_amigo_profiling
struct AmigoProfilingSubmitInfoSEC : VkAmigoProfilingSubmitInfoSEC {
  AmigoProfilingSubmitInfoSEC() noexcept : VkAmigoProfilingSubmitInfoSEC{.sType = VK_STRUCTURE_TYPE_AMIGO_PROFILING_SUBMIT_INFO_SEC} {}

  void setFirstDrawTimestamp(uint64_t value) { this->firstDrawTimestamp = value; }
  uint64_t getFirstDrawTimestamp() const { return this->firstDrawTimestamp; }
  void setSwapBufferTimestamp(uint64_t value) { this->swapBufferTimestamp = value; }
  uint64_t getSwapBufferTimestamp() const { return this->swapBufferTimestamp; }
};
inline void SubmitInfo::attach(AmigoProfilingSubmitInfoSEC& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_SEC_amigo_profiling

#if VK_VERSION_1_1
struct ProtectedSubmitInfo : VkProtectedSubmitInfo {
  ProtectedSubmitInfo() noexcept : VkProtectedSubmitInfo{.sType = VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO} {}

  // Submit protected command buffers
  void setProtectedSubmit(Bool32 value) { this->protectedSubmit = value; }
  Bool32 getProtectedSubmit() const { return this->protectedSubmit; }
};
inline void SubmitInfo::attach(ProtectedSubmitInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_1

#if VK_VERSION_1_2
struct TimelineSemaphoreSubmitInfo : VkTimelineSemaphoreSubmitInfo {
  TimelineSemaphoreSubmitInfo() noexcept : VkTimelineSemaphoreSubmitInfo{.sType = VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO} {}

  void setWaitSemaphoreValueCount(uint32_t value) { this->waitSemaphoreValueCount = value; }
  uint32_t getWaitSemaphoreValueCount() const { return this->waitSemaphoreValueCount; }
  void setWaitSemaphoreValues(const uint64_t* value) { this->pWaitSemaphoreValues = value; }
  const uint64_t* getWaitSemaphoreValues() const { return this->pWaitSemaphoreValues; }
  void setSignalSemaphoreValueCount(uint32_t value) { this->signalSemaphoreValueCount = value; }
  uint32_t getSignalSemaphoreValueCount() const { return this->signalSemaphoreValueCount; }
  void setSignalSemaphoreValues(const uint64_t* value) { this->pSignalSemaphoreValues = value; }
  const uint64_t* getSignalSemaphoreValues() const { return this->pSignalSemaphoreValues; }
};
inline void SubmitInfo::attach(TimelineSemaphoreSubmitInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void BindSparseInfo::attach(TimelineSemaphoreSubmitInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_VERSION_1_2

#if VK_KHR_external_semaphore_win32
struct D3D12FenceSubmitInfoKHR : VkD3D12FenceSubmitInfoKHR {
  D3D12FenceSubmitInfoKHR() noexcept : VkD3D12FenceSubmitInfoKHR{.sType = VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR} {}

  void setWaitSemaphoreValuesCount(uint32_t value) { this->waitSemaphoreValuesCount = value; }
  uint32_t getWaitSemaphoreValuesCount() const { return this->waitSemaphoreValuesCount; }
  void setWaitSemaphoreValues(const uint64_t* value) { this->pWaitSemaphoreValues = value; }
  const uint64_t* getWaitSemaphoreValues() const { return this->pWaitSemaphoreValues; }
  void setSignalSemaphoreValuesCount(uint32_t value) { this->signalSemaphoreValuesCount = value; }
  uint32_t getSignalSemaphoreValuesCount() const { return this->signalSemaphoreValuesCount; }
  void setSignalSemaphoreValues(const uint64_t* value) { this->pSignalSemaphoreValues = value; }
  const uint64_t* getSignalSemaphoreValues() const { return this->pSignalSemaphoreValues; }
};
inline void SubmitInfo::attach(D3D12FenceSubmitInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_external_semaphore_win32

#if VK_EXT_pipeline_robustness
using PipelineRobustnessCreateInfoEXT = PipelineRobustnessCreateInfo;
#endif // VK_EXT_pipeline_robustness
#if VK_KHR_maintenance5
using PipelineCreateFlags2CreateInfoKHR = PipelineCreateFlags2CreateInfo;
#endif // VK_KHR_maintenance5
#if VK_EXT_pipeline_creation_feedback
using PipelineCreationFeedbackCreateInfoEXT = PipelineCreationFeedbackCreateInfo;
#endif // VK_EXT_pipeline_creation_feedback

#if VK_ARM_tensors
struct FrameBoundaryTensorsARM : VkFrameBoundaryTensorsARM {
  FrameBoundaryTensorsARM() noexcept : VkFrameBoundaryTensorsARM{.sType = VK_STRUCTURE_TYPE_FRAME_BOUNDARY_TENSORS_ARM} {}

  void setTensorCount(uint32_t value) { this->tensorCount = value; }
  uint32_t getTensorCount() const { return this->tensorCount; }
  void setTensors(const TensorARM* value) { this->pTensors = std::bit_cast<const VkTensorARM*>(value); }
  const TensorARM* getTensors() const { return std::bit_cast<const TensorARM*>(this->pTensors); }
};
inline void SubmitInfo::attach(FrameBoundaryTensorsARM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void SubmitInfo2::attach(FrameBoundaryTensorsARM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void PresentInfoKHR::attach(FrameBoundaryTensorsARM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void BindSparseInfo::attach(FrameBoundaryTensorsARM& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_ARM_tensors

#if VK_KHR_synchronization2
using SubmitInfo2KHR = SubmitInfo2;
#endif // VK_KHR_synchronization2

#if VK_KHR_performance_query
struct PerformanceQuerySubmitInfoKHR : VkPerformanceQuerySubmitInfoKHR {
  PerformanceQuerySubmitInfoKHR() noexcept : VkPerformanceQuerySubmitInfoKHR{.sType = VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR} {}

  // Index for which counter pass to submit
  void setCounterPassIndex(uint32_t value) { this->counterPassIndex = value; }
  uint32_t getCounterPassIndex() const { return this->counterPassIndex; }
};
inline void SubmitInfo::attach(PerformanceQuerySubmitInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void SubmitInfo2::attach(PerformanceQuerySubmitInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_performance_query

#if VK_NV_low_latency2
struct LatencySubmissionPresentIdNV : VkLatencySubmissionPresentIdNV {
  LatencySubmissionPresentIdNV() noexcept : VkLatencySubmissionPresentIdNV{.sType = VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV} {}

  void setPresentID(uint64_t value) { this->presentID = value; }
  uint64_t getPresentID() const { return this->presentID; }
};
inline void SubmitInfo::attach(LatencySubmissionPresentIdNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void SubmitInfo2::attach(LatencySubmissionPresentIdNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_low_latency2

#if VK_EXT_frame_boundary
struct FrameBoundaryEXT : VkFrameBoundaryEXT {
  FrameBoundaryEXT() noexcept : VkFrameBoundaryEXT{.sType = VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT} {}

  void setFrameID(uint64_t value) { this->frameID = value; }
  uint64_t getFrameID() const { return this->frameID; }

  void setFlags(FrameBoundaryFlagsEXT value) { this->flags = std::bit_cast<VkFrameBoundaryFlagsEXT>(value); }
  FrameBoundaryFlagsEXT getFlags() const { return std::bit_cast<FrameBoundaryFlagsEXT>(this->flags); }
  void setImageCount(uint32_t value) { this->imageCount = value; }
  uint32_t getImageCount() const { return this->imageCount; }
  void setImages(const Image* value) { this->pImages = std::bit_cast<const VkImage*>(value); }
  const Image* getImages() const { return std::bit_cast<const Image*>(this->pImages); }
  void setBufferCount(uint32_t value) { this->bufferCount = value; }
  uint32_t getBufferCount() const { return this->bufferCount; }
  void setBuffers(const Buffer* value) { this->pBuffers = std::bit_cast<const VkBuffer*>(value); }
  const Buffer* getBuffers() const { return std::bit_cast<const Buffer*>(this->pBuffers); }
  void setTagName(uint64_t value) { this->tagName = value; }
  uint64_t getTagName() const { return this->tagName; }
  void setTagSize(size_t value) { this->tagSize = value; }
  size_t getTagSize() const { return this->tagSize; }
  void setTag(const void* value) { this->pTag = value; }
  const void* getTag() const { return this->pTag; }
};
inline void SubmitInfo::attach(FrameBoundaryEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void SubmitInfo2::attach(FrameBoundaryEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void PresentInfoKHR::attach(FrameBoundaryEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void BindSparseInfo::attach(FrameBoundaryEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_frame_boundary

#if VK_VERSION_1_0
struct Queue : Handle<VkQueue, ObjectType::eQueue> {
  Result submit(uint32_t submitCount = {}, const SubmitInfo* pSubmits = {}, Fence fence = {}) const { return Result(vkQueueSubmit(this->handle, submitCount, std::bit_cast<const VkSubmitInfo*>(pSubmits), std::bit_cast<VkFence>(fence))); }
  Result waitIdle() const { return Result(vkQueueWaitIdle(this->handle)); }
  Result bindSparse(uint32_t bindInfoCount = {}, const BindSparseInfo* pBindInfo = {}, Fence fence = {}) const { return Result(vkQueueBindSparse(this->handle, bindInfoCount, std::bit_cast<const VkBindSparseInfo*>(pBindInfo), std::bit_cast<VkFence>(fence))); }
#if VK_KHR_swapchain
  Result presentKHR(const PresentInfoKHR& presentInfo) const { return Result(vkQueuePresentKHR(this->handle, std::bit_cast<const VkPresentInfoKHR*>(&presentInfo))); }
#endif // VK_KHR_swapchain
#if VK_EXT_debug_utils
  void beginDebugUtilsLabelEXT(const DebugUtilsLabelEXT& labelInfo) const { vkQueueBeginDebugUtilsLabelEXT(this->handle, std::bit_cast<const VkDebugUtilsLabelEXT*>(&labelInfo)); }
  void endDebugUtilsLabelEXT() const { vkQueueEndDebugUtilsLabelEXT(this->handle); }
  void insertDebugUtilsLabelEXT(const DebugUtilsLabelEXT& labelInfo) const { vkQueueInsertDebugUtilsLabelEXT(this->handle, std::bit_cast<const VkDebugUtilsLabelEXT*>(&labelInfo)); }
#endif // VK_EXT_debug_utils
#if VK_NV_device_diagnostic_checkpoints
  void getCheckpointDataNV(uint32_t* pCheckpointDataCount, CheckpointDataNV* pCheckpointData = {}) const { vkGetQueueCheckpointDataNV(this->handle, pCheckpointDataCount, std::bit_cast<VkCheckpointDataNV*>(pCheckpointData)); }
#endif // VK_NV_device_diagnostic_checkpoints
#if VK_INTEL_performance_query
  Result setPerformanceConfigurationINTEL(PerformanceConfigurationINTEL configuration) const { return Result(vkQueueSetPerformanceConfigurationINTEL(this->handle, std::bit_cast<VkPerformanceConfigurationINTEL>(configuration))); }
#endif // VK_INTEL_performance_query
#if VK_VERSION_1_3
  Result submit2(uint32_t submitCount = {}, const SubmitInfo2* pSubmits = {}, Fence fence = {}) const { return Result(vkQueueSubmit2(this->handle, submitCount, std::bit_cast<const VkSubmitInfo2*>(pSubmits), std::bit_cast<VkFence>(fence))); }
#endif // VK_VERSION_1_3
#if VK_KHR_synchronization2
  Result submit2KHR(uint32_t submitCount = {}, const SubmitInfo2* pSubmits = {}, Fence fence = {}) const { return Result(vkQueueSubmit2KHR(this->handle, submitCount, std::bit_cast<const VkSubmitInfo2*>(pSubmits), std::bit_cast<VkFence>(fence))); }
#endif // VK_KHR_synchronization2
#if VK_NV_low_latency2
  void notifyOutOfBandNV(const OutOfBandQueueTypeInfoNV& queueTypeInfo) const { vkQueueNotifyOutOfBandNV(this->handle, std::bit_cast<const VkOutOfBandQueueTypeInfoNV*>(&queueTypeInfo)); }
#endif // VK_NV_low_latency2
};
#endif // VK_VERSION_1_0

#if VK_KHR_win32_keyed_mutex
struct Win32KeyedMutexAcquireReleaseInfoKHR : VkWin32KeyedMutexAcquireReleaseInfoKHR {
  Win32KeyedMutexAcquireReleaseInfoKHR() noexcept : VkWin32KeyedMutexAcquireReleaseInfoKHR{.sType = VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR} {}

  void setAcquireCount(uint32_t value) { this->acquireCount = value; }
  uint32_t getAcquireCount() const { return this->acquireCount; }
  void setAcquireSyncs(const DeviceMemory* value) { this->pAcquireSyncs = std::bit_cast<const VkDeviceMemory*>(value); }
  const DeviceMemory* getAcquireSyncs() const { return std::bit_cast<const DeviceMemory*>(this->pAcquireSyncs); }
  void setAcquireKeys(const uint64_t* value) { this->pAcquireKeys = value; }
  const uint64_t* getAcquireKeys() const { return this->pAcquireKeys; }
  void setAcquireTimeouts(const uint32_t* value) { this->pAcquireTimeouts = value; }
  const uint32_t* getAcquireTimeouts() const { return this->pAcquireTimeouts; }
  void setReleaseCount(uint32_t value) { this->releaseCount = value; }
  uint32_t getReleaseCount() const { return this->releaseCount; }
  void setReleaseSyncs(const DeviceMemory* value) { this->pReleaseSyncs = std::bit_cast<const VkDeviceMemory*>(value); }
  const DeviceMemory* getReleaseSyncs() const { return std::bit_cast<const DeviceMemory*>(this->pReleaseSyncs); }
  void setReleaseKeys(const uint64_t* value) { this->pReleaseKeys = value; }
  const uint64_t* getReleaseKeys() const { return this->pReleaseKeys; }
};
inline void SubmitInfo::attach(Win32KeyedMutexAcquireReleaseInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void SubmitInfo2::attach(Win32KeyedMutexAcquireReleaseInfoKHR& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_KHR_win32_keyed_mutex

#if VK_NV_win32_keyed_mutex
struct Win32KeyedMutexAcquireReleaseInfoNV : VkWin32KeyedMutexAcquireReleaseInfoNV {
  Win32KeyedMutexAcquireReleaseInfoNV() noexcept : VkWin32KeyedMutexAcquireReleaseInfoNV{.sType = VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV} {}

  void setAcquireCount(uint32_t value) { this->acquireCount = value; }
  uint32_t getAcquireCount() const { return this->acquireCount; }
  void setAcquireSyncs(const DeviceMemory* value) { this->pAcquireSyncs = std::bit_cast<const VkDeviceMemory*>(value); }
  const DeviceMemory* getAcquireSyncs() const { return std::bit_cast<const DeviceMemory*>(this->pAcquireSyncs); }
  void setAcquireKeys(const uint64_t* value) { this->pAcquireKeys = value; }
  const uint64_t* getAcquireKeys() const { return this->pAcquireKeys; }
  void setAcquireTimeoutMilliseconds(const uint32_t* value) { this->pAcquireTimeoutMilliseconds = value; }
  const uint32_t* getAcquireTimeoutMilliseconds() const { return this->pAcquireTimeoutMilliseconds; }
  void setReleaseCount(uint32_t value) { this->releaseCount = value; }
  uint32_t getReleaseCount() const { return this->releaseCount; }
  void setReleaseSyncs(const DeviceMemory* value) { this->pReleaseSyncs = std::bit_cast<const VkDeviceMemory*>(value); }
  const DeviceMemory* getReleaseSyncs() const { return std::bit_cast<const DeviceMemory*>(this->pReleaseSyncs); }
  void setReleaseKeys(const uint64_t* value) { this->pReleaseKeys = value; }
  const uint64_t* getReleaseKeys() const { return this->pReleaseKeys; }
};
inline void SubmitInfo::attach(Win32KeyedMutexAcquireReleaseInfoNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
inline void SubmitInfo2::attach(Win32KeyedMutexAcquireReleaseInfoNV& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_NV_win32_keyed_mutex

#if VK_KHR_device_group
using DeviceGroupSubmitInfoKHR = DeviceGroupSubmitInfo;
#endif // VK_KHR_device_group
#if VK_KHR_timeline_semaphore
using TimelineSemaphoreSubmitInfoKHR = TimelineSemaphoreSubmitInfo;
#endif // VK_KHR_timeline_semaphore

#if VK_EXT_metal_objects
struct ExportMetalCommandQueueInfoEXT : VkExportMetalCommandQueueInfoEXT {
  ExportMetalCommandQueueInfoEXT() noexcept : VkExportMetalCommandQueueInfoEXT{.sType = VK_STRUCTURE_TYPE_EXPORT_METAL_COMMAND_QUEUE_INFO_EXT} {}

  void setQueue(Queue value) { this->queue = std::bit_cast<VkQueue>(value); }
  Queue getQueue() const { return std::bit_cast<Queue>(this->queue); }
  void setMtlCommandQueue(MTLCommandQueue_id value) { this->mtlCommandQueue = value; }
  MTLCommandQueue_id getMtlCommandQueue() const { return this->mtlCommandQueue; }
};
inline void ExportMetalObjectsInfoEXT::attach(ExportMetalCommandQueueInfoEXT& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }
#endif // VK_EXT_metal_objects

#if VK_NV_external_compute_queue
struct ExternalComputeQueueCreateInfoNV : VkExternalComputeQueueCreateInfoNV {
  ExternalComputeQueueCreateInfoNV() noexcept : VkExternalComputeQueueCreateInfoNV{.sType = VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_CREATE_INFO_NV} {}

  void setPreferredQueue(Queue value) { this->preferredQueue = std::bit_cast<VkQueue>(value); }
  Queue getPreferredQueue() const { return std::bit_cast<Queue>(this->preferredQueue); }
};
#endif // VK_NV_external_compute_queue

#if VK_VERSION_1_0
struct Device : Handle<VkDevice, ObjectType::eDevice> {
  PFN_vkVoidFunction getProcAddr(const char* pName) const { return vkGetDeviceProcAddr(this->handle, pName); }
  void destroy(const AllocationCallbacks* pAllocator = {}) const { vkDestroyDevice(this->handle, std::bit_cast<const VkAllocationCallbacks*>(pAllocator)); }
  Queue getQueue(uint32_t queueFamilyIndex, uint32_t queueIndex) const { Queue value; vkGetDeviceQueue(this->handle, queueFamilyIndex, queueIndex, std::bit_cast<VkQueue*>(&value)); return value; }
  Result waitIdle() const { return Result(vkDeviceWaitIdle(this->handle)); }
  Ret<DeviceMemory> allocateMemory(const MemoryAllocateInfo& allocateInfo, const AllocationCallbacks* pAllocator = {}) const { DeviceMemory value; return {Result(vkAllocateMemory(this->handle, std::bit_cast<const VkMemoryAllocateInfo*>(&allocateInfo), std::bit_cast<const VkAllocationCallbacks*>(pAllocator), std::bit_cast<VkDeviceMemory*>(&value))), value}; }
  void freeMemory(DeviceMemory memory = {}, const AllocationCallbacks* pAllocator = {}) const { vkFreeMemory(this->handle, std::bit_cast<VkDeviceMemory>(memory), std::bit_cast<const VkAllocationCallbacks*>(pAllocator)); }
  Ret<void*> mapMemory(DeviceMemory memory, DeviceSize offset, DeviceSize size, MemoryMapFlags flags = {}) const { void* value; return {Result(vkMapMemory(this->handle, std::bit_cast<VkDeviceMemory>(memory), offset, size, std::bit_cast<VkMemoryMapFlags>(flags), &value)), value}; }
  void unmapMemory(DeviceMemory memory) const { vkUnmapMemory(this->handle, std::bit_cast<VkDeviceMemory>(memory)); }
  Result flushMappedMemoryRanges(uint32_t memoryRangeCount, const MappedMemoryRange* pMemoryRanges) const { return Result(vkFlushMappedMemoryRanges(this->handle, memoryRangeCount, std::bit_cast<const VkMappedMemoryRange*>(pMemoryRanges))); }
  Result invalidateMappedMemoryRanges(uint32_t memoryRangeCount, const MappedMemoryRange* pMemoryRanges) const { return Result(vkInvalidateMappedMemoryRanges(this->handle, memoryRangeCount, std::bit_cast<const VkMappedMemoryRange*>(pMemoryRanges))); }
  DeviceSize getMemoryCommitment(DeviceMemory memory) const { DeviceSize value; vkGetDeviceMemoryCommitment(this->handle, std::bit_cast<VkDeviceMemory>(memory), &value); return value; }
  void getBufferMemoryRequirements(Buffer buffer, MemoryRequirements* pMemoryRequirements) const { vkGetBufferMemoryRequirements(this->handle, std::bit_cast<VkBuffer>(buffer), std::bit_cast<VkMemoryRequirements*>(pMemoryRequirements)); }
  Result bindBufferMemory(Buffer buffer, DeviceMemory memory, DeviceSize memoryOffset) const { return Result(vkBindBufferMemory(this->handle, std::bit_cast<VkBuffer>(buffer), std::bit_cast<VkDeviceMemory>(memory), memoryOffset)); }
  void getImageMemoryRequirements(Image image, MemoryRequirements* pMemoryRequirements) const { vkGetImageMemoryRequirements(this->handle, std::bit_cast<VkImage>(image), std::bit_cast<VkMemoryRequirements*>(pMemoryRequirements)); }
  Result bindImageMemory(Image image, DeviceMemory memory, DeviceSize memoryOffset) const { return Result(vkBindImageMemory(this->handle, std::bit_cast<VkImage>(image), std::bit_cast<VkDeviceMemory>(memory), memoryOffset)); }
  void getImageSparseMemoryRequirements(Image image, uint32_t* pSparseMemoryRequirementCount, SparseImageMemoryRequirements* pSparseMemoryRequirements = {}) const { vkGetImageSparseMemoryRequirements(this->handle, std::bit_cast<VkImage>(image), pSparseMemoryRequirementCount, std::bit_cast<VkSparseImageMemoryRequirements*>(pSparseMemoryRequirements)); }
  Ret<Fence> createFence(const FenceCreateInfo& createInfo, const AllocationCallbacks* pAllocator = {}) const { Fence value; return {Result(vkCreateFence(this->handle, std::bit_cast<const VkFenceCreateInfo*>(&createInfo), std::bit_cast<const VkAllocationCallbacks*>(pAllocator), std::bit_cast<VkFence*>(&value))), value}; }
  void destroyFence(Fence fence = {}, const AllocationCallbacks* pAllocator = {}) const { vkDestroyFence(this->handle, std::bit_cast<VkFence>(fence), std::bit_cast<const VkAllocationCallbacks*>(pAllocator)); }
  Result resetFences(uint32_t fenceCount, const Fence* pFences) const { return Result(vkResetFences(this->handle, fenceCount, std::bit_cast<const VkFence*>(pFences))); }
  Result getFenceStatus(Fence fence) const { return Result(vkGetFenceStatus(this->handle, std::bit_cast<VkFence>(fence))); }
  Result waitForFences(uint32_t fenceCount, const Fence* pFences, Bool32 waitAll, uint64_t timeout) const { return Result(vkWaitForFences(this->handle, fenceCount, std::bit_cast<const VkFence*>(pFences), waitAll, timeout)); }
  Ret<Semaphore> createSemaphore(const SemaphoreCreateInfo& createInfo, const AllocationCallbacks* pAllocator = {}) const { Semaphore value; return {Result(vkCreateSemaphore(this->handle, std::bit_cast<const VkSemaphoreCreateInfo*>(&createInfo), std::bit_cast<const VkAllocationCallbacks*>(pAllocator), std::bit_cast<VkSemaphore*>(&value))), value}; }
  void destroySemaphore(Semaphore semaphore = {}, const AllocationCallbacks* pAllocator = {}) const { vkDestroySemaphore(this->handle, std::bit_cast<VkSemaphore>(semaphore), std::bit_cast<const VkAllocationCallbacks*>(pAllocator)); }
  Ret<Event> createEvent(const EventCreateInfo& createInfo, const AllocationCallbacks* pAllocator = {}) const { Event value; return {Result(vkCreateEvent(this->handle, std::bit_cast<const VkEventCreateInfo*>(&createInfo), std::bit_cast<const VkAllocationCallbacks*>(pAllocator), std::bit_cast<VkEvent*>(&value))), value}; }
  void destroyEvent(Event event = {}, const AllocationCallbacks* pAllocator = {}) const { vkDestroyEvent(this->handle, std::bit_cast<VkEvent>(event), std::bit_cast<const VkAllocationCallbacks*>(pAllocator)); }
  Result getEventStatus(Event event) const { return Result(vkGetEventStatus(this->handle, std::bit_cast<VkEvent>(event))); }
  Result setEvent(Event event) const { return Result(vkSetEvent(this->handle, std::bit_cast<VkEvent>(event))); }
  Result resetEvent(Event event) const { return Result(vkResetEvent(this->handle, std::bit_cast<VkEvent>(event))); }
  Ret<QueryPool> createQueryPool(const QueryPoolCreateInfo& createInfo, const AllocationCallbacks* pAllocator = {}) const { QueryPool value; return {Result(vkCreateQueryPool(this->handle, std::bit_cast<const VkQueryPoolCreateInfo*>(&createInfo), std::bit_cast<const VkAllocationCallbacks*>(pAllocator), std::bit_cast<VkQueryPool*>(&value))), value}; }
  void destroyQueryPool(QueryPool queryPool = {}, const AllocationCallbacks* pAllocator = {}) const { vkDestroyQueryPool(this->handle, std::bit_cast<VkQueryPool>(queryPool), std::bit_cast<const VkAllocationCallbacks*>(pAllocator)); }
  Result getQueryPoolResults(QueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, size_t dataSize, void* pData, DeviceSize stride, QueryResultFlags flags = {}) const { return Result(vkGetQueryPoolResults(this->handle, std::bit_cast<VkQueryPool>(queryPool), firstQuery, queryCount, dataSize, pData, stride, std::bit_cast<VkQueryResultFlags>(flags))); }
#if VK_VERSION_1_2
  void resetQueryPool(QueryPool queryPool, uint32_t firstQuery, uint32_t queryCount) const { vkResetQueryPool(this->handle, std::bit_cast<VkQueryPool>(queryPool), firstQuery, queryCount); }
#endif // VK_VERSION_1_2
#if VK_EXT_host_query_reset
  void resetQueryPoolEXT(QueryPool queryPool, uint32_t firstQuery, uint32_t queryCount) const { vkResetQueryPoolEXT(this->handle, std::bit_cast<VkQueryPool>(queryPool), firstQuery, queryCount); }
#endif // VK_EXT_host_query_reset
  Ret<Buffer> createBuffer(const BufferCreateInfo& createInfo, const AllocationCallbacks* pAllocator = {}) const { Buffer value; return {Result(vkCreateBuffer(this->handle, std::bit_cast<const VkBufferCreateInfo*>(&createInfo), std::bit_cast<const VkAllocationCallbacks*>(pAllocator), std::bit_cast<VkBuffer*>(&value))), value}; }
  void destroyBuffer(Buffer buffer = {}, const AllocationCallbacks* pAllocator = {}) const { vkDestroyBuffer(this->handle, std::bit_cast<VkBuffer>(buffer), std::bit_cast<const VkAllocationCallbacks*>(pAllocator)); }
  Ret<BufferView> createBufferView(const BufferViewCreateInfo& createInfo, const AllocationCallbacks* pAllocator = {}) const { BufferView value; return {Result(vkCreateBufferView(this->handle, std::bit_cast<const VkBufferViewCreateInfo*>(&createInfo), std::bit_cast<const VkAllocationCallbacks*>(pAllocator), std::bit_cast<VkBufferView*>(&value))), value}; }
  void destroyBufferView(BufferView bufferView = {}, const AllocationCallbacks* pAllocator = {}) const { vkDestroyBufferView(this->handle, std::bit_cast<VkBufferView>(bufferView), std::bit_cast<const VkAllocationCallbacks*>(pAllocator)); }
  Ret<Image> createImage(const ImageCreateInfo& createInfo, const AllocationCallbacks* pAllocator = {}) const { Image value; return {Result(vkCreateImage(this->handle, std::bit_cast<const VkImageCreateInfo*>(&createInfo), std::bit_cast<const VkAllocationCallbacks*>(pAllocator), std::bit_cast<VkImage*>(&value))), value}; }
  void destroyImage(Image image = {}, const AllocationCallbacks* pAllocator = {}) const { vkDestroyImage(this->handle, std::bit_cast<VkImage>(image), std::bit_cast<const VkAllocationCallbacks*>(pAllocator)); }
  void getImageSubresourceLayout(Image image, const ImageSubresource& subresource, SubresourceLayout* pLayout) const { vkGetImageSubresourceLayout(this->handle, std::bit_cast<VkImage>(image), std::bit_cast<const VkImageSubresource*>(&subresource), std::bit_cast<VkSubresourceLayout*>(pLayout)); }
  Ret<ImageView> createImageView(const ImageViewCreateInfo& createInfo, const AllocationCallbacks* pAllocator = {}) const { ImageView value; return {Result(vkCreateImageView(this->handle, std::bit_cast<const VkImageViewCreateInfo*>(&createInfo), std::bit_cast<const VkAllocationCallbacks*>(pAllocator), std::bit_cast<VkImageView*>(&value))), value}; }
  void destroyImageView(ImageView imageView = {}, const AllocationCallbacks* pAllocator = {}) const { vkDestroyImageView(this->handle, std::bit_cast<VkImageView>(imageView), std::bit_cast<const VkAllocationCallbacks*>(pAllocator)); }
  Ret<ShaderModule> createShaderModule(const ShaderModuleCreateInfo& createInfo, const AllocationCallbacks* pAllocator = {}) const { ShaderModule value; return {Result(vkCreateShaderModule(this->handle, std::bit_cast<const VkShaderModuleCreateInfo*>(&createInfo), std::bit_cast<const VkAllocationCallbacks*>(pAllocator), std::bit_cast<VkShaderModule*>(&value))), value}; }
  void destroyShaderModule(ShaderModule shaderModule = {}, const AllocationCallbacks* pAllocator = {}) const { vkDestroyShaderModule(this->handle, std::bit_cast<VkShaderModule>(shaderModule), std::bit_cast<const VkAllocationCallbacks*>(pAllocator)); }
  Ret<PipelineCache> createPipelineCache(const PipelineCacheCreateInfo& createInfo, const AllocationCallbacks* pAllocator = {}) const { PipelineCache value; return {Result(vkCreatePipelineCache(this->handle, std::bit_cast<const VkPipelineCacheCreateInfo*>(&createInfo), std::bit_cast<const VkAllocationCallbacks*>(pAllocator), std::bit_cast<VkPipelineCache*>(&value))), value}; }
  void destroyPipelineCache(PipelineCache pipelineCache = {}, const AllocationCallbacks* pAllocator = {}) const { vkDestroyPipelineCache(this->handle, std::bit_cast<VkPipelineCache>(pipelineCache), std::bit_cast<const VkAllocationCallbacks*>(pAllocator)); }
  Result getPipelineCacheData(PipelineCache pipelineCache, size_t* pDataSize, void* pData = {}) const { return Result(vkGetPipelineCacheData(this->handle, std::bit_cast<VkPipelineCache>(pipelineCache), pDataSize, pData)); }
  Result mergePipelineCaches(PipelineCache dstCache, uint32_t srcCacheCount, const PipelineCache* pSrcCaches) const { return Result(vkMergePipelineCaches(this->handle, std::bit_cast<VkPipelineCache>(dstCache), srcCacheCount, std::bit_cast<const VkPipelineCache*>(pSrcCaches))); }
#if VK_KHR_pipeline_binary
  Result createPipelineBinariesKHR(const PipelineBinaryCreateInfoKHR& createInfo, PipelineBinaryHandlesInfoKHR* pBinaries, const AllocationCallbacks* pAllocator = {}) const { return Result(vkCreatePipelineBinariesKHR(this->handle, std::bit_cast<const VkPipelineBinaryCreateInfoKHR*>(&createInfo), std::bit_cast<const VkAllocationCallbacks*>(pAllocator), std::bit_cast<VkPipelineBinaryHandlesInfoKHR*>(pBinaries))); }
  void destroyPipelineBinaryKHR(PipelineBinaryKHR pipelineBinary = {}, const AllocationCallbacks* pAllocator = {}) const { vkDestroyPipelineBinaryKHR(this->handle, std::bit_cast<VkPipelineBinaryKHR>(pipelineBinary), std::bit_cast<const VkAllocationCallbacks*>(pAllocator)); }
  Result getPipelineKeyKHR(const PipelineCreateInfoKHR* pPipelineCreateInfo, PipelineBinaryKeyKHR* pPipelineKey) const { return Result(vkGetPipelineKeyKHR(this->handle, std::bit_cast<const VkPipelineCreateInfoKHR*>(pPipelineCreateInfo), std::bit_cast<VkPipelineBinaryKeyKHR*>(pPipelineKey))); }
  Result getPipelineBinaryDataKHR(const PipelineBinaryDataInfoKHR& info, PipelineBinaryKeyKHR* pPipelineBinaryKey, size_t* pPipelineBinaryDataSize, void* pPipelineBinaryData = {}) const { return Result(vkGetPipelineBinaryDataKHR(this->handle, std::bit_cast<const VkPipelineBinaryDataInfoKHR*>(&info), std::bit_cast<VkPipelineBinaryKeyKHR*>(pPipelineBinaryKey), pPipelineBinaryDataSize, pPipelineBinaryData)); }
  Result releaseCapturedPipelineDataKHR(const ReleaseCapturedPipelineDataInfoKHR& info, const AllocationCallbacks* pAllocator = {}) const { return Result(vkReleaseCapturedPipelineDataKHR(this->handle, std::bit_cast<const VkReleaseCapturedPipelineDataInfoKHR*>(&info), std::bit_cast<const VkAllocationCallbacks*>(pAllocator))); }
#endif // VK_KHR_pipeline_binary
  Result createGraphicsPipelines(PipelineCache pipelineCache, uint32_t createInfoCount, const GraphicsPipelineCreateInfo* pCreateInfos, Pipeline* pPipelines, const AllocationCallbacks* pAllocator = {}) const { return Result(vkCreateGraphicsPipelines(this->handle, std::bit_cast<VkPipelineCache>(pipelineCache), createInfoCount, std::bit_cast<const VkGraphicsPipelineCreateInfo*>(pCreateInfos), std::bit_cast<const VkAllocationCallbacks*>(pAllocator), std::bit_cast<VkPipeline*>(pPipelines))); }
  Result createComputePipelines(PipelineCache pipelineCache, uint32_t createInfoCount, const ComputePipelineCreateInfo* pCreateInfos, Pipeline* pPipelines, const AllocationCallbacks* pAllocator = {}) const { return Result(vkCreateComputePipelines(this->handle, std::bit_cast<VkPipelineCache>(pipelineCache), createInfoCount, std::bit_cast<const VkComputePipelineCreateInfo*>(pCreateInfos), std::bit_cast<const VkAllocationCallbacks*>(pAllocator), std::bit_cast<VkPipeline*>(pPipelines))); }
#if VK_HUAWEI_subpass_shading
  Result getSubpassShadingMaxWorkgroupSizeHUAWEI(RenderPass renderpass, Extent2D* pMaxWorkgroupSize) const { return Result(vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI(this->handle, std::bit_cast<VkRenderPass>(renderpass), std::bit_cast<VkExtent2D*>(pMaxWorkgroupSize))); }
#endif // VK_HUAWEI_subpass_shading
  void destroyPipeline(Pipeline pipeline = {}, const AllocationCallbacks* pAllocator = {}) const { vkDestroyPipeline(this->handle, std::bit_cast<VkPipeline>(pipeline), std::bit_cast<const VkAllocationCallbacks*>(pAllocator)); }
  Ret<PipelineLayout> createPipelineLayout(const PipelineLayoutCreateInfo& createInfo, const AllocationCallbacks* pAllocator = {}) const { PipelineLayout value; return {Result(vkCreatePipelineLayout(this->handle, std::bit_cast<const VkPipelineLayoutCreateInfo*>(&createInfo), std::bit_cast<const VkAllocationCallbacks*>(pAllocator), std::bit_cast<VkPipelineLayout*>(&value))), value}; }
  void destroyPipelineLayout(PipelineLayout pipelineLayout = {}, const AllocationCallbacks* pAllocator = {}) const { vkDestroyPipelineLayout(this->handle, std::bit_cast<VkPipelineLayout>(pipelineLayout), std::bit_cast<const VkAllocationCallbacks*>(pAllocator)); }
  Ret<Sampler> createSampler(const SamplerCreateInfo& createInfo, const AllocationCallbacks* pAllocator = {}) const { Sampler value; return {Result(vkCreateSampler(this->handle, std::bit_cast<const VkSamplerCreateInfo*>(&createInfo), std::bit_cast<const VkAllocationCallbacks*>(pAllocator), std::bit_cast<VkSampler*>(&value))), value}; }
  void destroySampler(Sampler sampler = {}, const AllocationCallbacks* pAllocator = {}) const { vkDestroySampler(this->handle, std::bit_cast<VkSampler>(sampler), std::bit_cast<const VkAllocationCallbacks*>(pAllocator)); }
  Ret<DescriptorSetLayout> createDescriptorSetLayout(const DescriptorSetLayoutCreateInfo& createInfo, const AllocationCallbacks* pAllocator = {}) const { DescriptorSetLayout value; return {Result(vkCreateDescriptorSetLayout(this->handle, std::bit_cast<const VkDescriptorSetLayoutCreateInfo*>(&createInfo), std::bit_cast<const VkAllocationCallbacks*>(pAllocator), std::bit_cast<VkDescriptorSetLayout*>(&value))), value}; }
  void destroyDescriptorSetLayout(DescriptorSetLayout descriptorSetLayout = {}, const AllocationCallbacks* pAllocator = {}) const { vkDestroyDescriptorSetLayout(this->handle, std::bit_cast<VkDescriptorSetLayout>(descriptorSetLayout), std::bit_cast<const VkAllocationCallbacks*>(pAllocator)); }
  Ret<DescriptorPool> createDescriptorPool(const DescriptorPoolCreateInfo& createInfo, const AllocationCallbacks* pAllocator = {}) const { DescriptorPool value; return {Result(vkCreateDescriptorPool(this->handle, std::bit_cast<const VkDescriptorPoolCreateInfo*>(&createInfo), std::bit_cast<const VkAllocationCallbacks*>(pAllocator), std::bit_cast<VkDescriptorPool*>(&value))), value}; }
  void destroyDescriptorPool(DescriptorPool descriptorPool = {}, const AllocationCallbacks* pAllocator = {}) const { vkDestroyDescriptorPool(this->handle, std::bit_cast<VkDescriptorPool>(descriptorPool), std::bit_cast<const VkAllocationCallbacks*>(pAllocator)); }
  Result resetDescriptorPool(DescriptorPool descriptorPool, DescriptorPoolResetFlags flags = {}) const { return Result(vkResetDescriptorPool(this->handle, std::bit_cast<VkDescriptorPool>(descriptorPool), std::bit_cast<VkDescriptorPoolResetFlags>(flags))); }
  Result allocateDescriptorSets(const DescriptorSetAllocateInfo& allocateInfo, DescriptorSet* pDescriptorSets) const { return Result(vkAllocateDescriptorSets(this->handle, std::bit_cast<const VkDescriptorSetAllocateInfo*>(&allocateInfo), std::bit_cast<VkDescriptorSet*>(pDescriptorSets))); }
  Result freeDescriptorSets(DescriptorPool descriptorPool, uint32_t descriptorSetCount, const DescriptorSet* pDescriptorSets) const { return Result(vkFreeDescriptorSets(this->handle, std::bit_cast<VkDescriptorPool>(descriptorPool), descriptorSetCount, std::bit_cast<const VkDescriptorSet*>(pDescriptorSets))); }
  void updateDescriptorSets(uint32_t descriptorWriteCount = {}, const WriteDescriptorSet* pDescriptorWrites = {}, uint32_t descriptorCopyCount = {}, const CopyDescriptorSet* pDescriptorCopies = {}) const { vkUpdateDescriptorSets(this->handle, descriptorWriteCount, std::bit_cast<const VkWriteDescriptorSet*>(pDescriptorWrites), descriptorCopyCount, std::bit_cast<const VkCopyDescriptorSet*>(pDescriptorCopies)); }
  Ret<Framebuffer> createFramebuffer(const FramebufferCreateInfo& createInfo, const AllocationCallbacks* pAllocator = {}) const { Framebuffer value; return {Result(vkCreateFramebuffer(this->handle, std::bit_cast<const VkFramebufferCreateInfo*>(&createInfo), std::bit_cast<const VkAllocationCallbacks*>(pAllocator), std::bit_cast<VkFramebuffer*>(&value))), value}; }
  void destroyFramebuffer(Framebuffer framebuffer = {}, const AllocationCallbacks* pAllocator = {}) const { vkDestroyFramebuffer(this->handle, std::bit_cast<VkFramebuffer>(framebuffer), std::bit_cast<const VkAllocationCallbacks*>(pAllocator)); }
  Ret<RenderPass> createRenderPass(const RenderPassCreateInfo& createInfo, const AllocationCallbacks* pAllocator = {}) const { RenderPass value; return {Result(vkCreateRenderPass(this->handle, std::bit_cast<const VkRenderPassCreateInfo*>(&createInfo), std::bit_cast<const VkAllocationCallbacks*>(pAllocator), std::bit_cast<VkRenderPass*>(&value))), value}; }
  void destroyRenderPass(RenderPass renderPass = {}, const AllocationCallbacks* pAllocator = {}) const { vkDestroyRenderPass(this->handle, std::bit_cast<VkRenderPass>(renderPass), std::bit_cast<const VkAllocationCallbacks*>(pAllocator)); }
  void getRenderAreaGranularity(RenderPass renderPass, Extent2D* pGranularity) const { vkGetRenderAreaGranularity(this->handle, std::bit_cast<VkRenderPass>(renderPass), std::bit_cast<VkExtent2D*>(pGranularity)); }
#if VK_VERSION_1_4
  void getRenderingAreaGranularity(const RenderingAreaInfo& renderingAreaInfo, Extent2D* pGranularity) const { vkGetRenderingAreaGranularity(this->handle, std::bit_cast<const VkRenderingAreaInfo*>(&renderingAreaInfo), std::bit_cast<VkExtent2D*>(pGranularity)); }
#endif // VK_VERSION_1_4
#if VK_KHR_maintenance5
  void getRenderingAreaGranularityKHR(const RenderingAreaInfo& renderingAreaInfo, Extent2D* pGranularity) const { vkGetRenderingAreaGranularityKHR(this->handle, std::bit_cast<const VkRenderingAreaInfo*>(&renderingAreaInfo), std::bit_cast<VkExtent2D*>(pGranularity)); }
#endif // VK_KHR_maintenance5
  Ret<CommandPool> createCommandPool(const CommandPoolCreateInfo& createInfo, const AllocationCallbacks* pAllocator = {}) const { CommandPool value; return {Result(vkCreateCommandPool(this->handle, std::bit_cast<const VkCommandPoolCreateInfo*>(&createInfo), std::bit_cast<const VkAllocationCallbacks*>(pAllocator), std::bit_cast<VkCommandPool*>(&value))), value}; }
  void destroyCommandPool(CommandPool commandPool = {}, const AllocationCallbacks* pAllocator = {}) const { vkDestroyCommandPool(this->handle, std::bit_cast<VkCommandPool>(commandPool), std::bit_cast<const VkAllocationCallbacks*>(pAllocator)); }
  Result resetCommandPool(CommandPool commandPool, CommandPoolResetFlags flags = {}) const { return Result(vkResetCommandPool(this->handle, std::bit_cast<VkCommandPool>(commandPool), std::bit_cast<VkCommandPoolResetFlags>(flags))); }
  Result allocateCommandBuffers(const CommandBufferAllocateInfo& allocateInfo, CommandBuffer* pCommandBuffers) const { return Result(vkAllocateCommandBuffers(this->handle, std::bit_cast<const VkCommandBufferAllocateInfo*>(&allocateInfo), std::bit_cast<VkCommandBuffer*>(pCommandBuffers))); }
  void freeCommandBuffers(CommandPool commandPool, uint32_t commandBufferCount, const CommandBuffer* pCommandBuffers) const { vkFreeCommandBuffers(this->handle, std::bit_cast<VkCommandPool>(commandPool), commandBufferCount, std::bit_cast<const VkCommandBuffer*>(pCommandBuffers)); }
#if VK_KHR_display_swapchain
  Result createSharedSwapchainsKHR(uint32_t swapchainCount, const SwapchainCreateInfoKHR* pCreateInfos, SwapchainKHR* pSwapchains, const AllocationCallbacks* pAllocator = {}) const { return Result(vkCreateSharedSwapchainsKHR(this->handle, swapchainCount, std::bit_cast<const VkSwapchainCreateInfoKHR*>(pCreateInfos), std::bit_cast<const VkAllocationCallbacks*>(pAllocator), std::bit_cast<VkSwapchainKHR*>(pSwapchains))); }
#endif // VK_KHR_display_swapchain
#if VK_KHR_swapchain
  Ret<SwapchainKHR> createSwapchainKHR(const SwapchainCreateInfoKHR& createInfo, const AllocationCallbacks* pAllocator = {}) const { SwapchainKHR value; return {Result(vkCreateSwapchainKHR(this->handle, std::bit_cast<const VkSwapchainCreateInfoKHR*>(&createInfo), std::bit_cast<const VkAllocationCallbacks*>(pAllocator), std::bit_cast<VkSwapchainKHR*>(&value))), value}; }
  void destroySwapchainKHR(SwapchainKHR swapchain = {}, const AllocationCallbacks* pAllocator = {}) const { vkDestroySwapchainKHR(this->handle, std::bit_cast<VkSwapchainKHR>(swapchain), std::bit_cast<const VkAllocationCallbacks*>(pAllocator)); }
  Result getSwapchainImagesKHR(SwapchainKHR swapchain, uint32_t* pSwapchainImageCount, Image* pSwapchainImages = {}) const { return Result(vkGetSwapchainImagesKHR(this->handle, std::bit_cast<VkSwapchainKHR>(swapchain), pSwapchainImageCount, std::bit_cast<VkImage*>(pSwapchainImages))); }
  Ret<uint32_t> acquireNextImageKHR(SwapchainKHR swapchain, uint64_t timeout, Semaphore semaphore = {}, Fence fence = {}) const { uint32_t value; return {Result(vkAcquireNextImageKHR(this->handle, std::bit_cast<VkSwapchainKHR>(swapchain), timeout, std::bit_cast<VkSemaphore>(semaphore), std::bit_cast<VkFence>(fence), &value)), value}; }
#endif // VK_KHR_swapchain
#if VK_EXT_debug_marker
  Result debugMarkerSetObjectNameEXT(const DebugMarkerObjectNameInfoEXT& nameInfo) const { return Result(vkDebugMarkerSetObjectNameEXT(this->handle, std::bit_cast<const VkDebugMarkerObjectNameInfoEXT*>(&nameInfo))); }
  Result debugMarkerSetObjectTagEXT(const DebugMarkerObjectTagInfoEXT& tagInfo) const { return Result(vkDebugMarkerSetObjectTagEXT(this->handle, std::bit_cast<const VkDebugMarkerObjectTagInfoEXT*>(&tagInfo))); }
#endif // VK_EXT_debug_marker
#if VK_NV_device_generated_commands
  void getGeneratedCommandsMemoryRequirementsNV(const GeneratedCommandsMemoryRequirementsInfoNV& info, MemoryRequirements2* pMemoryRequirements) const { vkGetGeneratedCommandsMemoryRequirementsNV(this->handle, std::bit_cast<const VkGeneratedCommandsMemoryRequirementsInfoNV*>(&info), std::bit_cast<VkMemoryRequirements2*>(pMemoryRequirements)); }
  Ret<IndirectCommandsLayoutNV> createIndirectCommandsLayoutNV(const IndirectCommandsLayoutCreateInfoNV& createInfo, const AllocationCallbacks* pAllocator = {}) const { IndirectCommandsLayoutNV value; return {Result(vkCreateIndirectCommandsLayoutNV(this->handle, std::bit_cast<const VkIndirectCommandsLayoutCreateInfoNV*>(&createInfo), std::bit_cast<const VkAllocationCallbacks*>(pAllocator), std::bit_cast<VkIndirectCommandsLayoutNV*>(&value))), value}; }
  void destroyIndirectCommandsLayoutNV(IndirectCommandsLayoutNV indirectCommandsLayout = {}, const AllocationCallbacks* pAllocator = {}) const { vkDestroyIndirectCommandsLayoutNV(this->handle, std::bit_cast<VkIndirectCommandsLayoutNV>(indirectCommandsLayout), std::bit_cast<const VkAllocationCallbacks*>(pAllocator)); }
#endif // VK_NV_device_generated_commands
#if VK_EXT_device_generated_commands
  void getGeneratedCommandsMemoryRequirementsEXT(const GeneratedCommandsMemoryRequirementsInfoEXT& info, MemoryRequirements2* pMemoryRequirements) const { vkGetGeneratedCommandsMemoryRequirementsEXT(this->handle, std::bit_cast<const VkGeneratedCommandsMemoryRequirementsInfoEXT*>(&info), std::bit_cast<VkMemoryRequirements2*>(pMemoryRequirements)); }
  Ret<IndirectCommandsLayoutEXT> createIndirectCommandsLayoutEXT(const IndirectCommandsLayoutCreateInfoEXT& createInfo, const AllocationCallbacks* pAllocator = {}) const { IndirectCommandsLayoutEXT value; return {Result(vkCreateIndirectCommandsLayoutEXT(this->handle, std::bit_cast<const VkIndirectCommandsLayoutCreateInfoEXT*>(&createInfo), std::bit_cast<const VkAllocationCallbacks*>(pAllocator), std::bit_cast<VkIndirectCommandsLayoutEXT*>(&value))), value}; }
  void destroyIndirectCommandsLayoutEXT(IndirectCommandsLayoutEXT indirectCommandsLayout = {}, const AllocationCallbacks* pAllocator = {}) const { vkDestroyIndirectCommandsLayoutEXT(this->handle, std::bit_cast<VkIndirectCommandsLayoutEXT>(indirectCommandsLayout), std::bit_cast<const VkAllocationCallbacks*>(pAllocator)); }
  Ret<IndirectExecutionSetEXT> createIndirectExecutionSetEXT(const IndirectExecutionSetCreateInfoEXT& createInfo, const AllocationCallbacks* pAllocator = {}) const { IndirectExecutionSetEXT value; return {Result(vkCreateIndirectExecutionSetEXT(this->handle, std::bit_cast<const VkIndirectExecutionSetCreateInfoEXT*>(&createInfo), std::bit_cast<const VkAllocationCallbacks*>(pAllocator), std::bit_cast<VkIndirectExecutionSetEXT*>(&value))), value}; }
  void destroyIndirectExecutionSetEXT(IndirectExecutionSetEXT indirectExecutionSet = {}, const AllocationCallbacks* pAllocator = {}) const { vkDestroyIndirectExecutionSetEXT(this->handle, std::bit_cast<VkIndirectExecutionSetEXT>(indirectExecutionSet), std::bit_cast<const VkAllocationCallbacks*>(pAllocator)); }
  void updateIndirectExecutionSetPipelineEXT(IndirectExecutionSetEXT indirectExecutionSet, uint32_t executionSetWriteCount, const WriteIndirectExecutionSetPipelineEXT* pExecutionSetWrites) const { vkUpdateIndirectExecutionSetPipelineEXT(this->handle, std::bit_cast<VkIndirectExecutionSetEXT>(indirectExecutionSet), executionSetWriteCount, std::bit_cast<const VkWriteIndirectExecutionSetPipelineEXT*>(pExecutionSetWrites)); }
  void updateIndirectExecutionSetShaderEXT(IndirectExecutionSetEXT indirectExecutionSet, uint32_t executionSetWriteCount, const WriteIndirectExecutionSetShaderEXT* pExecutionSetWrites) const { vkUpdateIndirectExecutionSetShaderEXT(this->handle, std::bit_cast<VkIndirectExecutionSetEXT>(indirectExecutionSet), executionSetWriteCount, std::bit_cast<const VkWriteIndirectExecutionSetShaderEXT*>(pExecutionSetWrites)); }
#endif // VK_EXT_device_generated_commands
#if VK_VERSION_1_1
  void trimCommandPool(CommandPool commandPool, CommandPoolTrimFlags flags = {}) const { vkTrimCommandPool(this->handle, std::bit_cast<VkCommandPool>(commandPool), std::bit_cast<VkCommandPoolTrimFlags>(flags)); }
#endif // VK_VERSION_1_1
#if VK_KHR_maintenance1
  void trimCommandPoolKHR(CommandPool commandPool, CommandPoolTrimFlags flags = {}) const { vkTrimCommandPoolKHR(this->handle, std::bit_cast<VkCommandPool>(commandPool), std::bit_cast<VkCommandPoolTrimFlags>(flags)); }
#endif // VK_KHR_maintenance1
#if VK_KHR_external_memory_win32
  Ret<HANDLE> getMemoryWin32HandleKHR(const MemoryGetWin32HandleInfoKHR& getWin32HandleInfo) const { HANDLE value; return {Result(vkGetMemoryWin32HandleKHR(this->handle, std::bit_cast<const VkMemoryGetWin32HandleInfoKHR*>(&getWin32HandleInfo), &value)), value}; }
  Result getMemoryWin32HandlePropertiesKHR(ExternalMemoryHandleTypeFlagBits handleType, HANDLE handle, MemoryWin32HandlePropertiesKHR* pMemoryWin32HandleProperties) const { return Result(vkGetMemoryWin32HandlePropertiesKHR(this->handle, std::bit_cast<VkExternalMemoryHandleTypeFlagBits>(handleType), handle, std::bit_cast<VkMemoryWin32HandlePropertiesKHR*>(pMemoryWin32HandleProperties))); }
#endif // VK_KHR_external_memory_win32
#if VK_KHR_external_memory_fd
  Ret<int> getMemoryFdKHR(const MemoryGetFdInfoKHR& getFdInfo) const { int value; return {Result(vkGetMemoryFdKHR(this->handle, std::bit_cast<const VkMemoryGetFdInfoKHR*>(&getFdInfo), &value)), value}; }
  Result getMemoryFdPropertiesKHR(ExternalMemoryHandleTypeFlagBits handleType, int fd, MemoryFdPropertiesKHR* pMemoryFdProperties) const { return Result(vkGetMemoryFdPropertiesKHR(this->handle, std::bit_cast<VkExternalMemoryHandleTypeFlagBits>(handleType), fd, std::bit_cast<VkMemoryFdPropertiesKHR*>(pMemoryFdProperties))); }
#endif // VK_KHR_external_memory_fd
#if VK_FUCHSIA_external_memory
  Ret<zx_handle_t> getMemoryZirconHandleFUCHSIA(const MemoryGetZirconHandleInfoFUCHSIA& getZirconHandleInfo) const { zx_handle_t value; return {Result(vkGetMemoryZirconHandleFUCHSIA(this->handle, std::bit_cast<const VkMemoryGetZirconHandleInfoFUCHSIA*>(&getZirconHandleInfo), &value)), value}; }
  Result getMemoryZirconHandlePropertiesFUCHSIA(ExternalMemoryHandleTypeFlagBits handleType, zx_handle_t zirconHandle, MemoryZirconHandlePropertiesFUCHSIA* pMemoryZirconHandleProperties) const { return Result(vkGetMemoryZirconHandlePropertiesFUCHSIA(this->handle, std::bit_cast<VkExternalMemoryHandleTypeFlagBits>(handleType), zirconHandle, std::bit_cast<VkMemoryZirconHandlePropertiesFUCHSIA*>(pMemoryZirconHandleProperties))); }
#endif // VK_FUCHSIA_external_memory
#if VK_NV_external_memory_rdma
  Ret<RemoteAddressNV> getMemoryRemoteAddressNV(const MemoryGetRemoteAddressInfoNV& memoryGetRemoteAddressInfo) const { RemoteAddressNV value; return {Result(vkGetMemoryRemoteAddressNV(this->handle, std::bit_cast<const VkMemoryGetRemoteAddressInfoNV*>(&memoryGetRemoteAddressInfo), &value)), value}; }
#endif // VK_NV_external_memory_rdma
#if VK_KHR_external_semaphore_win32
  Ret<HANDLE> getSemaphoreWin32HandleKHR(const SemaphoreGetWin32HandleInfoKHR& getWin32HandleInfo) const { HANDLE value; return {Result(vkGetSemaphoreWin32HandleKHR(this->handle, std::bit_cast<const VkSemaphoreGetWin32HandleInfoKHR*>(&getWin32HandleInfo), &value)), value}; }
  Result importSemaphoreWin32HandleKHR(const ImportSemaphoreWin32HandleInfoKHR& importSemaphoreWin32HandleInfo) const { return Result(vkImportSemaphoreWin32HandleKHR(this->handle, std::bit_cast<const VkImportSemaphoreWin32HandleInfoKHR*>(&importSemaphoreWin32HandleInfo))); }
#endif // VK_KHR_external_semaphore_win32
#if VK_KHR_external_semaphore_fd
  Ret<int> getSemaphoreFdKHR(const SemaphoreGetFdInfoKHR& getFdInfo) const { int value; return {Result(vkGetSemaphoreFdKHR(this->handle, std::bit_cast<const VkSemaphoreGetFdInfoKHR*>(&getFdInfo), &value)), value}; }
  Result importSemaphoreFdKHR(const ImportSemaphoreFdInfoKHR& importSemaphoreFdInfo) const { return Result(vkImportSemaphoreFdKHR(this->handle, std::bit_cast<const VkImportSemaphoreFdInfoKHR*>(&importSemaphoreFdInfo))); }
#endif // VK_KHR_external_semaphore_fd
#if VK_FUCHSIA_external_semaphore
  Ret<zx_handle_t> getSemaphoreZirconHandleFUCHSIA(const SemaphoreGetZirconHandleInfoFUCHSIA& getZirconHandleInfo) const { zx_handle_t value; return {Result(vkGetSemaphoreZirconHandleFUCHSIA(this->handle, std::bit_cast<const VkSemaphoreGetZirconHandleInfoFUCHSIA*>(&getZirconHandleInfo), &value)), value}; }
  Result importSemaphoreZirconHandleFUCHSIA(const ImportSemaphoreZirconHandleInfoFUCHSIA& importSemaphoreZirconHandleInfo) const { return Result(vkImportSemaphoreZirconHandleFUCHSIA(this->handle, std::bit_cast<const VkImportSemaphoreZirconHandleInfoFUCHSIA*>(&importSemaphoreZirconHandleInfo))); }
#endif // VK_FUCHSIA_external_semaphore
#if VK_KHR_external_fence_win32
  Ret<HANDLE> getFenceWin32HandleKHR(const FenceGetWin32HandleInfoKHR& getWin32HandleInfo) const { HANDLE value; return {Result(vkGetFenceWin32HandleKHR(this->handle, std::bit_cast<const VkFenceGetWin32HandleInfoKHR*>(&getWin32HandleInfo), &value)), value}; }
  Result importFenceWin32HandleKHR(const ImportFenceWin32HandleInfoKHR& importFenceWin32HandleInfo) const { return Result(vkImportFenceWin32HandleKHR(this->handle, std::bit_cast<const VkImportFenceWin32HandleInfoKHR*>(&importFenceWin32HandleInfo))); }
#endif // VK_KHR_external_fence_win32
#if VK_KHR_external_fence_fd
  Ret<int> getFenceFdKHR(const FenceGetFdInfoKHR& getFdInfo) const { int value; return {Result(vkGetFenceFdKHR(this->handle, std::bit_cast<const VkFenceGetFdInfoKHR*>(&getFdInfo), &value)), value}; }
  Result importFenceFdKHR(const ImportFenceFdInfoKHR& importFenceFdInfo) const { return Result(vkImportFenceFdKHR(this->handle, std::bit_cast<const VkImportFenceFdInfoKHR*>(&importFenceFdInfo))); }
#endif // VK_KHR_external_fence_fd
#if VK_EXT_display_control
  Result displayPowerControlEXT(DisplayKHR display, const DisplayPowerInfoEXT& displayPowerInfo) const { return Result(vkDisplayPowerControlEXT(this->handle, std::bit_cast<VkDisplayKHR>(display), std::bit_cast<const VkDisplayPowerInfoEXT*>(&displayPowerInfo))); }
  Ret<Fence> registerDeviceEventEXT(const DeviceEventInfoEXT& deviceEventInfo, const AllocationCallbacks* pAllocator = {}) const { Fence value; return {Result(vkRegisterDeviceEventEXT(this->handle, std::bit_cast<const VkDeviceEventInfoEXT*>(&deviceEventInfo), std::bit_cast<const VkAllocationCallbacks*>(pAllocator), std::bit_cast<VkFence*>(&value))), value}; }
  Ret<Fence> registerDisplayEventEXT(DisplayKHR display, const DisplayEventInfoEXT& displayEventInfo, const AllocationCallbacks* pAllocator = {}) const { Fence value; return {Result(vkRegisterDisplayEventEXT(this->handle, std::bit_cast<VkDisplayKHR>(display), std::bit_cast<const VkDisplayEventInfoEXT*>(&displayEventInfo), std::bit_cast<const VkAllocationCallbacks*>(pAllocator), std::bit_cast<VkFence*>(&value))), value}; }
  Ret<uint64_t> getSwapchainCounterEXT(SwapchainKHR swapchain, SurfaceCounterFlagBitsEXT counter) const { uint64_t value; return {Result(vkGetSwapchainCounterEXT(this->handle, std::bit_cast<VkSwapchainKHR>(swapchain), std::bit_cast<VkSurfaceCounterFlagBitsEXT>(counter), &value)), value}; }
#endif // VK_EXT_display_control
#if VK_VERSION_1_1
  PeerMemoryFeatureFlags getGroupPeerMemoryFeatures(uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex) const { PeerMemoryFeatureFlags value; vkGetDeviceGroupPeerMemoryFeatures(this->handle, heapIndex, localDeviceIndex, remoteDeviceIndex, std::bit_cast<VkPeerMemoryFeatureFlags*>(&value)); return value; }
#endif // VK_VERSION_1_1
#if VK_KHR_device_group
  PeerMemoryFeatureFlags getGroupPeerMemoryFeaturesKHR(uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex) const { PeerMemoryFeatureFlags value; vkGetDeviceGroupPeerMemoryFeaturesKHR(this->handle, heapIndex, localDeviceIndex, remoteDeviceIndex, std::bit_cast<VkPeerMemoryFeatureFlags*>(&value)); return value; }
#endif // VK_KHR_device_group
#if VK_VERSION_1_1
  Result bindBufferMemory2(uint32_t bindInfoCount, const BindBufferMemoryInfo* pBindInfos) const { return Result(vkBindBufferMemory2(this->handle, bindInfoCount, std::bit_cast<const VkBindBufferMemoryInfo*>(pBindInfos))); }
#endif // VK_VERSION_1_1
#if VK_KHR_bind_memory2
  Result bindBufferMemory2KHR(uint32_t bindInfoCount, const BindBufferMemoryInfo* pBindInfos) const { return Result(vkBindBufferMemory2KHR(this->handle, bindInfoCount, std::bit_cast<const VkBindBufferMemoryInfo*>(pBindInfos))); }
#endif // VK_KHR_bind_memory2
#if VK_VERSION_1_1
  Result bindImageMemory2(uint32_t bindInfoCount, const BindImageMemoryInfo* pBindInfos) const { return Result(vkBindImageMemory2(this->handle, bindInfoCount, std::bit_cast<const VkBindImageMemoryInfo*>(pBindInfos))); }
#endif // VK_VERSION_1_1
#if VK_KHR_bind_memory2
  Result bindImageMemory2KHR(uint32_t bindInfoCount, const BindImageMemoryInfo* pBindInfos) const { return Result(vkBindImageMemory2KHR(this->handle, bindInfoCount, std::bit_cast<const VkBindImageMemoryInfo*>(pBindInfos))); }
#endif // VK_KHR_bind_memory2
#if VK_KHR_swapchain
  Result getGroupPresentCapabilitiesKHR(DeviceGroupPresentCapabilitiesKHR* pDeviceGroupPresentCapabilities) const { return Result(vkGetDeviceGroupPresentCapabilitiesKHR(this->handle, std::bit_cast<VkDeviceGroupPresentCapabilitiesKHR*>(pDeviceGroupPresentCapabilities))); }
  Ret<DeviceGroupPresentModeFlagsKHR> getGroupSurfacePresentModesKHR(SurfaceKHR surface) const { DeviceGroupPresentModeFlagsKHR value; return {Result(vkGetDeviceGroupSurfacePresentModesKHR(this->handle, std::bit_cast<VkSurfaceKHR>(surface), std::bit_cast<VkDeviceGroupPresentModeFlagsKHR*>(&value))), value}; }
  Ret<uint32_t> acquireNextImage2KHR(const AcquireNextImageInfoKHR& acquireInfo) const { uint32_t value; return {Result(vkAcquireNextImage2KHR(this->handle, std::bit_cast<const VkAcquireNextImageInfoKHR*>(&acquireInfo), &value)), value}; }
#endif // VK_KHR_swapchain
#if VK_VERSION_1_1
  Ret<DescriptorUpdateTemplate> createDescriptorUpdateTemplate(const DescriptorUpdateTemplateCreateInfo& createInfo, const AllocationCallbacks* pAllocator = {}) const { DescriptorUpdateTemplate value; return {Result(vkCreateDescriptorUpdateTemplate(this->handle, std::bit_cast<const VkDescriptorUpdateTemplateCreateInfo*>(&createInfo), std::bit_cast<const VkAllocationCallbacks*>(pAllocator), std::bit_cast<VkDescriptorUpdateTemplate*>(&value))), value}; }
#endif // VK_VERSION_1_1
#if VK_KHR_descriptor_update_template
  Ret<DescriptorUpdateTemplate> createDescriptorUpdateTemplateKHR(const DescriptorUpdateTemplateCreateInfo& createInfo, const AllocationCallbacks* pAllocator = {}) const { DescriptorUpdateTemplate value; return {Result(vkCreateDescriptorUpdateTemplateKHR(this->handle, std::bit_cast<const VkDescriptorUpdateTemplateCreateInfo*>(&createInfo), std::bit_cast<const VkAllocationCallbacks*>(pAllocator), std::bit_cast<VkDescriptorUpdateTemplate*>(&value))), value}; }
#endif // VK_KHR_descriptor_update_template
#if VK_VERSION_1_1
  void destroyDescriptorUpdateTemplate(DescriptorUpdateTemplate descriptorUpdateTemplate = {}, const AllocationCallbacks* pAllocator = {}) const { vkDestroyDescriptorUpdateTemplate(this->handle, std::bit_cast<VkDescriptorUpdateTemplate>(descriptorUpdateTemplate), std::bit_cast<const VkAllocationCallbacks*>(pAllocator)); }
#endif // VK_VERSION_1_1
#if VK_KHR_descriptor_update_template
  void destroyDescriptorUpdateTemplateKHR(DescriptorUpdateTemplate descriptorUpdateTemplate = {}, const AllocationCallbacks* pAllocator = {}) const { vkDestroyDescriptorUpdateTemplateKHR(this->handle, std::bit_cast<VkDescriptorUpdateTemplate>(descriptorUpdateTemplate), std::bit_cast<const VkAllocationCallbacks*>(pAllocator)); }
#endif // VK_KHR_descriptor_update_template
#if VK_VERSION_1_1
  void updateDescriptorSetWithTemplate(DescriptorSet descriptorSet, DescriptorUpdateTemplate descriptorUpdateTemplate, const void* pData) const { vkUpdateDescriptorSetWithTemplate(this->handle, std::bit_cast<VkDescriptorSet>(descriptorSet), std::bit_cast<VkDescriptorUpdateTemplate>(descriptorUpdateTemplate), pData); }
#endif // VK_VERSION_1_1
#if VK_KHR_descriptor_update_template
  void updateDescriptorSetWithTemplateKHR(DescriptorSet descriptorSet, DescriptorUpdateTemplate descriptorUpdateTemplate, const void* pData) const { vkUpdateDescriptorSetWithTemplateKHR(this->handle, std::bit_cast<VkDescriptorSet>(descriptorSet), std::bit_cast<VkDescriptorUpdateTemplate>(descriptorUpdateTemplate), pData); }
#endif // VK_KHR_descriptor_update_template
#if VK_EXT_hdr_metadata
  void setHdrMetadataEXT(uint32_t swapchainCount, const SwapchainKHR* pSwapchains, const HdrMetadataEXT* pMetadata) const { vkSetHdrMetadataEXT(this->handle, swapchainCount, std::bit_cast<const VkSwapchainKHR*>(pSwapchains), std::bit_cast<const VkHdrMetadataEXT*>(pMetadata)); }
#endif // VK_EXT_hdr_metadata
#if VK_KHR_shared_presentable_image
  Result getSwapchainStatusKHR(SwapchainKHR swapchain) const { return Result(vkGetSwapchainStatusKHR(this->handle, std::bit_cast<VkSwapchainKHR>(swapchain))); }
#endif // VK_KHR_shared_presentable_image
#if VK_GOOGLE_display_timing
  Result getRefreshCycleDurationGOOGLE(SwapchainKHR swapchain, RefreshCycleDurationGOOGLE* pDisplayTimingProperties) const { return Result(vkGetRefreshCycleDurationGOOGLE(this->handle, std::bit_cast<VkSwapchainKHR>(swapchain), std::bit_cast<VkRefreshCycleDurationGOOGLE*>(pDisplayTimingProperties))); }
  Result getPastPresentationTimingGOOGLE(SwapchainKHR swapchain, uint32_t* pPresentationTimingCount, PastPresentationTimingGOOGLE* pPresentationTimings = {}) const { return Result(vkGetPastPresentationTimingGOOGLE(this->handle, std::bit_cast<VkSwapchainKHR>(swapchain), pPresentationTimingCount, std::bit_cast<VkPastPresentationTimingGOOGLE*>(pPresentationTimings))); }
#endif // VK_GOOGLE_display_timing
#if VK_VERSION_1_1
  void getBufferMemoryRequirements2(const BufferMemoryRequirementsInfo2& info, MemoryRequirements2* pMemoryRequirements) const { vkGetBufferMemoryRequirements2(this->handle, std::bit_cast<const VkBufferMemoryRequirementsInfo2*>(&info), std::bit_cast<VkMemoryRequirements2*>(pMemoryRequirements)); }
#endif // VK_VERSION_1_1
#if VK_KHR_get_memory_requirements2
  void getBufferMemoryRequirements2KHR(const BufferMemoryRequirementsInfo2& info, MemoryRequirements2* pMemoryRequirements) const { vkGetBufferMemoryRequirements2KHR(this->handle, std::bit_cast<const VkBufferMemoryRequirementsInfo2*>(&info), std::bit_cast<VkMemoryRequirements2*>(pMemoryRequirements)); }
#endif // VK_KHR_get_memory_requirements2
#if VK_VERSION_1_1
  void getImageMemoryRequirements2(const ImageMemoryRequirementsInfo2& info, MemoryRequirements2* pMemoryRequirements) const { vkGetImageMemoryRequirements2(this->handle, std::bit_cast<const VkImageMemoryRequirementsInfo2*>(&info), std::bit_cast<VkMemoryRequirements2*>(pMemoryRequirements)); }
#endif // VK_VERSION_1_1
#if VK_KHR_get_memory_requirements2
  void getImageMemoryRequirements2KHR(const ImageMemoryRequirementsInfo2& info, MemoryRequirements2* pMemoryRequirements) const { vkGetImageMemoryRequirements2KHR(this->handle, std::bit_cast<const VkImageMemoryRequirementsInfo2*>(&info), std::bit_cast<VkMemoryRequirements2*>(pMemoryRequirements)); }
#endif // VK_KHR_get_memory_requirements2
#if VK_VERSION_1_1
  void getImageSparseMemoryRequirements2(const ImageSparseMemoryRequirementsInfo2& info, uint32_t* pSparseMemoryRequirementCount, SparseImageMemoryRequirements2* pSparseMemoryRequirements = {}) const { vkGetImageSparseMemoryRequirements2(this->handle, std::bit_cast<const VkImageSparseMemoryRequirementsInfo2*>(&info), pSparseMemoryRequirementCount, std::bit_cast<VkSparseImageMemoryRequirements2*>(pSparseMemoryRequirements)); }
#endif // VK_VERSION_1_1
#if VK_KHR_get_memory_requirements2
  void getImageSparseMemoryRequirements2KHR(const ImageSparseMemoryRequirementsInfo2& info, uint32_t* pSparseMemoryRequirementCount, SparseImageMemoryRequirements2* pSparseMemoryRequirements = {}) const { vkGetImageSparseMemoryRequirements2KHR(this->handle, std::bit_cast<const VkImageSparseMemoryRequirementsInfo2*>(&info), pSparseMemoryRequirementCount, std::bit_cast<VkSparseImageMemoryRequirements2*>(pSparseMemoryRequirements)); }
#endif // VK_KHR_get_memory_requirements2
#if VK_VERSION_1_3
  void getBufferMemoryRequirements(const DeviceBufferMemoryRequirements& info, MemoryRequirements2* pMemoryRequirements) const { vkGetDeviceBufferMemoryRequirements(this->handle, std::bit_cast<const VkDeviceBufferMemoryRequirements*>(&info), std::bit_cast<VkMemoryRequirements2*>(pMemoryRequirements)); }
#endif // VK_VERSION_1_3
#if VK_KHR_maintenance4
  void getBufferMemoryRequirementsKHR(const DeviceBufferMemoryRequirements& info, MemoryRequirements2* pMemoryRequirements) const { vkGetDeviceBufferMemoryRequirementsKHR(this->handle, std::bit_cast<const VkDeviceBufferMemoryRequirements*>(&info), std::bit_cast<VkMemoryRequirements2*>(pMemoryRequirements)); }
#endif // VK_KHR_maintenance4
#if VK_VERSION_1_3
  void getImageMemoryRequirements(const DeviceImageMemoryRequirements& info, MemoryRequirements2* pMemoryRequirements) const { vkGetDeviceImageMemoryRequirements(this->handle, std::bit_cast<const VkDeviceImageMemoryRequirements*>(&info), std::bit_cast<VkMemoryRequirements2*>(pMemoryRequirements)); }
#endif // VK_VERSION_1_3
#if VK_KHR_maintenance4
  void getImageMemoryRequirementsKHR(const DeviceImageMemoryRequirements& info, MemoryRequirements2* pMemoryRequirements) const { vkGetDeviceImageMemoryRequirementsKHR(this->handle, std::bit_cast<const VkDeviceImageMemoryRequirements*>(&info), std::bit_cast<VkMemoryRequirements2*>(pMemoryRequirements)); }
#endif // VK_KHR_maintenance4
#if VK_VERSION_1_3
  void getImageSparseMemoryRequirements(const DeviceImageMemoryRequirements& info, uint32_t* pSparseMemoryRequirementCount, SparseImageMemoryRequirements2* pSparseMemoryRequirements = {}) const { vkGetDeviceImageSparseMemoryRequirements(this->handle, std::bit_cast<const VkDeviceImageMemoryRequirements*>(&info), pSparseMemoryRequirementCount, std::bit_cast<VkSparseImageMemoryRequirements2*>(pSparseMemoryRequirements)); }
#endif // VK_VERSION_1_3
#if VK_KHR_maintenance4
  void getImageSparseMemoryRequirementsKHR(const DeviceImageMemoryRequirements& info, uint32_t* pSparseMemoryRequirementCount, SparseImageMemoryRequirements2* pSparseMemoryRequirements = {}) const { vkGetDeviceImageSparseMemoryRequirementsKHR(this->handle, std::bit_cast<const VkDeviceImageMemoryRequirements*>(&info), pSparseMemoryRequirementCount, std::bit_cast<VkSparseImageMemoryRequirements2*>(pSparseMemoryRequirements)); }
#endif // VK_KHR_maintenance4
#if VK_VERSION_1_1
  Ret<SamplerYcbcrConversion> createSamplerYcbcrConversion(const SamplerYcbcrConversionCreateInfo& createInfo, const AllocationCallbacks* pAllocator = {}) const { SamplerYcbcrConversion value; return {Result(vkCreateSamplerYcbcrConversion(this->handle, std::bit_cast<const VkSamplerYcbcrConversionCreateInfo*>(&createInfo), std::bit_cast<const VkAllocationCallbacks*>(pAllocator), std::bit_cast<VkSamplerYcbcrConversion*>(&value))), value}; }
#endif // VK_VERSION_1_1
#if VK_KHR_sampler_ycbcr_conversion
  Ret<SamplerYcbcrConversion> createSamplerYcbcrConversionKHR(const SamplerYcbcrConversionCreateInfo& createInfo, const AllocationCallbacks* pAllocator = {}) const { SamplerYcbcrConversion value; return {Result(vkCreateSamplerYcbcrConversionKHR(this->handle, std::bit_cast<const VkSamplerYcbcrConversionCreateInfo*>(&createInfo), std::bit_cast<const VkAllocationCallbacks*>(pAllocator), std::bit_cast<VkSamplerYcbcrConversion*>(&value))), value}; }
#endif // VK_KHR_sampler_ycbcr_conversion
#if VK_VERSION_1_1
  void destroySamplerYcbcrConversion(SamplerYcbcrConversion ycbcrConversion = {}, const AllocationCallbacks* pAllocator = {}) const { vkDestroySamplerYcbcrConversion(this->handle, std::bit_cast<VkSamplerYcbcrConversion>(ycbcrConversion), std::bit_cast<const VkAllocationCallbacks*>(pAllocator)); }
#endif // VK_VERSION_1_1
#if VK_KHR_sampler_ycbcr_conversion
  void destroySamplerYcbcrConversionKHR(SamplerYcbcrConversion ycbcrConversion = {}, const AllocationCallbacks* pAllocator = {}) const { vkDestroySamplerYcbcrConversionKHR(this->handle, std::bit_cast<VkSamplerYcbcrConversion>(ycbcrConversion), std::bit_cast<const VkAllocationCallbacks*>(pAllocator)); }
#endif // VK_KHR_sampler_ycbcr_conversion
#if VK_VERSION_1_1
  Queue getQueue2(const DeviceQueueInfo2& queueInfo) const { Queue value; vkGetDeviceQueue2(this->handle, std::bit_cast<const VkDeviceQueueInfo2*>(&queueInfo), std::bit_cast<VkQueue*>(&value)); return value; }
#endif // VK_VERSION_1_1
#if VK_EXT_validation_cache
  Ret<ValidationCacheEXT> createValidationCacheEXT(const ValidationCacheCreateInfoEXT& createInfo, const AllocationCallbacks* pAllocator = {}) const { ValidationCacheEXT value; return {Result(vkCreateValidationCacheEXT(this->handle, std::bit_cast<const VkValidationCacheCreateInfoEXT*>(&createInfo), std::bit_cast<const VkAllocationCallbacks*>(pAllocator), std::bit_cast<VkValidationCacheEXT*>(&value))), value}; }
  void destroyValidationCacheEXT(ValidationCacheEXT validationCache = {}, const AllocationCallbacks* pAllocator = {}) const { vkDestroyValidationCacheEXT(this->handle, std::bit_cast<VkValidationCacheEXT>(validationCache), std::bit_cast<const VkAllocationCallbacks*>(pAllocator)); }
  Result getValidationCacheDataEXT(ValidationCacheEXT validationCache, size_t* pDataSize, void* pData = {}) const { return Result(vkGetValidationCacheDataEXT(this->handle, std::bit_cast<VkValidationCacheEXT>(validationCache), pDataSize, pData)); }
  Result mergeValidationCachesEXT(ValidationCacheEXT dstCache, uint32_t srcCacheCount, const ValidationCacheEXT* pSrcCaches) const { return Result(vkMergeValidationCachesEXT(this->handle, std::bit_cast<VkValidationCacheEXT>(dstCache), srcCacheCount, std::bit_cast<const VkValidationCacheEXT*>(pSrcCaches))); }
#endif // VK_EXT_validation_cache
#if VK_VERSION_1_1
  void getDescriptorSetLayoutSupport(const DescriptorSetLayoutCreateInfo& createInfo, DescriptorSetLayoutSupport* pSupport) const { vkGetDescriptorSetLayoutSupport(this->handle, std::bit_cast<const VkDescriptorSetLayoutCreateInfo*>(&createInfo), std::bit_cast<VkDescriptorSetLayoutSupport*>(pSupport)); }
#endif // VK_VERSION_1_1
#if VK_KHR_maintenance3
  void getDescriptorSetLayoutSupportKHR(const DescriptorSetLayoutCreateInfo& createInfo, DescriptorSetLayoutSupport* pSupport) const { vkGetDescriptorSetLayoutSupportKHR(this->handle, std::bit_cast<const VkDescriptorSetLayoutCreateInfo*>(&createInfo), std::bit_cast<VkDescriptorSetLayoutSupport*>(pSupport)); }
#endif // VK_KHR_maintenance3
#if VK_AMD_shader_info
  Result getShaderInfoAMD(Pipeline pipeline, ShaderStageFlagBits shaderStage, ShaderInfoTypeAMD infoType, size_t* pInfoSize, void* pInfo = {}) const { return Result(vkGetShaderInfoAMD(this->handle, std::bit_cast<VkPipeline>(pipeline), std::bit_cast<VkShaderStageFlagBits>(shaderStage), std::bit_cast<VkShaderInfoTypeAMD>(infoType), pInfoSize, pInfo)); }
#endif // VK_AMD_shader_info
#if VK_AMD_display_native_hdr
  void setLocalDimmingAMD(SwapchainKHR swapChain, Bool32 localDimmingEnable) const { vkSetLocalDimmingAMD(this->handle, std::bit_cast<VkSwapchainKHR>(swapChain), localDimmingEnable); }
#endif // VK_AMD_display_native_hdr
#if VK_KHR_calibrated_timestamps
  Ret<uint64_t> getCalibratedTimestampsKHR(uint32_t timestampCount, const CalibratedTimestampInfoKHR* pTimestampInfos, uint64_t* pTimestamps) const { uint64_t value; return {Result(vkGetCalibratedTimestampsKHR(this->handle, timestampCount, std::bit_cast<const VkCalibratedTimestampInfoKHR*>(pTimestampInfos), pTimestamps, &value)), value}; }
#endif // VK_KHR_calibrated_timestamps
#if VK_EXT_calibrated_timestamps
  Ret<uint64_t> getCalibratedTimestampsEXT(uint32_t timestampCount, const CalibratedTimestampInfoKHR* pTimestampInfos, uint64_t* pTimestamps) const { uint64_t value; return {Result(vkGetCalibratedTimestampsEXT(this->handle, timestampCount, std::bit_cast<const VkCalibratedTimestampInfoKHR*>(pTimestampInfos), pTimestamps, &value)), value}; }
#endif // VK_EXT_calibrated_timestamps
#if VK_EXT_debug_utils
  Result setDebugUtilsObjectNameEXT(const DebugUtilsObjectNameInfoEXT& nameInfo) const { return Result(vkSetDebugUtilsObjectNameEXT(this->handle, std::bit_cast<const VkDebugUtilsObjectNameInfoEXT*>(&nameInfo))); }
  Result setDebugUtilsObjectTagEXT(const DebugUtilsObjectTagInfoEXT& tagInfo) const { return Result(vkSetDebugUtilsObjectTagEXT(this->handle, std::bit_cast<const VkDebugUtilsObjectTagInfoEXT*>(&tagInfo))); }
#endif // VK_EXT_debug_utils
#if VK_EXT_external_memory_host
  Result getMemoryHostPointerPropertiesEXT(ExternalMemoryHandleTypeFlagBits handleType, const void* pHostPointer, MemoryHostPointerPropertiesEXT* pMemoryHostPointerProperties) const { return Result(vkGetMemoryHostPointerPropertiesEXT(this->handle, std::bit_cast<VkExternalMemoryHandleTypeFlagBits>(handleType), pHostPointer, std::bit_cast<VkMemoryHostPointerPropertiesEXT*>(pMemoryHostPointerProperties))); }
#endif // VK_EXT_external_memory_host
#if VK_VERSION_1_2
  Ret<RenderPass> createRenderPass2(const RenderPassCreateInfo2& createInfo, const AllocationCallbacks* pAllocator = {}) const { RenderPass value; return {Result(vkCreateRenderPass2(this->handle, std::bit_cast<const VkRenderPassCreateInfo2*>(&createInfo), std::bit_cast<const VkAllocationCallbacks*>(pAllocator), std::bit_cast<VkRenderPass*>(&value))), value}; }
#endif // VK_VERSION_1_2
#if VK_KHR_create_renderpass2
  Ret<RenderPass> createRenderPass2KHR(const RenderPassCreateInfo2& createInfo, const AllocationCallbacks* pAllocator = {}) const { RenderPass value; return {Result(vkCreateRenderPass2KHR(this->handle, std::bit_cast<const VkRenderPassCreateInfo2*>(&createInfo), std::bit_cast<const VkAllocationCallbacks*>(pAllocator), std::bit_cast<VkRenderPass*>(&value))), value}; }
#endif // VK_KHR_create_renderpass2
#if VK_VERSION_1_2
  Ret<uint64_t> getSemaphoreCounterValue(Semaphore semaphore) const { uint64_t value; return {Result(vkGetSemaphoreCounterValue(this->handle, std::bit_cast<VkSemaphore>(semaphore), &value)), value}; }
#endif // VK_VERSION_1_2
#if VK_KHR_timeline_semaphore
  Ret<uint64_t> getSemaphoreCounterValueKHR(Semaphore semaphore) const { uint64_t value; return {Result(vkGetSemaphoreCounterValueKHR(this->handle, std::bit_cast<VkSemaphore>(semaphore), &value)), value}; }
#endif // VK_KHR_timeline_semaphore
#if VK_VERSION_1_2
  Result waitSemaphores(const SemaphoreWaitInfo& waitInfo, uint64_t timeout) const { return Result(vkWaitSemaphores(this->handle, std::bit_cast<const VkSemaphoreWaitInfo*>(&waitInfo), timeout)); }
#endif // VK_VERSION_1_2
#if VK_KHR_timeline_semaphore
  Result waitSemaphoresKHR(const SemaphoreWaitInfo& waitInfo, uint64_t timeout) const { return Result(vkWaitSemaphoresKHR(this->handle, std::bit_cast<const VkSemaphoreWaitInfo*>(&waitInfo), timeout)); }
#endif // VK_KHR_timeline_semaphore
#if VK_VERSION_1_2
  Result signalSemaphore(const SemaphoreSignalInfo& signalInfo) const { return Result(vkSignalSemaphore(this->handle, std::bit_cast<const VkSemaphoreSignalInfo*>(&signalInfo))); }
#endif // VK_VERSION_1_2
#if VK_KHR_timeline_semaphore
  Result signalSemaphoreKHR(const SemaphoreSignalInfo& signalInfo) const { return Result(vkSignalSemaphoreKHR(this->handle, std::bit_cast<const VkSemaphoreSignalInfo*>(&signalInfo))); }
#endif // VK_KHR_timeline_semaphore
#if VK_ANDROID_external_memory_android_hardware_buffer
  Result getAndroidHardwareBufferPropertiesANDROID(const struct AHardwareBuffer& buffer, AndroidHardwareBufferPropertiesANDROID* pProperties) const { return Result(vkGetAndroidHardwareBufferPropertiesANDROID(this->handle, &buffer, std::bit_cast<VkAndroidHardwareBufferPropertiesANDROID*>(pProperties))); }
  Ret<struct AHardwareBuffer*> getMemoryAndroidHardwareBufferANDROID(const MemoryGetAndroidHardwareBufferInfoANDROID& info) const { struct AHardwareBuffer* value; return {Result(vkGetMemoryAndroidHardwareBufferANDROID(this->handle, std::bit_cast<const VkMemoryGetAndroidHardwareBufferInfoANDROID*>(&info), &value)), value}; }
#endif // VK_ANDROID_external_memory_android_hardware_buffer
#if VK_KHR_acceleration_structure
  void destroyAccelerationStructureKHR(AccelerationStructureKHR accelerationStructure = {}, const AllocationCallbacks* pAllocator = {}) const { vkDestroyAccelerationStructureKHR(this->handle, std::bit_cast<VkAccelerationStructureKHR>(accelerationStructure), std::bit_cast<const VkAllocationCallbacks*>(pAllocator)); }
  Result copyAccelerationStructureKHR(DeferredOperationKHR deferredOperation, const CopyAccelerationStructureInfoKHR& info) const { return Result(vkCopyAccelerationStructureKHR(this->handle, std::bit_cast<VkDeferredOperationKHR>(deferredOperation), std::bit_cast<const VkCopyAccelerationStructureInfoKHR*>(&info))); }
  Result copyAccelerationStructureToMemoryKHR(DeferredOperationKHR deferredOperation, const CopyAccelerationStructureToMemoryInfoKHR& info) const { return Result(vkCopyAccelerationStructureToMemoryKHR(this->handle, std::bit_cast<VkDeferredOperationKHR>(deferredOperation), std::bit_cast<const VkCopyAccelerationStructureToMemoryInfoKHR*>(&info))); }
  Result copyMemoryToAccelerationStructureKHR(DeferredOperationKHR deferredOperation, const CopyMemoryToAccelerationStructureInfoKHR& info) const { return Result(vkCopyMemoryToAccelerationStructureKHR(this->handle, std::bit_cast<VkDeferredOperationKHR>(deferredOperation), std::bit_cast<const VkCopyMemoryToAccelerationStructureInfoKHR*>(&info))); }
  Result writeAccelerationStructuresPropertiesKHR(uint32_t accelerationStructureCount, const AccelerationStructureKHR* pAccelerationStructures, QueryType queryType, size_t dataSize, void* pData, size_t stride) const { return Result(vkWriteAccelerationStructuresPropertiesKHR(this->handle, accelerationStructureCount, std::bit_cast<const VkAccelerationStructureKHR*>(pAccelerationStructures), std::bit_cast<VkQueryType>(queryType), dataSize, pData, stride)); }
#endif // VK_KHR_acceleration_structure
#if VK_KHR_ray_tracing_pipeline
  Result getRayTracingShaderGroupHandlesKHR(Pipeline pipeline, uint32_t firstGroup, uint32_t groupCount, size_t dataSize, void* pData) const { return Result(vkGetRayTracingShaderGroupHandlesKHR(this->handle, std::bit_cast<VkPipeline>(pipeline), firstGroup, groupCount, dataSize, pData)); }
  Result getRayTracingCaptureReplayShaderGroupHandlesKHR(Pipeline pipeline, uint32_t firstGroup, uint32_t groupCount, size_t dataSize, void* pData) const { return Result(vkGetRayTracingCaptureReplayShaderGroupHandlesKHR(this->handle, std::bit_cast<VkPipeline>(pipeline), firstGroup, groupCount, dataSize, pData)); }
  Result createRayTracingPipelinesKHR(DeferredOperationKHR deferredOperation, PipelineCache pipelineCache, uint32_t createInfoCount, const RayTracingPipelineCreateInfoKHR* pCreateInfos, Pipeline* pPipelines, const AllocationCallbacks* pAllocator = {}) const { return Result(vkCreateRayTracingPipelinesKHR(this->handle, std::bit_cast<VkDeferredOperationKHR>(deferredOperation), std::bit_cast<VkPipelineCache>(pipelineCache), createInfoCount, std::bit_cast<const VkRayTracingPipelineCreateInfoKHR*>(pCreateInfos), std::bit_cast<const VkAllocationCallbacks*>(pAllocator), std::bit_cast<VkPipeline*>(pPipelines))); }
#endif // VK_KHR_ray_tracing_pipeline
#if VK_NV_cluster_acceleration_structure
  void getClusterAccelerationStructureBuildSizesNV(const ClusterAccelerationStructureInputInfoNV& info, AccelerationStructureBuildSizesInfoKHR* pSizeInfo) const { vkGetClusterAccelerationStructureBuildSizesNV(this->handle, std::bit_cast<const VkClusterAccelerationStructureInputInfoNV*>(&info), std::bit_cast<VkAccelerationStructureBuildSizesInfoKHR*>(pSizeInfo)); }
#endif // VK_NV_cluster_acceleration_structure
#if VK_KHR_acceleration_structure
  AccelerationStructureCompatibilityKHR getAccelerationStructureCompatibilityKHR(const AccelerationStructureVersionInfoKHR& versionInfo) const { AccelerationStructureCompatibilityKHR value; vkGetDeviceAccelerationStructureCompatibilityKHR(this->handle, std::bit_cast<const VkAccelerationStructureVersionInfoKHR*>(&versionInfo), std::bit_cast<VkAccelerationStructureCompatibilityKHR*>(&value)); return value; }
#endif // VK_KHR_acceleration_structure
#if VK_KHR_ray_tracing_pipeline
  DeviceSize getRayTracingShaderGroupStackSizeKHR(Pipeline pipeline, uint32_t group, ShaderGroupShaderKHR groupShader) const { return vkGetRayTracingShaderGroupStackSizeKHR(this->handle, std::bit_cast<VkPipeline>(pipeline), group, std::bit_cast<VkShaderGroupShaderKHR>(groupShader)); }
#endif // VK_KHR_ray_tracing_pipeline
#if VK_NVX_image_view_handle
  uint32_t getImageViewHandleNVX(const ImageViewHandleInfoNVX& info) const { return vkGetImageViewHandleNVX(this->handle, std::bit_cast<const VkImageViewHandleInfoNVX*>(&info)); }
  uint64_t getImageViewHandle64NVX(const ImageViewHandleInfoNVX& info) const { return vkGetImageViewHandle64NVX(this->handle, std::bit_cast<const VkImageViewHandleInfoNVX*>(&info)); }
  Result getImageViewAddressNVX(ImageView imageView, ImageViewAddressPropertiesNVX* pProperties) const { return Result(vkGetImageViewAddressNVX(this->handle, std::bit_cast<VkImageView>(imageView), std::bit_cast<VkImageViewAddressPropertiesNVX*>(pProperties))); }
#endif // VK_NVX_image_view_handle
#if VK_EXT_full_screen_exclusive
  Ret<DeviceGroupPresentModeFlagsKHR> getGroupSurfacePresentModes2EXT(const PhysicalDeviceSurfaceInfo2KHR& surfaceInfo) const { DeviceGroupPresentModeFlagsKHR value; return {Result(vkGetDeviceGroupSurfacePresentModes2EXT(this->handle, std::bit_cast<const VkPhysicalDeviceSurfaceInfo2KHR*>(&surfaceInfo), std::bit_cast<VkDeviceGroupPresentModeFlagsKHR*>(&value))), value}; }
  Result acquireFullScreenExclusiveModeEXT(SwapchainKHR swapchain) const { return Result(vkAcquireFullScreenExclusiveModeEXT(this->handle, std::bit_cast<VkSwapchainKHR>(swapchain))); }
  Result releaseFullScreenExclusiveModeEXT(SwapchainKHR swapchain) const { return Result(vkReleaseFullScreenExclusiveModeEXT(this->handle, std::bit_cast<VkSwapchainKHR>(swapchain))); }
#endif // VK_EXT_full_screen_exclusive
#if VK_KHR_performance_query
  Result acquireProfilingLockKHR(const AcquireProfilingLockInfoKHR& info) const { return Result(vkAcquireProfilingLockKHR(this->handle, std::bit_cast<const VkAcquireProfilingLockInfoKHR*>(&info))); }
  void releaseProfilingLockKHR() const { vkReleaseProfilingLockKHR(this->handle); }
#endif // VK_KHR_performance_query
#if VK_EXT_image_drm_format_modifier
  Result getImageDrmFormatModifierPropertiesEXT(Image image, ImageDrmFormatModifierPropertiesEXT* pProperties) const { return Result(vkGetImageDrmFormatModifierPropertiesEXT(this->handle, std::bit_cast<VkImage>(image), std::bit_cast<VkImageDrmFormatModifierPropertiesEXT*>(pProperties))); }
#endif // VK_EXT_image_drm_format_modifier
#if VK_VERSION_1_2
  uint64_t getBufferOpaqueCaptureAddress(const BufferDeviceAddressInfo& info) const { return vkGetBufferOpaqueCaptureAddress(this->handle, std::bit_cast<const VkBufferDeviceAddressInfo*>(&info)); }
#endif // VK_VERSION_1_2
#if VK_KHR_buffer_device_address
  uint64_t getBufferOpaqueCaptureAddressKHR(const BufferDeviceAddressInfo& info) const { return vkGetBufferOpaqueCaptureAddressKHR(this->handle, std::bit_cast<const VkBufferDeviceAddressInfo*>(&info)); }
#endif // VK_KHR_buffer_device_address
#if VK_VERSION_1_2
  DeviceAddress getBufferDeviceAddress(const BufferDeviceAddressInfo& info) const { return vkGetBufferDeviceAddress(this->handle, std::bit_cast<const VkBufferDeviceAddressInfo*>(&info)); }
#endif // VK_VERSION_1_2
#if VK_KHR_buffer_device_address
  DeviceAddress getBufferDeviceAddressKHR(const BufferDeviceAddressInfo& info) const { return vkGetBufferDeviceAddressKHR(this->handle, std::bit_cast<const VkBufferDeviceAddressInfo*>(&info)); }
#endif // VK_KHR_buffer_device_address
#if VK_INTEL_performance_query
  Result initializePerformanceApiINTEL(const InitializePerformanceApiInfoINTEL& initializeInfo) const { return Result(vkInitializePerformanceApiINTEL(this->handle, std::bit_cast<const VkInitializePerformanceApiInfoINTEL*>(&initializeInfo))); }
  void uninitializePerformanceApiINTEL() const { vkUninitializePerformanceApiINTEL(this->handle); }
  Ret<PerformanceConfigurationINTEL> acquirePerformanceConfigurationINTEL(const PerformanceConfigurationAcquireInfoINTEL& acquireInfo) const { PerformanceConfigurationINTEL value; return {Result(vkAcquirePerformanceConfigurationINTEL(this->handle, std::bit_cast<const VkPerformanceConfigurationAcquireInfoINTEL*>(&acquireInfo), std::bit_cast<VkPerformanceConfigurationINTEL*>(&value))), value}; }
  Result releasePerformanceConfigurationINTEL(PerformanceConfigurationINTEL configuration = {}) const { return Result(vkReleasePerformanceConfigurationINTEL(this->handle, std::bit_cast<VkPerformanceConfigurationINTEL>(configuration))); }
  Result getPerformanceParameterINTEL(PerformanceParameterTypeINTEL parameter, PerformanceValueINTEL* pValue) const { return Result(vkGetPerformanceParameterINTEL(this->handle, std::bit_cast<VkPerformanceParameterTypeINTEL>(parameter), std::bit_cast<VkPerformanceValueINTEL*>(pValue))); }
#endif // VK_INTEL_performance_query
#if VK_VERSION_1_2
  uint64_t getMemoryOpaqueCaptureAddress(const DeviceMemoryOpaqueCaptureAddressInfo& info) const { return vkGetDeviceMemoryOpaqueCaptureAddress(this->handle, std::bit_cast<const VkDeviceMemoryOpaqueCaptureAddressInfo*>(&info)); }
#endif // VK_VERSION_1_2
#if VK_KHR_buffer_device_address
  uint64_t getMemoryOpaqueCaptureAddressKHR(const DeviceMemoryOpaqueCaptureAddressInfo& info) const { return vkGetDeviceMemoryOpaqueCaptureAddressKHR(this->handle, std::bit_cast<const VkDeviceMemoryOpaqueCaptureAddressInfo*>(&info)); }
#endif // VK_KHR_buffer_device_address
#if VK_KHR_pipeline_executable_properties
  Result getPipelineExecutablePropertiesKHR(const PipelineInfoKHR& pipelineInfo, uint32_t* pExecutableCount, PipelineExecutablePropertiesKHR* pProperties = {}) const { return Result(vkGetPipelineExecutablePropertiesKHR(this->handle, std::bit_cast<const VkPipelineInfoKHR*>(&pipelineInfo), pExecutableCount, std::bit_cast<VkPipelineExecutablePropertiesKHR*>(pProperties))); }
  Result getPipelineExecutableStatisticsKHR(const PipelineExecutableInfoKHR& executableInfo, uint32_t* pStatisticCount, PipelineExecutableStatisticKHR* pStatistics = {}) const { return Result(vkGetPipelineExecutableStatisticsKHR(this->handle, std::bit_cast<const VkPipelineExecutableInfoKHR*>(&executableInfo), pStatisticCount, std::bit_cast<VkPipelineExecutableStatisticKHR*>(pStatistics))); }
  Result getPipelineExecutableInternalRepresentationsKHR(const PipelineExecutableInfoKHR& executableInfo, uint32_t* pInternalRepresentationCount, PipelineExecutableInternalRepresentationKHR* pInternalRepresentations = {}) const { return Result(vkGetPipelineExecutableInternalRepresentationsKHR(this->handle, std::bit_cast<const VkPipelineExecutableInfoKHR*>(&executableInfo), pInternalRepresentationCount, std::bit_cast<VkPipelineExecutableInternalRepresentationKHR*>(pInternalRepresentations))); }
#endif // VK_KHR_pipeline_executable_properties
#if VK_KHR_acceleration_structure
  Ret<AccelerationStructureKHR> createAccelerationStructureKHR(const AccelerationStructureCreateInfoKHR& createInfo, const AllocationCallbacks* pAllocator = {}) const { AccelerationStructureKHR value; return {Result(vkCreateAccelerationStructureKHR(this->handle, std::bit_cast<const VkAccelerationStructureCreateInfoKHR*>(&createInfo), std::bit_cast<const VkAllocationCallbacks*>(pAllocator), std::bit_cast<VkAccelerationStructureKHR*>(&value))), value}; }
  Result buildAccelerationStructuresKHR(DeferredOperationKHR deferredOperation, uint32_t infoCount, const AccelerationStructureBuildGeometryInfoKHR* pInfos, const AccelerationStructureBuildRangeInfoKHR* const* ppBuildRangeInfos) const { return Result(vkBuildAccelerationStructuresKHR(this->handle, std::bit_cast<VkDeferredOperationKHR>(deferredOperation), infoCount, std::bit_cast<const VkAccelerationStructureBuildGeometryInfoKHR*>(pInfos), std::bit_cast<const VkAccelerationStructureBuildRangeInfoKHR* const*>(ppBuildRangeInfos))); }
  DeviceAddress getAccelerationStructureDeviceAddressKHR(const AccelerationStructureDeviceAddressInfoKHR& info) const { return vkGetAccelerationStructureDeviceAddressKHR(this->handle, std::bit_cast<const VkAccelerationStructureDeviceAddressInfoKHR*>(&info)); }
#endif // VK_KHR_acceleration_structure
#if VK_KHR_deferred_host_operations
  Ret<DeferredOperationKHR> createDeferredOperationKHR(const AllocationCallbacks* pAllocator = {}) const { DeferredOperationKHR value; return {Result(vkCreateDeferredOperationKHR(this->handle, std::bit_cast<const VkAllocationCallbacks*>(pAllocator), std::bit_cast<VkDeferredOperationKHR*>(&value))), value}; }
  void destroyDeferredOperationKHR(DeferredOperationKHR operation = {}, const AllocationCallbacks* pAllocator = {}) const { vkDestroyDeferredOperationKHR(this->handle, std::bit_cast<VkDeferredOperationKHR>(operation), std::bit_cast<const VkAllocationCallbacks*>(pAllocator)); }
  uint32_t getDeferredOperationMaxConcurrencyKHR(DeferredOperationKHR operation) const { return vkGetDeferredOperationMaxConcurrencyKHR(this->handle, std::bit_cast<VkDeferredOperationKHR>(operation)); }
  Result getDeferredOperationResultKHR(DeferredOperationKHR operation) const { return Result(vkGetDeferredOperationResultKHR(this->handle, std::bit_cast<VkDeferredOperationKHR>(operation))); }
  Result deferredOperationJoinKHR(DeferredOperationKHR operation) const { return Result(vkDeferredOperationJoinKHR(this->handle, std::bit_cast<VkDeferredOperationKHR>(operation))); }
#endif // VK_KHR_deferred_host_operations
#if VK_NV_device_generated_commands_compute
  void getPipelineIndirectMemoryRequirementsNV(const ComputePipelineCreateInfo& createInfo, MemoryRequirements2* pMemoryRequirements) const { vkGetPipelineIndirectMemoryRequirementsNV(this->handle, std::bit_cast<const VkComputePipelineCreateInfo*>(&createInfo), std::bit_cast<VkMemoryRequirements2*>(pMemoryRequirements)); }
  DeviceAddress getPipelineIndirectDeviceAddressNV(const PipelineIndirectDeviceAddressInfoNV& info) const { return vkGetPipelineIndirectDeviceAddressNV(this->handle, std::bit_cast<const VkPipelineIndirectDeviceAddressInfoNV*>(&info)); }
#endif // VK_NV_device_generated_commands_compute
#if VK_AMD_anti_lag
  void antiLagUpdateAMD(const AntiLagDataAMD& data) const { vkAntiLagUpdateAMD(this->handle, std::bit_cast<const VkAntiLagDataAMD*>(&data)); }
#endif // VK_AMD_anti_lag
#if VK_VERSION_1_3
  Ret<PrivateDataSlot> createPrivateDataSlot(const PrivateDataSlotCreateInfo& createInfo, const AllocationCallbacks* pAllocator = {}) const { PrivateDataSlot value; return {Result(vkCreatePrivateDataSlot(this->handle, std::bit_cast<const VkPrivateDataSlotCreateInfo*>(&createInfo), std::bit_cast<const VkAllocationCallbacks*>(pAllocator), std::bit_cast<VkPrivateDataSlot*>(&value))), value}; }
#endif // VK_VERSION_1_3
#if VK_EXT_private_data
  Ret<PrivateDataSlot> createPrivateDataSlotEXT(const PrivateDataSlotCreateInfo& createInfo, const AllocationCallbacks* pAllocator = {}) const { PrivateDataSlot value; return {Result(vkCreatePrivateDataSlotEXT(this->handle, std::bit_cast<const VkPrivateDataSlotCreateInfo*>(&createInfo), std::bit_cast<const VkAllocationCallbacks*>(pAllocator), std::bit_cast<VkPrivateDataSlot*>(&value))), value}; }
#endif // VK_EXT_private_data
#if VK_VERSION_1_3
  void destroyPrivateDataSlot(PrivateDataSlot privateDataSlot = {}, const AllocationCallbacks* pAllocator = {}) const { vkDestroyPrivateDataSlot(this->handle, std::bit_cast<VkPrivateDataSlot>(privateDataSlot), std::bit_cast<const VkAllocationCallbacks*>(pAllocator)); }
#endif // VK_VERSION_1_3
#if VK_EXT_private_data
  void destroyPrivateDataSlotEXT(PrivateDataSlot privateDataSlot = {}, const AllocationCallbacks* pAllocator = {}) const { vkDestroyPrivateDataSlotEXT(this->handle, std::bit_cast<VkPrivateDataSlot>(privateDataSlot), std::bit_cast<const VkAllocationCallbacks*>(pAllocator)); }
#endif // VK_EXT_private_data
#if VK_VERSION_1_3
  Result setPrivateData(Object object, PrivateDataSlot privateDataSlot, uint64_t data) const { return Result(vkSetPrivateData(this->handle, std::bit_cast<VkObjectType>(object.type), object.handle, std::bit_cast<VkPrivateDataSlot>(privateDataSlot), data)); }
#endif // VK_VERSION_1_3
#if VK_EXT_private_data
  Result setPrivateDataEXT(Object object, PrivateDataSlot privateDataSlot, uint64_t data) const { return Result(vkSetPrivateDataEXT(this->handle, std::bit_cast<VkObjectType>(object.type), object.handle, std::bit_cast<VkPrivateDataSlot>(privateDataSlot), data)); }
#endif // VK_EXT_private_data
#if VK_VERSION_1_3
  uint64_t getPrivateData(Object object, PrivateDataSlot privateDataSlot) const { uint64_t value; vkGetPrivateData(this->handle, std::bit_cast<VkObjectType>(object.type), object.handle, std::bit_cast<VkPrivateDataSlot>(privateDataSlot), &value); return value; }
#endif // VK_VERSION_1_3
#if VK_EXT_private_data
  uint64_t getPrivateDataEXT(Object object, PrivateDataSlot privateDataSlot) const { uint64_t value; vkGetPrivateDataEXT(this->handle, std::bit_cast<VkObjectType>(object.type), object.handle, std::bit_cast<VkPrivateDataSlot>(privateDataSlot), &value); return value; }
#endif // VK_EXT_private_data
#if VK_KHR_acceleration_structure
  void getAccelerationStructureBuildSizesKHR(AccelerationStructureBuildTypeKHR buildType, const AccelerationStructureBuildGeometryInfoKHR& buildInfo, const uint32_t* pMaxPrimitiveCounts, AccelerationStructureBuildSizesInfoKHR* pSizeInfo) const { vkGetAccelerationStructureBuildSizesKHR(this->handle, std::bit_cast<VkAccelerationStructureBuildTypeKHR>(buildType), std::bit_cast<const VkAccelerationStructureBuildGeometryInfoKHR*>(&buildInfo), pMaxPrimitiveCounts, std::bit_cast<VkAccelerationStructureBuildSizesInfoKHR*>(pSizeInfo)); }
#endif // VK_KHR_acceleration_structure
#if VK_VERSION_1_4
  Result copyMemoryToImage(const CopyMemoryToImageInfo& copyMemoryToImageInfo) const { return Result(vkCopyMemoryToImage(this->handle, std::bit_cast<const VkCopyMemoryToImageInfo*>(&copyMemoryToImageInfo))); }
#endif // VK_VERSION_1_4
#if VK_EXT_host_image_copy
  Result copyMemoryToImageEXT(const CopyMemoryToImageInfo& copyMemoryToImageInfo) const { return Result(vkCopyMemoryToImageEXT(this->handle, std::bit_cast<const VkCopyMemoryToImageInfo*>(&copyMemoryToImageInfo))); }
#endif // VK_EXT_host_image_copy
#if VK_VERSION_1_4
  Result copyImageToMemory(const CopyImageToMemoryInfo& copyImageToMemoryInfo) const { return Result(vkCopyImageToMemory(this->handle, std::bit_cast<const VkCopyImageToMemoryInfo*>(&copyImageToMemoryInfo))); }
#endif // VK_VERSION_1_4
#if VK_EXT_host_image_copy
  Result copyImageToMemoryEXT(const CopyImageToMemoryInfo& copyImageToMemoryInfo) const { return Result(vkCopyImageToMemoryEXT(this->handle, std::bit_cast<const VkCopyImageToMemoryInfo*>(&copyImageToMemoryInfo))); }
#endif // VK_EXT_host_image_copy
#if VK_VERSION_1_4
  Result copyImageToImage(const CopyImageToImageInfo& copyImageToImageInfo) const { return Result(vkCopyImageToImage(this->handle, std::bit_cast<const VkCopyImageToImageInfo*>(&copyImageToImageInfo))); }
#endif // VK_VERSION_1_4
#if VK_EXT_host_image_copy
  Result copyImageToImageEXT(const CopyImageToImageInfo& copyImageToImageInfo) const { return Result(vkCopyImageToImageEXT(this->handle, std::bit_cast<const VkCopyImageToImageInfo*>(&copyImageToImageInfo))); }
#endif // VK_EXT_host_image_copy
#if VK_VERSION_1_4
  Result transitionImageLayout(uint32_t transitionCount, const HostImageLayoutTransitionInfo* pTransitions) const { return Result(vkTransitionImageLayout(this->handle, transitionCount, std::bit_cast<const VkHostImageLayoutTransitionInfo*>(pTransitions))); }
#endif // VK_VERSION_1_4
#if VK_EXT_host_image_copy
  Result transitionImageLayoutEXT(uint32_t transitionCount, const HostImageLayoutTransitionInfo* pTransitions) const { return Result(vkTransitionImageLayoutEXT(this->handle, transitionCount, std::bit_cast<const VkHostImageLayoutTransitionInfo*>(pTransitions))); }
#endif // VK_EXT_host_image_copy
#if VK_KHR_video_queue
  Ret<VideoSessionKHR> createVideoSessionKHR(const VideoSessionCreateInfoKHR& createInfo, const AllocationCallbacks* pAllocator = {}) const { VideoSessionKHR value; return {Result(vkCreateVideoSessionKHR(this->handle, std::bit_cast<const VkVideoSessionCreateInfoKHR*>(&createInfo), std::bit_cast<const VkAllocationCallbacks*>(pAllocator), std::bit_cast<VkVideoSessionKHR*>(&value))), value}; }
  void destroyVideoSessionKHR(VideoSessionKHR videoSession = {}, const AllocationCallbacks* pAllocator = {}) const { vkDestroyVideoSessionKHR(this->handle, std::bit_cast<VkVideoSessionKHR>(videoSession), std::bit_cast<const VkAllocationCallbacks*>(pAllocator)); }
  Ret<VideoSessionParametersKHR> createVideoSessionParametersKHR(const VideoSessionParametersCreateInfoKHR& createInfo, const AllocationCallbacks* pAllocator = {}) const { VideoSessionParametersKHR value; return {Result(vkCreateVideoSessionParametersKHR(this->handle, std::bit_cast<const VkVideoSessionParametersCreateInfoKHR*>(&createInfo), std::bit_cast<const VkAllocationCallbacks*>(pAllocator), std::bit_cast<VkVideoSessionParametersKHR*>(&value))), value}; }
  Result updateVideoSessionParametersKHR(VideoSessionParametersKHR videoSessionParameters, const VideoSessionParametersUpdateInfoKHR& updateInfo) const { return Result(vkUpdateVideoSessionParametersKHR(this->handle, std::bit_cast<VkVideoSessionParametersKHR>(videoSessionParameters), std::bit_cast<const VkVideoSessionParametersUpdateInfoKHR*>(&updateInfo))); }
#endif // VK_KHR_video_queue
#if VK_KHR_video_encode_queue
  Result getEncodedVideoSessionParametersKHR(const VideoEncodeSessionParametersGetInfoKHR& videoSessionParametersInfo, VideoEncodeSessionParametersFeedbackInfoKHR* pFeedbackInfo, size_t* pDataSize, void* pData = {}) const { return Result(vkGetEncodedVideoSessionParametersKHR(this->handle, std::bit_cast<const VkVideoEncodeSessionParametersGetInfoKHR*>(&videoSessionParametersInfo), std::bit_cast<VkVideoEncodeSessionParametersFeedbackInfoKHR*>(pFeedbackInfo), pDataSize, pData)); }
#endif // VK_KHR_video_encode_queue
#if VK_KHR_video_queue
  void destroyVideoSessionParametersKHR(VideoSessionParametersKHR videoSessionParameters = {}, const AllocationCallbacks* pAllocator = {}) const { vkDestroyVideoSessionParametersKHR(this->handle, std::bit_cast<VkVideoSessionParametersKHR>(videoSessionParameters), std::bit_cast<const VkAllocationCallbacks*>(pAllocator)); }
  Result getVideoSessionMemoryRequirementsKHR(VideoSessionKHR videoSession, uint32_t* pMemoryRequirementsCount, VideoSessionMemoryRequirementsKHR* pMemoryRequirements = {}) const { return Result(vkGetVideoSessionMemoryRequirementsKHR(this->handle, std::bit_cast<VkVideoSessionKHR>(videoSession), pMemoryRequirementsCount, std::bit_cast<VkVideoSessionMemoryRequirementsKHR*>(pMemoryRequirements))); }
  Result bindVideoSessionMemoryKHR(VideoSessionKHR videoSession, uint32_t bindSessionMemoryInfoCount, const BindVideoSessionMemoryInfoKHR* pBindSessionMemoryInfos) const { return Result(vkBindVideoSessionMemoryKHR(this->handle, std::bit_cast<VkVideoSessionKHR>(videoSession), bindSessionMemoryInfoCount, std::bit_cast<const VkBindVideoSessionMemoryInfoKHR*>(pBindSessionMemoryInfos))); }
#endif // VK_KHR_video_queue
#if VK_NV_partitioned_acceleration_structure
  void getPartitionedAccelerationStructuresBuildSizesNV(const PartitionedAccelerationStructureInstancesInputNV& info, AccelerationStructureBuildSizesInfoKHR* pSizeInfo) const { vkGetPartitionedAccelerationStructuresBuildSizesNV(this->handle, std::bit_cast<const VkPartitionedAccelerationStructureInstancesInputNV*>(&info), std::bit_cast<VkAccelerationStructureBuildSizesInfoKHR*>(pSizeInfo)); }
#endif // VK_NV_partitioned_acceleration_structure
#if VK_NVX_binary_import
  Ret<CuModuleNVX> createCuModuleNVX(const CuModuleCreateInfoNVX& createInfo, const AllocationCallbacks* pAllocator = {}) const { CuModuleNVX value; return {Result(vkCreateCuModuleNVX(this->handle, std::bit_cast<const VkCuModuleCreateInfoNVX*>(&createInfo), std::bit_cast<const VkAllocationCallbacks*>(pAllocator), std::bit_cast<VkCuModuleNVX*>(&value))), value}; }
  Ret<CuFunctionNVX> createCuFunctionNVX(const CuFunctionCreateInfoNVX& createInfo, const AllocationCallbacks* pAllocator = {}) const { CuFunctionNVX value; return {Result(vkCreateCuFunctionNVX(this->handle, std::bit_cast<const VkCuFunctionCreateInfoNVX*>(&createInfo), std::bit_cast<const VkAllocationCallbacks*>(pAllocator), std::bit_cast<VkCuFunctionNVX*>(&value))), value}; }
  void destroyCuModuleNVX(CuModuleNVX module, const AllocationCallbacks* pAllocator = {}) const { vkDestroyCuModuleNVX(this->handle, std::bit_cast<VkCuModuleNVX>(module), std::bit_cast<const VkAllocationCallbacks*>(pAllocator)); }
  void destroyCuFunctionNVX(CuFunctionNVX function, const AllocationCallbacks* pAllocator = {}) const { vkDestroyCuFunctionNVX(this->handle, std::bit_cast<VkCuFunctionNVX>(function), std::bit_cast<const VkAllocationCallbacks*>(pAllocator)); }
#endif // VK_NVX_binary_import
#if VK_EXT_descriptor_buffer
  DeviceSize getDescriptorSetLayoutSizeEXT(DescriptorSetLayout layout) const { DeviceSize value; vkGetDescriptorSetLayoutSizeEXT(this->handle, std::bit_cast<VkDescriptorSetLayout>(layout), &value); return value; }
  DeviceSize getDescriptorSetLayoutBindingOffsetEXT(DescriptorSetLayout layout, uint32_t binding) const { DeviceSize value; vkGetDescriptorSetLayoutBindingOffsetEXT(this->handle, std::bit_cast<VkDescriptorSetLayout>(layout), binding, &value); return value; }
  void getDescriptorEXT(const DescriptorGetInfoEXT& descriptorInfo, size_t dataSize, void* pDescriptor) const { vkGetDescriptorEXT(this->handle, std::bit_cast<const VkDescriptorGetInfoEXT*>(&descriptorInfo), dataSize, pDescriptor); }
  Result getBufferOpaqueCaptureDescriptorDataEXT(const BufferCaptureDescriptorDataInfoEXT& info, void* pData) const { return Result(vkGetBufferOpaqueCaptureDescriptorDataEXT(this->handle, std::bit_cast<const VkBufferCaptureDescriptorDataInfoEXT*>(&info), pData)); }
  Result getImageOpaqueCaptureDescriptorDataEXT(const ImageCaptureDescriptorDataInfoEXT& info, void* pData) const { return Result(vkGetImageOpaqueCaptureDescriptorDataEXT(this->handle, std::bit_cast<const VkImageCaptureDescriptorDataInfoEXT*>(&info), pData)); }
  Result getImageViewOpaqueCaptureDescriptorDataEXT(const ImageViewCaptureDescriptorDataInfoEXT& info, void* pData) const { return Result(vkGetImageViewOpaqueCaptureDescriptorDataEXT(this->handle, std::bit_cast<const VkImageViewCaptureDescriptorDataInfoEXT*>(&info), pData)); }
  Result getSamplerOpaqueCaptureDescriptorDataEXT(const SamplerCaptureDescriptorDataInfoEXT& info, void* pData) const { return Result(vkGetSamplerOpaqueCaptureDescriptorDataEXT(this->handle, std::bit_cast<const VkSamplerCaptureDescriptorDataInfoEXT*>(&info), pData)); }
#endif // VK_EXT_descriptor_buffer
#if VK_EXT_pageable_device_local_memory
  void setDeviceMemoryPriorityEXT(DeviceMemory memory, float priority) const { vkSetDeviceMemoryPriorityEXT(this->handle, std::bit_cast<VkDeviceMemory>(memory), priority); }
#endif // VK_EXT_pageable_device_local_memory
#if VK_KHR_present_wait2
  Result waitForPresent2KHR(SwapchainKHR swapchain, const PresentWait2InfoKHR& presentWait2Info) const { return Result(vkWaitForPresent2KHR(this->handle, std::bit_cast<VkSwapchainKHR>(swapchain), std::bit_cast<const VkPresentWait2InfoKHR*>(&presentWait2Info))); }
#endif // VK_KHR_present_wait2
#if VK_KHR_present_wait
  Result waitForPresentKHR(SwapchainKHR swapchain, uint64_t presentId, uint64_t timeout) const { return Result(vkWaitForPresentKHR(this->handle, std::bit_cast<VkSwapchainKHR>(swapchain), presentId, timeout)); }
#endif // VK_KHR_present_wait
#if VK_FUCHSIA_buffer_collection
  Ret<BufferCollectionFUCHSIA> createBufferCollectionFUCHSIA(const BufferCollectionCreateInfoFUCHSIA& createInfo, const AllocationCallbacks* pAllocator = {}) const { BufferCollectionFUCHSIA value; return {Result(vkCreateBufferCollectionFUCHSIA(this->handle, std::bit_cast<const VkBufferCollectionCreateInfoFUCHSIA*>(&createInfo), std::bit_cast<const VkAllocationCallbacks*>(pAllocator), std::bit_cast<VkBufferCollectionFUCHSIA*>(&value))), value}; }
  Result setBufferCollectionBufferConstraintsFUCHSIA(BufferCollectionFUCHSIA collection, const BufferConstraintsInfoFUCHSIA& bufferConstraintsInfo) const { return Result(vkSetBufferCollectionBufferConstraintsFUCHSIA(this->handle, std::bit_cast<VkBufferCollectionFUCHSIA>(collection), std::bit_cast<const VkBufferConstraintsInfoFUCHSIA*>(&bufferConstraintsInfo))); }
  Result setBufferCollectionImageConstraintsFUCHSIA(BufferCollectionFUCHSIA collection, const ImageConstraintsInfoFUCHSIA& imageConstraintsInfo) const { return Result(vkSetBufferCollectionImageConstraintsFUCHSIA(this->handle, std::bit_cast<VkBufferCollectionFUCHSIA>(collection), std::bit_cast<const VkImageConstraintsInfoFUCHSIA*>(&imageConstraintsInfo))); }
  void destroyBufferCollectionFUCHSIA(BufferCollectionFUCHSIA collection, const AllocationCallbacks* pAllocator = {}) const { vkDestroyBufferCollectionFUCHSIA(this->handle, std::bit_cast<VkBufferCollectionFUCHSIA>(collection), std::bit_cast<const VkAllocationCallbacks*>(pAllocator)); }
  Result getBufferCollectionPropertiesFUCHSIA(BufferCollectionFUCHSIA collection, BufferCollectionPropertiesFUCHSIA* pProperties) const { return Result(vkGetBufferCollectionPropertiesFUCHSIA(this->handle, std::bit_cast<VkBufferCollectionFUCHSIA>(collection), std::bit_cast<VkBufferCollectionPropertiesFUCHSIA*>(pProperties))); }
#endif // VK_FUCHSIA_buffer_collection
#if VK_VALVE_descriptor_set_host_mapping
  void getDescriptorSetLayoutHostMappingInfoVALVE(const DescriptorSetBindingReferenceVALVE& bindingReference, DescriptorSetLayoutHostMappingInfoVALVE* pHostMapping) const { vkGetDescriptorSetLayoutHostMappingInfoVALVE(this->handle, std::bit_cast<const VkDescriptorSetBindingReferenceVALVE*>(&bindingReference), std::bit_cast<VkDescriptorSetLayoutHostMappingInfoVALVE*>(pHostMapping)); }
  void* getDescriptorSetHostMappingVALVE(DescriptorSet descriptorSet) const { void* value; vkGetDescriptorSetHostMappingVALVE(this->handle, std::bit_cast<VkDescriptorSet>(descriptorSet), &value); return value; }
#endif // VK_VALVE_descriptor_set_host_mapping
#if VK_EXT_opacity_micromap
  Ret<MicromapEXT> createMicromapEXT(const MicromapCreateInfoEXT& createInfo, const AllocationCallbacks* pAllocator = {}) const { MicromapEXT value; return {Result(vkCreateMicromapEXT(this->handle, std::bit_cast<const VkMicromapCreateInfoEXT*>(&createInfo), std::bit_cast<const VkAllocationCallbacks*>(pAllocator), std::bit_cast<VkMicromapEXT*>(&value))), value}; }
  Result buildMicromapsEXT(DeferredOperationKHR deferredOperation, uint32_t infoCount, const MicromapBuildInfoEXT* pInfos) const { return Result(vkBuildMicromapsEXT(this->handle, std::bit_cast<VkDeferredOperationKHR>(deferredOperation), infoCount, std::bit_cast<const VkMicromapBuildInfoEXT*>(pInfos))); }
  void destroyMicromapEXT(MicromapEXT micromap = {}, const AllocationCallbacks* pAllocator = {}) const { vkDestroyMicromapEXT(this->handle, std::bit_cast<VkMicromapEXT>(micromap), std::bit_cast<const VkAllocationCallbacks*>(pAllocator)); }
  Result copyMicromapEXT(DeferredOperationKHR deferredOperation, const CopyMicromapInfoEXT& info) const { return Result(vkCopyMicromapEXT(this->handle, std::bit_cast<VkDeferredOperationKHR>(deferredOperation), std::bit_cast<const VkCopyMicromapInfoEXT*>(&info))); }
  Result copyMicromapToMemoryEXT(DeferredOperationKHR deferredOperation, const CopyMicromapToMemoryInfoEXT& info) const { return Result(vkCopyMicromapToMemoryEXT(this->handle, std::bit_cast<VkDeferredOperationKHR>(deferredOperation), std::bit_cast<const VkCopyMicromapToMemoryInfoEXT*>(&info))); }
  Result copyMemoryToMicromapEXT(DeferredOperationKHR deferredOperation, const CopyMemoryToMicromapInfoEXT& info) const { return Result(vkCopyMemoryToMicromapEXT(this->handle, std::bit_cast<VkDeferredOperationKHR>(deferredOperation), std::bit_cast<const VkCopyMemoryToMicromapInfoEXT*>(&info))); }
  Result writeMicromapsPropertiesEXT(uint32_t micromapCount, const MicromapEXT* pMicromaps, QueryType queryType, size_t dataSize, void* pData, size_t stride) const { return Result(vkWriteMicromapsPropertiesEXT(this->handle, micromapCount, std::bit_cast<const VkMicromapEXT*>(pMicromaps), std::bit_cast<VkQueryType>(queryType), dataSize, pData, stride)); }
  AccelerationStructureCompatibilityKHR getMicromapCompatibilityEXT(const MicromapVersionInfoEXT& versionInfo) const { AccelerationStructureCompatibilityKHR value; vkGetDeviceMicromapCompatibilityEXT(this->handle, std::bit_cast<const VkMicromapVersionInfoEXT*>(&versionInfo), std::bit_cast<VkAccelerationStructureCompatibilityKHR*>(&value)); return value; }
  void getMicromapBuildSizesEXT(AccelerationStructureBuildTypeKHR buildType, const MicromapBuildInfoEXT& buildInfo, MicromapBuildSizesInfoEXT* pSizeInfo) const { vkGetMicromapBuildSizesEXT(this->handle, std::bit_cast<VkAccelerationStructureBuildTypeKHR>(buildType), std::bit_cast<const VkMicromapBuildInfoEXT*>(&buildInfo), std::bit_cast<VkMicromapBuildSizesInfoEXT*>(pSizeInfo)); }
#endif // VK_EXT_opacity_micromap
#if VK_EXT_shader_module_identifier
  void getShaderModuleIdentifierEXT(ShaderModule shaderModule, ShaderModuleIdentifierEXT* pIdentifier) const { vkGetShaderModuleIdentifierEXT(this->handle, std::bit_cast<VkShaderModule>(shaderModule), std::bit_cast<VkShaderModuleIdentifierEXT*>(pIdentifier)); }
  void getShaderModuleCreateInfoIdentifierEXT(const ShaderModuleCreateInfo& createInfo, ShaderModuleIdentifierEXT* pIdentifier) const { vkGetShaderModuleCreateInfoIdentifierEXT(this->handle, std::bit_cast<const VkShaderModuleCreateInfo*>(&createInfo), std::bit_cast<VkShaderModuleIdentifierEXT*>(pIdentifier)); }
#endif // VK_EXT_shader_module_identifier
#if VK_VERSION_1_4
  void getImageSubresourceLayout2(Image image, const ImageSubresource2& subresource, SubresourceLayout2* pLayout) const { vkGetImageSubresourceLayout2(this->handle, std::bit_cast<VkImage>(image), std::bit_cast<const VkImageSubresource2*>(&subresource), std::bit_cast<VkSubresourceLayout2*>(pLayout)); }
#endif // VK_VERSION_1_4
#if VK_KHR_maintenance5
  void getImageSubresourceLayout2KHR(Image image, const ImageSubresource2& subresource, SubresourceLayout2* pLayout) const { vkGetImageSubresourceLayout2KHR(this->handle, std::bit_cast<VkImage>(image), std::bit_cast<const VkImageSubresource2*>(&subresource), std::bit_cast<VkSubresourceLayout2*>(pLayout)); }
#endif // VK_KHR_maintenance5
#if VK_EXT_host_image_copy
  void getImageSubresourceLayout2EXT(Image image, const ImageSubresource2& subresource, SubresourceLayout2* pLayout) const { vkGetImageSubresourceLayout2EXT(this->handle, std::bit_cast<VkImage>(image), std::bit_cast<const VkImageSubresource2*>(&subresource), std::bit_cast<VkSubresourceLayout2*>(pLayout)); }
#endif // VK_EXT_host_image_copy
#if VK_EXT_pipeline_properties
  Ret<BaseOutStructure> getPipelinePropertiesEXT(const PipelineInfoEXT& pipelineInfo) const { BaseOutStructure value; return {Result(vkGetPipelinePropertiesEXT(this->handle, std::bit_cast<const VkPipelineInfoEXT*>(&pipelineInfo), &value)), value}; }
#endif // VK_EXT_pipeline_properties
#if VK_EXT_metal_objects
  void exportMetalObjectsEXT(ExportMetalObjectsInfoEXT* pMetalObjectsInfo) const { vkExportMetalObjectsEXT(this->handle, std::bit_cast<VkExportMetalObjectsInfoEXT*>(pMetalObjectsInfo)); }
#endif // VK_EXT_metal_objects
#if VK_QCOM_tile_properties
  Result getFramebufferTilePropertiesQCOM(Framebuffer framebuffer, uint32_t* pPropertiesCount, TilePropertiesQCOM* pProperties = {}) const { return Result(vkGetFramebufferTilePropertiesQCOM(this->handle, std::bit_cast<VkFramebuffer>(framebuffer), pPropertiesCount, std::bit_cast<VkTilePropertiesQCOM*>(pProperties))); }
  Result getDynamicRenderingTilePropertiesQCOM(const RenderingInfo& renderingInfo, TilePropertiesQCOM* pProperties) const { return Result(vkGetDynamicRenderingTilePropertiesQCOM(this->handle, std::bit_cast<const VkRenderingInfo*>(&renderingInfo), std::bit_cast<VkTilePropertiesQCOM*>(pProperties))); }
#endif // VK_QCOM_tile_properties
#if VK_NV_optical_flow
  Ret<OpticalFlowSessionNV> createOpticalFlowSessionNV(const OpticalFlowSessionCreateInfoNV& createInfo, const AllocationCallbacks* pAllocator = {}) const { OpticalFlowSessionNV value; return {Result(vkCreateOpticalFlowSessionNV(this->handle, std::bit_cast<const VkOpticalFlowSessionCreateInfoNV*>(&createInfo), std::bit_cast<const VkAllocationCallbacks*>(pAllocator), std::bit_cast<VkOpticalFlowSessionNV*>(&value))), value}; }
  void destroyOpticalFlowSessionNV(OpticalFlowSessionNV session, const AllocationCallbacks* pAllocator = {}) const { vkDestroyOpticalFlowSessionNV(this->handle, std::bit_cast<VkOpticalFlowSessionNV>(session), std::bit_cast<const VkAllocationCallbacks*>(pAllocator)); }
  Result bindOpticalFlowSessionImageNV(OpticalFlowSessionNV session, OpticalFlowSessionBindingPointNV bindingPoint, ImageView view, ImageLayout layout) const { return Result(vkBindOpticalFlowSessionImageNV(this->handle, std::bit_cast<VkOpticalFlowSessionNV>(session), std::bit_cast<VkOpticalFlowSessionBindingPointNV>(bindingPoint), std::bit_cast<VkImageView>(view), std::bit_cast<VkImageLayout>(layout))); }
#endif // VK_NV_optical_flow
#if VK_EXT_device_fault
  Result getFaultInfoEXT(DeviceFaultCountsEXT* pFaultCounts, DeviceFaultInfoEXT* pFaultInfo = {}) const { return Result(vkGetDeviceFaultInfoEXT(this->handle, std::bit_cast<VkDeviceFaultCountsEXT*>(pFaultCounts), std::bit_cast<VkDeviceFaultInfoEXT*>(pFaultInfo))); }
#endif // VK_EXT_device_fault
#if VK_KHR_swapchain_maintenance1
  Result releaseSwapchainImagesKHR(const ReleaseSwapchainImagesInfoKHR& releaseInfo) const { return Result(vkReleaseSwapchainImagesKHR(this->handle, std::bit_cast<const VkReleaseSwapchainImagesInfoKHR*>(&releaseInfo))); }
#endif // VK_KHR_swapchain_maintenance1
#if VK_EXT_swapchain_maintenance1
  Result releaseSwapchainImagesEXT(const ReleaseSwapchainImagesInfoKHR& releaseInfo) const { return Result(vkReleaseSwapchainImagesEXT(this->handle, std::bit_cast<const VkReleaseSwapchainImagesInfoKHR*>(&releaseInfo))); }
#endif // VK_EXT_swapchain_maintenance1
#if VK_VERSION_1_4
  void getImageSubresourceLayout(const DeviceImageSubresourceInfo& info, SubresourceLayout2* pLayout) const { vkGetDeviceImageSubresourceLayout(this->handle, std::bit_cast<const VkDeviceImageSubresourceInfo*>(&info), std::bit_cast<VkSubresourceLayout2*>(pLayout)); }
#endif // VK_VERSION_1_4
#if VK_KHR_maintenance5
  void getImageSubresourceLayoutKHR(const DeviceImageSubresourceInfo& info, SubresourceLayout2* pLayout) const { vkGetDeviceImageSubresourceLayoutKHR(this->handle, std::bit_cast<const VkDeviceImageSubresourceInfo*>(&info), std::bit_cast<VkSubresourceLayout2*>(pLayout)); }
#endif // VK_KHR_maintenance5
#if VK_VERSION_1_4
  Ret<void*> mapMemory2(const MemoryMapInfo& memoryMapInfo) const { void* value; return {Result(vkMapMemory2(this->handle, std::bit_cast<const VkMemoryMapInfo*>(&memoryMapInfo), &value)), value}; }
#endif // VK_VERSION_1_4
#if VK_KHR_map_memory2
  Ret<void*> mapMemory2KHR(const MemoryMapInfo& memoryMapInfo) const { void* value; return {Result(vkMapMemory2KHR(this->handle, std::bit_cast<const VkMemoryMapInfo*>(&memoryMapInfo), &value)), value}; }
#endif // VK_KHR_map_memory2
#if VK_VERSION_1_4
  Result unmapMemory2(const MemoryUnmapInfo& memoryUnmapInfo) const { return Result(vkUnmapMemory2(this->handle, std::bit_cast<const VkMemoryUnmapInfo*>(&memoryUnmapInfo))); }
#endif // VK_VERSION_1_4
#if VK_KHR_map_memory2
  Result unmapMemory2KHR(const MemoryUnmapInfo& memoryUnmapInfo) const { return Result(vkUnmapMemory2KHR(this->handle, std::bit_cast<const VkMemoryUnmapInfo*>(&memoryUnmapInfo))); }
#endif // VK_KHR_map_memory2
#if VK_EXT_shader_object
  Result createShadersEXT(uint32_t createInfoCount, const ShaderCreateInfoEXT* pCreateInfos, ShaderEXT* pShaders, const AllocationCallbacks* pAllocator = {}) const { return Result(vkCreateShadersEXT(this->handle, createInfoCount, std::bit_cast<const VkShaderCreateInfoEXT*>(pCreateInfos), std::bit_cast<const VkAllocationCallbacks*>(pAllocator), std::bit_cast<VkShaderEXT*>(pShaders))); }
  void destroyShaderEXT(ShaderEXT shader = {}, const AllocationCallbacks* pAllocator = {}) const { vkDestroyShaderEXT(this->handle, std::bit_cast<VkShaderEXT>(shader), std::bit_cast<const VkAllocationCallbacks*>(pAllocator)); }
  Result getShaderBinaryDataEXT(ShaderEXT shader, size_t* pDataSize, void* pData = {}) const { return Result(vkGetShaderBinaryDataEXT(this->handle, std::bit_cast<VkShaderEXT>(shader), pDataSize, pData)); }
#endif // VK_EXT_shader_object
#if VK_QNX_external_memory_screen_buffer
  Result getScreenBufferPropertiesQNX(const struct _screen_buffer& buffer, ScreenBufferPropertiesQNX* pProperties) const { return Result(vkGetScreenBufferPropertiesQNX(this->handle, &buffer, std::bit_cast<VkScreenBufferPropertiesQNX*>(pProperties))); }
#endif // VK_QNX_external_memory_screen_buffer
#if VK_NV_low_latency2
  Result setLatencySleepModeNV(SwapchainKHR swapchain, const LatencySleepModeInfoNV& sleepModeInfo) const { return Result(vkSetLatencySleepModeNV(this->handle, std::bit_cast<VkSwapchainKHR>(swapchain), std::bit_cast<const VkLatencySleepModeInfoNV*>(&sleepModeInfo))); }
  Result latencySleepNV(SwapchainKHR swapchain, const LatencySleepInfoNV& sleepInfo) const { return Result(vkLatencySleepNV(this->handle, std::bit_cast<VkSwapchainKHR>(swapchain), std::bit_cast<const VkLatencySleepInfoNV*>(&sleepInfo))); }
  void setLatencyMarkerNV(SwapchainKHR swapchain, const SetLatencyMarkerInfoNV& latencyMarkerInfo) const { vkSetLatencyMarkerNV(this->handle, std::bit_cast<VkSwapchainKHR>(swapchain), std::bit_cast<const VkSetLatencyMarkerInfoNV*>(&latencyMarkerInfo)); }
  void getLatencyTimingsNV(SwapchainKHR swapchain, GetLatencyMarkerInfoNV* pLatencyMarkerInfo) const { vkGetLatencyTimingsNV(this->handle, std::bit_cast<VkSwapchainKHR>(swapchain), std::bit_cast<VkGetLatencyMarkerInfoNV*>(pLatencyMarkerInfo)); }
#endif // VK_NV_low_latency2
#if VK_EXT_external_memory_metal
  Ret<void*> getMemoryMetalHandleEXT(const MemoryGetMetalHandleInfoEXT& getMetalHandleInfo) const { void* value; return {Result(vkGetMemoryMetalHandleEXT(this->handle, std::bit_cast<const VkMemoryGetMetalHandleInfoEXT*>(&getMetalHandleInfo), &value)), value}; }
  Result getMemoryMetalHandlePropertiesEXT(ExternalMemoryHandleTypeFlagBits handleType, const void* pHandle, MemoryMetalHandlePropertiesEXT* pMemoryMetalHandleProperties) const { return Result(vkGetMemoryMetalHandlePropertiesEXT(this->handle, std::bit_cast<VkExternalMemoryHandleTypeFlagBits>(handleType), pHandle, std::bit_cast<VkMemoryMetalHandlePropertiesEXT*>(pMemoryMetalHandleProperties))); }
#endif // VK_EXT_external_memory_metal
#if VK_NV_cooperative_vector
  Result convertCooperativeVectorMatrixNV(const ConvertCooperativeVectorMatrixInfoNV& info) const { return Result(vkConvertCooperativeVectorMatrixNV(this->handle, std::bit_cast<const VkConvertCooperativeVectorMatrixInfoNV*>(&info))); }
#endif // VK_NV_cooperative_vector
#if VK_NV_external_compute_queue
  Ret<ExternalComputeQueueNV> createExternalComputeQueueNV(const ExternalComputeQueueCreateInfoNV& createInfo, const AllocationCallbacks* pAllocator = {}) const { ExternalComputeQueueNV value; return {Result(vkCreateExternalComputeQueueNV(this->handle, std::bit_cast<const VkExternalComputeQueueCreateInfoNV*>(&createInfo), std::bit_cast<const VkAllocationCallbacks*>(pAllocator), std::bit_cast<VkExternalComputeQueueNV*>(&value))), value}; }
  void destroyExternalComputeQueueNV(ExternalComputeQueueNV externalQueue, const AllocationCallbacks* pAllocator = {}) const { vkDestroyExternalComputeQueueNV(this->handle, std::bit_cast<VkExternalComputeQueueNV>(externalQueue), std::bit_cast<const VkAllocationCallbacks*>(pAllocator)); }
#endif // VK_NV_external_compute_queue
#if VK_ARM_tensors
  Ret<TensorARM> createTensorARM(const TensorCreateInfoARM& createInfo, const AllocationCallbacks* pAllocator = {}) const { TensorARM value; return {Result(vkCreateTensorARM(this->handle, std::bit_cast<const VkTensorCreateInfoARM*>(&createInfo), std::bit_cast<const VkAllocationCallbacks*>(pAllocator), std::bit_cast<VkTensorARM*>(&value))), value}; }
  void destroyTensorARM(TensorARM tensor = {}, const AllocationCallbacks* pAllocator = {}) const { vkDestroyTensorARM(this->handle, std::bit_cast<VkTensorARM>(tensor), std::bit_cast<const VkAllocationCallbacks*>(pAllocator)); }
  Ret<TensorViewARM> createTensorViewARM(const TensorViewCreateInfoARM& createInfo, const AllocationCallbacks* pAllocator = {}) const { TensorViewARM value; return {Result(vkCreateTensorViewARM(this->handle, std::bit_cast<const VkTensorViewCreateInfoARM*>(&createInfo), std::bit_cast<const VkAllocationCallbacks*>(pAllocator), std::bit_cast<VkTensorViewARM*>(&value))), value}; }
  void destroyTensorViewARM(TensorViewARM tensorView = {}, const AllocationCallbacks* pAllocator = {}) const { vkDestroyTensorViewARM(this->handle, std::bit_cast<VkTensorViewARM>(tensorView), std::bit_cast<const VkAllocationCallbacks*>(pAllocator)); }
  void getTensorMemoryRequirementsARM(const TensorMemoryRequirementsInfoARM& info, MemoryRequirements2* pMemoryRequirements) const { vkGetTensorMemoryRequirementsARM(this->handle, std::bit_cast<const VkTensorMemoryRequirementsInfoARM*>(&info), std::bit_cast<VkMemoryRequirements2*>(pMemoryRequirements)); }
  Result bindTensorMemoryARM(uint32_t bindInfoCount, const BindTensorMemoryInfoARM* pBindInfos) const { return Result(vkBindTensorMemoryARM(this->handle, bindInfoCount, std::bit_cast<const VkBindTensorMemoryInfoARM*>(pBindInfos))); }
  void getTensorMemoryRequirementsARM(const DeviceTensorMemoryRequirementsARM& info, MemoryRequirements2* pMemoryRequirements) const { vkGetDeviceTensorMemoryRequirementsARM(this->handle, std::bit_cast<const VkDeviceTensorMemoryRequirementsARM*>(&info), std::bit_cast<VkMemoryRequirements2*>(pMemoryRequirements)); }
  Result getTensorOpaqueCaptureDescriptorDataARM(const TensorCaptureDescriptorDataInfoARM& info, void* pData) const { return Result(vkGetTensorOpaqueCaptureDescriptorDataARM(this->handle, std::bit_cast<const VkTensorCaptureDescriptorDataInfoARM*>(&info), pData)); }
  Result getTensorViewOpaqueCaptureDescriptorDataARM(const TensorViewCaptureDescriptorDataInfoARM& info, void* pData) const { return Result(vkGetTensorViewOpaqueCaptureDescriptorDataARM(this->handle, std::bit_cast<const VkTensorViewCaptureDescriptorDataInfoARM*>(&info), pData)); }
#endif // VK_ARM_tensors
#if VK_ARM_data_graph
  Result createDataGraphPipelinesARM(DeferredOperationKHR deferredOperation, PipelineCache pipelineCache, uint32_t createInfoCount, const DataGraphPipelineCreateInfoARM* pCreateInfos, Pipeline* pPipelines, const AllocationCallbacks* pAllocator = {}) const { return Result(vkCreateDataGraphPipelinesARM(this->handle, std::bit_cast<VkDeferredOperationKHR>(deferredOperation), std::bit_cast<VkPipelineCache>(pipelineCache), createInfoCount, std::bit_cast<const VkDataGraphPipelineCreateInfoARM*>(pCreateInfos), std::bit_cast<const VkAllocationCallbacks*>(pAllocator), std::bit_cast<VkPipeline*>(pPipelines))); }
  Ret<DataGraphPipelineSessionARM> createDataGraphPipelineSessionARM(const DataGraphPipelineSessionCreateInfoARM& createInfo, const AllocationCallbacks* pAllocator = {}) const { DataGraphPipelineSessionARM value; return {Result(vkCreateDataGraphPipelineSessionARM(this->handle, std::bit_cast<const VkDataGraphPipelineSessionCreateInfoARM*>(&createInfo), std::bit_cast<const VkAllocationCallbacks*>(pAllocator), std::bit_cast<VkDataGraphPipelineSessionARM*>(&value))), value}; }
  Result getDataGraphPipelineSessionBindPointRequirementsARM(const DataGraphPipelineSessionBindPointRequirementsInfoARM& info, uint32_t* pBindPointRequirementCount, DataGraphPipelineSessionBindPointRequirementARM* pBindPointRequirements = {}) const { return Result(vkGetDataGraphPipelineSessionBindPointRequirementsARM(this->handle, std::bit_cast<const VkDataGraphPipelineSessionBindPointRequirementsInfoARM*>(&info), pBindPointRequirementCount, std::bit_cast<VkDataGraphPipelineSessionBindPointRequirementARM*>(pBindPointRequirements))); }
  void getDataGraphPipelineSessionMemoryRequirementsARM(const DataGraphPipelineSessionMemoryRequirementsInfoARM& info, MemoryRequirements2* pMemoryRequirements) const { vkGetDataGraphPipelineSessionMemoryRequirementsARM(this->handle, std::bit_cast<const VkDataGraphPipelineSessionMemoryRequirementsInfoARM*>(&info), std::bit_cast<VkMemoryRequirements2*>(pMemoryRequirements)); }
  Result bindDataGraphPipelineSessionMemoryARM(uint32_t bindInfoCount, const BindDataGraphPipelineSessionMemoryInfoARM* pBindInfos) const { return Result(vkBindDataGraphPipelineSessionMemoryARM(this->handle, bindInfoCount, std::bit_cast<const VkBindDataGraphPipelineSessionMemoryInfoARM*>(pBindInfos))); }
  void destroyDataGraphPipelineSessionARM(DataGraphPipelineSessionARM session, const AllocationCallbacks* pAllocator = {}) const { vkDestroyDataGraphPipelineSessionARM(this->handle, std::bit_cast<VkDataGraphPipelineSessionARM>(session), std::bit_cast<const VkAllocationCallbacks*>(pAllocator)); }
  Result getDataGraphPipelineAvailablePropertiesARM(const DataGraphPipelineInfoARM& pipelineInfo, uint32_t* pPropertiesCount, DataGraphPipelinePropertyARM* pProperties = {}) const { return Result(vkGetDataGraphPipelineAvailablePropertiesARM(this->handle, std::bit_cast<const VkDataGraphPipelineInfoARM*>(&pipelineInfo), pPropertiesCount, std::bit_cast<VkDataGraphPipelinePropertyARM*>(pProperties))); }
  Result getDataGraphPipelinePropertiesARM(const DataGraphPipelineInfoARM& pipelineInfo, uint32_t propertiesCount, DataGraphPipelinePropertyQueryResultARM* pProperties) const { return Result(vkGetDataGraphPipelinePropertiesARM(this->handle, std::bit_cast<const VkDataGraphPipelineInfoARM*>(&pipelineInfo), propertiesCount, std::bit_cast<VkDataGraphPipelinePropertyQueryResultARM*>(pProperties))); }
#endif // VK_ARM_data_graph
};
struct PhysicalDevice : Handle<VkPhysicalDevice, ObjectType::ePhysicalDevice> {
  void getProperties(PhysicalDeviceProperties* pProperties) const { vkGetPhysicalDeviceProperties(this->handle, std::bit_cast<VkPhysicalDeviceProperties*>(pProperties)); }
  void getQueueFamilyProperties(uint32_t* pQueueFamilyPropertyCount, QueueFamilyProperties* pQueueFamilyProperties = {}) const { vkGetPhysicalDeviceQueueFamilyProperties(this->handle, pQueueFamilyPropertyCount, std::bit_cast<VkQueueFamilyProperties*>(pQueueFamilyProperties)); }
  void getMemoryProperties(PhysicalDeviceMemoryProperties* pMemoryProperties) const { vkGetPhysicalDeviceMemoryProperties(this->handle, std::bit_cast<VkPhysicalDeviceMemoryProperties*>(pMemoryProperties)); }
  void getFeatures(PhysicalDeviceFeatures* pFeatures) const { vkGetPhysicalDeviceFeatures(this->handle, std::bit_cast<VkPhysicalDeviceFeatures*>(pFeatures)); }
  void getFormatProperties(Format format, FormatProperties* pFormatProperties) const { vkGetPhysicalDeviceFormatProperties(this->handle, std::bit_cast<VkFormat>(format), std::bit_cast<VkFormatProperties*>(pFormatProperties)); }
  Result getImageFormatProperties(Format format, ImageType type, ImageTiling tiling, ImageUsageFlags usage, ImageCreateFlags flags, ImageFormatProperties* pImageFormatProperties) const { return Result(vkGetPhysicalDeviceImageFormatProperties(this->handle, std::bit_cast<VkFormat>(format), std::bit_cast<VkImageType>(type), std::bit_cast<VkImageTiling>(tiling), std::bit_cast<VkImageUsageFlags>(usage), std::bit_cast<VkImageCreateFlags>(flags), std::bit_cast<VkImageFormatProperties*>(pImageFormatProperties))); }
  Ret<Device> createDevice(const DeviceCreateInfo& createInfo, const AllocationCallbacks* pAllocator = {}) const { Device value; return {Result(vkCreateDevice(this->handle, std::bit_cast<const VkDeviceCreateInfo*>(&createInfo), std::bit_cast<const VkAllocationCallbacks*>(pAllocator), std::bit_cast<VkDevice*>(&value))), value}; }
  Result enumerateDeviceLayerProperties(uint32_t* pPropertyCount, LayerProperties* pProperties = {}) const { return Result(vkEnumerateDeviceLayerProperties(this->handle, pPropertyCount, std::bit_cast<VkLayerProperties*>(pProperties))); }
  Result enumerateDeviceExtensionProperties(const char* pLayerName, uint32_t* pPropertyCount, ExtensionProperties* pProperties = {}) const { return Result(vkEnumerateDeviceExtensionProperties(this->handle, pLayerName, pPropertyCount, std::bit_cast<VkExtensionProperties*>(pProperties))); }
  void getSparseImageFormatProperties(Format format, ImageType type, SampleCountFlagBits samples, ImageUsageFlags usage, ImageTiling tiling, uint32_t* pPropertyCount, SparseImageFormatProperties* pProperties = {}) const { vkGetPhysicalDeviceSparseImageFormatProperties(this->handle, std::bit_cast<VkFormat>(format), std::bit_cast<VkImageType>(type), std::bit_cast<VkSampleCountFlagBits>(samples), std::bit_cast<VkImageUsageFlags>(usage), std::bit_cast<VkImageTiling>(tiling), pPropertyCount, std::bit_cast<VkSparseImageFormatProperties*>(pProperties)); }
#if VK_KHR_display
  Result getDisplayPropertiesKHR(uint32_t* pPropertyCount, DisplayPropertiesKHR* pProperties = {}) const { return Result(vkGetPhysicalDeviceDisplayPropertiesKHR(this->handle, pPropertyCount, std::bit_cast<VkDisplayPropertiesKHR*>(pProperties))); }
  Result getDisplayPlanePropertiesKHR(uint32_t* pPropertyCount, DisplayPlanePropertiesKHR* pProperties = {}) const { return Result(vkGetPhysicalDeviceDisplayPlanePropertiesKHR(this->handle, pPropertyCount, std::bit_cast<VkDisplayPlanePropertiesKHR*>(pProperties))); }
  Result getDisplayPlaneSupportedDisplaysKHR(uint32_t planeIndex, uint32_t* pDisplayCount, DisplayKHR* pDisplays = {}) const { return Result(vkGetDisplayPlaneSupportedDisplaysKHR(this->handle, planeIndex, pDisplayCount, std::bit_cast<VkDisplayKHR*>(pDisplays))); }
  Result getDisplayModePropertiesKHR(DisplayKHR display, uint32_t* pPropertyCount, DisplayModePropertiesKHR* pProperties = {}) const { return Result(vkGetDisplayModePropertiesKHR(this->handle, std::bit_cast<VkDisplayKHR>(display), pPropertyCount, std::bit_cast<VkDisplayModePropertiesKHR*>(pProperties))); }
  Ret<DisplayModeKHR> createDisplayModeKHR(DisplayKHR display, const DisplayModeCreateInfoKHR& createInfo, const AllocationCallbacks* pAllocator = {}) const { DisplayModeKHR value; return {Result(vkCreateDisplayModeKHR(this->handle, std::bit_cast<VkDisplayKHR>(display), std::bit_cast<const VkDisplayModeCreateInfoKHR*>(&createInfo), std::bit_cast<const VkAllocationCallbacks*>(pAllocator), std::bit_cast<VkDisplayModeKHR*>(&value))), value}; }
  Result getDisplayPlaneCapabilitiesKHR(DisplayModeKHR mode, uint32_t planeIndex, DisplayPlaneCapabilitiesKHR* pCapabilities) const { return Result(vkGetDisplayPlaneCapabilitiesKHR(this->handle, std::bit_cast<VkDisplayModeKHR>(mode), planeIndex, std::bit_cast<VkDisplayPlaneCapabilitiesKHR*>(pCapabilities))); }
#endif // VK_KHR_display
#if VK_KHR_surface
  Ret<Bool32> getSurfaceSupportKHR(uint32_t queueFamilyIndex, SurfaceKHR surface) const { Bool32 value; return {Result(vkGetPhysicalDeviceSurfaceSupportKHR(this->handle, queueFamilyIndex, std::bit_cast<VkSurfaceKHR>(surface), &value)), value}; }
  Result getSurfaceCapabilitiesKHR(SurfaceKHR surface, SurfaceCapabilitiesKHR* pSurfaceCapabilities) const { return Result(vkGetPhysicalDeviceSurfaceCapabilitiesKHR(this->handle, std::bit_cast<VkSurfaceKHR>(surface), std::bit_cast<VkSurfaceCapabilitiesKHR*>(pSurfaceCapabilities))); }
  Result getSurfaceFormatsKHR(SurfaceKHR surface, uint32_t* pSurfaceFormatCount, SurfaceFormatKHR* pSurfaceFormats = {}) const { return Result(vkGetPhysicalDeviceSurfaceFormatsKHR(this->handle, std::bit_cast<VkSurfaceKHR>(surface), pSurfaceFormatCount, std::bit_cast<VkSurfaceFormatKHR*>(pSurfaceFormats))); }
  Result getSurfacePresentModesKHR(SurfaceKHR surface, uint32_t* pPresentModeCount, PresentModeKHR* pPresentModes = {}) const { return Result(vkGetPhysicalDeviceSurfacePresentModesKHR(this->handle, std::bit_cast<VkSurfaceKHR>(surface), pPresentModeCount, std::bit_cast<VkPresentModeKHR*>(pPresentModes))); }
#endif // VK_KHR_surface
#if VK_KHR_wayland_surface
  Bool32 getWaylandPresentationSupportKHR(uint32_t queueFamilyIndex, struct wl_display* display) const { return vkGetPhysicalDeviceWaylandPresentationSupportKHR(this->handle, queueFamilyIndex, display); }
#endif // VK_KHR_wayland_surface
#if VK_KHR_win32_surface
  Bool32 getWin32PresentationSupportKHR(uint32_t queueFamilyIndex) const { return vkGetPhysicalDeviceWin32PresentationSupportKHR(this->handle, queueFamilyIndex); }
#endif // VK_KHR_win32_surface
#if VK_KHR_xlib_surface
  Bool32 getXlibPresentationSupportKHR(uint32_t queueFamilyIndex, Display* dpy, VisualID visualID) const { return vkGetPhysicalDeviceXlibPresentationSupportKHR(this->handle, queueFamilyIndex, dpy, visualID); }
#endif // VK_KHR_xlib_surface
#if VK_KHR_xcb_surface
  Bool32 getXcbPresentationSupportKHR(uint32_t queueFamilyIndex, xcb_connection_t* connection, xcb_visualid_t visual_id) const { return vkGetPhysicalDeviceXcbPresentationSupportKHR(this->handle, queueFamilyIndex, connection, visual_id); }
#endif // VK_KHR_xcb_surface
#if VK_EXT_directfb_surface
  Bool32 getDirectFBPresentationSupportEXT(uint32_t queueFamilyIndex, IDirectFB* dfb) const { return vkGetPhysicalDeviceDirectFBPresentationSupportEXT(this->handle, queueFamilyIndex, dfb); }
#endif // VK_EXT_directfb_surface
#if VK_QNX_screen_surface
  Bool32 getScreenPresentationSupportQNX(uint32_t queueFamilyIndex, struct _screen_window* window) const { return vkGetPhysicalDeviceScreenPresentationSupportQNX(this->handle, queueFamilyIndex, window); }
#endif // VK_QNX_screen_surface
#if VK_VERSION_1_1
  void getFeatures2(PhysicalDeviceFeatures2* pFeatures) const { vkGetPhysicalDeviceFeatures2(this->handle, std::bit_cast<VkPhysicalDeviceFeatures2*>(pFeatures)); }
#endif // VK_VERSION_1_1
#if VK_KHR_get_physical_device_properties2
  void getFeatures2KHR(PhysicalDeviceFeatures2* pFeatures) const { vkGetPhysicalDeviceFeatures2KHR(this->handle, std::bit_cast<VkPhysicalDeviceFeatures2*>(pFeatures)); }
#endif // VK_KHR_get_physical_device_properties2
#if VK_VERSION_1_1
  void getProperties2(PhysicalDeviceProperties2* pProperties) const { vkGetPhysicalDeviceProperties2(this->handle, std::bit_cast<VkPhysicalDeviceProperties2*>(pProperties)); }
#endif // VK_VERSION_1_1
#if VK_KHR_get_physical_device_properties2
  void getProperties2KHR(PhysicalDeviceProperties2* pProperties) const { vkGetPhysicalDeviceProperties2KHR(this->handle, std::bit_cast<VkPhysicalDeviceProperties2*>(pProperties)); }
#endif // VK_KHR_get_physical_device_properties2
#if VK_VERSION_1_1
  void getFormatProperties2(Format format, FormatProperties2* pFormatProperties) const { vkGetPhysicalDeviceFormatProperties2(this->handle, std::bit_cast<VkFormat>(format), std::bit_cast<VkFormatProperties2*>(pFormatProperties)); }
#endif // VK_VERSION_1_1
#if VK_KHR_get_physical_device_properties2
  void getFormatProperties2KHR(Format format, FormatProperties2* pFormatProperties) const { vkGetPhysicalDeviceFormatProperties2KHR(this->handle, std::bit_cast<VkFormat>(format), std::bit_cast<VkFormatProperties2*>(pFormatProperties)); }
#endif // VK_KHR_get_physical_device_properties2
#if VK_VERSION_1_1
  Result getImageFormatProperties2(const PhysicalDeviceImageFormatInfo2& imageFormatInfo, ImageFormatProperties2* pImageFormatProperties) const { return Result(vkGetPhysicalDeviceImageFormatProperties2(this->handle, std::bit_cast<const VkPhysicalDeviceImageFormatInfo2*>(&imageFormatInfo), std::bit_cast<VkImageFormatProperties2*>(pImageFormatProperties))); }
#endif // VK_VERSION_1_1
#if VK_KHR_get_physical_device_properties2
  Result getImageFormatProperties2KHR(const PhysicalDeviceImageFormatInfo2& imageFormatInfo, ImageFormatProperties2* pImageFormatProperties) const { return Result(vkGetPhysicalDeviceImageFormatProperties2KHR(this->handle, std::bit_cast<const VkPhysicalDeviceImageFormatInfo2*>(&imageFormatInfo), std::bit_cast<VkImageFormatProperties2*>(pImageFormatProperties))); }
#endif // VK_KHR_get_physical_device_properties2
#if VK_VERSION_1_1
  void getQueueFamilyProperties2(uint32_t* pQueueFamilyPropertyCount, QueueFamilyProperties2* pQueueFamilyProperties = {}) const { vkGetPhysicalDeviceQueueFamilyProperties2(this->handle, pQueueFamilyPropertyCount, std::bit_cast<VkQueueFamilyProperties2*>(pQueueFamilyProperties)); }
#endif // VK_VERSION_1_1
#if VK_KHR_get_physical_device_properties2
  void getQueueFamilyProperties2KHR(uint32_t* pQueueFamilyPropertyCount, QueueFamilyProperties2* pQueueFamilyProperties = {}) const { vkGetPhysicalDeviceQueueFamilyProperties2KHR(this->handle, pQueueFamilyPropertyCount, std::bit_cast<VkQueueFamilyProperties2*>(pQueueFamilyProperties)); }
#endif // VK_KHR_get_physical_device_properties2
#if VK_VERSION_1_1
  void getMemoryProperties2(PhysicalDeviceMemoryProperties2* pMemoryProperties) const { vkGetPhysicalDeviceMemoryProperties2(this->handle, std::bit_cast<VkPhysicalDeviceMemoryProperties2*>(pMemoryProperties)); }
#endif // VK_VERSION_1_1
#if VK_KHR_get_physical_device_properties2
  void getMemoryProperties2KHR(PhysicalDeviceMemoryProperties2* pMemoryProperties) const { vkGetPhysicalDeviceMemoryProperties2KHR(this->handle, std::bit_cast<VkPhysicalDeviceMemoryProperties2*>(pMemoryProperties)); }
#endif // VK_KHR_get_physical_device_properties2
#if VK_VERSION_1_1
  void getSparseImageFormatProperties2(const PhysicalDeviceSparseImageFormatInfo2& formatInfo, uint32_t* pPropertyCount, SparseImageFormatProperties2* pProperties = {}) const { vkGetPhysicalDeviceSparseImageFormatProperties2(this->handle, std::bit_cast<const VkPhysicalDeviceSparseImageFormatInfo2*>(&formatInfo), pPropertyCount, std::bit_cast<VkSparseImageFormatProperties2*>(pProperties)); }
#endif // VK_VERSION_1_1
#if VK_KHR_get_physical_device_properties2
  void getSparseImageFormatProperties2KHR(const PhysicalDeviceSparseImageFormatInfo2& formatInfo, uint32_t* pPropertyCount, SparseImageFormatProperties2* pProperties = {}) const { vkGetPhysicalDeviceSparseImageFormatProperties2KHR(this->handle, std::bit_cast<const VkPhysicalDeviceSparseImageFormatInfo2*>(&formatInfo), pPropertyCount, std::bit_cast<VkSparseImageFormatProperties2*>(pProperties)); }
#endif // VK_KHR_get_physical_device_properties2
#if VK_VERSION_1_1
  void getExternalBufferProperties(const PhysicalDeviceExternalBufferInfo& externalBufferInfo, ExternalBufferProperties* pExternalBufferProperties) const { vkGetPhysicalDeviceExternalBufferProperties(this->handle, std::bit_cast<const VkPhysicalDeviceExternalBufferInfo*>(&externalBufferInfo), std::bit_cast<VkExternalBufferProperties*>(pExternalBufferProperties)); }
#endif // VK_VERSION_1_1
#if VK_KHR_external_memory_capabilities
  void getExternalBufferPropertiesKHR(const PhysicalDeviceExternalBufferInfo& externalBufferInfo, ExternalBufferProperties* pExternalBufferProperties) const { vkGetPhysicalDeviceExternalBufferPropertiesKHR(this->handle, std::bit_cast<const VkPhysicalDeviceExternalBufferInfo*>(&externalBufferInfo), std::bit_cast<VkExternalBufferProperties*>(pExternalBufferProperties)); }
#endif // VK_KHR_external_memory_capabilities
#if VK_VERSION_1_1
  void getExternalSemaphoreProperties(const PhysicalDeviceExternalSemaphoreInfo& externalSemaphoreInfo, ExternalSemaphoreProperties* pExternalSemaphoreProperties) const { vkGetPhysicalDeviceExternalSemaphoreProperties(this->handle, std::bit_cast<const VkPhysicalDeviceExternalSemaphoreInfo*>(&externalSemaphoreInfo), std::bit_cast<VkExternalSemaphoreProperties*>(pExternalSemaphoreProperties)); }
#endif // VK_VERSION_1_1
#if VK_KHR_external_semaphore_capabilities
  void getExternalSemaphorePropertiesKHR(const PhysicalDeviceExternalSemaphoreInfo& externalSemaphoreInfo, ExternalSemaphoreProperties* pExternalSemaphoreProperties) const { vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(this->handle, std::bit_cast<const VkPhysicalDeviceExternalSemaphoreInfo*>(&externalSemaphoreInfo), std::bit_cast<VkExternalSemaphoreProperties*>(pExternalSemaphoreProperties)); }
#endif // VK_KHR_external_semaphore_capabilities
#if VK_VERSION_1_1
  void getExternalFenceProperties(const PhysicalDeviceExternalFenceInfo& externalFenceInfo, ExternalFenceProperties* pExternalFenceProperties) const { vkGetPhysicalDeviceExternalFenceProperties(this->handle, std::bit_cast<const VkPhysicalDeviceExternalFenceInfo*>(&externalFenceInfo), std::bit_cast<VkExternalFenceProperties*>(pExternalFenceProperties)); }
#endif // VK_VERSION_1_1
#if VK_KHR_external_fence_capabilities
  void getExternalFencePropertiesKHR(const PhysicalDeviceExternalFenceInfo& externalFenceInfo, ExternalFenceProperties* pExternalFenceProperties) const { vkGetPhysicalDeviceExternalFencePropertiesKHR(this->handle, std::bit_cast<const VkPhysicalDeviceExternalFenceInfo*>(&externalFenceInfo), std::bit_cast<VkExternalFenceProperties*>(pExternalFenceProperties)); }
#endif // VK_KHR_external_fence_capabilities
#if VK_EXT_direct_mode_display
  Result releaseDisplayEXT(DisplayKHR display) const { return Result(vkReleaseDisplayEXT(this->handle, std::bit_cast<VkDisplayKHR>(display))); }
#endif // VK_EXT_direct_mode_display
#if VK_EXT_acquire_xlib_display
  Result acquireXlibDisplayEXT(Display* dpy, DisplayKHR display) const { return Result(vkAcquireXlibDisplayEXT(this->handle, dpy, std::bit_cast<VkDisplayKHR>(display))); }
  Ret<DisplayKHR> getRandROutputDisplayEXT(Display* dpy, RROutput rrOutput) const { DisplayKHR value; return {Result(vkGetRandROutputDisplayEXT(this->handle, dpy, rrOutput, std::bit_cast<VkDisplayKHR*>(&value))), value}; }
#endif // VK_EXT_acquire_xlib_display
#if VK_NV_acquire_winrt_display
  Result acquireWinrtDisplayNV(DisplayKHR display) const { return Result(vkAcquireWinrtDisplayNV(this->handle, std::bit_cast<VkDisplayKHR>(display))); }
  Ret<DisplayKHR> getWinrtDisplayNV(uint32_t deviceRelativeId) const { DisplayKHR value; return {Result(vkGetWinrtDisplayNV(this->handle, deviceRelativeId, std::bit_cast<VkDisplayKHR*>(&value))), value}; }
#endif // VK_NV_acquire_winrt_display
#if VK_EXT_display_surface_counter
  Result getSurfaceCapabilities2EXT(SurfaceKHR surface, SurfaceCapabilities2EXT* pSurfaceCapabilities) const { return Result(vkGetPhysicalDeviceSurfaceCapabilities2EXT(this->handle, std::bit_cast<VkSurfaceKHR>(surface), std::bit_cast<VkSurfaceCapabilities2EXT*>(pSurfaceCapabilities))); }
#endif // VK_EXT_display_surface_counter
#if VK_KHR_swapchain
  Result getPresentRectanglesKHR(SurfaceKHR surface, uint32_t* pRectCount, Rect2D* pRects = {}) const { return Result(vkGetPhysicalDevicePresentRectanglesKHR(this->handle, std::bit_cast<VkSurfaceKHR>(surface), pRectCount, std::bit_cast<VkRect2D*>(pRects))); }
#endif // VK_KHR_swapchain
#if VK_EXT_sample_locations
  void getMultisamplePropertiesEXT(SampleCountFlagBits samples, MultisamplePropertiesEXT* pMultisampleProperties) const { vkGetPhysicalDeviceMultisamplePropertiesEXT(this->handle, std::bit_cast<VkSampleCountFlagBits>(samples), std::bit_cast<VkMultisamplePropertiesEXT*>(pMultisampleProperties)); }
#endif // VK_EXT_sample_locations
#if VK_KHR_get_surface_capabilities2
  Result getSurfaceCapabilities2KHR(const PhysicalDeviceSurfaceInfo2KHR& surfaceInfo, SurfaceCapabilities2KHR* pSurfaceCapabilities) const { return Result(vkGetPhysicalDeviceSurfaceCapabilities2KHR(this->handle, std::bit_cast<const VkPhysicalDeviceSurfaceInfo2KHR*>(&surfaceInfo), std::bit_cast<VkSurfaceCapabilities2KHR*>(pSurfaceCapabilities))); }
  Result getSurfaceFormats2KHR(const PhysicalDeviceSurfaceInfo2KHR& surfaceInfo, uint32_t* pSurfaceFormatCount, SurfaceFormat2KHR* pSurfaceFormats = {}) const { return Result(vkGetPhysicalDeviceSurfaceFormats2KHR(this->handle, std::bit_cast<const VkPhysicalDeviceSurfaceInfo2KHR*>(&surfaceInfo), pSurfaceFormatCount, std::bit_cast<VkSurfaceFormat2KHR*>(pSurfaceFormats))); }
#endif // VK_KHR_get_surface_capabilities2
#if VK_KHR_get_display_properties2
  Result getDisplayProperties2KHR(uint32_t* pPropertyCount, DisplayProperties2KHR* pProperties = {}) const { return Result(vkGetPhysicalDeviceDisplayProperties2KHR(this->handle, pPropertyCount, std::bit_cast<VkDisplayProperties2KHR*>(pProperties))); }
  Result getDisplayPlaneProperties2KHR(uint32_t* pPropertyCount, DisplayPlaneProperties2KHR* pProperties = {}) const { return Result(vkGetPhysicalDeviceDisplayPlaneProperties2KHR(this->handle, pPropertyCount, std::bit_cast<VkDisplayPlaneProperties2KHR*>(pProperties))); }
  Result getDisplayModeProperties2KHR(DisplayKHR display, uint32_t* pPropertyCount, DisplayModeProperties2KHR* pProperties = {}) const { return Result(vkGetDisplayModeProperties2KHR(this->handle, std::bit_cast<VkDisplayKHR>(display), pPropertyCount, std::bit_cast<VkDisplayModeProperties2KHR*>(pProperties))); }
  Result getDisplayPlaneCapabilities2KHR(const DisplayPlaneInfo2KHR& displayPlaneInfo, DisplayPlaneCapabilities2KHR* pCapabilities) const { return Result(vkGetDisplayPlaneCapabilities2KHR(this->handle, std::bit_cast<const VkDisplayPlaneInfo2KHR*>(&displayPlaneInfo), std::bit_cast<VkDisplayPlaneCapabilities2KHR*>(pCapabilities))); }
#endif // VK_KHR_get_display_properties2
#if VK_KHR_calibrated_timestamps
  Result getCalibrateableTimeDomainsKHR(uint32_t* pTimeDomainCount, TimeDomainKHR* pTimeDomains = {}) const { return Result(vkGetPhysicalDeviceCalibrateableTimeDomainsKHR(this->handle, pTimeDomainCount, std::bit_cast<VkTimeDomainKHR*>(pTimeDomains))); }
#endif // VK_KHR_calibrated_timestamps
#if VK_EXT_calibrated_timestamps
  Result getCalibrateableTimeDomainsEXT(uint32_t* pTimeDomainCount, TimeDomainKHR* pTimeDomains = {}) const { return Result(vkGetPhysicalDeviceCalibrateableTimeDomainsEXT(this->handle, pTimeDomainCount, std::bit_cast<VkTimeDomainKHR*>(pTimeDomains))); }
#endif // VK_EXT_calibrated_timestamps
#if VK_NV_cooperative_matrix
  Result getCooperativeMatrixPropertiesNV(uint32_t* pPropertyCount, CooperativeMatrixPropertiesNV* pProperties = {}) const { return Result(vkGetPhysicalDeviceCooperativeMatrixPropertiesNV(this->handle, pPropertyCount, std::bit_cast<VkCooperativeMatrixPropertiesNV*>(pProperties))); }
#endif // VK_NV_cooperative_matrix
#if VK_EXT_full_screen_exclusive
  Result getSurfacePresentModes2EXT(const PhysicalDeviceSurfaceInfo2KHR& surfaceInfo, uint32_t* pPresentModeCount, PresentModeKHR* pPresentModes = {}) const { return Result(vkGetPhysicalDeviceSurfacePresentModes2EXT(this->handle, std::bit_cast<const VkPhysicalDeviceSurfaceInfo2KHR*>(&surfaceInfo), pPresentModeCount, std::bit_cast<VkPresentModeKHR*>(pPresentModes))); }
#endif // VK_EXT_full_screen_exclusive
#if VK_KHR_performance_query
  Result enumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(uint32_t queueFamilyIndex, uint32_t* pCounterCount, PerformanceCounterKHR* pCounters = {}, PerformanceCounterDescriptionKHR* pCounterDescriptions = {}) const { return Result(vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(this->handle, queueFamilyIndex, pCounterCount, std::bit_cast<VkPerformanceCounterKHR*>(pCounters), std::bit_cast<VkPerformanceCounterDescriptionKHR*>(pCounterDescriptions))); }
  uint32_t getQueueFamilyPerformanceQueryPassesKHR(const QueryPoolPerformanceCreateInfoKHR& performanceQueryCreateInfo) const { uint32_t value; vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(this->handle, std::bit_cast<const VkQueryPoolPerformanceCreateInfoKHR*>(&performanceQueryCreateInfo), &value); return value; }
#endif // VK_KHR_performance_query
#if VK_NV_coverage_reduction_mode
  Result getSupportedFramebufferMixedSamplesCombinationsNV(uint32_t* pCombinationCount, FramebufferMixedSamplesCombinationNV* pCombinations = {}) const { return Result(vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(this->handle, pCombinationCount, std::bit_cast<VkFramebufferMixedSamplesCombinationNV*>(pCombinations))); }
#endif // VK_NV_coverage_reduction_mode
#if VK_VERSION_1_3
  Result getToolProperties(uint32_t* pToolCount, PhysicalDeviceToolProperties* pToolProperties = {}) const { return Result(vkGetPhysicalDeviceToolProperties(this->handle, pToolCount, std::bit_cast<VkPhysicalDeviceToolProperties*>(pToolProperties))); }
#endif // VK_VERSION_1_3
#if VK_EXT_tooling_info
  Result getToolPropertiesEXT(uint32_t* pToolCount, PhysicalDeviceToolProperties* pToolProperties = {}) const { return Result(vkGetPhysicalDeviceToolPropertiesEXT(this->handle, pToolCount, std::bit_cast<VkPhysicalDeviceToolProperties*>(pToolProperties))); }
#endif // VK_EXT_tooling_info
#if VK_KHR_fragment_shading_rate
  Result getFragmentShadingRatesKHR(uint32_t* pFragmentShadingRateCount, PhysicalDeviceFragmentShadingRateKHR* pFragmentShadingRates = {}) const { return Result(vkGetPhysicalDeviceFragmentShadingRatesKHR(this->handle, pFragmentShadingRateCount, std::bit_cast<VkPhysicalDeviceFragmentShadingRateKHR*>(pFragmentShadingRates))); }
#endif // VK_KHR_fragment_shading_rate
#if VK_KHR_video_queue
  Result getVideoCapabilitiesKHR(const VideoProfileInfoKHR& videoProfile, VideoCapabilitiesKHR* pCapabilities) const { return Result(vkGetPhysicalDeviceVideoCapabilitiesKHR(this->handle, std::bit_cast<const VkVideoProfileInfoKHR*>(&videoProfile), std::bit_cast<VkVideoCapabilitiesKHR*>(pCapabilities))); }
  Result getVideoFormatPropertiesKHR(const PhysicalDeviceVideoFormatInfoKHR& videoFormatInfo, uint32_t* pVideoFormatPropertyCount, VideoFormatPropertiesKHR* pVideoFormatProperties = {}) const { return Result(vkGetPhysicalDeviceVideoFormatPropertiesKHR(this->handle, std::bit_cast<const VkPhysicalDeviceVideoFormatInfoKHR*>(&videoFormatInfo), pVideoFormatPropertyCount, std::bit_cast<VkVideoFormatPropertiesKHR*>(pVideoFormatProperties))); }
#endif // VK_KHR_video_queue
#if VK_KHR_video_encode_queue
  Result getVideoEncodeQualityLevelPropertiesKHR(const PhysicalDeviceVideoEncodeQualityLevelInfoKHR& qualityLevelInfo, VideoEncodeQualityLevelPropertiesKHR* pQualityLevelProperties) const { return Result(vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR(this->handle, std::bit_cast<const VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR*>(&qualityLevelInfo), std::bit_cast<VkVideoEncodeQualityLevelPropertiesKHR*>(pQualityLevelProperties))); }
#endif // VK_KHR_video_encode_queue
#if VK_EXT_acquire_drm_display
  Result acquireDrmDisplayEXT(int32_t drmFd, DisplayKHR display) const { return Result(vkAcquireDrmDisplayEXT(this->handle, drmFd, std::bit_cast<VkDisplayKHR>(display))); }
  Ret<DisplayKHR> getDrmDisplayEXT(int32_t drmFd, uint32_t connectorId) const { DisplayKHR value; return {Result(vkGetDrmDisplayEXT(this->handle, drmFd, connectorId, std::bit_cast<VkDisplayKHR*>(&value))), value}; }
#endif // VK_EXT_acquire_drm_display
#if VK_NV_optical_flow
  Result getOpticalFlowImageFormatsNV(const OpticalFlowImageFormatInfoNV& opticalFlowImageFormatInfo, uint32_t* pFormatCount, OpticalFlowImageFormatPropertiesNV* pImageFormatProperties = {}) const { return Result(vkGetPhysicalDeviceOpticalFlowImageFormatsNV(this->handle, std::bit_cast<const VkOpticalFlowImageFormatInfoNV*>(&opticalFlowImageFormatInfo), pFormatCount, std::bit_cast<VkOpticalFlowImageFormatPropertiesNV*>(pImageFormatProperties))); }
#endif // VK_NV_optical_flow
#if VK_KHR_cooperative_matrix
  Result getCooperativeMatrixPropertiesKHR(uint32_t* pPropertyCount, CooperativeMatrixPropertiesKHR* pProperties = {}) const { return Result(vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR(this->handle, pPropertyCount, std::bit_cast<VkCooperativeMatrixPropertiesKHR*>(pProperties))); }
#endif // VK_KHR_cooperative_matrix
#if VK_NV_cooperative_matrix2
  Result getCooperativeMatrixFlexibleDimensionsPropertiesNV(uint32_t* pPropertyCount, CooperativeMatrixFlexibleDimensionsPropertiesNV* pProperties = {}) const { return Result(vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV(this->handle, pPropertyCount, std::bit_cast<VkCooperativeMatrixFlexibleDimensionsPropertiesNV*>(pProperties))); }
#endif // VK_NV_cooperative_matrix2
#if VK_NV_cooperative_vector
  Result getCooperativeVectorPropertiesNV(uint32_t* pPropertyCount, CooperativeVectorPropertiesNV* pProperties = {}) const { return Result(vkGetPhysicalDeviceCooperativeVectorPropertiesNV(this->handle, pPropertyCount, std::bit_cast<VkCooperativeVectorPropertiesNV*>(pProperties))); }
#endif // VK_NV_cooperative_vector
#if VK_ARM_tensors
  void getExternalTensorPropertiesARM(const PhysicalDeviceExternalTensorInfoARM& externalTensorInfo, ExternalTensorPropertiesARM* pExternalTensorProperties) const { vkGetPhysicalDeviceExternalTensorPropertiesARM(this->handle, std::bit_cast<const VkPhysicalDeviceExternalTensorInfoARM*>(&externalTensorInfo), std::bit_cast<VkExternalTensorPropertiesARM*>(pExternalTensorProperties)); }
#endif // VK_ARM_tensors
#if VK_ARM_data_graph
  Result getQueueFamilyDataGraphPropertiesARM(uint32_t queueFamilyIndex, uint32_t* pQueueFamilyDataGraphPropertyCount, QueueFamilyDataGraphPropertiesARM* pQueueFamilyDataGraphProperties = {}) const { return Result(vkGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM(this->handle, queueFamilyIndex, pQueueFamilyDataGraphPropertyCount, std::bit_cast<VkQueueFamilyDataGraphPropertiesARM*>(pQueueFamilyDataGraphProperties))); }
  void getQueueFamilyDataGraphProcessingEnginePropertiesARM(const PhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM& queueFamilyDataGraphProcessingEngineInfo, QueueFamilyDataGraphProcessingEnginePropertiesARM* pQueueFamilyDataGraphProcessingEngineProperties) const { vkGetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM(this->handle, std::bit_cast<const VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM*>(&queueFamilyDataGraphProcessingEngineInfo), std::bit_cast<VkQueueFamilyDataGraphProcessingEnginePropertiesARM*>(pQueueFamilyDataGraphProcessingEngineProperties)); }
#endif // VK_ARM_data_graph
};
#endif // VK_VERSION_1_0

#if VK_VERSION_1_1
struct DeviceGroupDeviceCreateInfo : VkDeviceGroupDeviceCreateInfo {
  DeviceGroupDeviceCreateInfo() noexcept : VkDeviceGroupDeviceCreateInfo{.sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO} {}

  void setPhysicalDeviceCount(uint32_t value) { this->physicalDeviceCount = value; }
  uint32_t getPhysicalDeviceCount() const { return this->physicalDeviceCount; }
  void setPhysicalDevices(const PhysicalDevice* value) { this->pPhysicalDevices = std::bit_cast<const VkPhysicalDevice*>(value); }
  const PhysicalDevice* getPhysicalDevices() const { return std::bit_cast<const PhysicalDevice*>(this->pPhysicalDevices); }
};
inline void DeviceCreateInfo::attach(DeviceGroupDeviceCreateInfo& ext) { ext.pNext = const_cast<void*>(pNext); pNext = &ext; }

struct PhysicalDeviceGroupProperties : VkPhysicalDeviceGroupProperties {
  PhysicalDeviceGroupProperties() noexcept : VkPhysicalDeviceGroupProperties{.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES} {}

  std::span<const PhysicalDevice> getPhysicalDevices() const { return std::span<const PhysicalDevice>(std::bit_cast<const PhysicalDevice*>(&this->physicalDevices), physicalDeviceCount); }
  Bool32 getSubsetAllocation() const { return this->subsetAllocation; }
};
#endif // VK_VERSION_1_1

#if VK_KHR_device_group_creation
using DeviceGroupDeviceCreateInfoKHR = DeviceGroupDeviceCreateInfo;
#endif // VK_KHR_device_group_creation

#if VK_VERSION_1_0
struct Instance : Handle<VkInstance, ObjectType::eInstance> {
  void destroy(const AllocationCallbacks* pAllocator = {}) const { vkDestroyInstance(this->handle, std::bit_cast<const VkAllocationCallbacks*>(pAllocator)); }
  Result enumeratePhysicalDevices(uint32_t* pPhysicalDeviceCount, PhysicalDevice* pPhysicalDevices = {}) const { return Result(vkEnumeratePhysicalDevices(this->handle, pPhysicalDeviceCount, std::bit_cast<VkPhysicalDevice*>(pPhysicalDevices))); }
  PFN_vkVoidFunction getProcAddr(const char* pName) const { return vkGetInstanceProcAddr(this->handle, pName); }
#if VK_KHR_android_surface
  Ret<SurfaceKHR> createAndroidSurfaceKHR(const AndroidSurfaceCreateInfoKHR& createInfo, const AllocationCallbacks* pAllocator = {}) const { SurfaceKHR value; return {Result(vkCreateAndroidSurfaceKHR(this->handle, std::bit_cast<const VkAndroidSurfaceCreateInfoKHR*>(&createInfo), std::bit_cast<const VkAllocationCallbacks*>(pAllocator), std::bit_cast<VkSurfaceKHR*>(&value))), value}; }
#endif // VK_KHR_android_surface
#if VK_OHOS_surface
  Ret<SurfaceKHR> createSurfaceOHOS(const SurfaceCreateInfoOHOS& createInfo, const AllocationCallbacks* pAllocator = {}) const { SurfaceKHR value; return {Result(vkCreateSurfaceOHOS(this->handle, std::bit_cast<const VkSurfaceCreateInfoOHOS*>(&createInfo), std::bit_cast<const VkAllocationCallbacks*>(pAllocator), std::bit_cast<VkSurfaceKHR*>(&value))), value}; }
#endif // VK_OHOS_surface
#if VK_KHR_display
  Ret<SurfaceKHR> createDisplayPlaneSurfaceKHR(const DisplaySurfaceCreateInfoKHR& createInfo, const AllocationCallbacks* pAllocator = {}) const { SurfaceKHR value; return {Result(vkCreateDisplayPlaneSurfaceKHR(this->handle, std::bit_cast<const VkDisplaySurfaceCreateInfoKHR*>(&createInfo), std::bit_cast<const VkAllocationCallbacks*>(pAllocator), std::bit_cast<VkSurfaceKHR*>(&value))), value}; }
#endif // VK_KHR_display
#if VK_KHR_surface
  void destroySurfaceKHR(SurfaceKHR surface = {}, const AllocationCallbacks* pAllocator = {}) const { vkDestroySurfaceKHR(this->handle, std::bit_cast<VkSurfaceKHR>(surface), std::bit_cast<const VkAllocationCallbacks*>(pAllocator)); }
#endif // VK_KHR_surface
#if VK_NN_vi_surface
  Ret<SurfaceKHR> createViSurfaceNN(const ViSurfaceCreateInfoNN& createInfo, const AllocationCallbacks* pAllocator = {}) const { SurfaceKHR value; return {Result(vkCreateViSurfaceNN(this->handle, std::bit_cast<const VkViSurfaceCreateInfoNN*>(&createInfo), std::bit_cast<const VkAllocationCallbacks*>(pAllocator), std::bit_cast<VkSurfaceKHR*>(&value))), value}; }
#endif // VK_NN_vi_surface
#if VK_KHR_wayland_surface
  Ret<SurfaceKHR> createWaylandSurfaceKHR(const WaylandSurfaceCreateInfoKHR& createInfo, const AllocationCallbacks* pAllocator = {}) const { SurfaceKHR value; return {Result(vkCreateWaylandSurfaceKHR(this->handle, std::bit_cast<const VkWaylandSurfaceCreateInfoKHR*>(&createInfo), std::bit_cast<const VkAllocationCallbacks*>(pAllocator), std::bit_cast<VkSurfaceKHR*>(&value))), value}; }
#endif // VK_KHR_wayland_surface
#if VK_KHR_win32_surface
  Ret<SurfaceKHR> createWin32SurfaceKHR(const Win32SurfaceCreateInfoKHR& createInfo, const AllocationCallbacks* pAllocator = {}) const { SurfaceKHR value; return {Result(vkCreateWin32SurfaceKHR(this->handle, std::bit_cast<const VkWin32SurfaceCreateInfoKHR*>(&createInfo), std::bit_cast<const VkAllocationCallbacks*>(pAllocator), std::bit_cast<VkSurfaceKHR*>(&value))), value}; }
#endif // VK_KHR_win32_surface
#if VK_KHR_xlib_surface
  Ret<SurfaceKHR> createXlibSurfaceKHR(const XlibSurfaceCreateInfoKHR& createInfo, const AllocationCallbacks* pAllocator = {}) const { SurfaceKHR value; return {Result(vkCreateXlibSurfaceKHR(this->handle, std::bit_cast<const VkXlibSurfaceCreateInfoKHR*>(&createInfo), std::bit_cast<const VkAllocationCallbacks*>(pAllocator), std::bit_cast<VkSurfaceKHR*>(&value))), value}; }
#endif // VK_KHR_xlib_surface
#if VK_KHR_xcb_surface
  Ret<SurfaceKHR> createXcbSurfaceKHR(const XcbSurfaceCreateInfoKHR& createInfo, const AllocationCallbacks* pAllocator = {}) const { SurfaceKHR value; return {Result(vkCreateXcbSurfaceKHR(this->handle, std::bit_cast<const VkXcbSurfaceCreateInfoKHR*>(&createInfo), std::bit_cast<const VkAllocationCallbacks*>(pAllocator), std::bit_cast<VkSurfaceKHR*>(&value))), value}; }
#endif // VK_KHR_xcb_surface
#if VK_EXT_directfb_surface
  Ret<SurfaceKHR> createDirectFBSurfaceEXT(const DirectFBSurfaceCreateInfoEXT& createInfo, const AllocationCallbacks* pAllocator = {}) const { SurfaceKHR value; return {Result(vkCreateDirectFBSurfaceEXT(this->handle, std::bit_cast<const VkDirectFBSurfaceCreateInfoEXT*>(&createInfo), std::bit_cast<const VkAllocationCallbacks*>(pAllocator), std::bit_cast<VkSurfaceKHR*>(&value))), value}; }
#endif // VK_EXT_directfb_surface
#if VK_FUCHSIA_imagepipe_surface
  Ret<SurfaceKHR> createImagePipeSurfaceFUCHSIA(const ImagePipeSurfaceCreateInfoFUCHSIA& createInfo, const AllocationCallbacks* pAllocator = {}) const { SurfaceKHR value; return {Result(vkCreateImagePipeSurfaceFUCHSIA(this->handle, std::bit_cast<const VkImagePipeSurfaceCreateInfoFUCHSIA*>(&createInfo), std::bit_cast<const VkAllocationCallbacks*>(pAllocator), std::bit_cast<VkSurfaceKHR*>(&value))), value}; }
#endif // VK_FUCHSIA_imagepipe_surface
#if VK_GGP_stream_descriptor_surface
  Ret<SurfaceKHR> createStreamDescriptorSurfaceGGP(const StreamDescriptorSurfaceCreateInfoGGP& createInfo, const AllocationCallbacks* pAllocator = {}) const { SurfaceKHR value; return {Result(vkCreateStreamDescriptorSurfaceGGP(this->handle, std::bit_cast<const VkStreamDescriptorSurfaceCreateInfoGGP*>(&createInfo), std::bit_cast<const VkAllocationCallbacks*>(pAllocator), std::bit_cast<VkSurfaceKHR*>(&value))), value}; }
#endif // VK_GGP_stream_descriptor_surface
#if VK_QNX_screen_surface
  Ret<SurfaceKHR> createScreenSurfaceQNX(const ScreenSurfaceCreateInfoQNX& createInfo, const AllocationCallbacks* pAllocator = {}) const { SurfaceKHR value; return {Result(vkCreateScreenSurfaceQNX(this->handle, std::bit_cast<const VkScreenSurfaceCreateInfoQNX*>(&createInfo), std::bit_cast<const VkAllocationCallbacks*>(pAllocator), std::bit_cast<VkSurfaceKHR*>(&value))), value}; }
#endif // VK_QNX_screen_surface
#if VK_VERSION_1_1
  Result enumeratePhysicalDeviceGroups(uint32_t* pPhysicalDeviceGroupCount, PhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties = {}) const { return Result(vkEnumeratePhysicalDeviceGroups(this->handle, pPhysicalDeviceGroupCount, std::bit_cast<VkPhysicalDeviceGroupProperties*>(pPhysicalDeviceGroupProperties))); }
#endif // VK_VERSION_1_1
#if VK_KHR_device_group_creation
  Result enumeratePhysicalDeviceGroupsKHR(uint32_t* pPhysicalDeviceGroupCount, PhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties = {}) const { return Result(vkEnumeratePhysicalDeviceGroupsKHR(this->handle, pPhysicalDeviceGroupCount, std::bit_cast<VkPhysicalDeviceGroupProperties*>(pPhysicalDeviceGroupProperties))); }
#endif // VK_KHR_device_group_creation
#if VK_EXT_metal_surface
  Ret<SurfaceKHR> createMetalSurfaceEXT(const MetalSurfaceCreateInfoEXT& createInfo, const AllocationCallbacks* pAllocator = {}) const { SurfaceKHR value; return {Result(vkCreateMetalSurfaceEXT(this->handle, std::bit_cast<const VkMetalSurfaceCreateInfoEXT*>(&createInfo), std::bit_cast<const VkAllocationCallbacks*>(pAllocator), std::bit_cast<VkSurfaceKHR*>(&value))), value}; }
#endif // VK_EXT_metal_surface
#if VK_EXT_debug_utils
  Ret<DebugUtilsMessengerEXT> createDebugUtilsMessengerEXT(const DebugUtilsMessengerCreateInfoEXT& createInfo, const AllocationCallbacks* pAllocator = {}) const { DebugUtilsMessengerEXT value; return {Result(vkCreateDebugUtilsMessengerEXT(this->handle, std::bit_cast<const VkDebugUtilsMessengerCreateInfoEXT*>(&createInfo), std::bit_cast<const VkAllocationCallbacks*>(pAllocator), std::bit_cast<VkDebugUtilsMessengerEXT*>(&value))), value}; }
  void destroyDebugUtilsMessengerEXT(DebugUtilsMessengerEXT messenger = {}, const AllocationCallbacks* pAllocator = {}) const { vkDestroyDebugUtilsMessengerEXT(this->handle, std::bit_cast<VkDebugUtilsMessengerEXT>(messenger), std::bit_cast<const VkAllocationCallbacks*>(pAllocator)); }
  void submitDebugUtilsMessageEXT(DebugUtilsMessageSeverityFlagBitsEXT messageSeverity, DebugUtilsMessageTypeFlagsEXT messageTypes, const DebugUtilsMessengerCallbackDataEXT& callbackData) const { vkSubmitDebugUtilsMessageEXT(this->handle, std::bit_cast<VkDebugUtilsMessageSeverityFlagBitsEXT>(messageSeverity), std::bit_cast<VkDebugUtilsMessageTypeFlagsEXT>(messageTypes), std::bit_cast<const VkDebugUtilsMessengerCallbackDataEXT*>(&callbackData)); }
#endif // VK_EXT_debug_utils
#if VK_EXT_headless_surface
  Ret<SurfaceKHR> createHeadlessSurfaceEXT(const HeadlessSurfaceCreateInfoEXT& createInfo, const AllocationCallbacks* pAllocator = {}) const { SurfaceKHR value; return {Result(vkCreateHeadlessSurfaceEXT(this->handle, std::bit_cast<const VkHeadlessSurfaceCreateInfoEXT*>(&createInfo), std::bit_cast<const VkAllocationCallbacks*>(pAllocator), std::bit_cast<VkSurfaceKHR*>(&value))), value}; }
#endif // VK_EXT_headless_surface
};
#endif // VK_VERSION_1_0

#if VK_KHR_device_group_creation
using PhysicalDeviceGroupPropertiesKHR = PhysicalDeviceGroupProperties;
#endif // VK_KHR_device_group_creation

#if VK_VERSION_1_0
inline Ret<Instance> createInstance(const InstanceCreateInfo& createInfo, const AllocationCallbacks* pAllocator = {}) { Instance value; return {Result(vkCreateInstance(std::bit_cast<const VkInstanceCreateInfo*>(&createInfo), std::bit_cast<const VkAllocationCallbacks*>(pAllocator), std::bit_cast<VkInstance*>(&value))), value}; }
#endif // VK_VERSION_1_0
#if VK_VERSION_1_1
inline Ret<uint32_t> enumerateInstanceVersion() { uint32_t value; return {Result(vkEnumerateInstanceVersion(&value)), value}; }
#endif // VK_VERSION_1_1
#if VK_VERSION_1_0
inline Result enumerateInstanceLayerProperties(uint32_t* pPropertyCount, LayerProperties* pProperties = {}) { return Result(vkEnumerateInstanceLayerProperties(pPropertyCount, std::bit_cast<VkLayerProperties*>(pProperties))); }
inline Result enumerateInstanceExtensionProperties(const char* pLayerName, uint32_t* pPropertyCount, ExtensionProperties* pProperties = {}) { return Result(vkEnumerateInstanceExtensionProperties(pLayerName, pPropertyCount, std::bit_cast<VkExtensionProperties*>(pProperties))); }
#endif // VK_VERSION_1_0
}

#endif // VKLITE_VULKAN_HPP